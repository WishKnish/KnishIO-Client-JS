import{shake256 as e}from"js-sha3";import t from"big-integer";import{encode as s,decode as n}from"@stablelib/base64";import a from"get-random-values";import i from"big-integer/BigInteger";import{Buffer as r}from"buffer";import o from"base-x";import{box as l}from"tweetnacl";import{seal as u,open as c}from"tweetnacl-sealedbox-js";import{encode as h,decode as d}from"@stablelib/utf8";import{gql as p,HttpLink as m,ApolloLink as y,Observable as g,ApolloClient as k,concat as b,from as _}from"@apollo/client/core";import f from"isomorphic-fetch";import{InMemoryCache as w}from"@apollo/client/cache";import{onError as $}from"@apollo/client/link/error";import S from"pusher-js";import{parse as I}from"uri-js";import{print as T}from"graphql";class A{static toHex(e,t){const s=(e,t)=>{const s=t?["0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F"]:["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"];return s[Math.floor(e/16)]+s[e%16]},n=Object.assign({grouping:0,rowlength:0,uppercase:!1},t||{});let a="",i=0,r=0;for(let t=0;t<e.length&&(a+=s(e[t],n.uppercase),t!==e.length-1);++t)n.grouping>0&&++i===n.grouping&&(i=0,n.rowlength>0&&++r===n.rowlength?(r=0,a+="\n"):a+=" ");return a}static toUint8Array(e){let t=e.toLowerCase().replace(/\s/g,"");t.length%2==1&&(t=`0${t}`);let s=new Uint8Array(Math.floor(t.length/2)),n=-1;for(let e=0;e<t.length;++e){let a=t[e],i=["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"].indexOf(a);if(-1===i)throw Error("unexpected character");-1===n?n=16*i:(s[Math.floor(e/2)]=n+i,n=-1)}return s}}function x(e,t){const s=Math.ceil(e.length/t),n=[];for(let a=0,i=0;a<s;++a,i+=t)n[a]=e.substr(i,t);return n}function v(e=256,t="abcdef0123456789"){let s=new Uint8Array(e);return s=a(s),s=s.map((e=>t.charCodeAt(e%t.length))),String.fromCharCode.apply(null,s)}function q(e,s,n,a,i){if(a=a||"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz~`!@#$%^&*()-_=+[{]}\\|;:'\",<.>/?¿¡",i=i||a,s>a.length||n>i.length)return console.warn("Strings::charsetBaseConvert() - Can't convert",e,"to base",n,"greater than symbol table length. src-table:",a.length,"dest-table:",i.length),!1;let r=t(0);for(let t=0;t<e.length;t++)r=r.multiply(s).add(a.indexOf(e.charAt(t)));if(r.lesser(0))return 0;let o=r.mod(n),l=i.charAt(o),u=r.divide(n);for(;!u.equals(0);)o=u.mod(n),u=u.divide(n),l=i.charAt(o)+l;return l}function W(e){return A.toHex(e,{})}function C(e){return A.toUint8Array(e)}function M(e){return s(A.toUint8Array(e))}function B(e){return A.toHex(n(e),{})}function U(e){return/^[A-F0-9]+$/i.test(e)}String.prototype.trim||(String.prototype.trim=function(){return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,"")}),String.prototype.toCamelCase||(String.prototype.toCamelCase=function(){return this.toLowerCase().replace(/[^a-zA-Z0-9]+(.)/g,((e,t)=>t.toUpperCase()))}),String.prototype.toSnakeCase||(String.prototype.toSnakeCase=function(){return this.replace(/[A-Z]/g,(e=>`_${e.toLowerCase()}`))});class O{static normalizeMeta(e){const t=[];for(const s in e)e.hasOwnProperty(s)&&null!==e[s]&&t.push({key:s,value:e[s].toString()});return t}static aggregateMeta(e){let t={};if(Array.isArray(e))for(let s of e)t[s.key]=s.value;else t=e;return t}}function H(e,t){let s,n,a,i=[Array,Date,Number,String,Boolean],r=Object.prototype.toString;for(t=t||[],s=0;s<t.length;s+=2)e===t[s]&&(n=t[s+1]);if(!n&&e&&"object"==typeof e){for(n={},s=0;s<i.length;s++)r.call(e)===r.call(a=new i[s](e))&&(n=s?a:[]);for(s in t.push(e,n),e)t.hasOwnProperty.call(e,s)&&(n[s]=H(e[s],t))}return n||e}function R(...e){return[].concat(...e.map(((t,s)=>{const n=e.slice(0);n.splice(s,1);const a=[...new Set([].concat(...n))];return t.filter((e=>!a.includes(e)))})))}function j(...e){return e.reduce(((e,t)=>e.filter((e=>t.includes(e)))))}class E{static normalizePolicy(e={}){let t={};for(const[s,n]of Object.entries(e))if(null!==n&&["read","write"].includes(s)){t[s]={};for(const[e,a]of Object.entries(n))t[s][e]=a}return t}constructor(e={},t={}){this.policy=E.normalizePolicy(e),this.fillDefault(t)}fillDefault(e={}){const t=Array.from(this.policy).filter((e=>"read"===e.action)),s=Array.from(this.policy).filter((e=>"write"===e.action));for(const[n,a]of Object.entries({read:t,write:s})){const t=a.map((e=>e.key));this.policy[n]||(this.policy[n]={});for(const s of R(e,t))this.policy[n][s]||(this.policy[n][s]="write"!==n||["characters","pubkey"].includes(s)?["all"]:["self"])}}get(){return this.policy}toJson(){return JSON.stringify(this.get())}}class K{constructor(e={}){this.meta=e}merge(e){return this.meta=Object.assign(this.meta,e),this}addContext(e=null){return this}addWallet(e){let t={pubkey:e.pubkey,characters:e.characters};return e.tokenUnits&&e.tokenUnits.length&&(t.tokenUnits=JSON.stringify(e.getTokenUnitsData())),e.tradeRates&&e.tradeRates.length&&(t.tradeRates=JSON.stringify(e.tradeRates)),this.merge(t),this}addPolicy(e){let t=new E(e,Object.keys(this.meta));return this.merge({policy:t.toJson()}),this}addSigningWallet(e){return this.merge({signingWallet:JSON.stringify({address:e.address,position:e.position,pubkey:e.pubkey,characters:e.characters})}),this}get(){return this.meta}}class Q{static getHashableProps(){return["position","walletAddress","isotope","token","value","batchId","metaType","metaId","meta","createdAt"]}constructor({position:e=null,walletAddress:t=null,isotope:s=null,token:n=null,value:a=null,batchId:i=null,metaType:r=null,metaId:o=null,meta:l=null,otsFragment:u=null,index:c=null}){this.position=e,this.walletAddress=t,this.isotope=s,this.token=n,this.value=null!==a?String(a):null,this.batchId=i,this.metaType=r,this.metaId=o,this.meta=l?O.normalizeMeta(l):[],this.index=c,this.otsFragment=u,this.createdAt=String(+new Date)}static create({isotope:e,wallet:t=null,value:s=null,metaType:n=null,metaId:a=null,meta:i=null,batchId:r=null}){return i||(i=new K),t&&(i.addWallet(t),r||(r=t.batchId)),new Q({position:t?t.position:null,walletAddress:t?t.address:null,isotope:e,token:t?t.token:null,value:s,batchId:r,metaType:n,metaId:a,meta:i.get()})}aggregatedMeta(){return O.aggregateMeta(this.meta)}static jsonToObject(e){const t=Object.assign(new Q({}),JSON.parse(e)),s=Object.keys(new Q({}));for(const e in t)t.hasOwnProperty(e)&&!s.includes(e)&&delete t[e];return t}getHashableValues(){const e=[];for(let t of Q.getHashableProps()){const s=this[t];if(null!==s||["position","walletAddress"].includes(t))if("meta"===t)for(const t of s)void 0!==t.value&&null!==t.value&&(e.push(String(t.key)),e.push(String(t.value)));else e.push(null===s?"":String(s))}return e}static hashAtoms({atoms:t,output:s="base17"}){const n=e.create(256),a=t.length,i=Q.sortAtoms(t);let r=[];for(const e of i)r.push(String(a)),r=r.concat(e.getHashableValues());for(const e of r)n.update(e);switch(s){case"hex":return n.hex();case"array":return n.array();default:return q(n.hex(),16,17,"0123456789abcdef","0123456789abcdefg").padStart(64,"0")}}static sortAtoms(e){const t=[...e];return t.sort(((e,t)=>e.index<t.index?-1:1)),t}}function P(t=null,s=2048){if(console.info(`Crypto::generateSecret() - Computing new secret${t?" from existing seed":""}...`),t){const n=e.create(2*s);return n.update(t),n.hex()}return v(s)}function N(t){console.info("Crypto::generateBundleHash() - Computing wallet bundle from secret...");const s=e.create(256);return s.update(t),s.hex()}function F({molecularHash:e=null,index:t=null}){return null!==e&&null!==t?N(String(e)+String(t)):v(64)}class V{static encode(e){return s(e)}static decode(e){return r.from(n(e))}encode(e){return V.encode(e)}decode(e){return V.decode(e)}}class D{constructor(e={}){this.$options=Object.assign({characters:"GMP"},e),this.$encoder=o(this[this.$options.characters]||this.GMP)}encode(e){return this.$encoder.encode(r.from(e))}decode(e){return this.$encoder.decode(e)}get GMP(){return"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuv"}get BITCOIN(){return"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}get FLICKR(){return"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}get RIPPLE(){return"rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz"}get IPFS(){return"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}}class J{constructor(e={}){this.$options=Object.assign({characters:"BASE64"},e),this.$encoder=new D,["BASE64"].includes(this.$options.characters)?this.$encoder=new V:["BASE2","BASE8","BASE11","BASE36","BASE62","BASE67"].includes(this.$options.characters)?this.$encoder=o(this[this.$options.characters]):["BITCOIN","FLICKR","RIPPLE","IPFS"].includes(this.$options.characters)&&(this.$encoder=new D(this.$options))}encode(e){return this.$encoder.encode(r.from(e))}decode(e){return this.$encoder.decode(e)}get BASE2(){return"01"}get BASE8(){return"01234567"}get BASE11(){return"0123456789a"}get BASE36(){return"0123456789abcdefghijklmnopqrstuvwxyz"}get BASE62(){return"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"}get BASE67(){return"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_.!~"}}class L{static createFromGraphQL(e){let t=e.metas||{};return t.length&&(t=JSON.parse(t),t||(t={})),new L(e.id,e.name,t)}static createFromDB(e){return new L(e[0],e[1],e.length>2?e[2]:{})}constructor(e,t,s){this.id=e,this.name=t,this.metas=s||{}}getFragmentZone(){return this.metas.fragmentZone||null}getFusedTokenUnits(){return this.metas.fusedTokenUnits||null}toData(){return[this.id,this.name,this.metas]}toGraphQLResponse(){return{id:this.id,name:this.name,metas:JSON.stringify(this.metas)}}}class z{constructor(e=null){this.base=new J({characters:e||"BASE64"})}encrypt(e,t){return this.encode(u(h(JSON.stringify(e)),this.decode(t)))}decrypt(e,t,s){try{return JSON.parse(d(c(this.decode(e),this.decode(s),this.decode(t))))}catch(e){return null}}generatePrivateKey(t){const s=e.create(8*l.secretKeyLength);return s.update(t),this.base.encode(r.from(s.digest()))}generatePublicKey(e){const t=l.keyPair.fromSecretKey(this.decode(e));return this.encode(t.publicKey)}shortHash(t){const s=e.create(64);return s.update(t),this.base.encode(r.from(s.digest()))}decode(e){return this.base.decode(e)}encode(e){return this.base.encode(e)}}class Z{constructor({secret:e=null,token:t="USER",position:s=null,batchId:n=null,characters:a=null}){this.token=t,this.balance=0,this.molecules={},this.key=null,this.address=null,this.privkey=null,this.pubkey=null,this.tokenUnits=[],this.tradeRates={},this.bundle=null,this.batchId=n,this.position=s,this.characters=a,e&&(this.bundle=N(e),this.position=this.position||Z.generatePosition(),this.key=Z.generateKey({secret:e,token:this.token,position:this.position}),this.address=Z.generateAddress(this.key),this.soda=new z(a),this.privkey=this.soda.generatePrivateKey(this.key),this.pubkey=this.soda.generatePublicKey(this.privkey),this.characters=this.characters||"BASE64")}static create({secretOrBundle:e,token:t,batchId:s=null,characters:n=null}){let a=Z.isBundleHash(e)?null:e,i=a?N(a):e,r=a?Z.generatePosition():null,o=new Z({secret:a,token:t,position:r,batchId:s,characters:n});return o.bundle=i,o}static isBundleHash(e){return"string"==typeof e&&(64===e.length&&U(e))}static getTokenUnits(e){let t=[];return e.forEach((e=>{t.push(L.createFromDB(e))})),t}getTokenUnitsData(){const e=[];return this.tokenUnits.forEach((t=>{e.push(t.toData())})),e}splitUnits(e,t,s=null){if(0===e.length)return;let n=[],a=[];this.tokenUnits.forEach((t=>{e.includes(t.id)?n.push(t):a.push(t)})),this.tokenUnits=n,null!==s&&(s.tokenUnits=n),t.tokenUnits=a}isShadow(){return!(void 0!==this.position&&null!==this.position||void 0!==this.address&&null!==this.address)}initBatchId({sourceWallet:e,isRemainder:t=!1}){e.batchId&&(this.batchId=t?e.batchId:F({}))}encryptMessage(e){const t={};for(let s=1,n=arguments.length;s<n;s++)t[this.soda.shortHash(arguments[s])]=this.soda.encrypt(e,arguments[s]);return t}decryptMessage(e){const t=this.pubkey;let s=e;return null!==e&&"object"==typeof e&&"[object Object]"===Object.prototype.toString.call(e)&&(s=e[this.soda.shortHash(t)]||""),this.soda.decrypt(s,this.privkey,t)}decryptBinary(e){const t=this.decryptMessage(e);return new J({characters:"BASE64"}).decode(t)}encryptBinary(e){const t=Array.from(arguments).slice(1),s=new J({characters:"BASE64"}).encode(e);return this.encryptMessage(s,...t)}encryptString({data:e,publicKeys:t}){if(e){const s=this.pubkey;"string"==typeof t&&(t=[t]);const n=this.encryptMessage(e,s,...t);return btoa(JSON.stringify(n))}}decryptString({data:e,fallbackValue:t=null}){if(e)try{const s=JSON.parse(atob(e));return this.decryptMessage(s)||t}catch(s){return console.error(s),t||e}}static generateKey({secret:t,token:s,position:n}){const a=i(t,16).add(i(n,16)),r=e.create(8192);return r.update(a.toString(16)),s&&r.update(s),e.create(8192).update(r.hex()).hex()}static generateAddress(t){const s=x(t,128),n=e.create(8192);for(const t in s){let a=s[t];for(let t=1;t<=16;t++)a=e.create(512).update(a).hex();n.update(a)}return e.create(256).update(n.hex()).hex()}static generatePosition(e=64){return v(e,"abcdef0123456789")}}class G extends TypeError{constructor(e=null,t=null,s=null){if(super(e,t,s),null===e)throw new this(`Unknown ${this.constructor.name}`);this.name="BaseException"}toString(){return`${this.name}: ${this.message}.\nStack:\n${this.stack}`}}class X extends G{constructor(e="There is an atom without an index",t=null,s=null){super(e,t,s),this.name="AtomIndexException"}}class Y extends G{constructor(e="The molecule does not contain atoms",t=null,s=null){super(e,t,s),this.name="AtomsMissingException"}}class ee extends G{constructor(e="The molecular hash does not match",t=null,s=null){super(e,t,s),this.name="MolecularHashMismatchException"}}class te extends G{constructor(e="The molecular hash is missing",t=null,s=null){super(e,t,s),this.name="MolecularHashMissingException"}}class se extends G{constructor(e="",t=null,s=null){super(e,t,s),this.name="PolicyInvalidException"}}class ne extends G{constructor(e="OTS malformed",t=null,s=null){super(e,t,s),this.name="SignatureMalformedException"}}class ae extends G{constructor(e="One-time signature (OTS) does not match!",t=null,s=null){super(e,t,s),this.name="SignatureMismatchException"}}class ie extends G{constructor(e="Insufficient balance to make transfer",t=null,s=null){super(e,t,s),this.name="TransferBalanceException"}}class re extends G{constructor(e="Token transfer atoms are malformed",t=null,s=null){super(e,t,s),this.name="TransferMalformedException"}}class oe extends G{constructor(e="Token slugs for wallets in transfer do not match!",t=null,s=null){super(e,t,s),this.name="TransferMismatchedException"}}class le extends G{constructor(e="Invalid remainder provided",t=null,s=null){super(e,t,s),this.name="TransferRemainderException"}}class ue extends G{constructor(e="Sender and recipient(s) cannot be the same",t=null,s=null){super(e,t,s),this.name="TransferToSelfException"}}class ce extends G{constructor(e="Token transfer atoms are unbalanced",t=null,s=null){super(e,t,s),this.name="TransferUnbalancedException"}}class he extends G{constructor(e="Empty meta data.",t=null,s=null){super(e,t,s),this.name="MetaMissingException"}}class de extends G{constructor(e="Wrong type of token for this isotope",t=null,s=null){super(e,t,s),this.name="WrongTokenTypeException"}}class pe extends G{constructor(e="Incorrect BatchId",t=null,s=null){super(e,t,s),this.name="BatchIdException"}}class me{constructor({}){const e=arguments[0];for(const t in e)this[`__${t}`]=e[t]}toJSON(){const e={};for(const t of Object.keys(this))"__"===t.substring(0,2)&&(e[t.substring(2,t.length)]=this[t]);return e}static toObject(e){return new this(e)}}class ye extends G{constructor(e="An incorrect argument!",t=null,s=null){super(e,t,s),this.name="RuleArgumentException"}}class ge extends G{constructor(e="Code exception",t=null,s=null){super(e,t,s),this.name="CodeException"}}class ke{constructor({action:e,metaType:t=null,metaId:s=null,meta:n=null,address:a=null,token:i=null,amount:r=null,comparison:o=null}){if(n&&(this.meta=n),!e)throw new ye('Callback structure violated, missing mandatory "action" parameter.');this.__metaId=s,this.__metaType=t,this.__action=e,this.__address=a,this.__token=i,this.__amount=r,this.__comparison=o}set comparison(e){this.__comparison=e}set amount(e){if("number"!=typeof(t=e)&&("string"!=typeof t||""===t.trim())||isNaN(t))throw new ge("Parameter amount should be a string containing numbers");var t;this.__amount=e}set token(e){this.__token=e}set address(e){this.__address=e}set meta(e){this.__meta=e instanceof me?e:me.toObject(e)}set metaType(e){this.__metaType=e}set metaId(e){this.__metaId=e}toJSON(){const e={action:this.__action};return this.__metaType&&(e.metaType=this.__metaType),this.__metaId&&(e.metaId=this.__metaId),this.__meta&&(e.meta=this.__meta),this.__address&&(e.address=this.__address),this.__token&&(e.token=this.__token),this.__amount&&(e.amount=this.__amount),this.__comparison&&(e.comparison=this.__comparison),e}static toObject(e){const t=new ke({action:e.action});return e.metaType&&(t.metaType=e.metaType),e.metaId&&(t.metaId=e.metaId),e.meta&&(t.meta=e.meta),e.address&&(t.address=e.address),e.token&&(t.token=e.token),e.amount&&(t.amount=e.amount),e.comparison&&(t.comparison=e.comparison),t}isReject(){return this._is("reject")}isMeta(){return 4===j(Object.keys(this.toJSON()),["action","metaId","metaType","meta"]).length&&this._is("meta")}isCollect(){return 5===j(Object.keys(this.toJSON()),["action","address","token","amount","comparison"]).length&&this._is("collect")}isBuffer(){return 5===j(Object.keys(this.toJSON()),["action","address","token","amount","comparison"]).length&&this._is("buffer")}isRemit(){return 3===j(Object.keys(this.toJSON()),["action","token","amount"]).length&&this._is("remit")}isBurn(){return 4===j(Object.keys(this.toJSON()),["action","token","amount","comparison"]).length&&this._is("burn")}_is(e){return this.__action.toLowerCase()===e.toLowerCase()}}class be{constructor({key:e,value:t,comparison:s}){if([e,t,s].some((e=>!e)))throw new ye("Condition::constructor( { key, value, comparison } ) - not all class parameters are initialised!");this.__key=e,this.__value=t,this.__comparison=s}toJSON(){return{key:this.__key,value:this.__value,comparison:this.__comparison}}static toObject(e){return new this({key:e.key,value:e.value,comparison:e.comparison})}}class _e{constructor({condition:e=[],callback:t=[]}){for(const t of e)if(!(t instanceof be))throw new ye;for(const e of t)if(!(e instanceof ke))throw new ye;this.__condition=e,this.__callback=t}set comparison(e){this.__condition.push(e instanceof be?e:be.toObject(e))}set callback(e){this.__callback.push(e instanceof ke?e:ke.toObject(e))}toJSON(){return{condition:this.__condition,callback:this.__callback}}static toObject(e){if(!e.condition)throw new he("Rule::toObject() - Incorrect rule format! There is no condition field.");if(!e.callback)throw new he("Rule::toObject() - Incorrect rule format! There is no callback field.");const t=new _e({});for(const s of e.condition)t.comparison=s;for(const s of e.callback)console.log(s),t.callback=s;return t}}class fe{static __init(e,t){this.arr=[],this.key=null,this.arr=String(t).split("."),this.key=this.arr.shift();const s=Number(this.key);Number.isInteger(s)&&(this.key=s),this.__nextKey=this.arr.length,this.__next=this.__tic(e)}static __tic(e){return!!(Array.isArray(e)||e instanceof Object)&&void 0!==e[this.key]}static has(e,t){return this.__init(e,t),!!this.__next&&(0===this.__nextKey||this.has(e[this.key],this.arr.join(".")))}static get(e,t,s=null){return this.__init(e,t),this.__next?0===this.__nextKey?e[this.key]:this.get(e[this.key],this.arr.join("."),s):s}}class we{constructor(e){if(null===e.molecularHash)throw new te;if(!e.atoms.length)throw new Y;for(let t of e.atoms)if(null===t.index)throw new X;this.molecule=e}verify(e){return this.molecularHash()&&this.ots()&&this.batchId()&&this.continuId()&&this.isotopeM()&&this.isotopeT()&&this.isotopeC()&&this.isotopeU()&&this.isotopeI()&&this.isotopeR()&&this.isotopeV(e)}continuId(){if("USER"===this.molecule.atoms[0].token&&this.molecule.getIsotopes("I").length<1)throw new Y("Check::continuId() - Molecule is missing required ContinuID Atom!");return!0}batchId(){if(this.molecule.atoms.length>0){const e=this.molecule.atoms[0];if("V"===e.isotope&&null!==e.batchId){const t=this.molecule.getIsotopes("V"),s=t[t.length-1];if(e.batchId!==s.batchId)throw new pe;for(const e of t)if(null===e.batchId)throw new pe}return!0}throw new pe}isotopeI(){for(let e of this.molecule.getIsotopes("I")){if("USER"!==e.token)throw new de(`Check::isotopeI() - "${e.token}" is not a valid Token slug for "${e.isotope}" isotope Atoms!`);if(0===e.index)throw new X(`Check::isotopeI() - Isotope "${e.isotope}" Atoms must have a non-zero index!`)}return!0}isotopeU(){for(let e of this.molecule.getIsotopes("U")){if("AUTH"!==e.token)throw new de(`Check::isotopeU() - "${e.token}" is not a valid Token slug for "${e.isotope}" isotope Atoms!`);if(0!==e.index)throw new X(`Check::isotopeU() - Isotope "${e.isotope}" Atoms must have an index equal to 0!`)}return!0}isotopeM(){const e=["readPolicy","writePolicy"];for(let t of this.molecule.getIsotopes("M")){if(t.meta.length<1)throw new he;if("USER"!==t.token)throw new de(`Check::isotopeM() - "${t.token}" is not a valid Token slug for "${t.isotope}" isotope Atoms!`);const s=O.aggregateMeta(t.meta);for(const t of e){let n=s[t];if(n){n=JSON.parse(n);for(const[t,a]of Object.entries(n))if(!e.includes(t)){if(!Object.keys(s).includes(t))throw new se(`${t} is missing from the meta.`);for(const e of a)if(!Z.isBundleHash(e)&&!["all","self"].includes(e))throw new se(`${e} does not correspond to the format of the policy.`)}}}}return!0}isotopeC(){for(let e of this.molecule.getIsotopes("C")){if("USER"!==e.token)throw new de(`Check::isotopeC() - "${e.token}" is not a valid Token slug for "${e.isotope}" isotope Atoms!`);if(0!==e.index)throw new X(`Check::isotopeC() - Isotope "${e.isotope}" Atoms must have an index equal to 0!`)}return!0}isotopeT(){for(let e of this.molecule.getIsotopes("T")){const t=e.aggregatedMeta();if("wallet"===String(e.metaType).toLowerCase())for(let e of["position","bundle"])if(!t.hasOwnProperty(e)||!Boolean(t[e]))throw new he(`Check::isotopeT() - Required meta field "${e}" is missing!`);for(let e of["token"])if(!t.hasOwnProperty(e)||!Boolean(t[e]))throw new he(`Check::isotopeT() - Required meta field "${e}" is missing!`);if("USER"!==e.token)throw new de(`Check::isotopeT() - "${e.token}" is not a valid Token slug for "${e.isotope}" isotope Atoms!`);if(0!==e.index)throw new X(`Check::isotopeT() - Isotope "${e.isotope}" Atoms must have an index equal to 0!`)}return!0}isotopeR(){for(let e of this.molecule.getIsotopes("R")){const t=e.aggregatedMeta();if(t.policy){const e=JSON.parse(t.policy);if(!Object.keys(e).every((e=>["read","write"].includes(e))))throw new he("Check::isotopeR() - Mixing rules with politics!")}if(t.rule){const e=JSON.parse(t.rule);if(!Array.isArray(e))throw new he("Check::isotopeR() - Incorrect rule format!");for(const t of e)_e.toObject(t);if(e.length<1)throw new he("Check::isotopeR() - No rules!")}}return!0}isotopeV(e=null){const t=this.molecule.getIsotopes("V");if(0===t.length)return!0;const s=this.molecule.atoms[0];if("V"===s.isotope&&2===t.length){const e=t[t.length-1];if(s.token!==e.token)throw new oe;if(e.value<0)throw new re;return!0}let n=0,a=0;for(let e in this.molecule.atoms)if(this.molecule.atoms.hasOwnProperty(e)){const t=this.molecule.atoms[e];if("V"!==t.isotope)continue;if(a=1*t.value,Number.isNaN(a))throw new TypeError('Invalid isotope "V" values');if(t.token!==s.token)throw new oe;if(e>0){if(a<0)throw new re;if(t.walletAddress===s.walletAddress)throw new ue}n+=a}if(n!==a)throw new ce;if(e){if(a=1*s.value,Number.isNaN(a))throw new TypeError('Invalid isotope "V" values');const t=1*e.balance+1*a;if(t<0)throw new ie;if(t!==n)throw new le}else if(0!==a)throw new le;return!0}molecularHash(){if(this.molecule.molecularHash!==Q.hashAtoms({atoms:this.molecule.atoms}))throw new ee;return!0}ots(){const t=this.molecule.normalizedHash();let s=this.molecule.atoms.map((e=>e.otsFragment)).reduce(((e,t)=>e+t));if(2048!==s.length&&(s=B(s),2048!==s.length))throw new ne;const n=x(s,128);let a="";for(const s in n){let i=n[s];for(let n=0,a=8+t[s];n<a;n++)i=e.create(512).update(i).hex();a+=i}const i=e.create(8192).update(a).hex(),r=e.create(256).update(i).hex();let o=this.molecule.atoms[0],l=o.walletAddress,u=fe.get(o.aggregatedMeta(),"signingWallet");if(u&&(l=fe.get(JSON.parse(u),"address")),r!==l)throw new ae;return!0}}class $e extends G{constructor(e="Insufficient balance for requested transfer",t=null,s=null){super(e,t,s),this.name="BalanceInsufficientException"}}class Se extends G{constructor(e="Amount cannot be negative!",t=null,s=null){super(e,t,s),this.name="NegativeAmountException"}}class Ie{constructor({secret:e=null,sourceWallet:t=null,remainderWallet:s=null,cellSlug:n=null}){this.cellSlugOrigin=this.cellSlug=n,this.secret=e,this.sourceWallet=t,this.atoms=[],(s||t)&&(this.remainderWallet=s||Z.create({secretOrBundle:e,token:t.token,batchId:t.batchId,characters:t.characters})),this.clear()}static isotopeFilter(e,t){return Array.isArray(e)||(e=[e]),t.filter((t=>e.includes(t.isotope)))}getIsotopes(e){return Ie.isotopeFilter(e,this.atoms)}static generateNextAtomIndex(e){return e.length}generateIndex(){return Ie.generateNextAtomIndex(this.atoms)}fill(e){for(let t in Object.keys(e))this[t]=e[t]}addAtom(e){return this.molecularHash=null,e.index=this.generateIndex(),this.atoms.push(e),this.atoms=Q.sortAtoms(this.atoms),this}addContinuIdAtom(){return this.addAtom(Q.create({isotope:"I",wallet:this.remainderWallet,metaType:"walletBundle",metaId:this.remainderWallet.bundle})),this}addPolicyAtom({metaType:e,metaId:t,meta:s={},policy:n={}}){let a=new K(s);return a.addPolicy(n),this.addAtom(Q.create({isotope:"R",metaType:e,metaId:t,meta:a})),this}fuseToken(e,t){let s=e.length;if(this.sourceWallet.balance-s<0)throw new $e;return this.addAtom(Q.create({isotope:"V",wallet:this.sourceWallet,value:-s})),this.addAtom(Q.create({isotope:"F",wallet:t,value:1,metaType:"walletBundle",metaId:t.bundle})),this.addAtom(Q.create({isotope:"V",wallet:this.remainderWallet,value:this.sourceWallet.balance-s,metaType:"walletBundle",metaId:this.remainderWallet.bundle})),this}burnToken({amount:e,walletBundle:t=null}){if(e<0)throw new Se("Molecule::burnToken() - Amount to burn must be positive!");if(this.sourceWallet.balance-e<0)throw new $e;return this.molecularHash=null,this.addAtom(Q.create({isotope:"V",wallet:this.sourceWallet,value:-e})),this.addAtom(Q.create({isotope:"V",wallet:this.remainderWallet,value:this.sourceWallet.balance-e,metaType:"walletBundle",metaId:this.remainderWallet.bundle})),this}replenishToken({amount:e,units:t=[]}){if(e<0)throw new Se("Molecule::replenishToken() - Amount to replenish must be positive!");if(t.length){t=Z.getTokenUnits(t),this.remainderWallet.tokenUnits=this.sourceWallet.tokenUnits;for(const e of t)this.remainderWallet.tokenUnits.push(e);this.remainderWallet.balance=this.remainderWallet.tokenUnits.length,this.sourceWallet.tokenUnits=t,this.sourceWallet.balance=this.sourceWallet.tokenUnits.length}else this.remainderWallet.balance=this.sourceWallet.balance+e,this.sourceWallet.balance=e;return this.molecularHash=null,this.addAtom(Q.create({isotope:"V",wallet:this.sourceWallet,value:this.sourceWallet.balance})),this.addAtom(Q.create({isotope:"V",wallet:this.remainderWallet,value:this.remainderWallet.balance,metaType:"walletBundle",metaId:this.remainderWallet.bundle})),this}initValue({recipientWallet:e,amount:t}){if(this.sourceWallet.balance-t<0)throw new $e;return this.molecularHash=null,this.addAtom(Q.create({isotope:"V",wallet:this.sourceWallet,value:-t})),this.addAtom(Q.create({isotope:"V",wallet:e,value:t,metaType:"walletBundle",metaId:e.bundle})),this.addAtom(Q.create({isotope:"V",wallet:this.remainderWallet,value:this.sourceWallet.balance-t,metaType:"walletBundle",metaId:this.remainderWallet.bundle})),this}initDepositBuffer({amount:e,tradeRates:t}){if(this.sourceWallet.balance-e<0)throw new $e;let s=Z.create({secretOrBundle:this.secret,token:this.sourceWallet.token,batchId:this.sourceWallet.batchId});return s.tradeRates=t,this.molecularHash=null,this.addAtom(Q.create({isotope:"V",wallet:this.sourceWallet,value:-e})),this.addAtom(Q.create({isotope:"B",wallet:s,value:e,metaType:"walletBundle",metaId:this.sourceWallet.bundle})),this.addAtom(Q.create({isotope:"V",wallet:this.remainderWallet,value:this.sourceWallet.balance-e,metaType:"walletBundle",metaId:this.sourceWallet.bundle})),this}initWithdrawBuffer({recipients:e,signingWallet:t=null}){let s=0;for(const[t,n]of Object.entries(e||{}))s+=n;if(this.sourceWallet.balance-s<0)throw new $e;let n=new K;t&&n.addSigningWallet(t),this.addAtom(Q.create({isotope:"B",wallet:this.sourceWallet,value:-s,meta:n,metaType:"walletBundle",metaId:this.sourceWallet.bundle}));for(const[t,s]of Object.entries(e||{}))this.addAtom(new Q({isotope:"V",token:this.sourceWallet.token,value:s,batchId:this.sourceWallet.batchId?F({}):null,metaType:"walletBundle",metaId:t}));return this.addAtom(Q.create({isotope:"B",wallet:this.remainderWallet,value:this.sourceWallet.balance-s,metaType:"walletBundle",metaId:this.remainderWallet.bundle})),this}initWalletCreation(e){this.molecularHash=null;let t=new K({address:e.address,token:e.token,bundle:e.bundle,position:e.position,amount:0,batchId:e.batchId});return this.addAtom(Q.create({isotope:"C",wallet:this.sourceWallet,metaType:"wallet",metaId:e.address,meta:t})),this.addContinuIdAtom(),this}initTokenCreation({recipientWallet:e,amount:t,meta:s}){this.molecularHash=null;for(const t of["walletAddress","walletPosition","walletPubkey","walletCharacters"])s[t]||(s[t]=e[t.toLowerCase().substring(6)]);return this.addAtom(Q.create({isotope:"C",wallet:this.sourceWallet,value:t,metaType:"token",metaId:e.token,meta:new K(s),batchId:e.batchId})),this.addContinuIdAtom(),this}createRule({metaType:e,metaId:t,rule:s,policy:n={}}){const a=[];for(const e of s)a.push(e instanceof _e?e:_e.toObject(e));let i=new K({rule:JSON.stringify(a)});return i.addPolicy(n),this.addAtom(Q.create({isotope:"R",wallet:this.sourceWallet,metaType:e,metaId:t,meta:i})),this.addContinuIdAtom(),this}initShadowWalletClaim({token:e,wallet:t}){let s={tokenSlug:e,walletAddress:t.address,walletPosition:t.position,pubkey:t.pubkey,characters:t.characters,batchId:t.batchId};return this.addAtom(Q.create({isotope:"C",wallet:this.sourceWallet,metaType:"wallet",metaId:t.address,meta:new K(s)})),this.addContinuIdAtom(),this}initIdentifierCreation({type:e,contact:t,code:s}){const n={code:s,hash:N(t.trim())};return this.addAtom(Q.create({isotope:"C",wallet:this.sourceWallet,metaType:"identifier",metaId:e,meta:new K(n)})),this.addContinuIdAtom(),this}initMeta({meta:e,metaType:t,metaId:s,policy:n}){return this.addAtom(Q.create({isotope:"M",wallet:this.sourceWallet,metaType:t,metaId:s,meta:new K(e)})),this.addPolicyAtom({metaType:t,metaId:s,meta:e,policy:n}),this.addContinuIdAtom(),this}initTokenRequest({token:e,amount:t,metaType:s,metaId:n,meta:a={},batchId:i=null}){return a.token=e,this.addAtom(Q.create({isotope:"T",wallet:this.sourceWallet,value:t,metaType:s,metaId:n,meta:new K(a),batchId:i})),this.addContinuIdAtom(),this}initAuthorization({meta:e}){return this.addAtom(Q.create({isotope:"U",wallet:this.sourceWallet,meta:new K(e)})),this.addContinuIdAtom(),this}clear(){return this.molecularHash=null,this.bundle=null,this.status=null,this.createdAt=String(+new Date),this.atoms=[],this}sign({anonymous:t=!1,compressed:s=!0}){if(0===this.atoms.length||0!==this.atoms.filter((e=>!(e instanceof Q))).length)throw new Y;t||(this.bundle=N(this.secret)),this.molecularHash=Q.hashAtoms({atoms:this.atoms});const n=this.atoms[0];let a=n.position,i=fe.get(n.aggregatedMeta(),"signingWallet");if(i&&(a=fe.get(JSON.parse(i),"position")),!a)throw new ne("Signing wallet must have a position!");const r=x(Z.generateKey({secret:this.secret,token:n.token,position:n.position}),128),o=this.normalizedHash();let l="";for(const t in r){let s=r[t];for(let n=0,a=8-o[t];n<a;n++)s=e.create(512).update(s).hex();l+=s}s&&(l=M(l));const u=x(l,Math.ceil(l.length/this.atoms.length));let c=null;for(let e=0,t=u.length;e<t;e++)this.atoms[e].otsFragment=u[e],c=this.atoms[e].position;return c}static jsonToObject(e){const t=Object.assign(new Ie({}),JSON.parse(e)),s=Object.keys(new Ie({}));if(!Array.isArray(t.atoms))throw new Y;for(const e in Object.keys(t.atoms)){t.atoms[e]=Q.jsonToObject(JSON.stringify(t.atoms[e]));for(const s of["position","walletAddress","isotope"])if(void 0===t.atoms[e][s]||null===t.atoms[e][s])throw new Y("MolecularStructure::jsonToObject() - Required Atom properties are missing!")}for(const e in t)t.hasOwnProperty(e)&&!s.includes(e)&&delete t[e];return t.atoms=Q.sortAtoms(t.atoms),t}get cellSlugDelimiter(){return"."}cellSlugBase(){return(this.cellSlug||"").split(this.cellSlugDelimiter)[0]}toJSON(){let e=H(this);for(let t of["remainderWallet","secret","sourceWallet","cellSlugOrigin"])e.hasOwnProperty(t)&&delete e[t];return e}check(e=null){new we(this).verify(e)}normalizedHash(){return Ie.normalize(Ie.enumerate(this.molecularHash))}static enumerate(e){const t={0:-8,1:-7,2:-6,3:-5,4:-4,5:-3,6:-2,7:-1,8:0,9:1,a:2,b:3,c:4,d:5,e:6,f:7,g:8},s=[],n=e.toLowerCase().split("");for(let e=0,a=n.length;e<a;++e){const a=n[e];void 0!==t[a]&&(s[e]=t[a])}return s}static normalize(e){let t=e.reduce(((e,t)=>e+t));const s=t<0;for(;t<0||t>0;)for(const n of Object.keys(e)){if((s?e[n]<8:e[n]>-8)&&(s?(++e[n],++t):(--e[n],--t),0===t))break}return e}}class Te{static val(e){return Math.abs(1e18*e)<1?0:e}static cmp(e,t,s=!1){const n=1e18*Te.val(e),a=1e18*Te.val(t);return Math.abs(n-a)<1?0:n>a?1:-1}static equal(e,t){return 0===Te.cmp(e,t)}}class Ae{static create(e,t){let s=new Ae(e);return s.setWallet(t),s}static restore(e,t){let s=new Z({secret:t,token:"AUTH",position:e.wallet.position,characters:e.wallet.characters});return Ae.create({token:e.token,expiresAt:e.expiresAt,pubkey:e.pubkey,encrypt:e.encrypt},s)}constructor({token:e,expiresAt:t,encrypt:s,pubkey:n}){this.$__token=e,this.$__expiresAt=t,this.$__pubkey=n,this.$__encrypt=s}setWallet(e){this.$__wallet=e}getWallet(){return this.$__wallet}getSnapshot(){return{token:this.$__token,expiresAt:this.$__expiresAt,pubkey:this.$__pubkey,encrypt:this.$__encrypt,wallet:{position:this.$__wallet.position,characters:this.$__wallet.characters}}}getToken(){return this.$__token}getPubkey(){return this.$__pubkey}getExpireInterval(){return 1e3*this.$__expiresAt-Date.now()}isExpired(){return!this.$__expiresAt||this.getExpireInterval()<0}getAuthData(){return{token:this.getToken(),pubkey:this.getPubkey(),wallet:this.getWallet()}}}class xe extends G{constructor(e="GraphQL did not provide a valid response.",t=null,s=null){super(e,t,s),this.name="InvalidResponseException"}}class ve extends G{constructor(e="Authorization token missing or invalid.",t=null,s=null){super(e,t,s),this.name="UnauthenticatedException"}}class qe{constructor({query:e,json:t,dataKey:s=null}){if(this.dataKey=s,this.errorKey="exception",this.$__payload=null,this.$__query=e,this.$__originResponse=t,this.$__response=t,void 0===this.$__response||null===this.$__response)throw new xe;if(fe.has(this.$__response,this.errorKey)){const e=fe.get(this.$__response,this.errorKey);if(String(e).includes("Unauthenticated"))throw new ve;throw new xe}this.init()}init(){}data(){if(!this.dataKey)return this.response();if(!fe.has(this.response(),this.dataKey))throw new xe;return fe.get(this.response(),this.dataKey)}response(){return this.$__response}payload(){return null}query(){return this.$__query}status(){return null}}class We{constructor(e){this.client=e,this.$__variables=null,this.$__query=null}response(){return this.$__response}async createResponseRaw(e){return this.createResponse(e)}createResponse(e){return new qe({query:this,json:e})}createQuery({variables:e=null}){if(this.$__variables=this.compiledVariables(e),!this.uri())throw new ge("Query::createQuery() - Node URI was not initialized for this client instance!");if(null===this.$__query)throw new ge("Query::createQuery() - GraphQL subscription was not initialized!");return{query:this.$__query,variables:this.variables()}}async execute({variables:e=null}){this.$__request=this.createQuery({variables:e});let t=await this.client.query(this.$__request);return this.$__response=await this.createResponseRaw(t),this.$__response}compiledVariables(e=null){return e||{}}uri(){return this.client.getUri()}variables(){return this.$__variables}}class Ce extends qe{constructor({query:e,json:t}){super({query:e,json:t,dataKey:"data.ContinuId"})}payload(){let e=null;const t=this.data();return t&&(e=new Z({secret:null,token:t.tokenSlug}),e.address=t.address,e.position=t.position,e.bundle=t.bundleHash,e.batchId=t.batchId,e.characters=t.characters,e.pubkey=t.pubkey,e.balance=1*t.amount),e}}class Me extends We{constructor(e){super(e),this.$__query=p`query ($bundle: String!) {
      ContinuId(bundle: $bundle) {
        address,
        bundleHash,
        tokenSlug,
        position,
        batchId,
        characters,
        pubkey,
        amount,
        createdAt
      }
    }`}createResponse(e){return new Ce({query:this,json:e})}}class Be extends qe{constructor({query:e,json:t}){super({query:e,json:t,dataKey:"data.WalletBundle"})}payload(){const e=this.data();if(!e||0===e.length)return null;const t={};return e.forEach((e=>{e.metas=O.aggregateMeta(e.metas),t[e.bundleHash]=e})),t}}class Ue extends We{constructor(e){super(e),this.$__query=p`query( $bundleHash: String, $bundleHashes: [ String! ], $key: String, $keys: [ String! ], $value: String, $values: [ String! ], $keys_values: [ MetaInput ], $latest: Boolean, $limit: Int, $order: String ) {
      WalletBundle( bundleHash: $bundleHash, bundleHashes: $bundleHashes, key: $key, keys: $keys, value: $value, values: $values, keys_values: $keys_values, latest: $latest, limit: $limit, order: $order ) {
        bundleHash,
        metas {
          molecularHash,
          position,
          key,
          value,
          createdAt
        },
        createdAt
      }
    }`}createResponse(e){return new Be({query:this,json:e})}static createVariables({bundleHash:e=null,key:t=null,value:s=null,latest:n=!0}){const a={latest:n};return e&&(a["string"==typeof e?"bundleHash":"bundleHashes"]=e),t&&(a["string"==typeof t?"key":"keys"]=t),s&&(a["string"==typeof s?"value":"values"]=s),a}}class Oe extends qe{constructor({query:e,json:t}){super({query:e,json:t,dataKey:"data.Wallet"})}static toClientWallet({data:e,secret:t=null}){let s;if(null===e.position||void 0===e.position?s=Z.create({secretOrBundle:e.bundleHash,token:e.tokenSlug,batchId:e.batchId,characters:e.characters}):(s=new Z({secret:t,token:e.tokenSlug,position:e.position,batchId:e.batchId,characters:e.characters}),s.address=e.address,s.bundle=e.bundleHash),e.token&&(s.tokenName=e.token.name,s.tokenAmount=e.token.amount,s.tokenSupply=e.token.supply,s.tokenFungibility=e.token.fungibility),e.tokenUnits.length)for(let t of e.tokenUnits)s.tokenUnits.push(L.createFromGraphQL(t));if(e.tradeRates.length)for(let t of e.tradeRates)s.tradeRates[t.tokenSlug]=t.amount;return s.molecules=e.molecules,s.balance=Number(e.amount),s.pubkey=e.pubkey,s.createdAt=e.createdAt,s}getWallets(e=null){const t=this.data();if(!t)return null;const s=[];for(let n of t)s.push(Oe.toClientWallet({data:n,secret:e}));return s}payload(){return this.getWallets()}}class He extends We{constructor(e){super(e),this.$__query=p`query( $address: String, $bundleHash: String, $token: String, $position: String, $unspent: Boolean ) {
      Wallet( address: $address, bundleHash: $bundleHash, token: $token, position: $position, unspent: $unspent ) {
        address,
        bundleHash,
        token {
          name,
          amount,
          fungibility,
          supply
        },
        molecules {
          molecularHash,
          createdAt
        }
        tokenSlug,
        batchId,
        position,
        amount,
        characters,
        pubkey,
        createdAt,
        tokenUnits {
          id,
          name,
          metas
        },
        tradeRates {
          tokenSlug,
          amount
        }
      }
    }`}createResponse(e){return new Oe({query:this,json:e})}}class Re extends qe{constructor({query:e,json:t}){super({query:e,json:t,dataKey:"data.Balance"})}payload(){const e=this.data();return e&&e.bundleHash&&e.tokenSlug?Oe.toClientWallet({data:e}):null}}class je extends We{constructor(e){super(e),this.$__query=p`query( $address: String, $bundleHash: String, $type: String, $token: String, $position: String ) {
      Balance( address: $address, bundleHash: $bundleHash, type: $type, token: $token, position: $position ) {
        address,
        bundleHash,
        type,
        tokenSlug,
        batchId,
        position,
        amount,
        characters,
        pubkey,
        createdAt,
        tokenUnits {
          id,
          name,
          metas
        },
        tradeRates {
          tokenSlug,
          amount
        }
      }
    }`}createResponse(e){return new Re({query:this,json:e})}}class Ee extends qe{constructor({query:e,json:t}){super({query:e,json:t,dataKey:"data.MetaType"})}payload(){const e=this.data();if(!e||0===e.length)return null;let t={instances:{},instanceCount:{},paginatorInfo:{}},s=e.pop();return s.instances&&(t.instances=s.instances),s.instanceCount&&(t.instanceCount=s.instanceCount),s.paginatorInfo&&(t.paginatorInfo=s.paginatorInfo),t}}class Ke extends We{constructor(e){super(e),this.$__query=p`query( $metaType: String, $metaTypes: [ String! ], $metaId: String, $metaIds: [ String! ], $key: String, $keys: [ String! ], $value: String, $values: [ String! ], $count: String, $latest: Boolean, $filter: [ MetaFilter! ], $latestMetas: Boolean, $queryArgs: QueryArgs, $countBy: String ) {
      MetaType( metaType: $metaType, metaTypes: $metaTypes, metaId: $metaId, metaIds: $metaIds, key: $key, keys: $keys, value: $value, values: $values, count: $count, filter: $filter, latestMetas: $latestMetas, queryArgs: $queryArgs, countBy: $countBy ) {
        metaType,
        instanceCount {
          key,
          value
        },
        instances {
          metaType,
          metaId,
          createdAt,
          metas(latest:$latest) {
            molecularHash,
            position,
            key,
            value,
            createdAt
          }
        },
        paginatorInfo {
          currentPage,
          total
        }
      }
    }`}createResponse(e){return new Ee({query:this,json:e})}static createVariables({metaType:e=null,metaId:t=null,key:s=null,value:n=null,latest:a=null,latestMetas:i=!0,filter:r=null,queryArgs:o=null,count:l=null,countBy:u=null}){const c={};return e&&(c["string"==typeof e?"metaType":"metaTypes"]=e),t&&(c["string"==typeof t?"metaId":"metaIds"]=t),s&&(c["string"==typeof s?"key":"keys"]=s),n&&(c["string"==typeof n?"value":"values"]=n),a&&(c.latest=!!a),i&&(c.latestMetas=!!i),r&&(c.filter=r),o&&(void 0!==o.limit&&0!==o.limit||(o.limit="*"),c.queryArgs=o),l&&(c.count=l),u&&(c.countBy=u),c}}class Qe extends We{constructor(e){super(e),this.$__query=p`query( $batchId: String ) {
      Batch( batchId: $batchId ) {
        ${Qe.getFields()},
        children {
          ${Qe.getFields()}
        }
      }
    }`}static getFields(){return"batchId,\n              molecularHash,\n              type,\n              status,\n              createdAt,\n              wallet {\n                  address,\n                  bundleHash,\n                  amount,\n                  tokenSlug,\n                  token {\n                      name,\n                      amount\n                  },\n                  tokenUnits {\n                      id,\n                      name,\n                      metas\n                  }\n              },\n              fromWallet {\n                  address,\n                  bundleHash,\n                  amount,\n                  batchId\n              },\n              toWallet {\n                  address,\n                  bundleHash,\n                  amount,\n                  batchId\n              },\n              sourceTokenUnits {\n                  id,\n                  name,\n                  metas\n              },\n              transferTokenUnits {\n                  id,\n                  name,\n                  metas\n              },\n              metas {\n                  key,\n                  value,\n              },\n              throughMetas {\n                  key,\n                  value\n              }"}createResponse(e){let t=new qe({query:this,json:e});return t.dataKey="data.Batch",t}}class Pe extends We{constructor(e){super(e),this.$__query=p`query( $batchId: String ) {
      BatchHistory( batchId: $batchId ) {
        ${Qe.getFields()}
      }
    }`}createResponse(e){let t=new qe({query:this,json:e});return t.dataKey="data.BatchHistory",t}}class Ne extends qe{constructor({query:e,json:t}){super({query:e,json:t,dataKey:"data.ProposeMolecule"}),this.$__clientMolecule=e.molecule()}init(){const e=fe.get(this.data(),"payload");try{this.$__payload="[object String]"===Object.prototype.toString.call(e)?JSON.parse(e):e}catch(e){this.$__payload=null}}clientMolecule(){return this.$__clientMolecule}molecule(){const e=this.data();if(!e)return null;const t=new Ie({});return t.molecularHash=fe.get(e,"molecularHash"),t.status=fe.get(e,"status"),t.createdAt=fe.get(e,"createdAt"),t}success(){return"accepted"===this.status()}status(){return fe.get(this.data(),"status","rejected")}reason(){return fe.get(this.data(),"reason","Invalid response from server")}payload(){return this.$__payload}}class Fe extends We{constructor(e){super(e)}createQuery({variables:e=null}){const t=super.createQuery({variables:e});return t.mutation=t.query,delete t.query,t}async execute({variables:e=null}){this.$__request=this.createQuery({variables:e});let t=await this.client.mutate(this.$__request);return this.$__response=await this.createResponseRaw(t),this.$__response}}class Ve extends Fe{constructor(e,t=null){super(e),this.$__molecule=t,this.$__remainderWallet=null,this.$__query=p`mutation( $molecule: MoleculeInput! ) {
      ProposeMolecule( molecule: $molecule ) {
        molecularHash,
        height,
        depth,
        status,
        reason,
        payload,
        createdAt,
        receivedAt,
        processedAt,
        broadcastedAt,
      }
    }`}compiledVariables(e){return{...super.compiledVariables(e),molecule:this.molecule()}}createResponse(e){return new Ne({query:this,json:e})}async execute({variables:e=null}){return(e=e||{}).molecule=this.molecule(),super.execute({variables:e})}remainderWallet(){return this.$__remainderWallet}molecule(){return this.$__molecule}}class De extends Ne{payloadKey(e){if(!fe.has(this.payload(),e))throw new xe(`ResponseRequestAuthorization::payloadKey() - '${e}' key was not found in the payload!`);return fe.get(this.payload(),e)}token(){return this.payloadKey("token")}time(){return this.payloadKey("time")}encrypt(){return this.payloadKey("encrypt")}pubKey(){return this.payloadKey("key")}}class Je extends Ve{fillMolecule({meta:e}){this.$__molecule.initAuthorization({meta:e}),this.$__molecule.sign({}),this.$__molecule.check()}createResponse(e){return new De({query:this,json:e})}}class Le extends Ne{}class ze extends Ve{fillMolecule({recipientWallet:e,amount:t,meta:s=null}){this.$__molecule.initTokenCreation({recipientWallet:e,amount:t,meta:s||{}}),this.$__molecule.sign({}),this.$__molecule.check()}createResponse(e){return new Le({query:this,json:e})}}class Ze extends Ne{}class Ge extends Ve{fillMolecule({token:e,amount:t,metaType:s,metaId:n,meta:a=null,batchId:i=null}){this.$__molecule.initTokenRequest({token:e,amount:t,metaType:s,metaId:n,meta:a||{},batchId:i}),this.$__molecule.sign({}),this.$__molecule.check()}createResponse(e){return new Ze({query:this,json:e})}}class Xe extends Ne{payload(){const e={reason:null,status:null},t=this.data();return e.reason=void 0===t.reason?"Invalid response from server":t.reason,e.status=void 0===t.status?"rejected":t.status,e}}class Ye extends Ve{fillMolecule({recipientWallet:e,amount:t}){this.$__molecule.initValue({recipientWallet:e,amount:t}),this.$__molecule.sign({}),this.$__molecule.check(this.$__molecule.sourceWallet)}createResponse(e){return new Xe({query:this,json:e})}}class et extends Ne{}class tt extends Ve{fillMolecule({type:e,contact:t,code:s}){this.$__molecule.initIdentifierCreation({type:e,contact:t,code:s}),this.$__molecule.sign({}),this.$__molecule.check()}createResponse(e){return new et({query:this,json:e})}}class st extends Ne{}class nt extends Ve{fillMolecule({token:e,batchId:t=null}){let s=Z.create({secretOrBundle:this.$__molecule.secret,token:e,batchId:t});this.$__molecule.initShadowWalletClaim({token:e,wallet:s}),this.$__molecule.sign({}),this.$__molecule.check()}createResponse(e){return new st({query:this,json:e})}}class at extends Ne{}class it extends Ve{fillMolecule({metaType:e,metaId:t,meta:s,policy:n}){this.$__molecule.initMeta({meta:s,metaType:e,metaId:t,policy:n}),this.$__molecule.sign({}),this.$__molecule.check()}createResponse(e){return new at({query:this,json:e})}}class rt extends Ne{}class ot extends Ve{fillMolecule(e){this.$__molecule.initWalletCreation(e),this.$__molecule.sign({}),this.$__molecule.check()}createResponse(e){return new rt({query:this,json:e})}}class lt extends qe{constructor({query:e,json:t}){super({query:e,json:t,dataKey:"data.AccessToken"})}reason(){return"Invalid response from server"}success(){return null!==this.payload()}payload(){return this.data()}payloadKey(e){if(!fe.has(this.payload(),e))throw new xe(`ResponseAuthorizationGuest::payloadKey() - '${e}' key is not found in the payload!`);return fe.get(this.payload(),e)}token(){return this.payloadKey("token")}time(){return this.payloadKey("time")}pubKey(){return this.payloadKey("key")}encrypt(){return this.payloadKey("encrypt")}}class ut extends Fe{constructor(e){super(e),this.$__query=p`mutation( $cellSlug: String, $pubkey: String, $encrypt: Boolean ) {
      AccessToken( cellSlug: $cellSlug, pubkey: $pubkey, encrypt: $encrypt ) {
        token,
        pubkey,
        expiresAt
      }
    }`}createResponse(e){return new lt({query:this,json:e})}}class ct extends G{constructor(e="The shadow wallet does not exist",t=null,s=null){super(e,t,s),this.name="WalletShadowException"}}class ht extends G{constructor(e="Stackable tokens with unit IDs cannot have decimal places!",t=null,s=null){super(e,t,s),this.name="StackableUnitDecimalsException"}}class dt extends G{constructor(e="Stackable tokens with unit IDs cannot have decimal places!",t=null,s=null){super(e,t,s),this.name="StackableUnitAmountException"}}function pt(e){return e.query.definitions.find((e=>"OperationDefinition"===e.kind)).selectionSet.selections.find((e=>"Field"===e.kind)).name.value}function mt({graphQLErrors:e,networkError:t,operation:s,forward:n,response:a}){if(e&&e.map((({message:e,debugMessage:t,locations:s,path:n})=>console.error(`[GraphQL error]: ${e}\r\n`,`  Message : ${t}\r\n`,`  Path    : ${n}\r\n`,`  Location: ${s}\r\n`))),t){const{name:e,statusCode:s,result:n={}}=t;console.error(`[Network error]: ${e}, status code: ${s}`)}}class yt extends m{constructor(e){super(e)}request(e,t){return t(e)}}class gt extends y{constructor({socketUri:e,authEndpoint:t,appKey:s="knishio"}){console.log("PusherLink::constructor()..."),super(),this.socketUri=e,this.authEndpoint=t,this.appKey=s,this.setAuthToken(""),this.setTransport(this.getSocketUri())}setTransport(e){console.log(`Connecting to socket endpoint ${e}...`);const t=I(e);if(!["ws","wss"].includes(t.scheme))throw new ge("Incorrect scheme for the socket");this.transport=new S(this.appKey,{auth:{headers:{"X-Auth-Token":this.getAuthToken(),Accept:"application/json"}},wsHost:t.host,wsPort:t.port,forceTLS:"wss"===t.scheme,encrypted:!0,enabledTransports:[t.scheme],authEndpoint:this.authEndpoint})}disconnect(){this.transport.disconnect()}channel(e){return this.transport.channel(e)||null}getAuthToken(){return this.auth}setAuthToken(e){this.auth=e}getSocketUri(){return this.socketUri}request(e,t){this.transport.config.auth.headers["X-Auth-Token"]=this.getAuthToken();const s=new g((e=>{})),n=s.subscribe.bind(s);return s.subscribe=(s,a,i)=>{n(s,a,i);const r=function(e,t,s){return"function"==typeof e?{next:t=>e(t),error:e=>t&&t(e),complete:()=>s&&s()}:{next:t=>e.next&&e.next(t),error:t=>e.error&&e.error(t),complete:()=>e.complete&&e.complete()}}(s,a,i);let o;return t(e).subscribe({next:e=>{if(o=fe.get(e,"extensions.lighthouse_subscriptions.channel"),!o)return r.next(e),void r.complete();this.subscribeToChannel(o,r)}}),{closed:!1,unsubscribe:()=>{o&&this.unsubscribeFromChannel(o)}}},s}subscribeToChannel(e,t){this.transport.subscribe(e).bind("lighthouse-subscription",(s=>{s.more||(this.unsubscribeFromChannel(e),t.complete());const n=s.result;n&&t.next(n)}))}unsubscribeFromChannel(e){this.transport.unsubscribe(e)}}class kt extends y{constructor(){super(),this.auth=""}getAuthToken(){return this.auth}setAuthToken(e){this.auth=e}request(e,t){return e.setContext((({headers:e={}})=>({headers:{...e,"X-Auth-Token":this.getAuthToken()}}))),t(e)}}class bt extends y{constructor(){super(),this.__wallet=null,this.__pubkey=null}setWallet(e){this.__wallet=e}getWallet(){return this.__wallet}setPubKey(e){this.__pubkey=e}getPubKey(){return this.__pubkey}request(e,t){const s=pt(e),n=function(e){return e.query.definitions.find((e=>"OperationDefinition"===e.kind)).operation}(e),a="mutation"===n&&"ProposeMolecule"===s,i=["query"===n&&["__schema","ContinuId"].includes(s),"mutation"===n&&"AccessToken"===s,a&&"U"===fe.get(e,"variables.molecule.atoms.0.isotope")],r={query:T(e.query),variables:JSON.stringify(e.variables)},o=this.getWallet(),l=this.getPubKey();for(const s in i)if(i[s])return t(e);if(!l)throw new ge("CipherLink::request() - Node public key missing!");if(!o)throw new ge("CipherLink::request() - Authorized wallet missing!");return e.operationName=null,e.query=p`query ( $Hash: String! ) { CipherHash ( Hash: $Hash ) { hash } }`,e.variables={Hash:JSON.stringify(o.encryptMessage(r,l))},t(e).map((e=>{let t=e.data;if(t.data&&(t=t.data),t.CipherHash&&t.CipherHash.hash){const e=JSON.parse(t.CipherHash.hash),s=o.decryptMessage(e);if(null===s)throw new ge("CipherLink::request() - Unable to decrypt response!");return s}return e}))}}class _t extends k{constructor({serverUri:e,soketi:t=null,encrypt:s=!1}){const n={socketUri:null,appKey:"knishio",...t||{}},a=[],i=new yt({uri:e,fetch:f,transportBatching:!0}),r=new kt;let o=null,l=null;if(a.push(r),s&&(o=new bt,a.push(o)),n&&n.socketUri){const t=I(e);l=new gt({socketUri:n.socketUri,authEndpoint:`${t.scheme}://${t.host}/graphql/subscriptions/auth`,appKey:n.appKey}),a.push(l)}a.push(b($(mt),i)),super({link:_(a),cache:new w,connectToDevTools:!0,defaultOptions:{watchQuery:{fetchPolicy:"no-cache",errorPolicy:"ignore"},query:{fetchPolicy:"no-cache",errorPolicy:"all"},mutate:{fetchPolicy:"no-cache",errorPolicy:"all"},subscribe:{fetchPolicy:"no-cache",errorPolicy:"all"}}}),this.__serverUri=e,this.__soketi=n,this.__authLink=r,this.__socket=l,this.__cipherLink=o,this.__pubkey=null,this.__wallet=null}getAuthToken(){return this.__authLink.getAuthToken()}getPubKey(){return this.__pubkey}getWallet(){return this.__wallet}setAuthData({token:e,pubkey:t=null,wallet:s=null}){this.__wallet=s,this.__pubkey=t,this.__authLink.setAuthToken(e),this.__socket&&this.__socket.setAuthToken(e),this.__cipherLink&&(this.__cipherLink.setWallet(this.__wallet),this.__cipherLink.setPubKey(this.__pubkey))}socketDisconnect(){this.__socket&&this.__socket.disconnect()}unsubscribeFromChannel(e){this.__socket&&this.__socket.unsubscribeFromChannel(e)}getServerUri(){return this.__serverUri}getSocketUri(){return this.__soketi.socketUri}}class ft{constructor({serverUri:e,socket:t=null,encrypt:s=!1}){this.$__subscribers={},this.$__uri=e,this.$__socket={socketUri:null,appKey:"knishio",...t||{}},this.$__client=null,this.restartTransport(s)}restartTransport(e=!1){const t=new _t({serverUri:this.$__uri,soketi:this.$__socket,encrypt:e});this.$__client&&(t.setAuthData({token:this.$__client.getAuthToken(),pubkey:this.$__client.getPubKey(),wallet:this.$__client.getWallet()}),this.socketDisconnect()),this.$__client=t}setEncryption(e=!1){this.restartTransport(e)}unsubscribe(e){this.$__subscribers.hasOwnProperty(e)&&(this.$__subscribers[e].unsubscribe(),this.$__client.unsubscribeFromChannel(e),delete this.$__subscribers[e])}unsubscribeAll(){for(let e in this.$__subscribers)this.unsubscribe(e)}socketDisconnect(){this.$__client.socketDisconnect(),this.$__subscribers={}}subscribe(e,t){const s=pt(e);return this.unsubscribe(s),this.$__subscribers[s]=this.$__client.subscribe(e).subscribe((e=>t(e))),s}async query(e){return await this.$__client.query(e)}async mutate(e){return await this.$__client.mutate(e)}setAuthData({token:e,pubkey:t,wallet:s}){this.$__client.setAuthData({token:e,pubkey:t,wallet:s})}getAuthToken(){let e=this.$__client.getAuthToken();return e?e.getToken():null}getUri(){return this.$__uri}setUri(e){this.$__uri=e}getSocketUri(){return this.$__socket?this.$__socket.socketUri:null}setSocketUri({socketUri:e,appKey:t}){this.$__socket=arguments.length?arguments[0]:this.$__socket}}class wt{constructor(e){this.client=e,this.$__variables=null,this.$__subscribe=null}createSubscribe({variables:e=null}){if(this.$__variables=this.compiledVariables(e),!this.uri())throw new ge("Subscribe::createSubscribe() - Node URI was not initialized for this client instance!");if(null===this.$__subscribe)throw new ge("Subscribe::createSubscribe() - GraphQL subscription was not initialized!");return{query:this.$__subscribe,variables:this.variables(),fetchPolicy:"no-cache"}}async execute({variables:e=null,closure:t}){if(!t)throw new ge(`${this.constructor.name}::execute() - closure parameter is required!`);return this.$__request=this.createSubscribe({variables:e}),this.client.subscribe(this.$__request,t)}compiledVariables(e=null){return e||{}}uri(){return this.client.getUri()}variables(){return this.$__variables}}class $t extends wt{constructor(e){super(e),this.$__subscribe=p`
      subscription onCreateMolecule ( $bundle: String! ) {
        CreateMolecule( bundle: $bundle ) {
          molecularHash,
          cellSlug,
          counterparty,
          bundleHash,
          status,
          local,
          height,
          depth,
          createdAt,
          receivedAt,
          processedAt,
          broadcastedAt,
          reason,
          reasonPayload,
          payload,
          status,
          atoms {
            molecularHash,
            position,
            isotope,
            walletAddress,
            tokenSlug,
            batchId,
            value,
            index,
            metaType,
            metaId,
            metasJson,
            otsFragment,
            createdAt,
            metas {
              molecularHash,
              position,
              metaType,
              metaId,
              key,
              value,
              createdAt,
            }
          }
        }
      }
    `}}class St extends wt{constructor(e){super(e),this.$__subscribe=p`
      subscription onWalletStatus ( $bundle: String!, $token: String! ) {
        WalletStatus( bundle: $bundle, token: $token ) {
          bundle,
          token,
          admission,
          balance,
        }
      }
    `}}class It extends wt{constructor(e){super(e),this.$__subscribe=p`
      subscription onActiveWallet ( $bundle: String! ) {
        ActiveWallet( bundle: $bundle ) {
          address,
          bundleHash,
          walletBundle {
            bundleHash,
            slug,
            createdAt,
          },
          tokenSlug,
          token {
            slug,
            name,
            fungibility,
            supply,
            decimals,
            amount,
            icon,
            createdAt
          },
          batchId,
          position,
          characters,
          pubkey,
          amount,
          createdAt,
          metas {
            molecularHash,
            position,
            metaType,
            metaId,
            key,
            value,
            createdAt,
          }
        }
      }
    `}}class Tt extends wt{constructor(e){super(e),this.$__subscribe=p`
      subscription onActiveUser ( $metaType: String!, $metaId: String! ) {
        ActiveUser( metaType: $metaType, metaId: $metaId ) {
          bundleHash,
          metaType,
          metaId,
          jsonData,
          createdAt,
          updatedAt
        }
      }`}}class At extends qe{constructor({query:e,json:t}){super({query:e,json:t,dataKey:"data.ActiveSession"})}}class xt extends Fe{constructor(e){super(e),this.$__query=p`mutation(
      $bundleHash: String!,
      $metaType: String!,
      $metaId: String!,
      $ipAddress: String,
      $browser: String,
      $osCpu: String,
      $resolution: String,
      $timeZone: String,
      $json: String ) {
      ActiveSession(
        bundleHash: $bundleHash,
        metaType: $metaType,
        metaId: $metaId,
        ipAddress: $ipAddress,
        browser: $browser,
        osCpu: $osCpu,
        resolution: $resolution,
        timeZone: $timeZone,
        json: $json
      ) {
        bundleHash,
        metaType,
        metaId,
        jsonData,
        createdAt,
        updatedAt
      }
    }`}createResponse(e){return new At({query:this,json:e})}}class vt extends qe{constructor({query:e,json:t}){super({query:e,json:t,dataKey:"data.ActiveUser"})}payload(){const e=this.data();if(!e)return null;const t=[];for(let s of e){const e={...s};e.jsonData&&(e.jsonData=JSON.parse(e.jsonData)),e.createdAt&&(e.createdAt=new Date(e.createdAt)),e.updatedAt&&(e.updatedAt=new Date(e.updatedAt)),t.push(e)}return t}}class qt extends We{constructor(e){super(e),this.$__query=p`query ActiveUserQuery ($bundleHash:String, $metaType: String, $metaId: String) {
      ActiveUser (bundleHash: $bundleHash, metaType: $metaType, metaId: $metaId) {
        bundleHash,
        metaType,
        metaId,
        jsonData,
        createdAt,
        updatedAt
      }
    }`}createResponse(e){return new vt({query:this,json:e})}}class Wt extends qe{constructor({query:e,json:t}){super({query:e,json:t,dataKey:"data.UserActivity"})}payload(){const e=JSON.parse(JSON.stringify(this.data()));if(e.instances)for(const t of e.instances)t.jsonData=JSON.parse(t.jsonData);return e}}class Ct extends We{constructor(e){super(e),this.$__query=p`query UserActivity (
      $bundleHash:String,
      $metaType: String,
      $metaId: String,
      $ipAddress: String,
      $browser: String,
      $osCpu: String,
      $resolution: String,
      $timeZone: String,
      $countBy: [CountByUserActivity],
      $interval: span
    ) {
      UserActivity (
        bundleHash: $bundleHash,
        metaType: $metaType,
        metaId: $metaId,
        ipAddress: $ipAddress,
        browser: $browser,
        osCpu: $osCpu,
        resolution: $resolution,
        timeZone: $timeZone,
        countBy: $countBy,
        interval: $interval
      ) {
        createdAt,
        bundleHash,
        metaType,
        metaId,
        instances {
          bundleHash,
          metaType,
          metaId,
          jsonData,
          createdAt,
          updatedAt
        },
        instanceCount {
          ...SubFields,
          ...Recursive
        }
      }
    }

    fragment SubFields on InstanceCountType {
      id,
      count
    }

    fragment Recursive on InstanceCountType {
      instances {
        ...SubFields
        instances {
          ...SubFields,
          instances {
            ...SubFields
            instances {
              ...SubFields
              instances {
                ...SubFields
                instances {
                  ...SubFields
                  instances {
                    ...SubFields
                    instances {
                      ...SubFields
                    }
                  }
                }
              }
            }
          }
        }
      }
    }`}createResponse(e){return new Wt({query:this,json:e})}}class Mt extends We{constructor(e){super(e),this.$__query=p`query( $slug: String, $slugs: [ String! ], $limit: Int, $order: String ) {
      Token( slug: $slug, slugs: $slugs, limit: $limit, order: $order ) {
        slug,
        name,
        fungibility,
        supply,
        decimals,
        amount,
        icon,
      }
    }`}createResponse(e){return new qe({query:this,json:e,dataKey:"data.Token"})}}class Bt extends G{constructor(e="Authorization attempt rejected by ledger.",t=null,s=null){super(e,t,s),this.name="AuthorizationRejectedException"}}class Ut extends qe{constructor({query:e,json:t}){super({query:e,json:t,dataKey:"data.Atom"})}payload(){const e=this.data();if(!e)return null;let t={instances:[],instanceCount:{},paginatorInfo:{}};if(e.instances){t.instances=e.instances;for(let e in t.instances){let s=t.instances[e];s.metasJson&&(t.instances[e].metas=JSON.parse(s.metasJson))}}return e.instanceCount&&(t.instanceCount=e.instanceCount),e.paginatorInfo&&(t.paginatorInfo=e.paginatorInfo),t}metas(){const e=this.payload(),t=[];if(e&&e.instances)for(const s of e.instances)s.metasJson&&t.push(JSON.parse(s.metasJson));return t}}class Ot extends We{constructor(e){super(e),this.$__query=p`query(
      $molecularHashes: [String!],
      $bundleHashes: [String!],
      $positions:[String!],
      $walletAddresses: [String!],
      $isotopes: [String!],
      $tokenSlugs: [String!],
      $cellSlugs: [String!],
      $batchIds: [String!],
      $values: [String!],
      $metaTypes: [String!],
      $metaIds: [String!],
      $indexes: [String!],
      $filter: [ MetaFilter! ],
      $latest: Boolean,
      $queryArgs: QueryArgs,
    ) {
      Atom(
        molecularHashes: $molecularHashes,
        bundleHashes: $bundleHashes,
        positions: $positions,
        walletAddresses: $walletAddresses,
        isotopes: $isotopes,
        tokenSlugs: $tokenSlugs,
        cellSlugs: $cellSlugs,
        batchIds: $batchIds,
        values: $values,
        metaTypes: $metaTypes,
        metaIds: $metaIds,
        indexes: $indexes,
        filter: $filter,
        latest: $latest,
        queryArgs: $queryArgs,
      ) {
        instances {
          position,
          walletAddress,
          tokenSlug,
          isotope,
          index,
          molecularHash,
          metaId,
          metaType,
          metasJson,
          batchId,
          value,
          bundleHashes,
          cellSlugs,
          createdAt,
          otsFragment
        },
        paginatorInfo {
          currentPage,
          total
        }
      }
    }`}createResponse(e){return new Ut({query:this,json:e})}static createVariables({molecularHashes:e,molecularHash:t,bundleHashes:s,bundleHash:n,positions:a,position:i,walletAddresses:r,walletAddress:o,isotopes:l,isotope:u,tokenSlugs:c,tokenSlug:h,cellSlugs:d,cellSlug:p,batchIds:m,batchId:y,values:g,value:k,metaTypes:b,metaType:_,metaIds:f,metaId:w,indexes:$,index:S,filter:I,latest:T,queryArgs:A}){return t&&(e=e||[]).push(t),n&&(s=s||[]).push(n),i&&(a=a||[]).push(i),o&&(r=r||[]).push(o),u&&(l=l||[]).push(u),h&&(c=c||[]).push(h),p&&(d=d||[]).push(p),y&&(m=m||[]).push(y),k&&(g=g||[]).push(k),_&&(b=b||[]).push(_),w&&(f=f||[]).push(w),S&&($=$||[]).push(S),{molecularHashes:e,bundleHashes:s,positions:a,walletAddresses:r,isotopes:l,tokenSlugs:c,cellSlugs:d,batchIds:m,values:g,metaTypes:b,metaIds:f,indexes:$,filter:I,latest:T,queryArgs:A}}}class Ht extends qe{constructor({query:e,json:t}){super({query:e,json:t}),this.dataKey="data.Policy",this.init()}payload(){const e=this.data();return e&&e.callback?JSON.parse(e.callback):null}}class Rt extends We{constructor(e){super(e),this.$__query=p`query( $metaType: String, $metaId: String, ) {
      Policy( metaType: $metaType, metaId: $metaId ) {
        molecularHash,
        position,
        metaType,
        metaId,
        conditions,
        callback,
        rule,
        createdAt
      }
    }`}createResponse(e){return new Ht({query:this,json:e})}}class jt extends qe{constructor({query:e,json:t}){super({query:e,json:t,dataKey:"data.MetaTypeViaAtom"})}payload(){const e=this.data();if(!e||0===e.length)return null;let t={instances:{},instanceCount:{},paginatorInfo:{}},s=e.pop();return s.instances&&(t.instances=s.instances),s.instanceCount&&(t.instanceCount=s.instanceCount),s.paginatorInfo&&(t.paginatorInfo=s.paginatorInfo),t}}class Et extends We{constructor(e){super(e),this.$__query=p`query ($metaTypes: [String!], $metaIds: [String!], $values: [String!], $keys: [String!], $latest: Boolean, $filter: [MetaFilter!], $queryArgs: QueryArgs, $countBy: String, $atomValues: [String!] ) {
      MetaTypeViaAtom(
        metaTypes: $metaTypes
        metaIds: $metaIds
        atomValues: $atomValues
        filter: $filter,
        latest: $latest,
        queryArgs: $queryArgs
        countBy: $countBy
      ) {
        metaType,
        instanceCount {
          key,
          value
        },
        instances {
          metaType,
          metaId,
          createdAt,
          metas( values: $values, keys: $keys ) {
            molecularHash,
            position,
            key,
            value,
            createdAt
          }
        },
        paginatorInfo {
          currentPage,
          total
        }
      }
    }`}createResponse(e){return new jt({query:this,json:e})}static createVariables({metaType:e=null,metaId:t=null,key:s=null,value:n=null,keys:a=null,values:i=null,atomValues:r=null,latest:o=null,latestMetas:l=!0,filter:u=null,queryArgs:c=null,countBy:h=null}){const d={};return r&&(d.atomValues=r),a&&(d.keys=a),i&&(d.values=i),e&&(d.metaTypes="string"==typeof e?[e]:e),t&&(d.metaIds="string"==typeof t?[t]:t),h&&(d.countBy=h),u&&(d.filter=u),s&&n&&(d.filter=d.filter||[],d.filter.push({key:s,value:n,comparison:"="})),o&&(d.latest=!!o,d.latest=!!l),c&&(void 0!==c.limit&&0!==c.limit||(c.limit="*"),d.queryArgs=c),d}}class Kt extends Ne{}class Qt extends Ve{fillMolecule({metaType:e,metaId:t,rule:s,policy:n}){this.$__molecule.createRule({metaType:e,metaId:t,rule:s,policy:n}),this.$__molecule.sign({}),this.$__molecule.check()}createResponse(e){return new Kt({query:this,json:e})}}class Pt extends Ve{fillMolecule({amount:e,tradeRates:t}){this.$__molecule.initDepositBuffer({amount:e,tradeRates:t}),this.$__molecule.sign({}),this.$__molecule.check(this.$__molecule.sourceWallet)}}class Nt extends Ve{fillMolecule({recipients:e,signingWallet:t}){this.$__molecule.initWithdrawBuffer({recipients:e,signingWallet:t}),this.$__molecule.sign({}),this.$__molecule.check(this.$__molecule.sourceWallet)}}class Ft{constructor({uri:e,cellSlug:t=null,client:s=null,socket:n=null,serverSdkVersion:a=3,logging:i=!1}){this.initialize({uri:e,cellSlug:t,socket:n,client:s,serverSdkVersion:a,logging:i})}initialize({uri:e,cellSlug:t=null,socket:s=null,client:n=null,serverSdkVersion:a=3,logging:i=!1}){this.$__logging=i,this.$__uris="object"==typeof e?e:[e],this.$__authTokenObjects={},this.$__authInProcess=!1,t&&this.setCellSlug(t);for(let e in this.$__uris){let t=this.$__uris[e];this.$__authTokenObjects[t]=null}this.$__logging&&console.info(`KnishIOClient::initialize() - Initializing new Knish.IO client session for SDK version ${a}...`),this.reset(),this.$__client=n||new ft({socket:{socketUri:null,appKey:"knishio",...s||{}},serverUri:this.getRandomUri()}),this.$__serverSdkVersion=a}getRandomUri(){let e=Math.floor(Math.random()*this.$__uris.length);return this.$__uris[e]}switchEncryption(e){return this.$__encrypt!==e&&(this.$__logging&&console.info(`KnishIOClient::switchEncryption() - Forcing encryption ${e?"on":"off"} to match node...`),this.$__encrypt=e,this.$__client.setEncryption(e),!0)}deinitialize(){this.$__logging&&console.info("KnishIOClient::deinitialize() - Clearing the Knish.IO client session..."),this.reset()}subscribe(){if(!this.client().getSocketUri())throw new ge("KnishIOClient::subscribe() - Socket client not initialized!");return this.client()}getServerSdkVersion(){return this.$__serverSdkVersion}reset(){this.$__secret="",this.$__bundle="",this.remainderWallet=null}cellSlug(){return this.$__cellSlug||null}setCellSlug(e){this.$__cellSlug=e}uri(){return this.$__client.getUri()}client(){if(!this.$__authInProcess){let e=this.getRandomUri();this.$__client.setUri(e);let t=this.$__authTokenObjects[e];t?this.$__client.setAuthData(t.getAuthData()):this.requestAuthToken({secret:this.$__secret,cellSlug:this.$__cellSlug,encrypt:this.$__encrypt}).then((()=>{}))}return this.$__client}hasSecret(){return!!this.$__secret}setSecret(e){this.$__secret=e,this.$__bundle=N(e)}getSecret(){if(!this.hasSecret())throw new ve("KnishIOClient::getSecret() - Unable to find a stored secret! Have you set a secret?");return this.$__secret}hasBundle(){return!!this.$__bundle}getBundle(){if(!this.hasBundle())throw new ve("KnishIOClient::getBundle() - Unable to find a stored bundle! Have you set a secret?");return this.$__bundle}async getSourceWallet(){let e=(await this.queryContinuId({bundle:this.getBundle()})).payload();return e?e.key=Z.generateKey({secret:this.getSecret(),token:e.token,position:e.position}):e=new Z({secret:this.getSecret()}),e}getRemainderWallet(){return this.remainderWallet}async createMolecule({secret:e=null,sourceWallet:t=null,remainderWallet:s=null}){return this.$__logging&&console.info("KnishIOClient::createMolecule() - Creating a new molecule..."),e=e||this.getSecret(),!t&&this.lastMoleculeQuery&&"USER"===this.getRemainderWallet().token&&this.lastMoleculeQuery.response()&&this.lastMoleculeQuery.response().success()&&(t=this.getRemainderWallet()),null===t&&(t=await this.getSourceWallet()),this.remainderWallet=s||Z.create({secretOrBundle:e,token:"USER",batchId:t.batchId,characters:t.characters}),new Ie({secret:e,sourceWallet:t,remainderWallet:this.getRemainderWallet(),cellSlug:this.cellSlug()})}createQuery(e){return new e(this.client())}createSubscribe(e){return new e(this.subscribe())}async createMoleculeMutation({mutationClass:e,molecule:t=null}){this.$__logging&&console.info(`KnishIOClient::createMoleculeQuery() - Creating a new ${e.name} query...`);let s=t||await this.createMolecule({});const n=new e(this.client(),s);if(!(n instanceof Ve))throw new ge(`${this.constructor.name}::createMoleculeMutation() - This method only accepts MutationProposeMolecule!`);return this.lastMoleculeQuery=n,n}async executeQuery(e,t=null){return this.$__authToken&&this.$__authToken.isExpired()&&(console.info("KnishIOClient::executeQuery() - Access token is expired. Getting new one..."),await this.requestAuthToken({secret:this.$__secret,cellSlug:this.$__cellSlug,encrypt:this.$__encrypt})),e.execute({variables:t})}async queryBalance({token:e,bundle:t=null,type:s="regular"}){const n=this.createQuery(je);return this.executeQuery(n,{bundleHash:t||this.getBundle(),token:e,type:s})}async querySourceWallet({token:e,amount:t,type:s="regular"}){let n=(await this.queryBalance({token:e,type:s})).payload();if(null===n||Te.cmp(n.balance,t)<0)throw new ie;if(!n.position||!n.address)throw new ie("Source wallet can not be a shadow wallet.");return n}async subscribeCreateMolecule({bundle:e,closure:t}){const s=this.createSubscribe($t);return await s.execute({variables:{bundle:e||this.getBundle()},closure:t})}subscribeWalletStatus({bundle:e,token:t,closure:s}){if(!t)throw new ge(`${this.constructor.name}::subscribeWalletStatus() - Token parameter is required!`);return this.createSubscribe(St).execute({variables:{bundle:e||this.getBundle(),token:t},closure:s})}subscribeActiveWallet({bundle:e,closure:t}){return this.createSubscribe(It).execute({variables:{bundle:e||this.getBundle()},closure:t})}subscribeActiveSession({metaType:e,metaId:t,closure:s}){return this.createSubscribe(Tt).execute({variables:{metaType:e,metaId:t},closure:s})}unsubscribe(e){this.subscribe().unsubscribe(e)}unsubscribeAll(){this.subscribe().unsubscribeAll()}queryMeta({metaType:e,metaId:t=null,key:s=null,value:n=null,latest:a=null,latestMetas:i=null,fields:r=null,filter:o=null,queryArgs:l=null,count:u=null,countBy:c=null,throughAtom:h=!1,values:d=null,keys:p=null,atomValues:m=null}){let y,g;return this.$__logging&&console.info(`KnishIOClient::queryMeta() - Querying metaType: ${e}, metaId: ${t}...`),h?(y=this.createQuery(Et),g=Et.createVariables({metaType:e,metaId:t,key:s,value:n,latest:a,latestMetas:i,filter:o,queryArgs:l,countBy:c,values:d,keys:p,atomValues:m})):(y=this.createQuery(Ke),g=Ke.createVariables({metaType:e,metaId:t,key:s,value:n,latest:a,latestMetas:i,filter:o,queryArgs:l,count:u,countBy:c})),this.executeQuery(y,g).then((e=>e.payload()))}queryMetaInstance({metaType:e,metaId:t=null,key:s=null,value:n=null,latest:a=null,filter:i=null,fields:r=null}){this.$__logging&&console.info(`KnishIOClient::queryMetaInstance() - Querying metaType: ${e}, metaId: ${t}...`);const o=this.createQuery(Ke),l={metaType:e,metaIds:[t],keys:[s],values:[n],latest:a,filter:i};return this.executeQuery(o,l).then((e=>e.data()))}async queryBatch({batchId:e}){this.$__logging&&console.info(`KnishIOClient::queryBatch() - Querying cascading meta instances for batchId: ${e}...`);const t=this.createQuery(Qe);return await this.executeQuery(t,{batchId:e})}async queryBatchHistory({batchId:e}){this.$__logging&&console.info(`KnishIOClient::queryBatchHistory() - Querying cascading meta instances for batchId: ${e}...`);const t=this.createQuery(Pe);return await this.executeQuery(t,{batchId:e})}async queryAtom({molecularHashes:e,molecularHash:t,bundleHashes:s,bundleHash:n,positions:a,position:i,walletAddresses:r,walletAddress:o,isotopes:l,isotope:u,tokenSlugs:c,tokenSlug:h,cellSlugs:d,cellSlug:p,batchIds:m,batchId:y,values:g,value:k,metaTypes:b,metaType:_,metaIds:f,metaId:w,indexes:$,index:S,filter:I,latest:T,queryArgs:A={limit:15,offset:1}}){this.$__logging&&console.info("KnishIOClient::queryAtom() - Querying atom instances");const x=this.createQuery(Ot);return await this.executeQuery(x,Ot.createVariables({molecularHashes:e,molecularHash:t,bundleHashes:s,bundleHash:n,positions:a,position:i,walletAddresses:r,walletAddress:o,isotopes:l,isotope:u,tokenSlugs:c,tokenSlug:h,cellSlugs:d,cellSlug:p,batchIds:m,batchId:y,values:g,value:k,metaTypes:b,metaType:_,metaIds:f,metaId:w,indexes:$,index:S,filter:I,latest:T,queryArgs:A}))}async createWallet({token:e}){const t=new Z({secret:this.getSecret(),token:e}),s=await this.createMoleculeMutation({mutationClass:ot});return s.fillMolecule(t),await this.executeQuery(s)}async queryActiveSession({bundleHash:e,metaType:t,metaId:s}){const n=this.createQuery(qt);return await this.executeQuery(n,{bundleHash:e,metaType:t,metaId:s})}async queryUserActivity({bundleHash:e,metaType:t,metaId:s,ipAddress:n,browser:a,osCpu:i,resolution:r,timeZone:o,countBy:l,interval:u}){const c=this.createQuery(Ct);return await this.executeQuery(c,{bundleHash:e,metaType:t,metaId:s,ipAddress:n,browser:a,osCpu:i,resolution:r,timeZone:o,countBy:l,interval:u})}async activeSession({bundle:e,metaType:t,metaId:s,ipAddress:n,browser:a,osCpu:i,resolution:r,timeZone:o,json:l={}}){const u=this.createQuery(xt);return await this.executeQuery(u,{bundleHash:e,metaType:t,metaId:s,ipAddress:n,browser:a,osCpu:i,resolution:r,timeZone:o,json:JSON.stringify(l)})}async createToken({token:e,amount:t=null,meta:s=null,batchId:n=null,units:a=[]}){const i=fe.get(s||{},"fungibility");if("stackable"===i&&(s.batchId=n||F({})),["nonfungible","stackable"].includes(i)&&a.length>0){if(fe.get(s||{},"decimals")>0)throw new ht;if(t>0)throw new dt;t=a.length,s.splittable=1,s.decimals=0,s.tokenUnits=JSON.stringify(a)}const r=new Z({secret:this.getSecret(),token:e,batchId:n}),o=await this.createMoleculeMutation({mutationClass:ze});return o.fillMolecule({recipientWallet:r,amount:t,meta:s||{}}),await this.executeQuery(o)}async createRule({metaType:e,metaId:t,rule:s,policy:n={}}){const a=await this.createMoleculeMutation({mutationClass:Qt,molecule:await this.createMolecule({secret:this.getSecret(),sourceWallet:await this.getSourceWallet()})});return a.fillMolecule({metaType:e,metaId:t,rule:s,policy:n}),await this.executeQuery(a)}async createMeta({metaType:e,metaId:t,meta:s=null,policy:n={}}){const a=await this.createMoleculeMutation({mutationClass:it,molecule:await this.createMolecule({secret:this.getSecret(),sourceWallet:await this.getSourceWallet()})}),i=s||{};return a.fillMolecule({metaType:e,metaId:t,meta:i,policy:n}),await this.executeQuery(a)}async createIdentifier({type:e,contact:t,code:s}){const n=await this.createMoleculeMutation({mutationClass:tt});return n.fillMolecule({type:e,contact:t,code:s}),await this.executeQuery(n)}async createPolicy({metaType:e,metaId:t,policy:s={}}){let n=await this.createMolecule({});n.addPolicyAtom({metaType:e,metaId:t,meta:{},policy:s}),n.addContinuIdAtom(),n.sign({}),n.check();const a=await this.createMoleculeMutation({mutationClass:Ve,molecule:n});return await this.executeQuery(a)}async queryPolicy({metaType:e,metaId:t}){const s=this.createQuery(Rt);return await this.executeQuery(s,{metaType:e,metaId:t})}queryWallets({bundle:e=null,token:t=null,unspent:s=!0}){this.$__logging&&console.info(`KnishIOClient::queryWallets() - Querying wallets${e?` for ${e}`:""}...`);const n=this.createQuery(He);return this.executeQuery(n,{bundleHash:e||this.getBundle(),token:t,unspent:s}).then((e=>e.payload()))}queryShadowWallets({token:e="KNISH",bundle:t=null}){t=t||this.getBundle(),this.$__logging&&console.info(`KnishIOClient::queryShadowWallets() - Querying ${e} shadow wallets for ${t}...`);const s=this.createQuery(He);return this.executeQuery(s,{bundleHash:t,token:e}).then((e=>e.payload()))}queryBundle({bundle:e=null,key:t=null,value:s=null,latest:n=!0,fields:a=null,raw:i=!1}){this.$__logging&&console.info(`KnishIOClient::queryBundle() - Querying wallet bundle metadata${e?` for ${e}`:""}...`);const r=this.createQuery(Ue),o=Ue.createVariables({bundleHash:e||this.getBundle(),key:t,value:s,latest:n});return this.executeQuery(r,o).then((e=>i?e:e.payload()))}async queryContinuId({bundle:e}){const t=this.createQuery(Me);return this.executeQuery(t,{bundle:e})}async requestTokens({token:e,to:t,amount:s=null,units:n=[],meta:a=null,batchId:i=null}){let r,o;a=a||{};const l=this.createQuery(Mt),u=await this.executeQuery(l,{slug:e}),c="stackable"===fe.get(u.data(),"0.fungibility");if(!c&&null!==i)throw new pe("Expected Batch ID = null for non-stackable tokens.");if(c&&null===i&&(i=F({})),n.length>0){if(s>0)throw new dt;s=n.length,a.tokenUnits=JSON.stringify(n)}t?("[object String]"===Object.prototype.toString.call(t)&&(Z.isBundleHash(t)?(r="walletBundle",o=t):t=Z.create({secretOrBundle:t,token:e})),t instanceof Z&&(r="wallet",a.position=t.position,a.bundle=t.bundle,o=t.address)):(r="walletBundle",o=this.getBundle());const h=await this.createMoleculeMutation({mutationClass:Ge});return h.fillMolecule({token:e,amount:s,metaType:r,metaId:o,meta:a,batchId:i}),await this.executeQuery(h)}async claimShadowWallet({token:e,batchId:t=null,molecule:s=null}){const n=await this.createMoleculeMutation({mutationClass:nt,molecule:s});return n.fillMolecule({token:e,batchId:t}),await this.executeQuery(n)}async claimShadowWallets({token:e}){const t=await this.queryShadowWallets({token:e});if(!t||!Array.isArray(t))throw new ct;t.forEach((e=>{if(!e.isShadow())throw new ct}));let s=[];for(const n of t)s.push(await this.claimShadowWallet({token:e,batchId:n.batchId}));return s}async transferToken({bundleHash:e,token:t,amount:s=null,units:n=[],batchId:a=null,sourceWallet:i=null}){if(n.length>0){if(s>0)throw new dt;s=n.length}if(null===i&&(i=await this.querySourceWallet({token:t,amount:s})),null===i||Te.cmp(i.balance,s)<0)throw new ie;let r=Z.create({secretOrBundle:e,token:t});null!==a?r.batchId=a:r.initBatchId({sourceWallet:i}),this.remainderWallet=Z.create({secretOrBundle:this.getSecret(),token:t,characters:i.characters}),this.remainderWallet.initBatchId({sourceWallet:i,isRemainder:!0}),i.splitUnits(n,this.remainderWallet,r);const o=await this.createMolecule({sourceWallet:i,remainderWallet:this.remainderWallet}),l=await this.createMoleculeMutation({mutationClass:Ye,molecule:o});return l.fillMolecule({recipientWallet:r,amount:s}),await this.executeQuery(l)}async depositBufferToken({tokenSlug:e,amount:t,tradeRates:s,sourceWallet:n=null}){null===n&&(n=await this.querySourceWallet({token:e,amount:t})),this.remainderWallet=Z.create({secretOrBundle:this.getSecret(),token:e,characters:n.characters}),this.remainderWallet.initBatchId({sourceWallet:n,isRemainder:!0});const a=await this.createMolecule({sourceWallet:n,remainderWallet:this.remainderWallet}),i=await this.createMoleculeMutation({mutationClass:Pt,molecule:a});return i.fillMolecule({amount:t,tradeRates:s}),await this.executeQuery(i)}async withdrawBufferToken({tokenSlug:e,amount:t,sourceWallet:s=null,signingWallet:n=null}){null===s&&(s=await this.querySourceWallet({token:e,amount:t,type:"buffer"})),this.remainderWallet=s;const a=await this.createMolecule({sourceWallet:s,remainderWallet:this.remainderWallet}),i=await this.createMoleculeMutation({mutationClass:Nt,molecule:a});let r={};return r[this.getBundle()]=t,i.fillMolecule({recipients:r,signingWallet:n}),await this.executeQuery(i)}async burnTokens({token:e,amount:t=null,units:s=[],sourceWallet:n=null}){null===n&&(n=await this.querySourceWallet({token:e,amount:t}));let a=Z.create({secretOrBundle:this.getSecret(),token:e,characters:n.characters});if(a.initBatchId({sourceWallet:n,isRemainder:!0}),s.length>0){if(t>0)throw new dt;t=s.length,n.splitUnits(s,a)}let i=await this.createMolecule({sourceWallet:n,remainderWallet:a});i.burnToken({amount:t}),i.sign({}),i.check();const r=await this.createMoleculeMutation({mutationClass:Ve,molecule:i});return this.executeQuery(r)}async replenishToken({token:e,amount:t=null,units:s=[],sourceWallet:n=null}){if(null===n&&(n=(await this.queryBalance({token:e})).payload()),!n)throw new ie("Source wallet is missing or invalid.");let a=Z.create({secretOrBundle:this.getSecret(),token:e,characters:n.characters});a.initBatchId({sourceWallet:n,isRemainder:!0});let i=await this.createMolecule({sourceWallet:n,remainderWallet:a});i.replenishToken({amount:t,units:s}),i.sign({}),i.check();const r=await this.createMoleculeMutation({mutationClass:Ve,molecule:i});return this.executeQuery(r)}async fuseToken({bundleHash:e,tokenSlug:t,newTokenUnit:s,fusedTokenUnitIds:n,sourceWallet:a=null}){if(null===a&&(a=(await this.queryBalance({token:t})).payload()),null===a)throw new ie("Source wallet is missing or invalid.");if(!a.tokenUnits||!a.tokenUnits.length)throw new ie("Source wallet does not have token units.");if(!n.length)throw new ie("Fused token unit list is empty.");let i=[];a.tokenUnits.forEach((e=>{i.push(e.id)})),n.forEach((e=>{if(!i.includes(e))throw new ie(`Fused token unit ID = ${e} does not found in the source wallet.`)}));let r=Z.create({secretOrBundle:e,token:t});r.initBatchId({sourceWallet:a});let o=Z.create({secretOrBundle:this.getSecret(),token:t,batchId:a.batchId,characters:a.characters});o.initBatchId({sourceWallet:a,isRemainder:!0}),a.splitUnits(n,o),s.metas.fusedTokenUnits=a.getTokenUnitsData(),r.tokenUnits=[s];let l=await this.createMolecule({sourceWallet:a,remainderWallet:o});l.fuseToken(a.tokenUnits,r),l.sign({}),l.check();const u=await this.createMoleculeMutation({mutationClass:Ve,molecule:l});return this.executeQuery(u)}async requestGuestAuthToken({cellSlug:e,encrypt:t}){this.setCellSlug(e);const s=new Z({secret:P(),token:"AUTH"}),n=await this.createQuery(ut),a={cellSlug:e,pubkey:s.pubkey,encrypt:t},i=await n.execute(a);if(!i.success())throw new Bt(`KnishIOClient::requestGuestAuthToken() - Authorization attempt rejected by ledger. Reason: ${i.reason()}`);{const e=Ae.create(i.payload(),s);this.setAuthToken(e)}return i}async requestProfileAuthToken({secret:e,encrypt:t}){this.setSecret(e);const s=new Z({secret:e,token:"AUTH"}),n=await this.createMolecule({secret:e,sourceWallet:s}),a=await this.createMoleculeMutation({mutationClass:Je,molecule:n});a.fillMolecule({meta:{encrypt:t?"true":"false"}});const i=await a.execute({});if(!i.success())throw new Bt(`KnishIOClient::requestProfileAuthToken() - Authorization attempt rejected by ledger. Reason: ${i.reason()}`);{const e=Ae.create(i.payload(),s);this.setAuthToken(e)}return i}async requestAuthToken({secret:e=null,seed:t=null,cellSlug:s=null,encrypt:n=!1}){if(this.$__serverSdkVersion<3)return this.$__logging&&console.warn("KnishIOClient::authorize() - Server SDK version does not require an authorization..."),null;let a;return null===e&&t&&(e=P(t)),this.$__authInProcess=!0,a=e?await this.requestProfileAuthToken({secret:e,encrypt:n}):await this.requestGuestAuthToken({cellSlug:s,encrypt:n}),this.$__logging&&console.info(`KnishIOClient::authorize() - Successfully retrieved auth token ${this.$__authToken.getToken()}...`),this.switchEncryption(n),this.$__authInProcess=!1,a}setAuthToken(e){e?(this.$__authTokenObjects[this.uri()]=e,this.client().setAuthData(e.getAuthData()),this.$__authToken=e):this.$__logging&&console.info("KnishIOClient::setAuthToken() - authToken object is empty.")}getAuthToken(){return this.$__authToken}}class Vt{static async run(e){for(let t in e){let s=new Vt(e[t]);await s.testAll()}}constructor(e,t=!1){this.encrypt=t,this.secrets=[P(),P()],this.tokenSlugs=["TESTTOKEN","UTENVSTACKABLE","UTSTACKUNIT","UTENVSTACKUNIT","UTSTACKUNITZONES","UTSLUG0","UTSLUG1"],this.graphqlUrl=e,console.log(`---------- GraphQL URI: ${this.graphqlUrl}`),this.clients={},this.tokenUnits=[["unit_id_1","unit_name_1"],["unit_id_2","unit_name_2"],["unit_id_3","unit_name_3"],["unit_id_4","unit_name_4"],["unit_id_5","unit_name_5"],["unit_id_6","unit_name_6"],["unit_id_7","unit_name_7"],["unit_id_8","unit_name_8"],["unit_id_9","unit_name_9"],["unit_id_10","unit_name_10"],["unit_id_11","unit_name_11"]],this.replenishTokenUnits=[["unit_id_12","unit_id_12"],["unit_id_13","unit_id_13"],["unit_id_14","unit_id_14"],["unit_id_15","unit_id_15"]];let s=(e,t=0)=>{let s=[];return e.forEach(((e,n)=>{let a=Array.from(e);a.push({fragmentZone:t+n}),s.push(a)})),s};this.tokenUnitsFZ=s(this.tokenUnits),this.replenishTokenUnitsFZ=s(Array.from(this.replenishTokenUnits),this.tokenUnits.length),this.fragmentZones=this.tokenUnitsFZ.length+this.replenishTokenUnitsFZ.length,this.fusedTokenUnitIds=[],this.tokenUnitsFZ.slice(0,5).forEach((e=>{this.fusedTokenUnitIds.push(e[0])}))}async testAll(){console.info(`Executing test for: ${this.graphqlUrl}...`),await this.client(this.secrets[0]),await this.client(this.secrets[1]),await this.testCreateToken(),await this.testFuseToken(),await this.testCreateWallet(),await this.testCreateMeta(),await this.testCreateIdentifier(),await this.testRequestTokens(),await this.testTransferToken(),await this.testBurnToken(),await this.testReplenishToken(),await this.testClaimShadowWallet(),await this.testWalletBufferTransactions(),await this.testQueryMeta(),await this.testQueryWallets(),await this.testQueryShadowWallets(),await this.testQueryBundle(),await this.testQueryBalance()}async testTokenExpiration(){const e=await this.client(this.secrets[0]),t=t=>{setTimeout((e=>{console.warn(`setTimeout ${t}`),e.queryMeta({metaType:"metaType",metaId:"metaId"})}),t,e,t)};t(3e3),t(3e4),t(61e3),t(64e3)}async testCreateToken(){let e={},t=await this.client(this.secrets[0]);e[0]=await t.createToken({token:this.tokenSlugs[0],amount:1e3,meta:{name:this.tokenSlugs[0],fungibility:"stackable",supply:"replenishable",decimals:0,icon:"icon"},batchId:"batch_0"}),this.checkResponse(e[0],"testCreateToken.0");let s=await this.client(process.env.SECRET_TOKEN_KNISH);e[1]=await s.createToken({token:this.tokenSlugs[1],amount:1e3,meta:{name:this.tokenSlugs[1],fungibility:"stackable",supply:"limited",decimals:0,icon:"icon"},batchId:"server_batch_0"}),this.checkResponse(e[1],"testCreateToken.1"),e[2]=await t.createToken({token:this.tokenSlugs[2],units:this.tokenUnits,meta:{name:this.tokenSlugs[2],supply:"replenishable",fungibility:"stackable"},batchId:"unit_batch_0"}),this.checkResponse(e[2],"testCreateToken.2"),e[3]=await s.createToken({token:this.tokenSlugs[3],units:this.tokenUnits,meta:{name:this.tokenSlugs[3],supply:"limited",fungibility:"stackable"},batchId:"server_unit_batch_0"}),this.checkResponse(e[3],"testCreateToken.3"),e[4]=await t.createToken({token:this.tokenSlugs[4],units:this.tokenUnitsFZ,meta:{name:this.tokenSlugs[4],supply:"replenishable",fungibility:"stackable",fragmentZones:this.fragmentZones},batchId:"unit_fz_batch_0"}),this.checkResponse(e[4],"testCreateToken.4"),t=await this.client(this.secrets[0]);for(const s of[this.tokenSlugs[5],this.tokenSlugs[6]])e[0]=await t.createToken({token:s,amount:1e3,meta:{name:s,fungibility:"fungible",supply:"limited",decimals:0,icon:"icon"}}),this.checkResponse(e[0],`testCreateToken.${s}`)}async testCreateWallet(){let e=await this.client(this.secrets[0]),t=await e.createWallet({token:this.tokenSlugs[1]});this.checkResponse(t,"testCreateWallet")}async testCreateMeta(){let e=await this.client(this.secrets[0]),t=await e.createMeta({metaType:"metaType",metaId:"metaId",meta:{key1:"value1",key2:"value2"}});this.checkResponse(t,"testCreateMeta")}async testCreateIdentifier(){let e=await this.client(this.secrets[0]),t=await e.createIdentifier({type:"email",contact:"test@test.com",code:"1234"});console.log(" ############### testCreateIdentifier ###############"),"Outdated code"!==t.reason()&&console.error("Error with response."),this.debug(t)}async testRequestTokens(){let e=await this.client(this.secrets[0]),t=await e.requestTokens({token:this.tokenSlugs[1],amount:10,to:this.secrets[0],batchId:"batch_5"});this.checkResponse(t,"testRequestTokens.1"),t=await e.requestTokens({token:this.tokenSlugs[3],units:["unit_id_10","unit_id_11"],to:this.secrets[0],batchId:"batch_6"}),this.checkResponse(t,"testRequestTokens.2")}async testTransferToken(){let e,t=N(this.secrets[1]),s=await this.client(this.secrets[0]);e=await s.transferToken({bundleHash:t,token:this.tokenSlugs[0],amount:10,batchId:"batch_1"}),this.checkResponse(e,"testTransferToken"),e=await s.transferToken({bundleHash:t,token:this.tokenSlugs[2],units:["unit_id_1","unit_id_2"],batchId:"batch_2"}),this.checkResponse(e,"testTransferUnitToken")}async testBurnToken(){let e,t=await this.client(this.secrets[0]);e=await t.burnTokens({token:this.tokenSlugs[0],amount:10}),this.checkResponse(e,"testBurnToken"),e=await t.burnTokens({token:this.tokenSlugs[2],units:["unit_id_3","unit_id_4"]}),this.checkResponse(e,"testBurnUnitToken")}async testReplenishToken(){let e,t=await this.client(this.secrets[0]);e=await t.replenishToken({token:this.tokenSlugs[0],amount:25}),this.checkResponse(e,"testReplenishToken"),e=await t.replenishToken({token:this.tokenSlugs[2],amount:0,units:this.replenishTokenUnits}),this.checkResponse(e,"testReplenishUnitToken")}async testFuseToken(){let e=this.tokenSlugs[4],t=P(),s=await this.client(t),n=new L("fusedTokenUnitId"),a=await this.client(this.secrets[0]),i=await a.fuseToken({bundleHash:s.getBundle(),tokenSlug:e,newTokenUnit:n,fusedTokenUnitIds:this.fusedTokenUnitIds});this.checkResponse(i,"testFuseToken");let r=(await s.queryBalance({token:e})).payload(),o=(await a.queryBalance({token:e})).payload();console.assert(r.tokenUnits.length,1),console.assert(r.tokenUnits[0].id,"fusedTokenUnitId");let l=r.tokenUnits[0].getFusedTokenUnits();console.assert(l.length,this.fusedTokenUnitIds.length);let u=[];l.forEach((e=>{u.push(e[0])})),console.assert(o.tokenUnits.length,6);let c=[];o.tokenUnits.forEach((e=>{c.push(e.id)})),console.assert(c,["unit_id_6","unit_id_7","unit_id_8","unit_id_9","unit_id_10","unit_id_11"])}async testClaimShadowWallet(){let e=await this.client(this.secrets[1]),t=await e.queryBalance({token:this.tokenSlugs[0]}),s=await e.claimShadowWallet({token:this.tokenSlugs[0],batchId:t.payload().batchId});this.checkResponse(s,"testClaimShadowWallet")}async testWalletBufferTransactions(){let e=await this.client(this.secrets[0]),t={};t[this.tokenSlugs[1]]=2,t[this.tokenSlugs[3]]=1;let s=await e.depositBufferToken({tokenSlug:this.tokenSlugs[5],amount:200,tradeRates:t});this.checkResponse(s,"testWalletBufferTransactions: depositBufferToken"),await e.withdrawBufferToken({tokenSlug:this.tokenSlugs[5],amount:100}),this.checkResponse(s,"testWalletBufferTransactions: withdrawBufferToken")}async testQueryMeta(){let e=await this.client(this.secrets[0]),t=await e.queryMeta({metaType:"metaType",metaId:"metaId"});this.checkResponse(t,"testQueryMeta")}async testQueryWallets(){let e=await this.client(this.secrets[0]),t=await e.queryWallets({});this.checkResponse(t,"testQueryWallets")}async testQueryShadowWallets(){let e=await this.client(this.secrets[1]),t=await e.queryShadowWallets({token:this.tokenSlugs[0]});this.checkResponse(t,"testQueryShadowWallets")}async testQueryBundle(){let e=await this.client(this.secrets[0]),t=await e.queryBundle({});this.checkResponse(t,"testQueryBundle")}async testQueryContinuId(){let e=N(this.secrets[0]),t=await this.client(this.secrets[0]),s=await t.queryContinuId({bundle:e});this.checkResponse(s,"testQueryContinuId")}async testQueryBalance(){let e=await this.client(this.secrets[0]),t=await e.queryBalance({token:this.tokenSlugs[0]});this.checkResponse(t,"testQueryBalance")}async client(e,t="unit_test"){return this.clients[e]||(this.clients[e]=new Ft({uri:this.graphqlUrl,logging:!0}),await this.clients[e].requestAuthToken({secret:e,encrypt:this.encrypt,cellSlug:t}),this.clients[e].getAuthToken()||console.log("Error with authorize - get an empty response.")),this.clients[e]}checkResponse(e,t){console.log(` ############### ${t} ###############`),console.log(e),e instanceof Ne?(e.success()||this.debug(e),console.assert(e.success(),e)):this.debug(e)}debug(e){e.data&&fe.get(e.data()||{},"reason")?console.log(e.data().reason):console.log(e)}}export{Q as Atom,Ft as KnishIOClient,O as Meta,Ie as Molecule,Vt as Test,Z as Wallet,B as base64ToHex,W as bufferToHexString,q as charsetBaseConvert,x as chunkSubstr,N as generateBundleHash,P as generateSecret,C as hexStringToBuffer,M as hexToBase64,U as isHex,v as randomString};
