import{shake256 as e}from"js-sha3";import t from"big-integer";import{decode as s,encode as n}from"@stablelib/base64";import r from"big-integer/BigInteger";import i from"base-x";import{Buffer as l}from"buffer";import{box as a}from"tweetnacl";import{seal as o,open as u}from"tweetnacl-sealedbox-js";import{encode as c,decode as h}from"@stablelib/utf8";import{Request as d,Headers as p}from"servie";import{fetch as m}from"popsicle";class f{static toHex(e,t){const s=(e,t)=>{const s=t?["0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F"]:["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"];return s[Math.floor(e/16)]+s[e%16]},n=Object.assign({grouping:0,rowlength:0,uppercase:!1},t||{});let r="",i=0,l=0;for(let t=0;t<e.length&&(r+=s(e[t],n.uppercase),t!==e.length-1);++t)n.grouping>0&&++i===n.grouping&&(i=0,n.rowlength>0&&++l===n.rowlength?(l=0,r+="\n"):r+=" ");return r}static toUint8Array(e){let t=e.toLowerCase().replace(/\s/g,"");t.length%2==1&&(t="0"+t);let s=new Uint8Array(Math.floor(t.length/2)),n=-1;for(let e=0;e<t.length;++e){let r=t[e],i=["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"].indexOf(r);if(-1===i)throw Error("unexpected character");-1===n?n=16*i:(s[Math.floor(e/2)]=n+i,n=-1)}return s}}function g(e,t){const s=Math.ceil(e.length/t),n=new Array(s);for(let r=0,i=0;r<s;++r,i+=t)n[r]=e.substr(i,t);return n}function y(e=256,t="abcdef0123456789"){let s=new Uint8Array(e);return(window.crypto||window.msCrypto).getRandomValues(s),s=s.map(e=>t.charCodeAt(e%t.length)),String.fromCharCode.apply(null,s)}function w(e,s,n,r,i){if(r=r||"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz~`!@#$%^&*()-_=+[{]}\\|;:'\",<.>/?¿¡",i=i||r,s>r.length||n>i.length)return console.warn("Can't convert",e,"to base",n,"greater than symbol table length. src-table:",r.length,"dest-table:",i.length),!1;let l=t(0);for(let t=0;t<e.length;t++)l=l.multiply(s).add(r.indexOf(e.charAt(t)));if(l.lesser(0))return 0;let a=l.mod(n),o=i.charAt(a),u=l.divide(n);for(;!u.equals(0);)a=u.mod(n),u=u.divide(n),o=i.charAt(a)+o;return o}function b(e){return f.toHex(e)}function _(e){return f.toUint8Array(e)}function k(e){return n(f.toUint8Array(e))}function x(e){return f.toHex(s(e))}function $(e){return/^[A-F0-9]+$/i.test(e)}String.prototype.trim||(String.prototype.trim=function(){return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,"")});class W{constructor(e,t,s,n=null){this.modelType=e,this.modelId=t,this.meta=s,this.snapshotMolecule=n,this.createdAt=+new Date}static normalizeMeta(e){if("[object Object]"===Object.prototype.toString.call(e)){const t=[];for(const s in e)e.hasOwnProperty(s)&&t.push({key:s,value:e[s]});return t}return e}static aggregateMeta(e){const t={};if("[object Array]"===Object.prototype.toString.call(e))for(let s of e)t[s.key]=s.value;return Object.keys(t).length>0?t:e}}class I{constructor(e,t,s,n=null,r=null,i=null,l=null,a=null,o=null,u=null,c=null){this.position=e,this.walletAddress=t,this.isotope=s,this.token=n,this.value=null!==r?String(r):null,this.batchId=i,this.metaType=l,this.metaId=a,this.meta=o?W.normalizeMeta(o):[],this.index=c,this.otsFragment=u,this.createdAt=String(+new Date)}static jsonToObject(e){const t=Object.assign(new I(null,null,null),JSON.parse(e)),s=Object.keys(new I(null,null,null));for(const e in t)t.hasOwnProperty(e)&&!s.includes(e)&&delete t[e];return t}static hashAtoms(t,s="base17"){const n=e.create(256),r=t.length,i=I.sortAtoms(t);for(const e of i){n.update(String(r));for(const t in e)if(e.hasOwnProperty(t)){if(["batchId"].includes(t)&&null===e[t])continue;if(["otsFragment","index"].includes(t))continue;if("meta"===t){e[t]=W.normalizeMeta(e[t]);for(const s of e[t])void 0!==s.value&&null!==s.value&&(n.update(String(s.key)),n.update(String(s.value)));continue}if(["position","walletAddress","isotope"].includes(t)){n.update(String(e[t]));continue}null!==e[t]&&n.update(String(e[t]))}}switch(s){case"hex":return n.hex();case"array":return n.array();case"base17":return w(n.hex(),16,17,"0123456789abcdef","0123456789abcdefg").padStart(64,"0");default:return null}}static sortAtoms(e){const t=[...e];return t.sort((e,t)=>e.index===t.index?0:e.index<t.index?-1:1),t}}class A{constructor(e={}){this.$options=Object.assign({characters:"GMP"},e),this.$encoder=i(this[this.$options.characters]||this.GMP)}encode(e){return this.$encoder.encode(l.from(e))}decode(e){return this.$encoder.decode(e)}get GMP(){return"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuv"}get BITCOIN(){return"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}get FLICKR(){return"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}get RIPPLE(){return"rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz"}get IPFS(){return"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}}class M{static val(e){return Math.abs(1e18*e)<1?0:e}static cmp(e,t,s=!1){const n=1e18*M.val(e),r=1e18*M.val(t);return Math.abs(n-r)<1?0:n>r?1:-1}static equal(e,t){return 0===M.cmp(e,t)}}class S{constructor(e=null){this.base=new A(e)}encrypt(e,t){return this.encode(o(c(JSON.stringify(e)),this.decode(t)))}decrypt(e,t,s){try{return JSON.parse(h(u(this.decode(e),this.decode(s),this.decode(t))))}catch(e){return null}}generatePrivateKey(t){const s=e.create(8*a.secretKeyLength);return s.update(t),this.base.encode(l.from(s.digest()))}generatePublicKey(e){const t=a.keyPair.fromSecretKey(this.decode(e));return this.encode(t.publicKey)}shortHash(t){const s=e.create(64);return s.update(t),this.base.encode(l.from(s.digest()))}decode(e){return this.base.decode(e)}encode(e){return this.base.encode(e)}}function v(t=null,s=2048){if(t){const n=e.create(2*s);return n.update(t),n.hex()}return y(s)}function T(t){const s=e.create(256);return s.update(t),s.hex()}function H(e,t,s=null){return new S(s).encrypt(e,t)}function O(e,t,s,n=null){return new S(n).decrypt(e,t,s)}function E(e,t=null){return new S(t).generatePrivateKey(e)}function R(e,t=null){return new S(t).generatePublicKey(e)}function C(e,t=null){return new S(t).shortHash(e)}class K{constructor(e,t=null,s=null,n=null){this.token=t||"USER",this.balance=0,this.molecules={},this.bundle=e,this.batchId=s,this.characters="undefined"!==(new A)[n]?n:null,this.key=null,this.address=null,this.position=null,this.privkey=null,this.pubkey=null}}class j{constructor(e=null,t="USER",s=null,n=64,r=null){this.position=s||y(n,"abcdef0123456789"),this.token=t,this.balance=0,this.molecules={},this.batchId=null,this.characters="undefined"!==(new A)[r]?r:null,this.key=null,this.address=null,this.bundle=null,this.privkey=null,this.pubkey=null,e&&this.sign(e)}static create(e,t,s=null,n=null){if(j.isBundleHash(e))return new K(e,t,s,n);const r=new j(e,t);return r.batchId=s,r.characters="undefined"!==(new A)[n]?n:null,r}static isBundleHash(e){return"string"==typeof e&&(64===e.length&&isHex(e))}sign(e){null===this.key&&null===this.address&&null===this.bundle&&(this.key=j.generateWalletKey(e,this.token,this.position),this.address=j.generateWalletAddress(this.key),this.bundle=T(e),this.getMyEncPrivateKey(),this.getMyEncPublicKey())}static generateBatchId(){return y(64)}initBatchId(e,t){e.batchId&&(this.batchId=!this.batchId&&M.cmp(e.balance,t)>0?j.generateBatchId():e.batchId)}getMyEncPrivateKey(){return null===this.privkey&&null!==this.key&&(this.privkey=E(this.key,this.characters)),this.privkey}getMyEncPublicKey(){const e=this.getMyEncPrivateKey();return null===this.pubkey&&null!==e&&(this.pubkey=R(e,this.characters)),this.pubkey}encryptMyMessage(e){const t={};for(let s=1,n=arguments.length;s<n;s++)t[C(arguments[s],this.characters)]=H(e,arguments[s],this.characters);return t}decryptMyMessage(e){const t=this.getMyEncPublicKey();let s=e;return null!==e&&"object"==typeof e&&"[object Object]"===Object.prototype.toString.call(e)&&(s=e[C(t,this.characters)]||""),O(s,this.getMyEncPrivateKey(),t,this.characters)}static generateWalletKey(t,s,n){const i=r(t,16).add(r(n,16)),l=e.create(8192);return l.update(i.toString(16)),s&&l.update(s),e.create(8192).update(l.hex()).hex()}static generateWalletAddress(t){const s=g(t,128),n=e.create(8192);for(const t in s){let r=s[t];for(let t=1;t<=16;t++)r=e.create(512).update(r).hex();n.update(r)}return e.create(256).update(n.hex()).hex()}}class U extends TypeError{constructor(e=null,t,s){if(super(e,t,s),null===e)throw new this("Unknown "+this.constructor.name);this.name="BaseException"}toString(){return`${this.name}: ${this.message}.\nStack:\n${this.stack}`}}class q extends U{constructor(e="There is an atom without an index",t,s){super(e,t,s),this.name="AtomIndexException"}}class P extends U{constructor(e="The molecule does not contain atoms",t,s){super(e,t,s),this.name="AtomsMissingException"}}class B extends U{constructor(e="The molecular hash does not match",t,s){super(e,t,s),this.name="MolecularHashMismatchException"}}class F extends U{constructor(e="The molecular hash is missing",t,s){super(e,t,s),this.name="MolecularHashMissingException"}}class N extends U{constructor(e="OTS malformed",t,s){super(e,t,s),this.name="SignatureMalformedException"}}class Q extends U{constructor(e="OTS mismatch",t,s){super(e,t,s),this.name="SignatureMismatchException"}}class V extends U{constructor(e="Insufficient balance to make transfer",t,s){super(e,t,s),this.name="TransferBalanceException"}}class z extends U{constructor(e="Token transfer atoms are malformed",t,s){super(e,t,s),this.name="TransferMalformedException"}}class J extends U{constructor(e="Token transfer slugs are mismached",t,s){super(e,t,s),this.name="TransferMismatchedException"}}class D extends U{constructor(e="Invalid remainder provided",t,s){super(e,t,s),this.name="TransferRemainderException"}}class L extends U{constructor(e="Sender and recipient(s) cannot be the same",t,s){super(e,t,s),this.name="TransferToSelfException"}}class G extends U{constructor(e="Token transfer atoms are unbalanced",t,s){super(e,t,s),this.name="TransferUnbalancedException"}}class X extends U{constructor(e="Empty meta data.",t,s){super(e,t,s),this.name="MetaMissingException"}}class Y extends U{constructor(e="Wrong type of token for this isotope",t,s){super(e,t,s),this.name="WrongTokenTypeException"}}class Z{static continueId(e){Z.missing(e);if("USER"===e.atoms[0].token&&Z.isotopeFilter("I",e.atoms).length<1)throw new P("Missing atom ContinueID");return!0}static isotopeI(e){Z.missing(e);for(let t of Z.isotopeFilter("I",e.atoms)){if("USER"!==t.token)throw new Y(`Invalid token name for "${t.isotope}" isotope`);if(0===t.index)throw new q(`Invalid isotope "${t.isotope}" index`)}return!0}static isotopeU(e){Z.missing(e);for(let t of Z.isotopeFilter("U",e.atoms)){if("AUTH"!==t.token)throw new Y(`Invalid token name for "${t.isotope}" isotope`);if(0!==t.index)throw new q(`Invalid isotope "${t.isotope}" index`)}return!0}static isotopeM(e){Z.missing(e);for(let t of Z.isotopeFilter("M",e.atoms)){if(t.meta.length<1)throw new X;if("USER"!==t.token)throw new Y(`Invalid token name for "${t.isotope}" isotope`)}return!0}static isotopeC(e){Z.missing(e);for(let t of Z.isotopeFilter("C",e.atoms)){if("USER"!==t.token)throw new Y(`Invalid token name for "${t.isotope}" isotope`);if(0!==t.index)throw new q(`Invalid isotope "${t.isotope}" index`)}return!0}static isotopeT(e){Z.missing(e);for(let t of Z.isotopeFilter("T",e.atoms)){const e=W.aggregateMeta(W.normalizeMeta(t.meta));if("wallet"===String(t.metaType).toLowerCase())for(let t of["position","bundle"])if(!e.hasOwnProperty(t)||!Boolean(e[t]))throw new X(`No or not defined "${t}" in meta`);for(let t of["token"])if(!e.hasOwnProperty(t)||!Boolean(e[t]))throw new X(`No or not defined "${t}" in meta`);if("USER"!==t.token)throw new Y(`Invalid token name for "${$atom.isotope}" isotope`);if(0!==t.index)throw new q(`Invalid isotope "${t.isotope}" index`)}return!0}static isotopeV(e,t=null){Z.missing(e);const s=Z.isotopeFilter("V",e.atoms);if(0===s.length)return!0;const n=e.atoms[0];if("V"===n.isotope&&2===s.length){const e=s[s.length-1];if(n.token!==e.token)throw new J;if(e.value<0)throw new z;return!0}let r=0,i=0;for(let t in e.atoms)if(e.atoms.hasOwnProperty(t)){const s=e.atoms[t];if("V"!==s.isotope)continue;if(i=1*s.value,Number.isNaN(i))throw new TypeError('Invalid isotope "V" values');if(s.token!==n.token)throw new J;if(t>0){if(i<0)throw new z;if(s.walletAddress===n.walletAddress)throw new L}r+=i}if(r!==i)throw new G;if(t){if(i=1*n.value,Number.isNaN(i))throw new TypeError('Invalid isotope "V" values');const e=1*t.balance+i;if(e<0)throw new V;if(e!==r)throw new D}else if(0!==i)throw new D;return!0}static molecularHash(e){if(Z.missing(e),e.molecularHash!==I.hashAtoms(e.atoms))throw new B;return!0}static ots(t){Z.missing(t);const s=t.atoms[0].walletAddress,n=Z.normalizedHash(t.molecularHash);let r=t.atoms.map(e=>e.otsFragment).reduce((e,t)=>e+t);if(2048!==r.length&&(r=x(r),2048!==r.length))throw new N;const i=g(r,128);let l="";for(const t in i){let s=i[t];for(let r=0,i=8+n[t];r<i;r++)s=e.create(512).update(s).hex();l+=s}const a=e.create(8192).update(l).hex();if(e.create(256).update(a).hex()!==s)throw new Q;return!0}static index(e){Z.missing(e);for(let t of e.atoms)if(null===t.index)throw new q;return!0}static isotopeFilter(e,t){return(t=t||[]).filter(t=>e===t.isotope)}static normalizedHash(e){return Z.normalize(Z.enumerate(e))}static enumerate(e){const t={0:-8,1:-7,2:-6,3:-5,4:-4,5:-3,6:-2,7:-1,8:0,9:1,a:2,b:3,c:4,d:5,e:6,f:7,g:8},s=[],n=e.toLowerCase().split("");for(let e=0,r=n.length;e<r;++e){const r=n[e];void 0!==t[r]&&(s[e]=t[r])}return s}static normalize(e){let t=e.reduce((e,t)=>e+t);const s=t<0;for(;t<0||t>0;)for(const n of Object.keys(e)){if(s?e[n]<8:e[n]>-8){s?(++e[n],++t):(--e[n],--t);if(0===t)break}}return e}static missing(e){if(null===e.molecularHash)throw new F;if(1>e.atoms.length)throw new P}}class ee extends U{constructor(e="Insufficient balance for requested transfer",t,s){super(e,t,s),this.name="BalanceInsufficientException"}}class te extends U{constructor(e="Negative meaning",t,s){super(e,t,s),this.name="NegativeMeaningException"}}const se=require("lodash.clonedeep"),ne=require("lodash.merge");class re{constructor(e=null){this.cellSlugOrigin=this.cellSlug=e}get cellSlugDelimiter(){return"."}cellSlugBase(){return(this.cellSlug||"").split(this.cellSlugDelimiter)[0]}toJSON(){let e=se(this);for(let t of["remainderWallet","secret","sourceWallet","cellSlugOrigin"])e.hasOwnProperty(t)&&delete e[t];return e}check(e=null){return re.verify(this,e)}static verify(e,t=null){return Z.molecularHash(e)&&Z.ots(e)&&Z.index(e)&&Z.continueId(e)&&Z.isotopeM(e)&&Z.isotopeT(e)&&Z.isotopeC(e)&&Z.isotopeU(e)&&Z.isotopeI(e)&&Z.isotopeV(e,t)}static jsonToObject(e){const t=ne(new this,JSON.parse(e)),s=Object.keys(new this);if(!Array.isArray(t.atoms))throw new P;for(const e in Object.keys(t.atoms)){t.atoms[e]=I.jsonToObject(JSON.stringify(t.atoms[e]));for(const s of["position","walletAddress","isotope"])if(void 0===t.atoms[e][s]||null===t.atoms[e][s])throw new P("The required properties of the atom are not filled.")}for(const e in t)t.hasOwnProperty(e)&&!s.includes(e)&&delete t[e];return t.atoms=I.sortAtoms(t.atoms),t}}const ie=require("lodash.merge");class le extends re{constructor(e,t=null,s=null,n=null){super(n),this.secret=e,this.sourceWallet=t,(s||t)&&(this.remainderWallet=s||j.create(e,t.batchId,t.characters)),this.clear()}continuIdMetaType(){return"walletBundle"}fill(e){for(let t in Object.keys(e))this[t]=e[t]}encryptMessage(e,t=[]){const s=[e,this.sourceWallet.pubkey];for(let e of t)s.push(e.pubkey);return this.sourceWallet.encryptMessage(...s)}addAtom(e){return this.molecularHash=null,this.atoms.push(atoms),this.atoms=I.sortAtoms(this.atoms),this}static mergeMetas(e,t={}){return ie(e||{},t)}replenishingTokens(e,t,s){const n=W.aggregateMeta(W.normalizeMeta(s));n.action="add";for(let e of["address","position","batchId"])if(void 0===n[e])throw new X(`No or not defined  ${e}  in meta`);return this.molecularHash=null,this.atoms.push(new I(this.sourceWallet.position,this.sourceWallet.address,"C",this.sourceWallet.token,e,this.sourceWallet.batchId,"token",t,le.mergeMetas({pubkey:this.sourceWallet.pubkey,characters:this.sourceWallet.characters},n),null,this.generateIndex())),this.addUserRemainderAtom(this.remainderWallet),this.atoms=I.sortAtoms(this.atoms),this}addUserRemainderAtom(e){return this.molecularHash=null,this.atoms.push(new I(e.position,e.address,"I",e.token,null,null,"walletBundle",e.bundle,{pubkey:e.pubkey,characters:e.characters},null,this.generateIndex())),this.atoms=I.sortAtoms(this.atoms),this}burningTokens(e,t=null){if(e<0)throw new te("It is impossible to use a negative value for the number of tokens");if(this.sourceWallet.balance-e<0)throw new ee;return this.molecularHash=null,this.atoms.push(new I(this.sourceWallet.position,this.sourceWallet.address,"V",this.sourceWallet.token,-e,this.sourceWallet.batchId,null,null,{pubkey:this.sourceWallet.pubkey,characters:this.sourceWallet.characters},null,this.generateIndex())),this.atoms.push(new I(this.remainderWallet.position,this.remainderWallet.address,"V",this.sourceWallet.token,this.sourceWallet.balance-e,this.remainderWallet.batchId,t?"walletBundle":null,t,{pubkey:this.remainderWallet.pubkey,characters:this.remainderWallet.characters},null,this.generateIndex())),this.atoms=I.sortAtoms(this.atoms),this}initValue(e,t){if(sourceWallet.balance-t<0)throw new ee;return this.molecularHash=null,this.atoms.push(new I(this.sourceWallet.position,this.sourceWallet.address,"V",this.sourceWallet.token,-t,this.sourceWallet.batchId,null,null,{pubkey:this.sourceWallet.pubkey,characters:this.sourceWallet.characters},null,this.generateIndex())),this.atoms.push(new I(e.position,e.address,"V",sourceWallet.token,t,e.batchId,"walletBundle",e.bundle,{pubkey:e.pubkey,characters:e.characters},null,this.generateIndex())),this.atoms.push(new I(this.remainderWallet.position,this.remainderWallet.address,"V",this.sourceWallet.token,this.sourceWallet.balance-t,this.remainderWallet.batchId,"walletBundle",this.sourceWallet.bundle,{pubkey:this.remainderWallet.pubkey,characters:this.remainderWallet.characters},this.remainderWallet.pubkey,this.remainderWallet.characters,null,this.generateIndex())),this.atoms=I.sortAtoms(this.atoms),this}initWalletCreation(e){this.molecularHash=null;const t={address:e.address,token:e.token,bundle:e.bundle,position:e.position,amount:0,batch_id:e.batchId,pubkey:e.pubkey,characters:e.characters};return this.atoms.push(new I(this.sourceWallet.position,this.sourceWallet.address,"C",this.sourceWallet.token,null,this.sourceWallet.batchId,"wallet",e.address,t,null,this.generateIndex())),this.addUserRemainderAtom(this.remainderWallet),this.atoms=I.sortAtoms(this.atoms),this}initIdentifierCreation(e,t,s){return this.molecularHash=null,this.atoms.push(new I(this.sourceWallet.position,this.sourceWallet.address,"C",this.sourceWallet.token,null,null,"identifier",e,{pubkey:this.sourceWallet.pubkey,characters:this.sourceWallet.characters,code:s,hash:T(source.trim())},null,this.generateIndex())),this.addUserRemainderAtom(this.remainderWallet),this.atoms=I.sortAtoms(this.atoms),this}initTokenCreation(e,t,s){this.molecularHash=null;const n=W.normalizeMeta(s);for(const t of["walletAddress","walletPosition","walletPubkey","walletCharacters"])0===n.filter(e=>"[object Object]"===toString.call(e)&&void 0!==e.key&&e.key===t).length&&n.push({key:t,value:e[t.toLowerCase().substr(6)]});return this.atoms.push(new I(this.sourceWallet.position,this.sourceWallet.address,"C",this.sourceWallet.token,t,e.batchId,"token",e.token,le.mergeMetas({pubkey:this.sourceWallet.pubkey,characters:this.sourceWallet.characters},n),null,this.generateIndex())),this.addUserRemainderAtom(this.remainderWallet),this.atoms=I.sortAtoms(this.atoms),this}initShadowWalletClaim(e,t={}){return this.molecularHash=null,this.atoms.push(new I(this.sourceWallet.position,this.sourceWallet.address,"C",this.sourceWallet.token,null,e.batchId,"shadowWallet",e.token,le.mergeMetas({pubkey:this.sourceWallet.pubkey,characters:this.sourceWallet.characters},t),null,this.generateIndex())),this.addUserRemainderAtom(this.remainderWallet),this.atoms=I.sortAtoms(this.atoms),this}initMeta(e,t,s){return this.molecularHash=null,this.atoms.push(new I(this.sourceWallet.position,this.sourceWallet.address,"M",this.sourceWallet.token,null,this.sourceWallet.batchId,t,s,le.mergeMetas({pubkey:this.sourceWallet.pubkey,characters:this.sourceWallet.characters},e),null,this.generateIndex())),this.addUserRemainderAtom(this.remainderWallet),this.atoms=I.sortAtoms(this.atoms),this}initTokenTransfer(e,t,s,n,r={}){return this.molecularHash=null,this.atoms.push(new I(this.sourceWallet.position,this.sourceWallet.address,"T",this.sourceWallet.token,t,null,s,n,le.mergeMetas({pubkey:this.sourceWallet.pubkey,characters:this.sourceWallet.characters,token:e},r),null,this.generateIndex())),this.addUserRemainderAtom(this.remainderWallet),this.atoms=I.sortAtoms(this.atoms),this}initAuthentication(){return this.molecularHash=null,this.atoms.push(new I(this.sourceWallet.position,this.sourceWallet.address,"U",this.sourceWallet.token,null,this.sourceWallet.batchId,null,null,{pubkey:this.sourceWallet.pubkey,characters:this.sourceWallet.characters},null,this.generateIndex())),this.atoms=I.sortAtoms(this.atoms),this}clear(){return this.molecularHash=null,this.bundle=null,this.status=null,this.createdAt=String(+new Date),this.atoms=[],this}sign(t=!1,s=!0){if(0===this.atoms.length||0!==this.atoms.filter(e=>!(e instanceof I)).length)throw new P;t||(this.bundle=T(this.secret)),this.molecularHash=I.hashAtoms(this.atoms);const n=this.atoms[0],r=g(j.generateWalletKey(this.secret,n.token,n.position),128),i=Z.normalizedHash(this.molecularHash);let l="";for(const t in r){let s=r[t];for(let n=0,r=8-i[t];n<r;n++)s=e.create(512).update(s).hex();l+=s}s&&(l=k(l));const a=g(l,Math.ceil(l.length/this.atoms.length));let o=null;for(let e=0,t=a.length;e<t;e++)this.atoms[e].otsFragment=a[e],o=this.atoms[e].position;return o}check(e=null){return le.verify(this,e)}static verify(e,t=null){return Z.molecularHash(e)&&Z.ots(e)&&Z.index(e)&&Z.continueId(e)&&Z.isotopeM(e)&&Z.isotopeT(e)&&Z.isotopeC(e)&&Z.isotopeU(e)&&Z.isotopeI(e)&&Z.isotopeV(e,t)}generateIndex(){return le.generateNextAtomIndex(this.atoms)}static generateNextAtomIndex(e){const t=e.length-1;return t>-1?e[t].index+1:0}}class ae extends U{constructor(e="GraphQL did not provide a valid response.",t,s){super(e,t,s),this.name="InvalidResponseException"}}class oe extends U{constructor(e="Unauthenticated.",t,s){super(e,t,s),this.name="UnauthenticatedException"}}class ue{static __init(e,t){this.arr=[],this.key=null,this.arr=String(t).split("."),this.key=this.arr.shift();const s=Number(this.key);Number.isInteger(s)&&(this.key=s),this.__nextKey=this.arr.length,this.__next=this.__tic(e)}static __tic(e){return!!(Array.isArray(e)||e instanceof Object)&&void 0!==e[this.key]}static has(e,t){return this.__init(e,t),!!this.__next&&(0===this.__nextKey||this.has(e[this.key],this.arr.join(".")))}static get(e,t,s=null){return this.__init(e,t),this.__next?0===this.__nextKey?e[this.key]:this.get(e[this.key],this.arr.join("."),s):s}}class ce extends U{constructor(e="Error during decryption.",t,s){super(e,t,s),this.name="DecryptException"}}class he{constructor(e,t){if(this.dataKey=null,this.errorKey="exception",this.$__payload=null,this.$__query=e,this.$__originResponse=t,this.$__response=t,void 0===this.$__response||null===this.$__response)throw new ae;if(ue.has(this.$__response,this.errorKey)){const e=ue.get(this.$__response,this.errorKey);if(String(e).includes("Unauthenticated"))throw new oe;throw new ae}if("QueryAuthentication"!==e.constructor.name){const t=e.getKnishIOClient().getAuthorizationWallet();if(null===t)throw new oe;if(this.$__response=t.decryptMyMessage(this.$__response),null===this.$__response)throw new ce}this.init()}data(){if(!this.dataKey)return this.response();if(!ue.has(this.response(),this.dataKey))throw new ae;return ue.get(this.response(),this.dataKey)}response(){return this.$__response}payload(){return null}query(){return this.$__query}init(){return null}}class de{constructor(e){this.knishIO=e,this.$__fields=null,this.$__variables=null,this.$__request=null,this.$__response=null,this.$__query=null}request(){return this.$__request}response(){return this.$__response}client(){return this.knishIO.client()}createRequest(e=null,t=null){return this.$__variables=this.compiledVariables(e),new d(this.url(),this.getRequestBody(t,this.variables()))}compiledVariables(e=null){return e||{}}compiledQuery(e=null){return null!==e&&(this.$__fields=e),this.$__query.replace(new RegExp("@fields","g"),this.compiledFields(this.$__fields))}compiledFields(e){const t=[];for(let s of Object.keys(e))t.push(e[s]?`${s} ${this.compiledFields(e[s])}`:""+s);return`{ ${t.join(", ")} }`}async execute(e=null,t=null){this.$__request=this.createRequest(e,t);let s=await this.client().send(this.$__request);return"QueryAuthentication"!==this.constructor.name&&401===s.status&&(await this.knishIO.authentication(),s=await this.client().send(this.$__request)),this.$__response=await this.createResponseRaw(s),this.$__response}async createResponseRaw(e){return this.createResponse(JSON.parse(await e.text()))}createResponse(e){return new he(this,e)}url(){return this.knishIO.client().getUrl()}variables(){return this.$__variables}getKnishIOClient(){return this.knishIO}getRequestBody(e,t){const s={query:this.compiledQuery(e),variables:t};if("QueryAuthentication"===this.constructor.name)return{body:JSON.stringify(s)};const n=this.knishIO.getAuthorizationWallet(),r=this.knishIO.getServerKey();if(![n,r].includes(null))return{body:JSON.stringify(n.encryptMyMessage(s,r))};throw new oe("Unauthorized query")}}class pe extends he{constructor(e,t){super(e,t),this.dataKey="data.ContinuId",this.init()}payload(){let e=null;const t=this.data();return t&&(e=new j(null,t.tokenSlug),e.address=t.address,e.position=t.position,e.bundle=t.bundleHash,e.batchId=t.batchId,e.characters=t.characters,e.pubkey=t.pubkey,e.balance=1*t.amount),e}}class me extends de{constructor(e){super(e),this.$__query="query ($bundle: String!) { ContinuId(bundle: $bundle) @fields }",this.$__fields={address:null,bundleHash:null,tokenSlug:null,position:null,batchId:null,characters:null,pubkey:null,amount:null,createdAt:null}}createResponse(e){return new pe(this,e)}}class fe extends he{constructor(e,t){super(e,t),this.dataKey="data.ProposeMolecule",this.init()}init(){const e=ue.get(this.data(),"payload");try{this.$__payload=JSON.parse(e)}catch(e){this.$__payload=null}}molecule(){const e=this.data();if(!e)return null;const t=new re;return t.molecularHash=ue.get(e,"molecularHash"),t.status=ue.get(e,"status"),t.status=ue.get(e,"createdAt"),t}success(){return"accepted"===this.status()}status(){return ue.get(this.data(),"status","rejected")}reason(){return ue.get(this.data(),"reason","Invalid response from server")}payload(){return this.$__payload}}const ge=require("lodash.merge");class ye extends de{constructor(e,t=null){super(e),this.$__molecule=t,this.$__remainderWallet=null,this.$__query="mutation( $molecule: MoleculeInput! ) { ProposeMolecule( molecule: $molecule ) @fields }",this.$__fields={molecularHash:null,height:null,depth:null,status:null,reason:null,payload:null,createdAt:null,receivedAt:null,processedAt:null,broadcastedAt:null}}compiledVariables(e){const t=super.compiledVariables(e);return ge(t,{molecule:this.molecule()})}createResponse(e){return new fe(this,e)}async execute(e=null,t=null){return await super.execute(ge(e||{},{molecule:this.molecule()}),t)}remainderWallet(){return this.$__remainderWallet}molecule(){return this.$__molecule}}class we extends fe{payloadKey(e){if(!ue.has(this.payload(),e))throw new ae(`ResponseAuthentication: '${e}' key is not found in the payload.`);return ue.get(this.payload(),e)}token(){return this.payloadKey("token")}time(){return this.payloadKey("time")}pubkey(){return this.payloadKey("pubkey")}}class be extends ye{fillMolecule(){this.$__molecule.initAuthentication(),this.$__molecule.sign(),this.$__molecule.check()}createResponse(e){return new we(this,e)}}class _e extends he{constructor(e,t){super(e,t),this.dataKey="data.Balance",this.init()}payload(){const e=this.data();if(!e)return null;let t=null;return null===e.position?t=new K(e.bundleHash,e.tokenSlug,e.batchId):(t=new j(null,e.tokenSlug),t.address=e.address,t.position=e.position,t.bundle=e.bundleHash,t.batchId=e.batchId,t.characters=e.characters,t.pubkey=e.pubkey),t.balance=e.amount,t}}class ke extends de{constructor(e){super(e),this.$__query="query( $address: String, $bundleHash: String, $token: String, $position: String ) { Balance( address: $address, bundleHash: $bundleHash, token: $token, position: $position ) @fields }",this.$__fields={address:null,bundleHash:null,tokenSlug:null,batchId:null,position:null,amount:null,characters:null,pubkey:null,createdAt:null}}createResponse(e){return new _e(this,e)}}class xe extends fe{}class $e extends ye{fillMolecule(e,t,s=null){this.$__molecule.initTokenCreation(e,t,s||{}),this.$__molecule.sign(),this.$__molecule.check()}createResponse(e){return new xe(this,e)}}class We extends ye{fillMolecule(e,t,s,n,r=null){this.$__molecule.initTokenTransfer(e,t,s,n,r||{}),this.$__molecule.sign(),console.log(this.$__molecule),this.$__molecule.check()}}class Ie extends U{constructor(e="The shadow wallet does not exist",t,s){super(e,t,s),this.name="WalletShadowException"}}class Ae extends fe{payload(){const e={reason:null,status:null},t=this.data();return e.reason=void 0===t.reason?"Invalid response from server":t.reason,e.status=void 0===t.status?"rejected":t.status,e}}class Me extends ye{fillMolecule(e,t){this.$__molecule.initValue(e,t),this.$__molecule.sign(),this.$__molecule.check(this.$__molecule.sourceWallet())}createResponse(e){return new Ae(this,e)}}const Se=require("lodash.merge");class ve{constructor(e,t={}){this.$__headers=new p(t.headers||{}),this.$__config=Se(t,{method:"POST",headers:this.$__headers}),this.setUrl(e)}getConfig(){return this.$__config}setUrl(e){this.$__url=e}getUrl(){return this.$__url}setAuthToken(e){this.$__headers.set("X-Auth-Token",e||"")}getAuthToken(){return this.$__headers.get("X-Auth-Token")||""}async send(e,t={}){e.headers.extend(t),this.$__headers.extend(e.headers.asObject()),this.$__headers.delete("content-type"),this.$__headers.append("Accept","application/json"),this.$__headers.append("Content-Type","application/json;charset=UTF-8"),this.setAuthToken(this.getAuthToken());const s=new d(e,this.$__config);return s.headers.delete("content-length"),await m(s)}}class Te extends U{constructor(e="Code exception",t,s){super(e,t,s),this.name="CodeException"}}class He extends ye{fillMolecule(e,t,s){this.$__molecule.initIdentifierCreation(e,t,s),this.$__molecule.sign(),this.$__molecule.check()}}class Oe extends he{constructor(e,t){super(e,t),this.dataKey="data.Wallet",this.init()}toClientWallet(e){let t;return null===e.position||void 0===e.position?t=new K(e.bundleHash,e.tokenSlug,e.batchId):(t=new j(null,e.tokenSlug),t.address=e.address,t.position=e.position,t.bundle=e.bundleHash,t.batchId=e.batchId,t.characters=e.characters,t.pubkey=e.pubkey),t.balance=e.amount,t}payload(){const e=this.data();if(!e)return null;const t=[];for(let s of e)t.push(this.toClientWallet(s));return t}}class Ee extends de{constructor(e){super(e),this.$__query="query( $address: String, $bundleHash: String, $token: String, $position: String ) { Wallet( address: $address, bundleHash: $bundleHash, token: $token, position: $position ) @fields }",this.$__fields={address:null,bundleHash:null,tokenSlug:null,batchId:null,position:null,amount:null,characters:null,pubkey:null,createdAt:null}}createResponse(e){return new Oe(this,e)}}class Re extends ye{fillMolecule(e,t){const s=[];for(let n of t)s.push(j.create(this.$__molecule.secret(),e,n.batchId));this.$__molecule.initShadowWalletClaimAtom(e,s),this.$__molecule.sign(),this.$__molecule.check()}}class Ce{constructor(e,t=null){this.$__url=e,this.$__secret="",this.$__client=t||new ve(this.$__url),this.remainderWallet=null,this.$__authorizationWallet=null,this.$__serverKey=null}cellSlug(){return this.$__cellSlug||null}setCellSlug(e){this.$__cellSlug=e}setAuthToken(e){this.client().setAuthToken(e)}getAuthToken(){return this.client().getAuthToken()}url(){return this.client().getUrl()}client(){return this.$__client}async createMolecule(e=null,t=null,s=null){const n=e||this.secret();let r=t;return!t&&this.lastMoleculeQuery&&"AUTH"!==this.getRemainderWallet().token&&this.lastMoleculeQuery.response().success()&&(r=this.getRemainderWallet()),null===r&&(r=await this.getSourceWallet()),this.remainderWallet=s||j.create(n,r.token,r.batchId,r.characters),new le(n,r,this.getRemainderWallet(),this.cellSlug())}createQuery(e){return new e(this)}async createMoleculeQuery(e,t=null){let s=t;null===s&&(s=e.name===be.name?await this.createMolecule(this.secret(),new j(this.secret(),"AUTH")):await this.createMolecule());const n=new e(this,s);if(!(n instanceof ye))throw new Te(this.constructor.name+"::createMoleculeQuery - required class instance of QueryMoleculePropose.");return this.lastMoleculeQuery=n,n}async authentication(e=null,t=null){this.$__secret=e||this.secret(),this.$__cellSlug=t||this.cellSlug();const s=await this.createMoleculeQuery(be);s.fillMolecule();const n=await s.execute();if(!n.success())throw new oe(n.reason());return this.$__authorizationWallet=this.extractingAuthorizationWallet(s.molecule()),this.client().setAuthToken(n.token()),this.$__serverKey=n.pubkey(),n}async getBalance(e,t){const s=this.createQuery(ke);return await s.execute({bundleHash:j.isBundleHash(e)?e:T(e),token:t})}secret(){if(!this.$__secret)throw new oe(`Expected ${this.constructor.name}::authentication call before.`);return this.$__secret}async createToken(e,t,s=null){const n=new j(this.secret(),e);"stackable"===ue.get(s||{},"fungibility")&&(n.batchId=j.generateBatchId());const r=await this.createMoleculeQuery($e);return r.fillMolecule(n,t,s||{}),await r.execute()}async createIdentifier(e,t,s){const n=await this.createMoleculeQuery(He);return n.fillMolecule(e,t,s),await n.execute()}async getShadowWallets(e){const t=this.createQuery(Ee),s=(await t.execute({bundleHash:T(this.secret()),token:e})).payload();if(!s)throw new Ie;for(let e of s)if(!e instanceof K)throw new Ie;return s}async receiveToken(e,t,s,n=null){let r,i;"[object String]"===Object.prototype.toString.call(s)&&(j.isBundleHash(s)?(r="walletbundle",i=s):s=j.create(s,e)),s instanceof j&&(r="wallet",n=le.mergeMetas(n||{},{position:s.position,bundle:s.bundle}),i=s.address);const l=await this.createMoleculeQuery(We);return l.fillMolecule(e,t,r,i,n),await l.execute()}async claimShadowWallet(e,t=null){const s=this.getShadowWallets(e),n=await this.createMoleculeQuery(Re,t);return n.fillMolecule(e,s),await n.execute()}async transferToken(e,t,s){const n=(await this.getBalance(this.secret(),t)).payload();if(null===n||M.cmp(n.balance,s)<0)throw new V("The transfer amount cannot be greater than the sender's balance");let r=e instanceof j?e:(await this.getBalance(e,t)).payload();null===r&&(r=j.create(e,t)),r.initBatchId(n,s),this.remainderWallet=j.create(this.secret(),t,r.batchId,n.characters);const i=await this.createMolecule(null,n,this.getRemainderWallet()),l=await this.createMoleculeQuery(Me,i);return l.fillMolecule(r,s),await l.execute()}async getSourceWallet(){let e=(await this.getContinuId(T(this.secret()))).payload();return e||(e=new j(this.secret())),e}async getContinuId(e){return await this.createQuery(me).execute({bundle:e})}getRemainderWallet(){return this.remainderWallet}getAuthorizationWallet(){return this.$__authorizationWallet}getServerKey(){return this.$__serverKey}extractingAuthorizationWallet(e){const t=function(e){return ue.get(e.atoms,"0")}(e);return null!==t?new j(this.secret(),t.token,t.position):null}}export{I as Atom,Ce as KnishIOClient,W as Meta,le as Molecule,j as Wallet,K as WalletShadow,x as base64ToHex,b as bufferToHexString,w as charsetBaseConvert,g as chunkSubstr,O as decryptMessage,H as encryptMessage,T as generateBundleHash,E as generateEncPrivateKey,R as generateEncPublicKey,v as generateSecret,C as hashShare,_ as hexStringToBuffer,k as hexToBase64,$ as isHex,y as randomString};
