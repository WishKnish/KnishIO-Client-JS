var pg = Object.defineProperty, vg = Object.defineProperties;
var yg = Object.getOwnPropertyDescriptors;
var tl = Object.getOwnPropertySymbols, bg = Object.getPrototypeOf, mg = Object.prototype.hasOwnProperty, gg = Object.prototype.propertyIsEnumerable, wg = Reflect.get;
var ar = Math.pow, rl = (r, e, t) => e in r ? pg(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, Wn = (r, e) => {
  for (var t in e || (e = {}))
    mg.call(e, t) && rl(r, t, e[t]);
  if (tl)
    for (var t of tl(e))
      gg.call(e, t) && rl(r, t, e[t]);
  return r;
}, Go = (r, e) => vg(r, yg(e));
var nl = (r, e, t) => wg(bg(r), t, e);
var wt = (r, e, t) => new Promise((n, a) => {
  var i = (c) => {
    try {
      u(t.next(c));
    } catch (h) {
      a(h);
    }
  }, o = (c) => {
    try {
      u(t.throw(c));
    } catch (h) {
      a(h);
    }
  }, u = (c) => c.done ? n(c.value) : Promise.resolve(c.value).then(i, o);
  u((t = t.apply(r, e)).next());
});
function _g(r, e) {
  for (var t = 0; t < e.length; t++) {
    const n = e[t];
    if (typeof n != "string" && !Array.isArray(n)) {
      for (const a in n)
        if (a !== "default" && !(a in r)) {
          const i = Object.getOwnPropertyDescriptor(n, a);
          i && Object.defineProperty(r, a, i.get ? i : {
            enumerable: !0,
            get: () => n[a]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(r, Symbol.toStringTag, { value: "Module" }));
}
const Wv = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", Kv = "ARRAYBUFFER not supported by this environment", Qv = "UINT8ARRAY not supported by this environment";
function il(r, e, t, n) {
  let a, i, o;
  const u = e || [0], c = (t = t || 0) >>> 3, h = n === -1 ? 3 : 0;
  for (a = 0; a < r.length; a += 1)
    o = a + c, i = o >>> 2, u.length <= i && u.push(0), u[i] |= r[a] << 8 * (h + n * (o % 4));
  return { value: u, binLen: 8 * r.length + t };
}
function Ti(r, e, t) {
  switch (e) {
    case "UTF8":
    case "UTF16BE":
    case "UTF16LE":
      break;
    default:
      throw new Error("encoding must be UTF8, UTF16BE, or UTF16LE");
  }
  switch (r) {
    case "HEX":
      return function(n, a, i) {
        return function(o, u, c, h) {
          let s, d, l, y;
          if (o.length % 2 != 0)
            throw new Error("String of HEX type must be in byte increments");
          const m = u || [0], w = (c = c || 0) >>> 3, E = h === -1 ? 3 : 0;
          for (s = 0; s < o.length; s += 2) {
            if (d = parseInt(o.substr(s, 2), 16), isNaN(d))
              throw new Error("String of HEX type contains invalid characters");
            for (y = (s >>> 1) + w, l = y >>> 2; m.length <= l; )
              m.push(0);
            m[l] |= d << 8 * (E + h * (y % 4));
          }
          return { value: m, binLen: 4 * o.length + c };
        }(n, a, i, t);
      };
    case "TEXT":
      return function(n, a, i) {
        return function(o, u, c, h, s) {
          let d, l, y, m, w, E, S, P, L = 0;
          const U = c || [0], z = (h = h || 0) >>> 3;
          if (u === "UTF8")
            for (S = s === -1 ? 3 : 0, y = 0; y < o.length; y += 1)
              for (d = o.charCodeAt(y), l = [], 128 > d ? l.push(d) : 2048 > d ? (l.push(192 | d >>> 6), l.push(128 | 63 & d)) : 55296 > d || 57344 <= d ? l.push(224 | d >>> 12, 128 | d >>> 6 & 63, 128 | 63 & d) : (y += 1, d = 65536 + ((1023 & d) << 10 | 1023 & o.charCodeAt(y)), l.push(240 | d >>> 18, 128 | d >>> 12 & 63, 128 | d >>> 6 & 63, 128 | 63 & d)), m = 0; m < l.length; m += 1) {
                for (E = L + z, w = E >>> 2; U.length <= w; )
                  U.push(0);
                U[w] |= l[m] << 8 * (S + s * (E % 4)), L += 1;
              }
          else
            for (S = s === -1 ? 2 : 0, P = u === "UTF16LE" && s !== 1 || u !== "UTF16LE" && s === 1, y = 0; y < o.length; y += 1) {
              for (d = o.charCodeAt(y), P === !0 && (m = 255 & d, d = m << 8 | d >>> 8), E = L + z, w = E >>> 2; U.length <= w; )
                U.push(0);
              U[w] |= d << 8 * (S + s * (E % 4)), L += 2;
            }
          return { value: U, binLen: 8 * L + h };
        }(n, e, a, i, t);
      };
    case "B64":
      return function(n, a, i) {
        return function(o, u, c, h) {
          let s, d, l, y, m, w, E, S = 0;
          const P = u || [0], L = (c = c || 0) >>> 3, U = h === -1 ? 3 : 0, z = o.indexOf("=");
          if (o.search(/^[a-zA-Z0-9=+/]+$/) === -1)
            throw new Error("Invalid character in base-64 string");
          if (o = o.replace(/=/g, ""), z !== -1 && z < o.length)
            throw new Error("Invalid '=' found in base-64 string");
          for (d = 0; d < o.length; d += 4) {
            for (m = o.substr(d, 4), y = 0, l = 0; l < m.length; l += 1)
              s = Wv.indexOf(m.charAt(l)), y |= s << 18 - 6 * l;
            for (l = 0; l < m.length - 1; l += 1) {
              for (E = S + L, w = E >>> 2; P.length <= w; )
                P.push(0);
              P[w] |= (y >>> 16 - 8 * l & 255) << 8 * (U + h * (E % 4)), S += 1;
            }
          }
          return { value: P, binLen: 8 * S + c };
        }(n, a, i, t);
      };
    case "BYTES":
      return function(n, a, i) {
        return function(o, u, c, h) {
          let s, d, l, y;
          const m = u || [0], w = (c = c || 0) >>> 3, E = h === -1 ? 3 : 0;
          for (d = 0; d < o.length; d += 1)
            s = o.charCodeAt(d), y = d + w, l = y >>> 2, m.length <= l && m.push(0), m[l] |= s << 8 * (E + h * (y % 4));
          return { value: m, binLen: 8 * o.length + c };
        }(n, a, i, t);
      };
    case "ARRAYBUFFER":
      try {
        new ArrayBuffer(0);
      } catch (n) {
        throw new Error(Kv);
      }
      return function(n, a, i) {
        return function(o, u, c, h) {
          return il(new Uint8Array(o), u, c, h);
        }(n, a, i, t);
      };
    case "UINT8ARRAY":
      try {
        new Uint8Array(0);
      } catch (n) {
        throw new Error(Qv);
      }
      return function(n, a, i) {
        return il(n, a, i, t);
      };
    default:
      throw new Error("format must be HEX, TEXT, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY");
  }
}
function al(r, e, t, n) {
  switch (r) {
    case "HEX":
      return function(a) {
        return function(i, o, u, c) {
          const h = "0123456789abcdef";
          let s, d, l = "";
          const y = o / 8, m = u === -1 ? 3 : 0;
          for (s = 0; s < y; s += 1)
            d = i[s >>> 2] >>> 8 * (m + u * (s % 4)), l += h.charAt(d >>> 4 & 15) + h.charAt(15 & d);
          return c.outputUpper ? l.toUpperCase() : l;
        }(a, e, t, n);
      };
    case "B64":
      return function(a) {
        return function(i, o, u, c) {
          let h, s, d, l, y, m = "";
          const w = o / 8, E = u === -1 ? 3 : 0;
          for (h = 0; h < w; h += 3)
            for (l = h + 1 < w ? i[h + 1 >>> 2] : 0, y = h + 2 < w ? i[h + 2 >>> 2] : 0, d = (i[h >>> 2] >>> 8 * (E + u * (h % 4)) & 255) << 16 | (l >>> 8 * (E + u * ((h + 1) % 4)) & 255) << 8 | y >>> 8 * (E + u * ((h + 2) % 4)) & 255, s = 0; s < 4; s += 1)
              m += 8 * h + 6 * s <= o ? Wv.charAt(d >>> 6 * (3 - s) & 63) : c.b64Pad;
          return m;
        }(a, e, t, n);
      };
    case "BYTES":
      return function(a) {
        return function(i, o, u) {
          let c, h, s = "";
          const d = o / 8, l = u === -1 ? 3 : 0;
          for (c = 0; c < d; c += 1)
            h = i[c >>> 2] >>> 8 * (l + u * (c % 4)) & 255, s += String.fromCharCode(h);
          return s;
        }(a, e, t);
      };
    case "ARRAYBUFFER":
      try {
        new ArrayBuffer(0);
      } catch (a) {
        throw new Error(Kv);
      }
      return function(a) {
        return function(i, o, u) {
          let c;
          const h = o / 8, s = new ArrayBuffer(h), d = new Uint8Array(s), l = u === -1 ? 3 : 0;
          for (c = 0; c < h; c += 1)
            d[c] = i[c >>> 2] >>> 8 * (l + u * (c % 4)) & 255;
          return s;
        }(a, e, t);
      };
    case "UINT8ARRAY":
      try {
        new Uint8Array(0);
      } catch (a) {
        throw new Error(Qv);
      }
      return function(a) {
        return function(i, o, u) {
          let c;
          const h = o / 8, s = u === -1 ? 3 : 0, d = new Uint8Array(h);
          for (c = 0; c < h; c += 1)
            d[c] = i[c >>> 2] >>> 8 * (s + u * (c % 4)) & 255;
          return d;
        }(a, e, t);
      };
    default:
      throw new Error("format must be HEX, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY");
  }
}
const va = 4294967296, vt = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], vn = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428], yn = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], ya = "Chosen SHA variant is not supported", Gv = "Cannot set numRounds with MAC";
function co(r, e) {
  let t, n;
  const a = r.binLen >>> 3, i = e.binLen >>> 3, o = a << 3, u = 4 - a << 3;
  if (a % 4 != 0) {
    for (t = 0; t < i; t += 4)
      n = a + t >>> 2, r.value[n] |= e.value[t >>> 2] << o, r.value.push(0), r.value[n + 1] |= e.value[t >>> 2] >>> u;
    return (r.value.length << 2) - 4 >= i + a && r.value.pop(), { value: r.value, binLen: r.binLen + e.binLen };
  }
  return { value: r.value.concat(e.value), binLen: r.binLen + e.binLen };
}
function ol(r) {
  const e = { outputUpper: !1, b64Pad: "=", outputLen: -1 }, t = r || {}, n = "Output length must be a multiple of 8";
  if (e.outputUpper = t.outputUpper || !1, t.b64Pad && (e.b64Pad = t.b64Pad), t.outputLen) {
    if (t.outputLen % 8 != 0)
      throw new Error(n);
    e.outputLen = t.outputLen;
  } else if (t.shakeLen) {
    if (t.shakeLen % 8 != 0)
      throw new Error(n);
    e.outputLen = t.shakeLen;
  }
  if (typeof e.outputUpper != "boolean")
    throw new Error("Invalid outputUpper formatting option");
  if (typeof e.b64Pad != "string")
    throw new Error("Invalid b64Pad formatting option");
  return e;
}
function Bn(r, e, t, n) {
  const a = r + " must include a value and format";
  if (!e) {
    if (!n)
      throw new Error(a);
    return n;
  }
  if (e.value === void 0 || !e.format)
    throw new Error(a);
  return Ti(e.format, e.encoding || "UTF8", t)(e.value);
}
let xo = class {
  constructor(e, t, n) {
    const a = n || {};
    if (this.t = t, this.i = a.encoding || "UTF8", this.numRounds = a.numRounds || 1, isNaN(this.numRounds) || this.numRounds !== parseInt(this.numRounds, 10) || 1 > this.numRounds)
      throw new Error("numRounds must a integer >= 1");
    this.o = e, this.h = [], this.u = 0, this.l = !1, this.A = 0, this.H = !1, this.S = [], this.p = [];
  }
  update(e) {
    let t, n = 0;
    const a = this.m >>> 5, i = this.C(e, this.h, this.u), o = i.binLen, u = i.value, c = o >>> 5;
    for (t = 0; t < c; t += a)
      n + this.m <= o && (this.U = this.v(u.slice(t, t + a), this.U), n += this.m);
    return this.A += n, this.h = u.slice(n >>> 5), this.u = o % this.m, this.l = !0, this;
  }
  getHash(e, t) {
    let n, a, i = this.R;
    const o = ol(t);
    if (this.K) {
      if (o.outputLen === -1)
        throw new Error("Output length must be specified in options");
      i = o.outputLen;
    }
    const u = al(e, i, this.T, o);
    if (this.H && this.g)
      return u(this.g(o));
    for (a = this.F(this.h.slice(), this.u, this.A, this.L(this.U), i), n = 1; n < this.numRounds; n += 1)
      this.K && i % 32 != 0 && (a[a.length - 1] &= 16777215 >>> 24 - i % 32), a = this.F(a, i, 0, this.B(this.o), i);
    return u(a);
  }
  setHMACKey(e, t, n) {
    if (!this.M)
      throw new Error("Variant does not support HMAC");
    if (this.l)
      throw new Error("Cannot set MAC key after calling update");
    const a = Ti(t, (n || {}).encoding || "UTF8", this.T);
    this.k(a(e));
  }
  k(e) {
    const t = this.m >>> 3, n = t / 4 - 1;
    let a;
    if (this.numRounds !== 1)
      throw new Error(Gv);
    if (this.H)
      throw new Error("MAC key already set");
    for (t < e.binLen / 8 && (e.value = this.F(e.value, e.binLen, 0, this.B(this.o), this.R)); e.value.length <= n; )
      e.value.push(0);
    for (a = 0; a <= n; a += 1)
      this.S[a] = 909522486 ^ e.value[a], this.p[a] = 1549556828 ^ e.value[a];
    this.U = this.v(this.S, this.U), this.A = this.m, this.H = !0;
  }
  getHMAC(e, t) {
    const n = ol(t);
    return al(e, this.R, this.T, n)(this.Y());
  }
  Y() {
    let e;
    if (!this.H)
      throw new Error("Cannot call getHMAC without first setting MAC key");
    const t = this.F(this.h.slice(), this.u, this.A, this.L(this.U), this.R);
    return e = this.v(this.p, this.B(this.o)), e = this.F(t, this.R, this.m, e, this.R), e;
  }
};
function si(r, e) {
  return r << e | r >>> 32 - e;
}
function un(r, e) {
  return r >>> e | r << 32 - e;
}
function Jv(r, e) {
  return r >>> e;
}
function sl(r, e, t) {
  return r ^ e ^ t;
}
function Yv(r, e, t) {
  return r & e ^ ~r & t;
}
function Xv(r, e, t) {
  return r & e ^ r & t ^ e & t;
}
function xg(r) {
  return un(r, 2) ^ un(r, 13) ^ un(r, 22);
}
function Br(r, e) {
  const t = (65535 & r) + (65535 & e);
  return (65535 & (r >>> 16) + (e >>> 16) + (t >>> 16)) << 16 | 65535 & t;
}
function Sg(r, e, t, n) {
  const a = (65535 & r) + (65535 & e) + (65535 & t) + (65535 & n);
  return (65535 & (r >>> 16) + (e >>> 16) + (t >>> 16) + (n >>> 16) + (a >>> 16)) << 16 | 65535 & a;
}
function Qi(r, e, t, n, a) {
  const i = (65535 & r) + (65535 & e) + (65535 & t) + (65535 & n) + (65535 & a);
  return (65535 & (r >>> 16) + (e >>> 16) + (t >>> 16) + (n >>> 16) + (a >>> 16) + (i >>> 16)) << 16 | 65535 & i;
}
function Eg(r) {
  return un(r, 7) ^ un(r, 18) ^ Jv(r, 3);
}
function Mg(r) {
  return un(r, 6) ^ un(r, 11) ^ un(r, 25);
}
function Ag(r) {
  return [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
}
function Zv(r, e) {
  let t, n, a, i, o, u, c;
  const h = [];
  for (t = e[0], n = e[1], a = e[2], i = e[3], o = e[4], c = 0; c < 80; c += 1)
    h[c] = c < 16 ? r[c] : si(h[c - 3] ^ h[c - 8] ^ h[c - 14] ^ h[c - 16], 1), u = c < 20 ? Qi(si(t, 5), Yv(n, a, i), o, 1518500249, h[c]) : c < 40 ? Qi(si(t, 5), sl(n, a, i), o, 1859775393, h[c]) : c < 60 ? Qi(si(t, 5), Xv(n, a, i), o, 2400959708, h[c]) : Qi(si(t, 5), sl(n, a, i), o, 3395469782, h[c]), o = i, i = a, a = si(n, 30), n = t, t = u;
  return e[0] = Br(t, e[0]), e[1] = Br(n, e[1]), e[2] = Br(a, e[2]), e[3] = Br(i, e[3]), e[4] = Br(o, e[4]), e;
}
function Tg(r, e, t, n) {
  let a;
  const i = 15 + (e + 65 >>> 9 << 4), o = e + t;
  for (; r.length <= i; )
    r.push(0);
  for (r[e >>> 5] |= 128 << 24 - e % 32, r[i] = 4294967295 & o, r[i - 1] = o / va | 0, a = 0; a < r.length; a += 16)
    n = Zv(r.slice(a, a + 16), n);
  return n;
}
let kg = class extends xo {
  constructor(e, t, n) {
    if (e !== "SHA-1")
      throw new Error(ya);
    super(e, t, n);
    const a = n || {};
    this.M = !0, this.g = this.Y, this.T = -1, this.C = Ti(this.t, this.i, this.T), this.v = Zv, this.L = function(i) {
      return i.slice();
    }, this.B = Ag, this.F = Tg, this.U = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.m = 512, this.R = 160, this.K = !1, a.hmacKey && this.k(Bn("hmacKey", a.hmacKey, this.T));
  }
};
function fl(r) {
  let e;
  return e = r == "SHA-224" ? vn.slice() : yn.slice(), e;
}
function ul(r, e) {
  let t, n, a, i, o, u, c, h, s, d, l;
  const y = [];
  for (t = e[0], n = e[1], a = e[2], i = e[3], o = e[4], u = e[5], c = e[6], h = e[7], l = 0; l < 64; l += 1)
    y[l] = l < 16 ? r[l] : Sg(un(m = y[l - 2], 17) ^ un(m, 19) ^ Jv(m, 10), y[l - 7], Eg(y[l - 15]), y[l - 16]), s = Qi(h, Mg(o), Yv(o, u, c), vt[l], y[l]), d = Br(xg(t), Xv(t, n, a)), h = c, c = u, u = o, o = Br(i, s), i = a, a = n, n = t, t = Br(s, d);
  var m;
  return e[0] = Br(t, e[0]), e[1] = Br(n, e[1]), e[2] = Br(a, e[2]), e[3] = Br(i, e[3]), e[4] = Br(o, e[4]), e[5] = Br(u, e[5]), e[6] = Br(c, e[6]), e[7] = Br(h, e[7]), e;
}
let Ig = class extends xo {
  constructor(e, t, n) {
    if (e !== "SHA-224" && e !== "SHA-256")
      throw new Error(ya);
    super(e, t, n);
    const a = n || {};
    this.g = this.Y, this.M = !0, this.T = -1, this.C = Ti(this.t, this.i, this.T), this.v = ul, this.L = function(i) {
      return i.slice();
    }, this.B = fl, this.F = function(i, o, u, c) {
      return function(h, s, d, l, y) {
        let m, w;
        const E = 15 + (s + 65 >>> 9 << 4), S = s + d;
        for (; h.length <= E; )
          h.push(0);
        for (h[s >>> 5] |= 128 << 24 - s % 32, h[E] = 4294967295 & S, h[E - 1] = S / va | 0, m = 0; m < h.length; m += 16)
          l = ul(h.slice(m, m + 16), l);
        return w = y === "SHA-224" ? [l[0], l[1], l[2], l[3], l[4], l[5], l[6]] : l, w;
      }(i, o, u, c, e);
    }, this.U = fl(e), this.m = 512, this.R = e === "SHA-224" ? 224 : 256, this.K = !1, a.hmacKey && this.k(Bn("hmacKey", a.hmacKey, this.T));
  }
};
class xe {
  constructor(e, t) {
    this.N = e, this.I = t;
  }
}
function cl(r, e) {
  let t;
  return e > 32 ? (t = 64 - e, new xe(r.I << e | r.N >>> t, r.N << e | r.I >>> t)) : e !== 0 ? (t = 32 - e, new xe(r.N << e | r.I >>> t, r.I << e | r.N >>> t)) : r;
}
function cn(r, e) {
  let t;
  return e < 32 ? (t = 32 - e, new xe(r.N >>> e | r.I << t, r.I >>> e | r.N << t)) : (t = 64 - e, new xe(r.I >>> e | r.N << t, r.N >>> e | r.I << t));
}
function e1(r, e) {
  return new xe(r.N >>> e, r.I >>> e | r.N << 32 - e);
}
function Rg(r, e, t) {
  return new xe(r.N & e.N ^ r.N & t.N ^ e.N & t.N, r.I & e.I ^ r.I & t.I ^ e.I & t.I);
}
function Cg(r) {
  const e = cn(r, 28), t = cn(r, 34), n = cn(r, 39);
  return new xe(e.N ^ t.N ^ n.N, e.I ^ t.I ^ n.I);
}
function Gr(r, e) {
  let t, n;
  t = (65535 & r.I) + (65535 & e.I), n = (r.I >>> 16) + (e.I >>> 16) + (t >>> 16);
  const a = (65535 & n) << 16 | 65535 & t;
  return t = (65535 & r.N) + (65535 & e.N) + (n >>> 16), n = (r.N >>> 16) + (e.N >>> 16) + (t >>> 16), new xe((65535 & n) << 16 | 65535 & t, a);
}
function Og(r, e, t, n) {
  let a, i;
  a = (65535 & r.I) + (65535 & e.I) + (65535 & t.I) + (65535 & n.I), i = (r.I >>> 16) + (e.I >>> 16) + (t.I >>> 16) + (n.I >>> 16) + (a >>> 16);
  const o = (65535 & i) << 16 | 65535 & a;
  return a = (65535 & r.N) + (65535 & e.N) + (65535 & t.N) + (65535 & n.N) + (i >>> 16), i = (r.N >>> 16) + (e.N >>> 16) + (t.N >>> 16) + (n.N >>> 16) + (a >>> 16), new xe((65535 & i) << 16 | 65535 & a, o);
}
function Bg(r, e, t, n, a) {
  let i, o;
  i = (65535 & r.I) + (65535 & e.I) + (65535 & t.I) + (65535 & n.I) + (65535 & a.I), o = (r.I >>> 16) + (e.I >>> 16) + (t.I >>> 16) + (n.I >>> 16) + (a.I >>> 16) + (i >>> 16);
  const u = (65535 & o) << 16 | 65535 & i;
  return i = (65535 & r.N) + (65535 & e.N) + (65535 & t.N) + (65535 & n.N) + (65535 & a.N) + (o >>> 16), o = (r.N >>> 16) + (e.N >>> 16) + (t.N >>> 16) + (n.N >>> 16) + (a.N >>> 16) + (i >>> 16), new xe((65535 & o) << 16 | 65535 & i, u);
}
function qi(r, e) {
  return new xe(r.N ^ e.N, r.I ^ e.I);
}
function Pg(r) {
  const e = cn(r, 19), t = cn(r, 61), n = e1(r, 6);
  return new xe(e.N ^ t.N ^ n.N, e.I ^ t.I ^ n.I);
}
function Dg(r) {
  const e = cn(r, 1), t = cn(r, 8), n = e1(r, 7);
  return new xe(e.N ^ t.N ^ n.N, e.I ^ t.I ^ n.I);
}
function Ng(r) {
  const e = cn(r, 14), t = cn(r, 18), n = cn(r, 41);
  return new xe(e.N ^ t.N ^ n.N, e.I ^ t.I ^ n.I);
}
const qg = [new xe(vt[0], 3609767458), new xe(vt[1], 602891725), new xe(vt[2], 3964484399), new xe(vt[3], 2173295548), new xe(vt[4], 4081628472), new xe(vt[5], 3053834265), new xe(vt[6], 2937671579), new xe(vt[7], 3664609560), new xe(vt[8], 2734883394), new xe(vt[9], 1164996542), new xe(vt[10], 1323610764), new xe(vt[11], 3590304994), new xe(vt[12], 4068182383), new xe(vt[13], 991336113), new xe(vt[14], 633803317), new xe(vt[15], 3479774868), new xe(vt[16], 2666613458), new xe(vt[17], 944711139), new xe(vt[18], 2341262773), new xe(vt[19], 2007800933), new xe(vt[20], 1495990901), new xe(vt[21], 1856431235), new xe(vt[22], 3175218132), new xe(vt[23], 2198950837), new xe(vt[24], 3999719339), new xe(vt[25], 766784016), new xe(vt[26], 2566594879), new xe(vt[27], 3203337956), new xe(vt[28], 1034457026), new xe(vt[29], 2466948901), new xe(vt[30], 3758326383), new xe(vt[31], 168717936), new xe(vt[32], 1188179964), new xe(vt[33], 1546045734), new xe(vt[34], 1522805485), new xe(vt[35], 2643833823), new xe(vt[36], 2343527390), new xe(vt[37], 1014477480), new xe(vt[38], 1206759142), new xe(vt[39], 344077627), new xe(vt[40], 1290863460), new xe(vt[41], 3158454273), new xe(vt[42], 3505952657), new xe(vt[43], 106217008), new xe(vt[44], 3606008344), new xe(vt[45], 1432725776), new xe(vt[46], 1467031594), new xe(vt[47], 851169720), new xe(vt[48], 3100823752), new xe(vt[49], 1363258195), new xe(vt[50], 3750685593), new xe(vt[51], 3785050280), new xe(vt[52], 3318307427), new xe(vt[53], 3812723403), new xe(vt[54], 2003034995), new xe(vt[55], 3602036899), new xe(vt[56], 1575990012), new xe(vt[57], 1125592928), new xe(vt[58], 2716904306), new xe(vt[59], 442776044), new xe(vt[60], 593698344), new xe(vt[61], 3733110249), new xe(vt[62], 2999351573), new xe(vt[63], 3815920427), new xe(3391569614, 3928383900), new xe(3515267271, 566280711), new xe(3940187606, 3454069534), new xe(4118630271, 4000239992), new xe(116418474, 1914138554), new xe(174292421, 2731055270), new xe(289380356, 3203993006), new xe(460393269, 320620315), new xe(685471733, 587496836), new xe(852142971, 1086792851), new xe(1017036298, 365543100), new xe(1126000580, 2618297676), new xe(1288033470, 3409855158), new xe(1501505948, 4234509866), new xe(1607167915, 987167468), new xe(1816402316, 1246189591)];
function hl(r) {
  return r === "SHA-384" ? [new xe(3418070365, vn[0]), new xe(1654270250, vn[1]), new xe(2438529370, vn[2]), new xe(355462360, vn[3]), new xe(1731405415, vn[4]), new xe(41048885895, vn[5]), new xe(3675008525, vn[6]), new xe(1203062813, vn[7])] : [new xe(yn[0], 4089235720), new xe(yn[1], 2227873595), new xe(yn[2], 4271175723), new xe(yn[3], 1595750129), new xe(yn[4], 2917565137), new xe(yn[5], 725511199), new xe(yn[6], 4215389547), new xe(yn[7], 327033209)];
}
function ll(r, e) {
  let t, n, a, i, o, u, c, h, s, d, l, y;
  const m = [];
  for (t = e[0], n = e[1], a = e[2], i = e[3], o = e[4], u = e[5], c = e[6], h = e[7], l = 0; l < 80; l += 1)
    l < 16 ? (y = 2 * l, m[l] = new xe(r[y], r[y + 1])) : m[l] = Og(Pg(m[l - 2]), m[l - 7], Dg(m[l - 15]), m[l - 16]), s = Bg(h, Ng(o), (E = u, S = c, new xe((w = o).N & E.N ^ ~w.N & S.N, w.I & E.I ^ ~w.I & S.I)), qg[l], m[l]), d = Gr(Cg(t), Rg(t, n, a)), h = c, c = u, u = o, o = Gr(i, s), i = a, a = n, n = t, t = Gr(s, d);
  var w, E, S;
  return e[0] = Gr(t, e[0]), e[1] = Gr(n, e[1]), e[2] = Gr(a, e[2]), e[3] = Gr(i, e[3]), e[4] = Gr(o, e[4]), e[5] = Gr(u, e[5]), e[6] = Gr(c, e[6]), e[7] = Gr(h, e[7]), e;
}
let Lg = class extends xo {
  constructor(r, e, t) {
    if (r !== "SHA-384" && r !== "SHA-512")
      throw new Error(ya);
    super(r, e, t);
    const n = t || {};
    this.g = this.Y, this.M = !0, this.T = -1, this.C = Ti(this.t, this.i, this.T), this.v = ll, this.L = function(a) {
      return a.slice();
    }, this.B = hl, this.F = function(a, i, o, u) {
      return function(c, h, s, d, l) {
        let y, m;
        const w = 31 + (h + 129 >>> 10 << 5), E = h + s;
        for (; c.length <= w; )
          c.push(0);
        for (c[h >>> 5] |= 128 << 24 - h % 32, c[w] = 4294967295 & E, c[w - 1] = E / va | 0, y = 0; y < c.length; y += 32)
          d = ll(c.slice(y, y + 32), d);
        return m = l === "SHA-384" ? [d[0].N, d[0].I, d[1].N, d[1].I, d[2].N, d[2].I, d[3].N, d[3].I, d[4].N, d[4].I, d[5].N, d[5].I] : [d[0].N, d[0].I, d[1].N, d[1].I, d[2].N, d[2].I, d[3].N, d[3].I, d[4].N, d[4].I, d[5].N, d[5].I, d[6].N, d[6].I, d[7].N, d[7].I], m;
      }(a, i, o, u, r);
    }, this.U = hl(r), this.m = 1024, this.R = r === "SHA-384" ? 384 : 512, this.K = !1, n.hmacKey && this.k(Bn("hmacKey", n.hmacKey, this.T));
  }
};
const Fg = [new xe(0, 1), new xe(0, 32898), new xe(2147483648, 32906), new xe(2147483648, 2147516416), new xe(0, 32907), new xe(0, 2147483649), new xe(2147483648, 2147516545), new xe(2147483648, 32777), new xe(0, 138), new xe(0, 136), new xe(0, 2147516425), new xe(0, 2147483658), new xe(0, 2147516555), new xe(2147483648, 139), new xe(2147483648, 32905), new xe(2147483648, 32771), new xe(2147483648, 32770), new xe(2147483648, 128), new xe(0, 32778), new xe(2147483648, 2147483658), new xe(2147483648, 2147516545), new xe(2147483648, 32896), new xe(0, 2147483649), new xe(2147483648, 2147516424)], Ug = [[0, 36, 3, 41, 18], [1, 44, 10, 45, 2], [62, 6, 43, 15, 61], [28, 55, 25, 21, 56], [27, 20, 39, 8, 14]];
function ac(r) {
  let e;
  const t = [];
  for (e = 0; e < 5; e += 1)
    t[e] = [new xe(0, 0), new xe(0, 0), new xe(0, 0), new xe(0, 0), new xe(0, 0)];
  return t;
}
function $g(r) {
  let e;
  const t = [];
  for (e = 0; e < 5; e += 1)
    t[e] = r[e].slice();
  return t;
}
function Ia(r, e) {
  let t, n, a, i;
  const o = [], u = [];
  if (r !== null)
    for (n = 0; n < r.length; n += 2)
      e[(n >>> 1) % 5][(n >>> 1) / 5 | 0] = qi(e[(n >>> 1) % 5][(n >>> 1) / 5 | 0], new xe(r[n + 1], r[n]));
  for (t = 0; t < 24; t += 1) {
    for (i = ac(), n = 0; n < 5; n += 1)
      o[n] = (c = e[n][0], h = e[n][1], s = e[n][2], d = e[n][3], l = e[n][4], new xe(c.N ^ h.N ^ s.N ^ d.N ^ l.N, c.I ^ h.I ^ s.I ^ d.I ^ l.I));
    for (n = 0; n < 5; n += 1)
      u[n] = qi(o[(n + 4) % 5], cl(o[(n + 1) % 5], 1));
    for (n = 0; n < 5; n += 1)
      for (a = 0; a < 5; a += 1)
        e[n][a] = qi(e[n][a], u[n]);
    for (n = 0; n < 5; n += 1)
      for (a = 0; a < 5; a += 1)
        i[a][(2 * n + 3 * a) % 5] = cl(e[n][a], Ug[n][a]);
    for (n = 0; n < 5; n += 1)
      for (a = 0; a < 5; a += 1)
        e[n][a] = qi(i[n][a], new xe(~i[(n + 1) % 5][a].N & i[(n + 2) % 5][a].N, ~i[(n + 1) % 5][a].I & i[(n + 2) % 5][a].I));
    e[0][0] = qi(e[0][0], Fg[t]);
  }
  var c, h, s, d, l;
  return e;
}
function t1(r) {
  let e, t, n = 0;
  const a = [0, 0], i = [4294967295 & r, r / va & 2097151];
  for (e = 6; e >= 0; e--)
    t = i[e >> 2] >>> 8 * e & 255, t === 0 && n === 0 || (a[n + 1 >> 2] |= t << 8 * (n + 1), n += 1);
  return n = n !== 0 ? n : 1, a[0] |= n, { value: n + 1 > 4 ? a : [a[0]], binLen: 8 + 8 * n };
}
function Jo(r) {
  return co(t1(r.binLen), r);
}
function dl(r, e) {
  let t, n = t1(e);
  n = co(n, r);
  const a = e >>> 2, i = (a - n.value.length % a) % a;
  for (t = 0; t < i; t++)
    n.value.push(0);
  return n.value;
}
let jg = class extends xo {
  constructor(r, e, t) {
    let n = 6, a = 0;
    super(r, e, t);
    const i = t || {};
    if (this.numRounds !== 1) {
      if (i.kmacKey || i.hmacKey)
        throw new Error(Gv);
      if (this.o === "CSHAKE128" || this.o === "CSHAKE256")
        throw new Error("Cannot set numRounds for CSHAKE variants");
    }
    switch (this.T = 1, this.C = Ti(this.t, this.i, this.T), this.v = Ia, this.L = $g, this.B = ac, this.U = ac(), this.K = !1, r) {
      case "SHA3-224":
        this.m = a = 1152, this.R = 224, this.M = !0, this.g = this.Y;
        break;
      case "SHA3-256":
        this.m = a = 1088, this.R = 256, this.M = !0, this.g = this.Y;
        break;
      case "SHA3-384":
        this.m = a = 832, this.R = 384, this.M = !0, this.g = this.Y;
        break;
      case "SHA3-512":
        this.m = a = 576, this.R = 512, this.M = !0, this.g = this.Y;
        break;
      case "SHAKE128":
        n = 31, this.m = a = 1344, this.R = -1, this.K = !0, this.M = !1, this.g = null;
        break;
      case "SHAKE256":
        n = 31, this.m = a = 1088, this.R = -1, this.K = !0, this.M = !1, this.g = null;
        break;
      case "KMAC128":
        n = 4, this.m = a = 1344, this.X(t), this.R = -1, this.K = !0, this.M = !1, this.g = this._;
        break;
      case "KMAC256":
        n = 4, this.m = a = 1088, this.X(t), this.R = -1, this.K = !0, this.M = !1, this.g = this._;
        break;
      case "CSHAKE128":
        this.m = a = 1344, n = this.O(t), this.R = -1, this.K = !0, this.M = !1, this.g = null;
        break;
      case "CSHAKE256":
        this.m = a = 1088, n = this.O(t), this.R = -1, this.K = !0, this.M = !1, this.g = null;
        break;
      default:
        throw new Error(ya);
    }
    this.F = function(o, u, c, h, s) {
      return function(d, l, y, m, w, E, S) {
        let P, L, U = 0;
        const z = [], K = w >>> 5, re = l >>> 5;
        for (P = 0; P < re && l >= w; P += K)
          m = Ia(d.slice(P, P + K), m), l -= w;
        for (d = d.slice(P), l %= w; d.length < K; )
          d.push(0);
        for (P = l >>> 3, d[P >> 2] ^= E << P % 4 * 8, d[K - 1] ^= 2147483648, m = Ia(d, m); 32 * z.length < S && (L = m[U % 5][U / 5 | 0], z.push(L.I), !(32 * z.length >= S)); )
          z.push(L.N), U += 1, 64 * U % w == 0 && (Ia(null, m), U = 0);
        return z;
      }(o, u, 0, h, a, n, s);
    }, i.hmacKey && this.k(Bn("hmacKey", i.hmacKey, this.T));
  }
  O(r, e) {
    const t = function(a) {
      const i = a || {};
      return { funcName: Bn("funcName", i.funcName, 1, { value: [], binLen: 0 }), customization: Bn("Customization", i.customization, 1, { value: [], binLen: 0 }) };
    }(r || {});
    e && (t.funcName = e);
    const n = co(Jo(t.funcName), Jo(t.customization));
    if (t.customization.binLen !== 0 || t.funcName.binLen !== 0) {
      const a = dl(n, this.m >>> 3);
      for (let i = 0; i < a.length; i += this.m >>> 5)
        this.U = this.v(a.slice(i, i + (this.m >>> 5)), this.U), this.A += this.m;
      return 4;
    }
    return 31;
  }
  X(r) {
    const e = function(n) {
      const a = n || {};
      return { kmacKey: Bn("kmacKey", a.kmacKey, 1), funcName: { value: [1128353099], binLen: 32 }, customization: Bn("Customization", a.customization, 1, { value: [], binLen: 0 }) };
    }(r || {});
    this.O(r, e.funcName);
    const t = dl(Jo(e.kmacKey), this.m >>> 3);
    for (let n = 0; n < t.length; n += this.m >>> 5)
      this.U = this.v(t.slice(n, n + (this.m >>> 5)), this.U), this.A += this.m;
    this.H = !0;
  }
  _(r) {
    const e = co({ value: this.h.slice(), binLen: this.u }, function(t) {
      let n, a, i = 0;
      const o = [0, 0], u = [4294967295 & t, t / va & 2097151];
      for (n = 6; n >= 0; n--)
        a = u[n >> 2] >>> 8 * n & 255, a === 0 && i === 0 || (o[i >> 2] |= a << 8 * i, i += 1);
      return i = i !== 0 ? i : 1, o[i >> 2] |= i << 8 * i, { value: i + 1 > 4 ? o : [o[0]], binLen: 8 + 8 * i };
    }(r.outputLen));
    return this.F(e.value, e.binLen, this.A, this.L(this.U), r.outputLen);
  }
};
class Lr {
  constructor(e, t, n) {
    if (e == "SHA-1")
      this.P = new kg(e, t, n);
    else if (e == "SHA-224" || e == "SHA-256")
      this.P = new Ig(e, t, n);
    else if (e == "SHA-384" || e == "SHA-512")
      this.P = new Lg(e, t, n);
    else {
      if (e != "SHA3-224" && e != "SHA3-256" && e != "SHA3-384" && e != "SHA3-512" && e != "SHAKE128" && e != "SHAKE256" && e != "CSHAKE128" && e != "CSHAKE256" && e != "KMAC128" && e != "KMAC256")
        throw new Error(ya);
      this.P = new jg(e, t, n);
    }
  }
  update(e) {
    return this.P.update(e), this;
  }
  getHash(e, t) {
    return this.P.getHash(e, t);
  }
  setHMACKey(e, t, n) {
    this.P.setHMACKey(e, t, n);
  }
  getHMAC(e, t) {
    return this.P.getHMAC(e, t);
  }
}
var xr = {}, So = {};
So.byteLength = Vg;
So.toByteArray = Kg;
So.fromByteArray = Jg;
var fn = [], Vr = [], Hg = typeof Uint8Array != "undefined" ? Uint8Array : Array, Yo = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var fi = 0, zg = Yo.length; fi < zg; ++fi)
  fn[fi] = Yo[fi], Vr[Yo.charCodeAt(fi)] = fi;
Vr[45] = 62;
Vr[95] = 63;
function r1(r) {
  var e = r.length;
  if (e % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var t = r.indexOf("=");
  t === -1 && (t = e);
  var n = t === e ? 0 : 4 - t % 4;
  return [t, n];
}
function Vg(r) {
  var e = r1(r), t = e[0], n = e[1];
  return (t + n) * 3 / 4 - n;
}
function Wg(r, e, t) {
  return (e + t) * 3 / 4 - t;
}
function Kg(r) {
  var e, t = r1(r), n = t[0], a = t[1], i = new Hg(Wg(r, n, a)), o = 0, u = a > 0 ? n - 4 : n, c;
  for (c = 0; c < u; c += 4)
    e = Vr[r.charCodeAt(c)] << 18 | Vr[r.charCodeAt(c + 1)] << 12 | Vr[r.charCodeAt(c + 2)] << 6 | Vr[r.charCodeAt(c + 3)], i[o++] = e >> 16 & 255, i[o++] = e >> 8 & 255, i[o++] = e & 255;
  return a === 2 && (e = Vr[r.charCodeAt(c)] << 2 | Vr[r.charCodeAt(c + 1)] >> 4, i[o++] = e & 255), a === 1 && (e = Vr[r.charCodeAt(c)] << 10 | Vr[r.charCodeAt(c + 1)] << 4 | Vr[r.charCodeAt(c + 2)] >> 2, i[o++] = e >> 8 & 255, i[o++] = e & 255), i;
}
function Qg(r) {
  return fn[r >> 18 & 63] + fn[r >> 12 & 63] + fn[r >> 6 & 63] + fn[r & 63];
}
function Gg(r, e, t) {
  for (var n, a = [], i = e; i < t; i += 3)
    n = (r[i] << 16 & 16711680) + (r[i + 1] << 8 & 65280) + (r[i + 2] & 255), a.push(Qg(n));
  return a.join("");
}
function Jg(r) {
  for (var e, t = r.length, n = t % 3, a = [], i = 16383, o = 0, u = t - n; o < u; o += i)
    a.push(Gg(r, o, o + i > u ? u : o + i));
  return n === 1 ? (e = r[t - 1], a.push(
    fn[e >> 2] + fn[e << 4 & 63] + "=="
  )) : n === 2 && (e = (r[t - 2] << 8) + r[t - 1], a.push(
    fn[e >> 10] + fn[e >> 4 & 63] + fn[e << 2 & 63] + "="
  )), a.join("");
}
var $c = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
$c.read = function(r, e, t, n, a) {
  var i, o, u = a * 8 - n - 1, c = (1 << u) - 1, h = c >> 1, s = -7, d = t ? a - 1 : 0, l = t ? -1 : 1, y = r[e + d];
  for (d += l, i = y & (1 << -s) - 1, y >>= -s, s += u; s > 0; i = i * 256 + r[e + d], d += l, s -= 8)
    ;
  for (o = i & (1 << -s) - 1, i >>= -s, s += n; s > 0; o = o * 256 + r[e + d], d += l, s -= 8)
    ;
  if (i === 0)
    i = 1 - h;
  else {
    if (i === c)
      return o ? NaN : (y ? -1 : 1) * (1 / 0);
    o = o + Math.pow(2, n), i = i - h;
  }
  return (y ? -1 : 1) * o * Math.pow(2, i - n);
};
$c.write = function(r, e, t, n, a, i) {
  var o, u, c, h = i * 8 - a - 1, s = (1 << h) - 1, d = s >> 1, l = a === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, y = n ? 0 : i - 1, m = n ? 1 : -1, w = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
  for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (u = isNaN(e) ? 1 : 0, o = s) : (o = Math.floor(Math.log(e) / Math.LN2), e * (c = Math.pow(2, -o)) < 1 && (o--, c *= 2), o + d >= 1 ? e += l / c : e += l * Math.pow(2, 1 - d), e * c >= 2 && (o++, c /= 2), o + d >= s ? (u = 0, o = s) : o + d >= 1 ? (u = (e * c - 1) * Math.pow(2, a), o = o + d) : (u = e * Math.pow(2, d - 1) * Math.pow(2, a), o = 0)); a >= 8; r[t + y] = u & 255, y += m, u /= 256, a -= 8)
    ;
  for (o = o << a | u, h += a; h > 0; r[t + y] = o & 255, y += m, o /= 256, h -= 8)
    ;
  r[t + y - m] |= w * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(r) {
  const e = So, t = $c, n = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  r.Buffer = s, r.SlowBuffer = z, r.INSPECT_MAX_BYTES = 50;
  const a = 2147483647;
  r.kMaxLength = a;
  const { Uint8Array: i, ArrayBuffer: o, SharedArrayBuffer: u } = globalThis;
  s.TYPED_ARRAY_SUPPORT = c(), !s.TYPED_ARRAY_SUPPORT && typeof console != "undefined" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function c() {
    try {
      const W = new i(1), q = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(q, i.prototype), Object.setPrototypeOf(W, q), W.foo() === 42;
    } catch (W) {
      return !1;
    }
  }
  Object.defineProperty(s.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (s.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(s.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (s.isBuffer(this))
        return this.byteOffset;
    }
  });
  function h(W) {
    if (W > a)
      throw new RangeError('The value "' + W + '" is invalid for option "size"');
    const q = new i(W);
    return Object.setPrototypeOf(q, s.prototype), q;
  }
  function s(W, q, F) {
    if (typeof W == "number") {
      if (typeof q == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return m(W);
    }
    return d(W, q, F);
  }
  s.poolSize = 8192;
  function d(W, q, F) {
    if (typeof W == "string")
      return w(W, q);
    if (o.isView(W))
      return S(W);
    if (W == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof W
      );
    if (Mt(W, o) || W && Mt(W.buffer, o) || typeof u != "undefined" && (Mt(W, u) || W && Mt(W.buffer, u)))
      return P(W, q, F);
    if (typeof W == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const J = W.valueOf && W.valueOf();
    if (J != null && J !== W)
      return s.from(J, q, F);
    const he = L(W);
    if (he)
      return he;
    if (typeof Symbol != "undefined" && Symbol.toPrimitive != null && typeof W[Symbol.toPrimitive] == "function")
      return s.from(W[Symbol.toPrimitive]("string"), q, F);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof W
    );
  }
  s.from = function(W, q, F) {
    return d(W, q, F);
  }, Object.setPrototypeOf(s.prototype, i.prototype), Object.setPrototypeOf(s, i);
  function l(W) {
    if (typeof W != "number")
      throw new TypeError('"size" argument must be of type number');
    if (W < 0)
      throw new RangeError('The value "' + W + '" is invalid for option "size"');
  }
  function y(W, q, F) {
    return l(W), W <= 0 ? h(W) : q !== void 0 ? typeof F == "string" ? h(W).fill(q, F) : h(W).fill(q) : h(W);
  }
  s.alloc = function(W, q, F) {
    return y(W, q, F);
  };
  function m(W) {
    return l(W), h(W < 0 ? 0 : U(W) | 0);
  }
  s.allocUnsafe = function(W) {
    return m(W);
  }, s.allocUnsafeSlow = function(W) {
    return m(W);
  };
  function w(W, q) {
    if ((typeof q != "string" || q === "") && (q = "utf8"), !s.isEncoding(q))
      throw new TypeError("Unknown encoding: " + q);
    const F = K(W, q) | 0;
    let J = h(F);
    const he = J.write(W, q);
    return he !== F && (J = J.slice(0, he)), J;
  }
  function E(W) {
    const q = W.length < 0 ? 0 : U(W.length) | 0, F = h(q);
    for (let J = 0; J < q; J += 1)
      F[J] = W[J] & 255;
    return F;
  }
  function S(W) {
    if (Mt(W, i)) {
      const q = new i(W);
      return P(q.buffer, q.byteOffset, q.byteLength);
    }
    return E(W);
  }
  function P(W, q, F) {
    if (q < 0 || W.byteLength < q)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (W.byteLength < q + (F || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let J;
    return q === void 0 && F === void 0 ? J = new i(W) : F === void 0 ? J = new i(W, q) : J = new i(W, q, F), Object.setPrototypeOf(J, s.prototype), J;
  }
  function L(W) {
    if (s.isBuffer(W)) {
      const q = U(W.length) | 0, F = h(q);
      return F.length === 0 || W.copy(F, 0, 0, q), F;
    }
    if (W.length !== void 0)
      return typeof W.length != "number" || lt(W.length) ? h(0) : E(W);
    if (W.type === "Buffer" && Array.isArray(W.data))
      return E(W.data);
  }
  function U(W) {
    if (W >= a)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + a.toString(16) + " bytes");
    return W | 0;
  }
  function z(W) {
    return +W != W && (W = 0), s.alloc(+W);
  }
  s.isBuffer = function(q) {
    return q != null && q._isBuffer === !0 && q !== s.prototype;
  }, s.compare = function(q, F) {
    if (Mt(q, i) && (q = s.from(q, q.offset, q.byteLength)), Mt(F, i) && (F = s.from(F, F.offset, F.byteLength)), !s.isBuffer(q) || !s.isBuffer(F))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (q === F)
      return 0;
    let J = q.length, he = F.length;
    for (let de = 0, pe = Math.min(J, he); de < pe; ++de)
      if (q[de] !== F[de]) {
        J = q[de], he = F[de];
        break;
      }
    return J < he ? -1 : he < J ? 1 : 0;
  }, s.isEncoding = function(q) {
    switch (String(q).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, s.concat = function(q, F) {
    if (!Array.isArray(q))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (q.length === 0)
      return s.alloc(0);
    let J;
    if (F === void 0)
      for (F = 0, J = 0; J < q.length; ++J)
        F += q[J].length;
    const he = s.allocUnsafe(F);
    let de = 0;
    for (J = 0; J < q.length; ++J) {
      let pe = q[J];
      if (Mt(pe, i))
        de + pe.length > he.length ? (s.isBuffer(pe) || (pe = s.from(pe)), pe.copy(he, de)) : i.prototype.set.call(
          he,
          pe,
          de
        );
      else if (s.isBuffer(pe))
        pe.copy(he, de);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      de += pe.length;
    }
    return he;
  };
  function K(W, q) {
    if (s.isBuffer(W))
      return W.length;
    if (o.isView(W) || Mt(W, o))
      return W.byteLength;
    if (typeof W != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof W
      );
    const F = W.length, J = arguments.length > 2 && arguments[2] === !0;
    if (!J && F === 0)
      return 0;
    let he = !1;
    for (; ; )
      switch (q) {
        case "ascii":
        case "latin1":
        case "binary":
          return F;
        case "utf8":
        case "utf-8":
          return ht(W).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return F * 2;
        case "hex":
          return F >>> 1;
        case "base64":
          return ot(W).length;
        default:
          if (he)
            return J ? -1 : ht(W).length;
          q = ("" + q).toLowerCase(), he = !0;
      }
  }
  s.byteLength = K;
  function re(W, q, F) {
    let J = !1;
    if ((q === void 0 || q < 0) && (q = 0), q > this.length || ((F === void 0 || F > this.length) && (F = this.length), F <= 0) || (F >>>= 0, q >>>= 0, F <= q))
      return "";
    for (W || (W = "utf8"); ; )
      switch (W) {
        case "hex":
          return p(this, q, F);
        case "utf8":
        case "utf-8":
          return M(this, q, F);
        case "ascii":
          return x(this, q, F);
        case "latin1":
        case "binary":
          return T(this, q, F);
        case "base64":
          return g(this, q, F);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return B(this, q, F);
        default:
          if (J)
            throw new TypeError("Unknown encoding: " + W);
          W = (W + "").toLowerCase(), J = !0;
      }
  }
  s.prototype._isBuffer = !0;
  function oe(W, q, F) {
    const J = W[q];
    W[q] = W[F], W[F] = J;
  }
  s.prototype.swap16 = function() {
    const q = this.length;
    if (q % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let F = 0; F < q; F += 2)
      oe(this, F, F + 1);
    return this;
  }, s.prototype.swap32 = function() {
    const q = this.length;
    if (q % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let F = 0; F < q; F += 4)
      oe(this, F, F + 3), oe(this, F + 1, F + 2);
    return this;
  }, s.prototype.swap64 = function() {
    const q = this.length;
    if (q % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let F = 0; F < q; F += 8)
      oe(this, F, F + 7), oe(this, F + 1, F + 6), oe(this, F + 2, F + 5), oe(this, F + 3, F + 4);
    return this;
  }, s.prototype.toString = function() {
    const q = this.length;
    return q === 0 ? "" : arguments.length === 0 ? M(this, 0, q) : re.apply(this, arguments);
  }, s.prototype.toLocaleString = s.prototype.toString, s.prototype.equals = function(q) {
    if (!s.isBuffer(q))
      throw new TypeError("Argument must be a Buffer");
    return this === q ? !0 : s.compare(this, q) === 0;
  }, s.prototype.inspect = function() {
    let q = "";
    const F = r.INSPECT_MAX_BYTES;
    return q = this.toString("hex", 0, F).replace(/(.{2})/g, "$1 ").trim(), this.length > F && (q += " ... "), "<Buffer " + q + ">";
  }, n && (s.prototype[n] = s.prototype.inspect), s.prototype.compare = function(q, F, J, he, de) {
    if (Mt(q, i) && (q = s.from(q, q.offset, q.byteLength)), !s.isBuffer(q))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof q
      );
    if (F === void 0 && (F = 0), J === void 0 && (J = q ? q.length : 0), he === void 0 && (he = 0), de === void 0 && (de = this.length), F < 0 || J > q.length || he < 0 || de > this.length)
      throw new RangeError("out of range index");
    if (he >= de && F >= J)
      return 0;
    if (he >= de)
      return -1;
    if (F >= J)
      return 1;
    if (F >>>= 0, J >>>= 0, he >>>= 0, de >>>= 0, this === q)
      return 0;
    let pe = de - he, Je = J - F;
    const tt = Math.min(pe, Je), Ne = this.slice(he, de), St = q.slice(F, J);
    for (let rt = 0; rt < tt; ++rt)
      if (Ne[rt] !== St[rt]) {
        pe = Ne[rt], Je = St[rt];
        break;
      }
    return pe < Je ? -1 : Je < pe ? 1 : 0;
  };
  function se(W, q, F, J, he) {
    if (W.length === 0)
      return -1;
    if (typeof F == "string" ? (J = F, F = 0) : F > 2147483647 ? F = 2147483647 : F < -2147483648 && (F = -2147483648), F = +F, lt(F) && (F = he ? 0 : W.length - 1), F < 0 && (F = W.length + F), F >= W.length) {
      if (he)
        return -1;
      F = W.length - 1;
    } else if (F < 0)
      if (he)
        F = 0;
      else
        return -1;
    if (typeof q == "string" && (q = s.from(q, J)), s.isBuffer(q))
      return q.length === 0 ? -1 : ve(W, q, F, J, he);
    if (typeof q == "number")
      return q = q & 255, typeof i.prototype.indexOf == "function" ? he ? i.prototype.indexOf.call(W, q, F) : i.prototype.lastIndexOf.call(W, q, F) : ve(W, [q], F, J, he);
    throw new TypeError("val must be string, number or Buffer");
  }
  function ve(W, q, F, J, he) {
    let de = 1, pe = W.length, Je = q.length;
    if (J !== void 0 && (J = String(J).toLowerCase(), J === "ucs2" || J === "ucs-2" || J === "utf16le" || J === "utf-16le")) {
      if (W.length < 2 || q.length < 2)
        return -1;
      de = 2, pe /= 2, Je /= 2, F /= 2;
    }
    function tt(St, rt) {
      return de === 1 ? St[rt] : St.readUInt16BE(rt * de);
    }
    let Ne;
    if (he) {
      let St = -1;
      for (Ne = F; Ne < pe; Ne++)
        if (tt(W, Ne) === tt(q, St === -1 ? 0 : Ne - St)) {
          if (St === -1 && (St = Ne), Ne - St + 1 === Je)
            return St * de;
        } else
          St !== -1 && (Ne -= Ne - St), St = -1;
    } else
      for (F + Je > pe && (F = pe - Je), Ne = F; Ne >= 0; Ne--) {
        let St = !0;
        for (let rt = 0; rt < Je; rt++)
          if (tt(W, Ne + rt) !== tt(q, rt)) {
            St = !1;
            break;
          }
        if (St)
          return Ne;
      }
    return -1;
  }
  s.prototype.includes = function(q, F, J) {
    return this.indexOf(q, F, J) !== -1;
  }, s.prototype.indexOf = function(q, F, J) {
    return se(this, q, F, J, !0);
  }, s.prototype.lastIndexOf = function(q, F, J) {
    return se(this, q, F, J, !1);
  };
  function Q(W, q, F, J) {
    F = Number(F) || 0;
    const he = W.length - F;
    J ? (J = Number(J), J > he && (J = he)) : J = he;
    const de = q.length;
    J > de / 2 && (J = de / 2);
    let pe;
    for (pe = 0; pe < J; ++pe) {
      const Je = parseInt(q.substr(pe * 2, 2), 16);
      if (lt(Je))
        return pe;
      W[F + pe] = Je;
    }
    return pe;
  }
  function A(W, q, F, J) {
    return Ve(ht(q, W.length - F), W, F, J);
  }
  function b(W, q, F, J) {
    return Ve($e(q), W, F, J);
  }
  function f(W, q, F, J) {
    return Ve(ot(q), W, F, J);
  }
  function v(W, q, F, J) {
    return Ve(Et(q, W.length - F), W, F, J);
  }
  s.prototype.write = function(q, F, J, he) {
    if (F === void 0)
      he = "utf8", J = this.length, F = 0;
    else if (J === void 0 && typeof F == "string")
      he = F, J = this.length, F = 0;
    else if (isFinite(F))
      F = F >>> 0, isFinite(J) ? (J = J >>> 0, he === void 0 && (he = "utf8")) : (he = J, J = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const de = this.length - F;
    if ((J === void 0 || J > de) && (J = de), q.length > 0 && (J < 0 || F < 0) || F > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    he || (he = "utf8");
    let pe = !1;
    for (; ; )
      switch (he) {
        case "hex":
          return Q(this, q, F, J);
        case "utf8":
        case "utf-8":
          return A(this, q, F, J);
        case "ascii":
        case "latin1":
        case "binary":
          return b(this, q, F, J);
        case "base64":
          return f(this, q, F, J);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return v(this, q, F, J);
        default:
          if (pe)
            throw new TypeError("Unknown encoding: " + he);
          he = ("" + he).toLowerCase(), pe = !0;
      }
  }, s.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function g(W, q, F) {
    return q === 0 && F === W.length ? e.fromByteArray(W) : e.fromByteArray(W.slice(q, F));
  }
  function M(W, q, F) {
    F = Math.min(W.length, F);
    const J = [];
    let he = q;
    for (; he < F; ) {
      const de = W[he];
      let pe = null, Je = de > 239 ? 4 : de > 223 ? 3 : de > 191 ? 2 : 1;
      if (he + Je <= F) {
        let tt, Ne, St, rt;
        switch (Je) {
          case 1:
            de < 128 && (pe = de);
            break;
          case 2:
            tt = W[he + 1], (tt & 192) === 128 && (rt = (de & 31) << 6 | tt & 63, rt > 127 && (pe = rt));
            break;
          case 3:
            tt = W[he + 1], Ne = W[he + 2], (tt & 192) === 128 && (Ne & 192) === 128 && (rt = (de & 15) << 12 | (tt & 63) << 6 | Ne & 63, rt > 2047 && (rt < 55296 || rt > 57343) && (pe = rt));
            break;
          case 4:
            tt = W[he + 1], Ne = W[he + 2], St = W[he + 3], (tt & 192) === 128 && (Ne & 192) === 128 && (St & 192) === 128 && (rt = (de & 15) << 18 | (tt & 63) << 12 | (Ne & 63) << 6 | St & 63, rt > 65535 && rt < 1114112 && (pe = rt));
        }
      }
      pe === null ? (pe = 65533, Je = 1) : pe > 65535 && (pe -= 65536, J.push(pe >>> 10 & 1023 | 55296), pe = 56320 | pe & 1023), J.push(pe), he += Je;
    }
    return R(J);
  }
  const I = 4096;
  function R(W) {
    const q = W.length;
    if (q <= I)
      return String.fromCharCode.apply(String, W);
    let F = "", J = 0;
    for (; J < q; )
      F += String.fromCharCode.apply(
        String,
        W.slice(J, J += I)
      );
    return F;
  }
  function x(W, q, F) {
    let J = "";
    F = Math.min(W.length, F);
    for (let he = q; he < F; ++he)
      J += String.fromCharCode(W[he] & 127);
    return J;
  }
  function T(W, q, F) {
    let J = "";
    F = Math.min(W.length, F);
    for (let he = q; he < F; ++he)
      J += String.fromCharCode(W[he]);
    return J;
  }
  function p(W, q, F) {
    const J = W.length;
    (!q || q < 0) && (q = 0), (!F || F < 0 || F > J) && (F = J);
    let he = "";
    for (let de = q; de < F; ++de)
      he += Xe[W[de]];
    return he;
  }
  function B(W, q, F) {
    const J = W.slice(q, F);
    let he = "";
    for (let de = 0; de < J.length - 1; de += 2)
      he += String.fromCharCode(J[de] + J[de + 1] * 256);
    return he;
  }
  s.prototype.slice = function(q, F) {
    const J = this.length;
    q = ~~q, F = F === void 0 ? J : ~~F, q < 0 ? (q += J, q < 0 && (q = 0)) : q > J && (q = J), F < 0 ? (F += J, F < 0 && (F = 0)) : F > J && (F = J), F < q && (F = q);
    const he = this.subarray(q, F);
    return Object.setPrototypeOf(he, s.prototype), he;
  };
  function ee(W, q, F) {
    if (W % 1 !== 0 || W < 0)
      throw new RangeError("offset is not uint");
    if (W + q > F)
      throw new RangeError("Trying to access beyond buffer length");
  }
  s.prototype.readUintLE = s.prototype.readUIntLE = function(q, F, J) {
    q = q >>> 0, F = F >>> 0, J || ee(q, F, this.length);
    let he = this[q], de = 1, pe = 0;
    for (; ++pe < F && (de *= 256); )
      he += this[q + pe] * de;
    return he;
  }, s.prototype.readUintBE = s.prototype.readUIntBE = function(q, F, J) {
    q = q >>> 0, F = F >>> 0, J || ee(q, F, this.length);
    let he = this[q + --F], de = 1;
    for (; F > 0 && (de *= 256); )
      he += this[q + --F] * de;
    return he;
  }, s.prototype.readUint8 = s.prototype.readUInt8 = function(q, F) {
    return q = q >>> 0, F || ee(q, 1, this.length), this[q];
  }, s.prototype.readUint16LE = s.prototype.readUInt16LE = function(q, F) {
    return q = q >>> 0, F || ee(q, 2, this.length), this[q] | this[q + 1] << 8;
  }, s.prototype.readUint16BE = s.prototype.readUInt16BE = function(q, F) {
    return q = q >>> 0, F || ee(q, 2, this.length), this[q] << 8 | this[q + 1];
  }, s.prototype.readUint32LE = s.prototype.readUInt32LE = function(q, F) {
    return q = q >>> 0, F || ee(q, 4, this.length), (this[q] | this[q + 1] << 8 | this[q + 2] << 16) + this[q + 3] * 16777216;
  }, s.prototype.readUint32BE = s.prototype.readUInt32BE = function(q, F) {
    return q = q >>> 0, F || ee(q, 4, this.length), this[q] * 16777216 + (this[q + 1] << 16 | this[q + 2] << 8 | this[q + 3]);
  }, s.prototype.readBigUInt64LE = st(function(q) {
    q = q >>> 0, qe(q, "offset");
    const F = this[q], J = this[q + 7];
    (F === void 0 || J === void 0) && Ue(q, this.length - 8);
    const he = F + this[++q] * ar(2, 8) + this[++q] * ar(2, 16) + this[++q] * ar(2, 24), de = this[++q] + this[++q] * ar(2, 8) + this[++q] * ar(2, 16) + J * ar(2, 24);
    return BigInt(he) + (BigInt(de) << BigInt(32));
  }), s.prototype.readBigUInt64BE = st(function(q) {
    q = q >>> 0, qe(q, "offset");
    const F = this[q], J = this[q + 7];
    (F === void 0 || J === void 0) && Ue(q, this.length - 8);
    const he = F * ar(2, 24) + this[++q] * ar(2, 16) + this[++q] * ar(2, 8) + this[++q], de = this[++q] * ar(2, 24) + this[++q] * ar(2, 16) + this[++q] * ar(2, 8) + J;
    return (BigInt(he) << BigInt(32)) + BigInt(de);
  }), s.prototype.readIntLE = function(q, F, J) {
    q = q >>> 0, F = F >>> 0, J || ee(q, F, this.length);
    let he = this[q], de = 1, pe = 0;
    for (; ++pe < F && (de *= 256); )
      he += this[q + pe] * de;
    return de *= 128, he >= de && (he -= Math.pow(2, 8 * F)), he;
  }, s.prototype.readIntBE = function(q, F, J) {
    q = q >>> 0, F = F >>> 0, J || ee(q, F, this.length);
    let he = F, de = 1, pe = this[q + --he];
    for (; he > 0 && (de *= 256); )
      pe += this[q + --he] * de;
    return de *= 128, pe >= de && (pe -= Math.pow(2, 8 * F)), pe;
  }, s.prototype.readInt8 = function(q, F) {
    return q = q >>> 0, F || ee(q, 1, this.length), this[q] & 128 ? (255 - this[q] + 1) * -1 : this[q];
  }, s.prototype.readInt16LE = function(q, F) {
    q = q >>> 0, F || ee(q, 2, this.length);
    const J = this[q] | this[q + 1] << 8;
    return J & 32768 ? J | 4294901760 : J;
  }, s.prototype.readInt16BE = function(q, F) {
    q = q >>> 0, F || ee(q, 2, this.length);
    const J = this[q + 1] | this[q] << 8;
    return J & 32768 ? J | 4294901760 : J;
  }, s.prototype.readInt32LE = function(q, F) {
    return q = q >>> 0, F || ee(q, 4, this.length), this[q] | this[q + 1] << 8 | this[q + 2] << 16 | this[q + 3] << 24;
  }, s.prototype.readInt32BE = function(q, F) {
    return q = q >>> 0, F || ee(q, 4, this.length), this[q] << 24 | this[q + 1] << 16 | this[q + 2] << 8 | this[q + 3];
  }, s.prototype.readBigInt64LE = st(function(q) {
    q = q >>> 0, qe(q, "offset");
    const F = this[q], J = this[q + 7];
    (F === void 0 || J === void 0) && Ue(q, this.length - 8);
    const he = this[q + 4] + this[q + 5] * ar(2, 8) + this[q + 6] * ar(2, 16) + (J << 24);
    return (BigInt(he) << BigInt(32)) + BigInt(F + this[++q] * ar(2, 8) + this[++q] * ar(2, 16) + this[++q] * ar(2, 24));
  }), s.prototype.readBigInt64BE = st(function(q) {
    q = q >>> 0, qe(q, "offset");
    const F = this[q], J = this[q + 7];
    (F === void 0 || J === void 0) && Ue(q, this.length - 8);
    const he = (F << 24) + // Overflow
    this[++q] * ar(2, 16) + this[++q] * ar(2, 8) + this[++q];
    return (BigInt(he) << BigInt(32)) + BigInt(this[++q] * ar(2, 24) + this[++q] * ar(2, 16) + this[++q] * ar(2, 8) + J);
  }), s.prototype.readFloatLE = function(q, F) {
    return q = q >>> 0, F || ee(q, 4, this.length), t.read(this, q, !0, 23, 4);
  }, s.prototype.readFloatBE = function(q, F) {
    return q = q >>> 0, F || ee(q, 4, this.length), t.read(this, q, !1, 23, 4);
  }, s.prototype.readDoubleLE = function(q, F) {
    return q = q >>> 0, F || ee(q, 8, this.length), t.read(this, q, !0, 52, 8);
  }, s.prototype.readDoubleBE = function(q, F) {
    return q = q >>> 0, F || ee(q, 8, this.length), t.read(this, q, !1, 52, 8);
  };
  function ae(W, q, F, J, he, de) {
    if (!s.isBuffer(W))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (q > he || q < de)
      throw new RangeError('"value" argument is out of bounds');
    if (F + J > W.length)
      throw new RangeError("Index out of range");
  }
  s.prototype.writeUintLE = s.prototype.writeUIntLE = function(q, F, J, he) {
    if (q = +q, F = F >>> 0, J = J >>> 0, !he) {
      const Je = Math.pow(2, 8 * J) - 1;
      ae(this, q, F, J, Je, 0);
    }
    let de = 1, pe = 0;
    for (this[F] = q & 255; ++pe < J && (de *= 256); )
      this[F + pe] = q / de & 255;
    return F + J;
  }, s.prototype.writeUintBE = s.prototype.writeUIntBE = function(q, F, J, he) {
    if (q = +q, F = F >>> 0, J = J >>> 0, !he) {
      const Je = Math.pow(2, 8 * J) - 1;
      ae(this, q, F, J, Je, 0);
    }
    let de = J - 1, pe = 1;
    for (this[F + de] = q & 255; --de >= 0 && (pe *= 256); )
      this[F + de] = q / pe & 255;
    return F + J;
  }, s.prototype.writeUint8 = s.prototype.writeUInt8 = function(q, F, J) {
    return q = +q, F = F >>> 0, J || ae(this, q, F, 1, 255, 0), this[F] = q & 255, F + 1;
  }, s.prototype.writeUint16LE = s.prototype.writeUInt16LE = function(q, F, J) {
    return q = +q, F = F >>> 0, J || ae(this, q, F, 2, 65535, 0), this[F] = q & 255, this[F + 1] = q >>> 8, F + 2;
  }, s.prototype.writeUint16BE = s.prototype.writeUInt16BE = function(q, F, J) {
    return q = +q, F = F >>> 0, J || ae(this, q, F, 2, 65535, 0), this[F] = q >>> 8, this[F + 1] = q & 255, F + 2;
  }, s.prototype.writeUint32LE = s.prototype.writeUInt32LE = function(q, F, J) {
    return q = +q, F = F >>> 0, J || ae(this, q, F, 4, 4294967295, 0), this[F + 3] = q >>> 24, this[F + 2] = q >>> 16, this[F + 1] = q >>> 8, this[F] = q & 255, F + 4;
  }, s.prototype.writeUint32BE = s.prototype.writeUInt32BE = function(q, F, J) {
    return q = +q, F = F >>> 0, J || ae(this, q, F, 4, 4294967295, 0), this[F] = q >>> 24, this[F + 1] = q >>> 16, this[F + 2] = q >>> 8, this[F + 3] = q & 255, F + 4;
  };
  function Z(W, q, F, J, he) {
    Oe(q, J, he, W, F, 7);
    let de = Number(q & BigInt(4294967295));
    W[F++] = de, de = de >> 8, W[F++] = de, de = de >> 8, W[F++] = de, de = de >> 8, W[F++] = de;
    let pe = Number(q >> BigInt(32) & BigInt(4294967295));
    return W[F++] = pe, pe = pe >> 8, W[F++] = pe, pe = pe >> 8, W[F++] = pe, pe = pe >> 8, W[F++] = pe, F;
  }
  function ne(W, q, F, J, he) {
    Oe(q, J, he, W, F, 7);
    let de = Number(q & BigInt(4294967295));
    W[F + 7] = de, de = de >> 8, W[F + 6] = de, de = de >> 8, W[F + 5] = de, de = de >> 8, W[F + 4] = de;
    let pe = Number(q >> BigInt(32) & BigInt(4294967295));
    return W[F + 3] = pe, pe = pe >> 8, W[F + 2] = pe, pe = pe >> 8, W[F + 1] = pe, pe = pe >> 8, W[F] = pe, F + 8;
  }
  s.prototype.writeBigUInt64LE = st(function(q, F = 0) {
    return Z(this, q, F, BigInt(0), BigInt("0xffffffffffffffff"));
  }), s.prototype.writeBigUInt64BE = st(function(q, F = 0) {
    return ne(this, q, F, BigInt(0), BigInt("0xffffffffffffffff"));
  }), s.prototype.writeIntLE = function(q, F, J, he) {
    if (q = +q, F = F >>> 0, !he) {
      const tt = Math.pow(2, 8 * J - 1);
      ae(this, q, F, J, tt - 1, -tt);
    }
    let de = 0, pe = 1, Je = 0;
    for (this[F] = q & 255; ++de < J && (pe *= 256); )
      q < 0 && Je === 0 && this[F + de - 1] !== 0 && (Je = 1), this[F + de] = (q / pe >> 0) - Je & 255;
    return F + J;
  }, s.prototype.writeIntBE = function(q, F, J, he) {
    if (q = +q, F = F >>> 0, !he) {
      const tt = Math.pow(2, 8 * J - 1);
      ae(this, q, F, J, tt - 1, -tt);
    }
    let de = J - 1, pe = 1, Je = 0;
    for (this[F + de] = q & 255; --de >= 0 && (pe *= 256); )
      q < 0 && Je === 0 && this[F + de + 1] !== 0 && (Je = 1), this[F + de] = (q / pe >> 0) - Je & 255;
    return F + J;
  }, s.prototype.writeInt8 = function(q, F, J) {
    return q = +q, F = F >>> 0, J || ae(this, q, F, 1, 127, -128), q < 0 && (q = 255 + q + 1), this[F] = q & 255, F + 1;
  }, s.prototype.writeInt16LE = function(q, F, J) {
    return q = +q, F = F >>> 0, J || ae(this, q, F, 2, 32767, -32768), this[F] = q & 255, this[F + 1] = q >>> 8, F + 2;
  }, s.prototype.writeInt16BE = function(q, F, J) {
    return q = +q, F = F >>> 0, J || ae(this, q, F, 2, 32767, -32768), this[F] = q >>> 8, this[F + 1] = q & 255, F + 2;
  }, s.prototype.writeInt32LE = function(q, F, J) {
    return q = +q, F = F >>> 0, J || ae(this, q, F, 4, 2147483647, -2147483648), this[F] = q & 255, this[F + 1] = q >>> 8, this[F + 2] = q >>> 16, this[F + 3] = q >>> 24, F + 4;
  }, s.prototype.writeInt32BE = function(q, F, J) {
    return q = +q, F = F >>> 0, J || ae(this, q, F, 4, 2147483647, -2147483648), q < 0 && (q = 4294967295 + q + 1), this[F] = q >>> 24, this[F + 1] = q >>> 16, this[F + 2] = q >>> 8, this[F + 3] = q & 255, F + 4;
  }, s.prototype.writeBigInt64LE = st(function(q, F = 0) {
    return Z(this, q, F, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), s.prototype.writeBigInt64BE = st(function(q, F = 0) {
    return ne(this, q, F, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function fe(W, q, F, J, he, de) {
    if (F + J > W.length)
      throw new RangeError("Index out of range");
    if (F < 0)
      throw new RangeError("Index out of range");
  }
  function le(W, q, F, J, he) {
    return q = +q, F = F >>> 0, he || fe(W, q, F, 4), t.write(W, q, F, J, 23, 4), F + 4;
  }
  s.prototype.writeFloatLE = function(q, F, J) {
    return le(this, q, F, !0, J);
  }, s.prototype.writeFloatBE = function(q, F, J) {
    return le(this, q, F, !1, J);
  };
  function ke(W, q, F, J, he) {
    return q = +q, F = F >>> 0, he || fe(W, q, F, 8), t.write(W, q, F, J, 52, 8), F + 8;
  }
  s.prototype.writeDoubleLE = function(q, F, J) {
    return ke(this, q, F, !0, J);
  }, s.prototype.writeDoubleBE = function(q, F, J) {
    return ke(this, q, F, !1, J);
  }, s.prototype.copy = function(q, F, J, he) {
    if (!s.isBuffer(q))
      throw new TypeError("argument should be a Buffer");
    if (J || (J = 0), !he && he !== 0 && (he = this.length), F >= q.length && (F = q.length), F || (F = 0), he > 0 && he < J && (he = J), he === J || q.length === 0 || this.length === 0)
      return 0;
    if (F < 0)
      throw new RangeError("targetStart out of bounds");
    if (J < 0 || J >= this.length)
      throw new RangeError("Index out of range");
    if (he < 0)
      throw new RangeError("sourceEnd out of bounds");
    he > this.length && (he = this.length), q.length - F < he - J && (he = q.length - F + J);
    const de = he - J;
    return this === q && typeof i.prototype.copyWithin == "function" ? this.copyWithin(F, J, he) : i.prototype.set.call(
      q,
      this.subarray(J, he),
      F
    ), de;
  }, s.prototype.fill = function(q, F, J, he) {
    if (typeof q == "string") {
      if (typeof F == "string" ? (he = F, F = 0, J = this.length) : typeof J == "string" && (he = J, J = this.length), he !== void 0 && typeof he != "string")
        throw new TypeError("encoding must be a string");
      if (typeof he == "string" && !s.isEncoding(he))
        throw new TypeError("Unknown encoding: " + he);
      if (q.length === 1) {
        const pe = q.charCodeAt(0);
        (he === "utf8" && pe < 128 || he === "latin1") && (q = pe);
      }
    } else
      typeof q == "number" ? q = q & 255 : typeof q == "boolean" && (q = Number(q));
    if (F < 0 || this.length < F || this.length < J)
      throw new RangeError("Out of range index");
    if (J <= F)
      return this;
    F = F >>> 0, J = J === void 0 ? this.length : J >>> 0, q || (q = 0);
    let de;
    if (typeof q == "number")
      for (de = F; de < J; ++de)
        this[de] = q;
    else {
      const pe = s.isBuffer(q) ? q : s.from(q, he), Je = pe.length;
      if (Je === 0)
        throw new TypeError('The value "' + q + '" is invalid for argument "value"');
      for (de = 0; de < J - F; ++de)
        this[de + F] = pe[de % Je];
    }
    return this;
  };
  const X = {};
  function G(W, q, F) {
    X[W] = class extends F {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: q.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${W}]`, this.stack, delete this.name;
      }
      get code() {
        return W;
      }
      set code(he) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: he,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${W}]: ${this.message}`;
      }
    };
  }
  G(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(W) {
      return W ? `${W} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), G(
    "ERR_INVALID_ARG_TYPE",
    function(W, q) {
      return `The "${W}" argument must be of type number. Received type ${typeof q}`;
    },
    TypeError
  ), G(
    "ERR_OUT_OF_RANGE",
    function(W, q, F) {
      let J = `The value of "${W}" is out of range.`, he = F;
      return Number.isInteger(F) && Math.abs(F) > ar(2, 32) ? he = we(String(F)) : typeof F == "bigint" && (he = String(F), (F > ar(BigInt(2), BigInt(32)) || F < -ar(BigInt(2), BigInt(32))) && (he = we(he)), he += "n"), J += ` It must be ${q}. Received ${he}`, J;
    },
    RangeError
  );
  function we(W) {
    let q = "", F = W.length;
    const J = W[0] === "-" ? 1 : 0;
    for (; F >= J + 4; F -= 3)
      q = `_${W.slice(F - 3, F)}${q}`;
    return `${W.slice(0, F)}${q}`;
  }
  function Ae(W, q, F) {
    qe(q, "offset"), (W[q] === void 0 || W[q + F] === void 0) && Ue(q, W.length - (F + 1));
  }
  function Oe(W, q, F, J, he, de) {
    if (W > F || W < q) {
      const pe = typeof q == "bigint" ? "n" : "";
      let Je;
      throw de > 3 ? q === 0 || q === BigInt(0) ? Je = `>= 0${pe} and < 2${pe} ** ${(de + 1) * 8}${pe}` : Je = `>= -(2${pe} ** ${(de + 1) * 8 - 1}${pe}) and < 2 ** ${(de + 1) * 8 - 1}${pe}` : Je = `>= ${q}${pe} and <= ${F}${pe}`, new X.ERR_OUT_OF_RANGE("value", Je, W);
    }
    Ae(J, he, de);
  }
  function qe(W, q) {
    if (typeof W != "number")
      throw new X.ERR_INVALID_ARG_TYPE(q, "number", W);
  }
  function Ue(W, q, F) {
    throw Math.floor(W) !== W ? (qe(W, F), new X.ERR_OUT_OF_RANGE(F || "offset", "an integer", W)) : q < 0 ? new X.ERR_BUFFER_OUT_OF_BOUNDS() : new X.ERR_OUT_OF_RANGE(
      F || "offset",
      `>= ${F ? 1 : 0} and <= ${q}`,
      W
    );
  }
  const ze = /[^+/0-9A-Za-z-_]/g;
  function ge(W) {
    if (W = W.split("=")[0], W = W.trim().replace(ze, ""), W.length < 2)
      return "";
    for (; W.length % 4 !== 0; )
      W = W + "=";
    return W;
  }
  function ht(W, q) {
    q = q || 1 / 0;
    let F;
    const J = W.length;
    let he = null;
    const de = [];
    for (let pe = 0; pe < J; ++pe) {
      if (F = W.charCodeAt(pe), F > 55295 && F < 57344) {
        if (!he) {
          if (F > 56319) {
            (q -= 3) > -1 && de.push(239, 191, 189);
            continue;
          } else if (pe + 1 === J) {
            (q -= 3) > -1 && de.push(239, 191, 189);
            continue;
          }
          he = F;
          continue;
        }
        if (F < 56320) {
          (q -= 3) > -1 && de.push(239, 191, 189), he = F;
          continue;
        }
        F = (he - 55296 << 10 | F - 56320) + 65536;
      } else
        he && (q -= 3) > -1 && de.push(239, 191, 189);
      if (he = null, F < 128) {
        if ((q -= 1) < 0)
          break;
        de.push(F);
      } else if (F < 2048) {
        if ((q -= 2) < 0)
          break;
        de.push(
          F >> 6 | 192,
          F & 63 | 128
        );
      } else if (F < 65536) {
        if ((q -= 3) < 0)
          break;
        de.push(
          F >> 12 | 224,
          F >> 6 & 63 | 128,
          F & 63 | 128
        );
      } else if (F < 1114112) {
        if ((q -= 4) < 0)
          break;
        de.push(
          F >> 18 | 240,
          F >> 12 & 63 | 128,
          F >> 6 & 63 | 128,
          F & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return de;
  }
  function $e(W) {
    const q = [];
    for (let F = 0; F < W.length; ++F)
      q.push(W.charCodeAt(F) & 255);
    return q;
  }
  function Et(W, q) {
    let F, J, he;
    const de = [];
    for (let pe = 0; pe < W.length && !((q -= 2) < 0); ++pe)
      F = W.charCodeAt(pe), J = F >> 8, he = F % 256, de.push(he), de.push(J);
    return de;
  }
  function ot(W) {
    return e.toByteArray(ge(W));
  }
  function Ve(W, q, F, J) {
    let he;
    for (he = 0; he < J && !(he + F >= q.length || he >= W.length); ++he)
      q[he + F] = W[he];
    return he;
  }
  function Mt(W, q) {
    return W instanceof q || W != null && W.constructor != null && W.constructor.name != null && W.constructor.name === q.name;
  }
  function lt(W) {
    return W !== W;
  }
  const Xe = function() {
    const W = "0123456789abcdef", q = new Array(256);
    for (let F = 0; F < 16; ++F) {
      const J = F * 16;
      for (let he = 0; he < 16; ++he)
        q[J + he] = W[F] + W[he];
    }
    return q;
  }();
  function st(W) {
    return typeof BigInt == "undefined" ? gt : W;
  }
  function gt() {
    throw new Error("BigInt not supported");
  }
})(xr);
const Xt = xr.Buffer, Yg = xr.Blob, Xg = xr.BlobOptions, Zg = xr.Buffer, e2 = xr.File, t2 = xr.FileOptions, r2 = xr.INSPECT_MAX_BYTES, n2 = xr.SlowBuffer, i2 = xr.TranscodeEncoding, a2 = xr.atob, o2 = xr.btoa, s2 = xr.constants, f2 = xr.isAscii, u2 = xr.isUtf8, c2 = xr.kMaxLength, h2 = xr.kStringMaxLength, l2 = xr.resolveObjectURL, d2 = xr.transcode, p2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Blob: Yg,
  BlobOptions: Xg,
  Buffer: Zg,
  File: e2,
  FileOptions: t2,
  INSPECT_MAX_BYTES: r2,
  SlowBuffer: n2,
  TranscodeEncoding: i2,
  atob: a2,
  btoa: o2,
  constants: s2,
  default: Xt,
  isAscii: f2,
  isUtf8: u2,
  kMaxLength: c2,
  kStringMaxLength: h2,
  resolveObjectURL: l2,
  transcode: d2
}, Symbol.toStringTag, { value: "Module" }));
class n1 {
  /**
   * Converts the given buffer to a string containing its hexadecimal representation.
   *
   * arr a Uint8Array buffer to convert.
   *
   * options an optional object with the following members:
   *     grouping this number of hex bytes are grouped together with spaces between groups. 0 means no grouping is applied. 0 if unspecified.
   *     rowlength the number of groups which make up a row. When 0, no splitting into rows occurs. 0 if unspecified.
   *     uppercase if true, the output will be in uppercase. true by default.
   *
   * return a hexadecimal string representing the buffer.
   *
   * @param {array|ArrayBuffer|Uint8Array} arr
   * @param {object} options
   * @return {string}
   */
  static toHex(e, t) {
    const n = (c, h) => {
      const s = h ? ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F"] : ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
      return s[Math.floor(c / 16)] + s[c % 16];
    }, a = Object.assign(
      {
        grouping: 0,
        rowlength: 0,
        uppercase: !1
      },
      t || {}
    );
    let i = "", o = 0, u = 0;
    for (let c = 0; c < e.length && (i += n(e[c], a.uppercase), c !== e.length - 1); ++c)
      a.grouping > 0 && ++o === a.grouping && (o = 0, a.rowlength > 0 && ++u === a.rowlength ? (u = 0, i += `
`) : i += " ");
    return i;
  }
  /**
   * Takes a string containing hexadecimal and returns the equivalent as a Uint8Array buffer.
   *
   * str The string to convert. Whitespace is ignored. If an odd number of characters are specified,
   * it will act as if preceeded with a leading 0; that is, "FFF" is equivalent to "0FFF".
   *
   * return a Uint8Array array.
   *
   * @param {string} str
   * @return {Uint8Array}
   */
  static toUint8Array(e) {
    let t = e.toLowerCase().replace(/\s/g, "");
    t.length % 2 === 1 && (t = `0${t}`);
    const n = new Uint8Array(Math.floor(t.length / 2));
    let a = -1;
    for (let i = 0; i < t.length; ++i) {
      const o = t[i], u = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"].indexOf(o);
      if (u === -1)
        throw Error("unexpected character");
      a === -1 ? a = 16 * u : (n[Math.floor(i / 2)] = a + u, a = -1);
    }
    return n;
  }
}
String.prototype.trim || (String.prototype.trim = function() {
  return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
});
String.prototype.toCamelCase || (String.prototype.toCamelCase = function() {
  return this.toLowerCase().replace(/[^a-zA-Z0-9]+(.)/g, (r, e) => e.toUpperCase());
});
String.prototype.toSnakeCase || (String.prototype.toSnakeCase = function() {
  return this.replace(/[A-Z]/g, (r) => `_${r.toLowerCase()}`);
});
function ho(r, e) {
  const t = Math.ceil(r.length / e), n = [];
  for (let a = 0, i = 0; a < t; ++a, i += e)
    n[a] = r.substr(i, e);
  return n;
}
function jc(r = 256, e = "abcdef0123456789") {
  let t = new Uint8Array(r);
  return t = crypto.getRandomValues(t), t = t.map((n) => e.charCodeAt(n % e.length)), String.fromCharCode.apply(null, t);
}
function v2(r, e, t, n, a) {
  if (n = n || "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz~`!@#$%^&*()-_=+[{]}\\|;:'\",<.>/?", a = a || n, e > n.length || t > a.length)
    return console.warn("Strings::charsetBaseConvert() - Can't convert", r, "to base", t, "greater than symbol table length. src-table:", n.length, "dest-table:", a.length), !1;
  let o = BigInt(0);
  for (let c = 0; c < r.length; c++)
    o = o * BigInt(e) + BigInt(n.indexOf(r.charAt(c)));
  let u = "";
  for (; o > 0; ) {
    const c = o % BigInt(t);
    u = a.charAt(Number(c)) + u, o /= BigInt(t);
  }
  return u || "0";
}
function Ex(r) {
  return n1.toHex(r, {});
}
function Mx(r) {
  return n1.toUint8Array(r);
}
function y2(r) {
  return Xt.from(r, "hex").toString("base64");
}
function b2(r) {
  return Xt.from(r, "base64").toString("hex");
}
function m2(r) {
  return /^[A-F0-9]+$/i.test(r);
}
function g2(r) {
  return (typeof r == "number" || typeof r == "string" && r.trim() !== "") && !isNaN(r);
}
let lo = class {
  /**
   * Normalizes the meta array into the standard {key: ..., value: ...} format
   *
   * @param {array|object} meta
   * @return {array}
   */
  static normalizeMeta(e) {
    const t = [];
    for (const n in e)
      e.hasOwnProperty(n) && e[n] !== null && t.push({
        key: n,
        value: e[n].toString()
      });
    return t;
  }
  /**
   * Condenses metadata array into object-based key: value notation
   *
   * @param {array|object} meta
   * @return {object}
   */
  static aggregateMeta(e) {
    let t = {};
    if (Array.isArray(e))
      for (const n of e)
        t[n.key] = n.value;
    else
      t = e;
    return t;
  }
};
function i1(r, e) {
  let t, n, a;
  const i = [Array, Date, Number, String, Boolean], o = Object.prototype.toString;
  for (e = e || [], t = 0; t < e.length; t += 2)
    r === e[t] && (n = e[t + 1]);
  if (!n && r && typeof r == "object") {
    for (n = {}, t = 0; t < i.length; t++)
      o.call(r) === o.call(
        //   comparing Object.prototype.toString's of our object
        a = new i[t](r)
      ) && (n = t ? a : []);
    e.push(r, n);
    for (t in r)
      e.hasOwnProperty.call(r, t) && (n[t] = i1(r[t], e));
  }
  return n || r;
}
function w2(...r) {
  return [].concat(...r.map((e, t) => {
    const n = r.slice(0);
    n.splice(t, 1);
    const a = [...new Set([].concat(...n))];
    return e.filter((i) => !a.includes(i));
  }));
}
function Li(...r) {
  return r.reduce((e, t) => e.filter((n) => t.includes(n)));
}
class Hc {
  /**
   *
   * @param policy
   * @param metaKeys
   */
  constructor(e = {}, t = {}) {
    this.policy = Hc.normalizePolicy(e), this.fillDefault(t);
  }
  /**
   *
   * @param policy
   * @returns {{}}
   */
  static normalizePolicy(e = {}) {
    const t = {};
    for (const [n, a] of Object.entries(e))
      if (a !== null && ["read", "write"].includes(n)) {
        t[n] = {};
        for (const [i, o] of Object.entries(a))
          t[n][i] = o;
      }
    return t;
  }
  /**
   *
   */
  fillDefault(e = {}) {
    const t = Array.from(this.policy).filter((a) => a.action === "read"), n = Array.from(this.policy).filter((a) => a.action === "write");
    for (const [a, i] of Object.entries({
      read: t,
      write: n
    })) {
      const o = i.map((u) => u.key);
      this.policy[a] || (this.policy[a] = {});
      for (const u of w2(e, o))
        this.policy[a][u] || (this.policy[a][u] = a === "write" && !["characters", "pubkey"].includes(u) ? ["self"] : ["all"]);
    }
  }
  /**
   *
   * @returns {{}|*}
   */
  get() {
    return this.policy;
  }
  /**
   *
   * @returns {string}
   */
  toJson() {
    return JSON.stringify(this.get());
  }
}
class Yr {
  /**
   *
   * @param meta
   */
  constructor(e = {}) {
    this.meta = e;
  }
  /**
   *
   * @param meta
   * @returns {AtomMeta}
   */
  merge(e) {
    return this.meta = Object.assign(this.meta, e), this;
  }
  /**
   *
   * @param context
   * @returns {AtomMeta}
   */
  addContext(e = null) {
    return this;
  }
  /**
   *
   * @param {Wallet} wallet
   * @returns {AtomMeta}
   */
  setAtomWallet(e) {
    const t = {
      pubkey: e.pubkey,
      characters: e.characters
    };
    return e.tokenUnits && e.tokenUnits.length && (t.tokenUnits = JSON.stringify(e.getTokenUnitsData())), e.tradeRates && e.tradeRates.length && (t.tradeRates = JSON.stringify(e.tradeRates)), this.merge(t), this;
  }
  /**
   * Set full NEW wallet metadata
   * Used for shadow wallet claim & wallet creation & token creation
   *
   * @param {Wallet} wallet
   * @returns {AtomMeta}
   */
  setMetaWallet(e) {
    return this.merge({
      walletTokenSlug: e.token,
      walletBundleHash: e.bundle,
      walletAddress: e.address,
      walletPosition: e.position,
      walletBatchId: e.batchId,
      walletPubkey: e.pubkey,
      walletCharacters: e.characters
    }), this;
  }
  /**
   *
   * @param shadowWalletClaim
   * @returns {AtomMeta}
   */
  setShadowWalletClaim(e) {
    return this.merge({ shadowWalletClaim: e * 1 }), this;
  }
  /**
   *
   * @param {Wallet} signingWallet
   * @returns {AtomMeta}
   */
  setSigningWallet(e) {
    return this.merge({
      signingWallet: JSON.stringify({
        tokenSlug: e.token,
        bundleHash: e.bundle,
        address: e.address,
        position: e.position,
        pubkey: e.pubkey,
        characters: e.characters
      })
    }), this;
  }
  /**
   *
   * @param policy
   * @todo move logic to the separated class
   * @returns {AtomMeta}
   */
  addPolicy(e) {
    const t = new Hc(e, Object.keys(this.meta));
    return this.merge({
      policy: t.toJson()
    }), this;
  }
  /**
   *
   * @returns {*}
   */
  get() {
    return this.meta;
  }
}
class sr extends TypeError {
  /**
   * @param {string|null} message
   * @param {string|null} fileName
   * @param {number|null} lineNumber
   */
  constructor(e = null, t = null, n = null) {
    if (super(e, t, n), e === null)
      throw new this(`Unknown ${this.constructor.name}`);
    this.name = "BaseException";
  }
  /**
   * @return {string}
   */
  toString() {
    return `${this.name}: ${this.message}.
Stack:
${this.stack}`;
  }
}
class ri extends sr {
  /**
   * Class constructor
   *
   * @param {string} message
   * @param {string|null} fileName
   * @param {number|null} lineNumber
   */
  constructor(e = "The molecule does not contain atoms", t = null, n = null) {
    super(e, t, n), this.name = "AtomsMissingException";
  }
}
class Xn {
  /**
   *
   * @param {Atom} atom
   */
  static create(e) {
    const t = {};
    for (const n of Object.keys(e))
      e.hasOwnProperty(n) && (t[n] = e[n]);
    return new this(t);
  }
  /**
   *
   * @param {Object|Array} object
   * @returns {Object|Array[]}
   */
  static structure(e) {
    switch (Object.prototype.toString.call(e)) {
      case "[object Array]": {
        const t = [];
        for (const n in e)
          t.push(Xn.isStructure(e[n]) ? Xn.structure(e[n]) : e[n]);
        return t;
      }
      case "[object Object]": {
        const t = [], n = Object.keys(e).sort((a, i) => a === i ? 0 : a < i ? -1 : 1);
        for (const a of n)
          if (e.hasOwnProperty(a)) {
            const i = {};
            i[a] = Xn.isStructure(e[a]) ? Xn.structure(e[a]) : e[a], t.push(i);
          }
        if (t.length > 0)
          return t;
        break;
      }
    }
    return e;
  }
  /**
   *
   * @param {*} structure
   * @returns {boolean}
   */
  static isStructure(e) {
    return ["[object Object]", "[object Array]"].includes(Object.prototype.toString.call(e));
  }
  /**
   *
   * @returns {Object[]}
   */
  view() {
    return Xn.structure(this);
  }
}
class _2 extends Xn {
  constructor({
    position: e = null,
    walletAddress: t = null,
    isotope: n = null,
    token: a = null,
    value: i = null,
    batchId: o = null,
    metaType: u = null,
    metaId: c = null,
    meta: h = null,
    index: s = null,
    createdAt: d = null,
    version: l = null
  }) {
    super(), this.position = e, this.walletAddress = t, this.isotope = n, this.token = a, this.value = i, this.batchId = o, this.metaType = u, this.metaId = c, this.meta = h, this.index = s, this.createdAt = d, this.version = l;
  }
}
const Ja = {
  4: _2
};
class Ut {
  /**
   * Class constructor
   *
   * @param {string|null} position
   * @param {string|null} walletAddress
   * @param {string|null} isotope
   * @param {string|null} token
   * @param {string|number|null} value
   * @param {string|null} batchId
   * @param {string|null} metaType
   * @param {string|null} metaId
   * @param {array|object|null} meta
   * @param {string|null} otsFragment
   * @param {number|null} index
   * @param {string|null} version
   */
  constructor({
    position: e = null,
    walletAddress: t = null,
    isotope: n = null,
    token: a = null,
    value: i = null,
    batchId: o = null,
    metaType: u = null,
    metaId: c = null,
    meta: h = null,
    otsFragment: s = null,
    index: d = null,
    version: l = null
  }) {
    this.position = e, this.walletAddress = t, this.isotope = n, this.token = a, this.value = i !== null ? String(i) : null, this.batchId = o, this.metaType = u, this.metaId = c, this.meta = h ? lo.normalizeMeta(h) : [], this.index = d, this.otsFragment = s, this.createdAt = String(+/* @__PURE__ */ new Date()), l !== null && Ja.hasOwnProperty(l) && (this.version = String(l));
  }
  /**
   *
   * @returns {string[]}
   */
  static getHashableProps() {
    return [
      "position",
      "walletAddress",
      "isotope",
      "token",
      "value",
      "batchId",
      "metaType",
      "metaId",
      "meta",
      "createdAt"
    ];
  }
  /**
   *
   * @returns {string[]}
   */
  static getUnclaimedProps() {
    return [
      "otsFragment"
    ];
  }
  /**
   *
   * @param {string} isotope
   * @param {Wallet|null} wallet
   * @param {int|null} value
   * @param {string|null} metaType
   * @param {string|null} metaId
   * @param {array|object|null} meta
   * @param {string|null} batchId
   * @returns {Atom}
   */
  static create({
    isotope: e,
    wallet: t = null,
    value: n = null,
    metaType: a = null,
    metaId: i = null,
    meta: o = null,
    batchId: u = null
  }) {
    return o || (o = new Yr()), t && (o.setAtomWallet(t), u || (u = t.batchId)), new Ut({
      position: t ? t.position : null,
      walletAddress: t ? t.address : null,
      isotope: e,
      token: t ? t.token : null,
      value: n,
      batchId: u,
      metaType: a,
      metaId: i,
      meta: o.get()
    });
  }
  /**
   * Converts a compliant JSON string into an Atom class instance
   *
   * @param {string} json
   * @return {object}
   */
  static jsonToObject(e) {
    const t = Object.assign(new Ut({}), JSON.parse(e)), n = Object.keys(new Ut({}));
    for (const a in t)
      t.hasOwnProperty(a) && !n.includes(a) && delete t[a];
    return t;
  }
  /**
   * Produces a hash of the atoms inside a molecule.
   * Used to generate the molecularHash field for Molecules.
   *
   * @param {array} atoms
   * @param {string} output
   * @return {number[]|*}
   */
  static hashAtoms({
    atoms: e,
    output: t = "base17"
  }) {
    const n = new Lr("SHAKE256", "TEXT"), a = Ut.sortAtoms(e);
    if (a.length === 0)
      throw new ri();
    if (a.map((i) => {
      if (!(i instanceof Ut))
        throw new ri();
    }), a.every((i) => i.version && Ja.hasOwnProperty(i.version)))
      n.update(JSON.stringify(a.map((i) => Ja[i.version].create(i).view())));
    else {
      const i = String(e.length);
      let o = [];
      for (const u of a)
        o.push(i), o = o.concat(u.getHashableValues());
      for (const u of o)
        n.update(u);
    }
    switch (t) {
      case "hex":
        return n.getHash("HEX", { outputLen: 256 });
      case "array":
        return n.getHash("ARRAYBUFFER", { outputLen: 256 });
      default:
        return v2(n.getHash("HEX", { outputLen: 256 }), 16, 17, "0123456789abcdef", "0123456789abcdefg").padStart(64, "0");
    }
  }
  static jsonSerialization(e, t) {
    if (!Ut.getUnclaimedProps().includes(e))
      return t;
  }
  /**
   * Sort the atoms in a Molecule
   *
   * @param {array} atoms
   * @return {array}
   */
  static sortAtoms(e) {
    const t = [...e];
    return t.sort((n, a) => n.index < a.index ? -1 : 1), t;
  }
  /**
   * Get aggregated meta from stored normalized ones
   */
  aggregatedMeta() {
    return lo.aggregateMeta(this.meta);
  }
  /**
   *
   * @returns {*[]}
   */
  getHashableValues() {
    const e = [];
    for (const t of Ut.getHashableProps()) {
      const n = this[t];
      if (!(n === null && !["position", "walletAddress"].includes(t)))
        if (t === "meta")
          for (const a of n)
            typeof a.value != "undefined" && a.value !== null && (e.push(String(a.key)), e.push(String(a.value)));
        else
          e.push(n === null ? "" : String(n));
    }
    return e;
  }
}
function Yi(r = null, e = 2048) {
  if (console.info(`Crypto::generateSecret() - Computing new secret${r ? " from existing seed" : ""}...`), r) {
    const t = new Lr("SHAKE256", "TEXT");
    return t.update(r), t.getHash("HEX", { outputLen: e * 2 });
  } else
    return jc(e);
}
function Nn(r, e = null) {
  console.info(`Crypto::generateBundleHash(${e ? `source: ${e}` : ""}) - Computing wallet bundle from secret...`);
  const t = new Lr("SHAKE256", "TEXT");
  return t.update(r), t.getHash("HEX", { outputLen: 256 });
}
function po({
  molecularHash: r = null,
  index: e = null
}) {
  return r !== null && e !== null ? Nn(String(r) + String(e), "generateBatchId") : jc(64);
}
class vo {
  /**
   * @param {Buffer|ArrayBuffer|Uint8Array} data
   * @return {string}
   */
  static encode(e) {
    const t = String.fromCharCode(...e);
    return btoa(t);
  }
  /**
   * @param {string} data
   * @return {Buffer|ArrayBuffer|Uint8Array}
   */
  static decode(e) {
    const t = atob(e), n = new Uint8Array(t.length);
    for (let a = 0; a < t.length; a++)
      n[a] = t.charCodeAt(a);
    return n;
  }
  /**
   * @param {Buffer|ArrayBuffer|Uint8Array} data
   * @return {string}
   */
  encode(e) {
    return vo.encode(e);
  }
  /**
   * @param {string} data
   * @return {Buffer|ArrayBuffer|Uint8Array}
   */
  decode(e) {
    return vo.decode(e);
  }
}
var Jt = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
function ki(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
function a1(r) {
  if (r.__esModule)
    return r;
  var e = r.default;
  if (typeof e == "function") {
    var t = function n() {
      return this instanceof n ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else
    t = {};
  return Object.defineProperty(t, "__esModule", { value: !0 }), Object.keys(r).forEach(function(n) {
    var a = Object.getOwnPropertyDescriptor(r, n);
    Object.defineProperty(t, n, a.get ? a : {
      enumerable: !0,
      get: function() {
        return r[n];
      }
    });
  }), t;
}
function x2(r) {
  if (r.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var e = new Uint8Array(256), t = 0; t < e.length; t++)
    e[t] = 255;
  for (var n = 0; n < r.length; n++) {
    var a = r.charAt(n), i = a.charCodeAt(0);
    if (e[i] !== 255)
      throw new TypeError(a + " is ambiguous");
    e[i] = n;
  }
  var o = r.length, u = r.charAt(0), c = Math.log(o) / Math.log(256), h = Math.log(256) / Math.log(o);
  function s(y) {
    if (y instanceof Uint8Array || (ArrayBuffer.isView(y) ? y = new Uint8Array(y.buffer, y.byteOffset, y.byteLength) : Array.isArray(y) && (y = Uint8Array.from(y))), !(y instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (y.length === 0)
      return "";
    for (var m = 0, w = 0, E = 0, S = y.length; E !== S && y[E] === 0; )
      E++, m++;
    for (var P = (S - E) * h + 1 >>> 0, L = new Uint8Array(P); E !== S; ) {
      for (var U = y[E], z = 0, K = P - 1; (U !== 0 || z < w) && K !== -1; K--, z++)
        U += 256 * L[K] >>> 0, L[K] = U % o >>> 0, U = U / o >>> 0;
      if (U !== 0)
        throw new Error("Non-zero carry");
      w = z, E++;
    }
    for (var re = P - w; re !== P && L[re] === 0; )
      re++;
    for (var oe = u.repeat(m); re < P; ++re)
      oe += r.charAt(L[re]);
    return oe;
  }
  function d(y) {
    if (typeof y != "string")
      throw new TypeError("Expected String");
    if (y.length === 0)
      return new Uint8Array();
    for (var m = 0, w = 0, E = 0; y[m] === u; )
      w++, m++;
    for (var S = (y.length - m) * c + 1 >>> 0, P = new Uint8Array(S); y[m]; ) {
      var L = e[y.charCodeAt(m)];
      if (L === 255)
        return;
      for (var U = 0, z = S - 1; (L !== 0 || U < E) && z !== -1; z--, U++)
        L += o * P[z] >>> 0, P[z] = L % 256 >>> 0, L = L / 256 >>> 0;
      if (L !== 0)
        throw new Error("Non-zero carry");
      E = U, m++;
    }
    for (var K = S - E; K !== S && P[K] === 0; )
      K++;
    for (var re = new Uint8Array(w + (S - K)), oe = w; K !== S; )
      re[oe++] = P[K++];
    return re;
  }
  function l(y) {
    var m = d(y);
    if (m)
      return m;
    throw new Error("Non-base" + o + " character");
  }
  return {
    encode: s,
    decodeUnsafe: d,
    decode: l
  };
}
var S2 = x2;
const o1 = /* @__PURE__ */ ki(S2);
class pl {
  /**
   * @param {object} options
   */
  constructor(e = {}) {
    this.$options = Object.assign({ characters: "GMP" }, e), this.$encoder = o1(this[this.$options.characters] || this.GMP);
  }
  /**
   * @return {string}
   * @constructor
   */
  get GMP() {
    return "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuv";
  }
  /**
   * @return {string}
   * @constructor
   */
  get BITCOIN() {
    return "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  }
  /**
   * @return {string}
   * @constructor
   */
  get FLICKR() {
    return "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ";
  }
  /**
   * @return {string}
   * @constructor
   */
  get RIPPLE() {
    return "rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz";
  }
  /**
   * @return {string}
   * @constructor
   */
  get IPFS() {
    return "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  }
  /**
   * @param {Buffer} data
   * @return {string}
   */
  encode(e) {
    return this.$encoder.encode(Xt.from(e));
  }
  /**
   * @param {string} data
   * @return {Buffer}
   */
  decode(e) {
    return this.$encoder.decode(e);
  }
}
class oc {
  /**
   * @param {object} options
   */
  constructor(e = {}) {
    const t = ["BASE2", "BASE8", "BASE11", "BASE36", "BASE62", "BASE67"], n = ["BITCOIN", "FLICKR", "RIPPLE", "IPFS"], a = ["BASE64"];
    this.$options = Object.assign({ characters: "BASE64" }, e), this.$encoder = new pl(), a.includes(this.$options.characters) ? this.$encoder = new vo() : t.includes(this.$options.characters) ? this.$encoder = o1(this[this.$options.characters]) : n.includes(this.$options.characters) && (this.$encoder = new pl(this.$options));
  }
  /**
   * @return {string}
   * @constructor
   */
  get BASE2() {
    return "01";
  }
  /**
   * @return {string}
   * @constructor
   */
  get BASE8() {
    return "01234567";
  }
  /**
   * @return {string}
   * @constructor
   */
  get BASE11() {
    return "0123456789a";
  }
  /**
   * @return {string}
   * @constructor
   */
  get BASE36() {
    return "0123456789abcdefghijklmnopqrstuvwxyz";
  }
  /**
   * @return {string}
   * @constructor
   */
  get BASE62() {
    return "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
  }
  /**
   * @return {string}
   * @constructor
   */
  get BASE67() {
    return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_.!~";
  }
  /**
   * @param {Buffer|ArrayBuffer|Uint8Array} data
   * @return {string}
   */
  encode(e) {
    const t = e instanceof Uint8Array ? e : new Uint8Array(e), n = String.fromCharCode(...t);
    return this.$encoder.encode(n);
  }
  /**
   * @param {string} data
   * @return {Buffer|ArrayBuffer|Uint8Array}
   */
  decode(e) {
    return this.$encoder.decode(e);
  }
}
class xi {
  /**
   *
   * @param id
   * @param name
   * @param metas
   */
  constructor(e, t, n) {
    this.id = e, this.name = t, this.metas = n || {};
  }
  /**
   *
   * @param data
   * @returns {*}
   */
  static createFromGraphQL(e) {
    let t = e.metas || {};
    return t.length && (t = JSON.parse(t), t || (t = {})), new xi(
      e.id,
      e.name,
      t
    );
  }
  /**
   *
   * @param data
   * @returns {TokenUnit}
   */
  static createFromDB(e) {
    return new xi(
      e[0],
      e[1],
      e.length > 2 ? e[2] : {}
    );
  }
  /**
   *
   * @returns {*|null}
   */
  getFragmentZone() {
    return this.metas.fragmentZone || null;
  }
  /**
   *
   * @returns {*|null}
   */
  getFusedTokenUnits() {
    return this.metas.fusedTokenUnits || null;
  }
  /**
   * @return array
   */
  toData() {
    return [this.id, this.name, this.metas];
  }
  /**
   *
   * @returns {{metas: string, name: *, id: *}}
   */
  toGraphQLResponse() {
    return {
      id: this.id,
      name: this.name,
      metas: JSON.stringify(this.metas)
    };
  }
}
function E2(r) {
  throw new Error('Could not dynamically require "' + r + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var s1 = { exports: {} }, Lt = {};
function M2(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
var f1 = { exports: {} }, mr = f1.exports = {}, on, sn;
function sc() {
  throw new Error("setTimeout has not been defined");
}
function fc() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? on = setTimeout : on = sc;
  } catch (r) {
    on = sc;
  }
  try {
    typeof clearTimeout == "function" ? sn = clearTimeout : sn = fc;
  } catch (r) {
    sn = fc;
  }
})();
function u1(r) {
  if (on === setTimeout)
    return setTimeout(r, 0);
  if ((on === sc || !on) && setTimeout)
    return on = setTimeout, setTimeout(r, 0);
  try {
    return on(r, 0);
  } catch (e) {
    try {
      return on.call(null, r, 0);
    } catch (t) {
      return on.call(this, r, 0);
    }
  }
}
function A2(r) {
  if (sn === clearTimeout)
    return clearTimeout(r);
  if ((sn === fc || !sn) && clearTimeout)
    return sn = clearTimeout, clearTimeout(r);
  try {
    return sn(r);
  } catch (e) {
    try {
      return sn.call(null, r);
    } catch (t) {
      return sn.call(this, r);
    }
  }
}
var gn = [], bi = !1, ti, Ya = -1;
function T2() {
  !bi || !ti || (bi = !1, ti.length ? gn = ti.concat(gn) : Ya = -1, gn.length && c1());
}
function c1() {
  if (!bi) {
    var r = u1(T2);
    bi = !0;
    for (var e = gn.length; e; ) {
      for (ti = gn, gn = []; ++Ya < e; )
        ti && ti[Ya].run();
      Ya = -1, e = gn.length;
    }
    ti = null, bi = !1, A2(r);
  }
}
mr.nextTick = function(r) {
  var e = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var t = 1; t < arguments.length; t++)
      e[t - 1] = arguments[t];
  gn.push(new h1(r, e)), gn.length === 1 && !bi && u1(c1);
};
function h1(r, e) {
  this.fun = r, this.array = e;
}
h1.prototype.run = function() {
  this.fun.apply(null, this.array);
};
mr.title = "browser";
mr.browser = !0;
mr.env = {};
mr.argv = [];
mr.version = "";
mr.versions = {};
function En() {
}
mr.on = En;
mr.addListener = En;
mr.once = En;
mr.off = En;
mr.removeListener = En;
mr.removeAllListeners = En;
mr.emit = En;
mr.prependListener = En;
mr.prependOnceListener = En;
mr.listeners = function(r) {
  return [];
};
mr.binding = function(r) {
  throw new Error("process.binding is not supported");
};
mr.cwd = function() {
  return "/";
};
mr.chdir = function(r) {
  throw new Error("process.chdir is not supported");
};
mr.umask = function() {
  return 0;
};
var k2 = f1.exports;
const Bt = /* @__PURE__ */ M2(k2);
var Ra = { exports: {} }, Ca = { exports: {} };
const Mn = /* @__PURE__ */ a1(p2);
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var vl;
function $t() {
  return vl || (vl = 1, function(r, e) {
    var t = Mn, n = t.Buffer;
    function a(o, u) {
      for (var c in o)
        u[c] = o[c];
    }
    n.from && n.alloc && n.allocUnsafe && n.allocUnsafeSlow ? r.exports = t : (a(t, e), e.Buffer = i);
    function i(o, u, c) {
      return n(o, u, c);
    }
    i.prototype = Object.create(n.prototype), a(n, i), i.from = function(o, u, c) {
      if (typeof o == "number")
        throw new TypeError("Argument must not be a number");
      return n(o, u, c);
    }, i.alloc = function(o, u, c) {
      if (typeof o != "number")
        throw new TypeError("Argument must be a number");
      var h = n(o);
      return u !== void 0 ? typeof c == "string" ? h.fill(u, c) : h.fill(u) : h.fill(0), h;
    }, i.allocUnsafe = function(o) {
      if (typeof o != "number")
        throw new TypeError("Argument must be a number");
      return n(o);
    }, i.allocUnsafeSlow = function(o) {
      if (typeof o != "number")
        throw new TypeError("Argument must be a number");
      return t.SlowBuffer(o);
    };
  }(Ca, Ca.exports)), Ca.exports;
}
var yl;
function Ii() {
  if (yl)
    return Ra.exports;
  yl = 1;
  var r = 65536, e = 4294967295;
  function t() {
    throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
  }
  var n = $t().Buffer, a = Jt.crypto || Jt.msCrypto;
  a && a.getRandomValues ? Ra.exports = i : Ra.exports = t;
  function i(o, u) {
    if (o > e)
      throw new RangeError("requested too many random bytes");
    var c = n.allocUnsafe(o);
    if (o > 0)
      if (o > r)
        for (var h = 0; h < o; h += r)
          a.getRandomValues(c.slice(h, h + r));
      else
        a.getRandomValues(c);
    return typeof u == "function" ? Bt.nextTick(function() {
      u(null, c);
    }) : c;
  }
  return Ra.exports;
}
var Oa = { exports: {} }, bl;
function Ft() {
  return bl || (bl = 1, typeof Object.create == "function" ? Oa.exports = function(e, t) {
    t && (e.super_ = t, e.prototype = Object.create(t.prototype, {
      constructor: {
        value: e,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : Oa.exports = function(e, t) {
    if (t) {
      e.super_ = t;
      var n = function() {
      };
      n.prototype = t.prototype, e.prototype = new n(), e.prototype.constructor = e;
    }
  }), Oa.exports;
}
var Ba = { exports: {} }, Pa = { exports: {} }, ml;
function zc() {
  if (ml)
    return Pa.exports;
  ml = 1;
  var r = typeof Reflect == "object" ? Reflect : null, e = r && typeof r.apply == "function" ? r.apply : function(z, K, re) {
    return Function.prototype.apply.call(z, K, re);
  }, t;
  r && typeof r.ownKeys == "function" ? t = r.ownKeys : Object.getOwnPropertySymbols ? t = function(z) {
    return Object.getOwnPropertyNames(z).concat(Object.getOwnPropertySymbols(z));
  } : t = function(z) {
    return Object.getOwnPropertyNames(z);
  };
  function n(U) {
    console && console.warn && console.warn(U);
  }
  var a = Number.isNaN || function(z) {
    return z !== z;
  };
  function i() {
    i.init.call(this);
  }
  Pa.exports = i, Pa.exports.once = S, i.EventEmitter = i, i.prototype._events = void 0, i.prototype._eventsCount = 0, i.prototype._maxListeners = void 0;
  var o = 10;
  function u(U) {
    if (typeof U != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof U);
  }
  Object.defineProperty(i, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
      return o;
    },
    set: function(U) {
      if (typeof U != "number" || U < 0 || a(U))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + U + ".");
      o = U;
    }
  }), i.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, i.prototype.setMaxListeners = function(z) {
    if (typeof z != "number" || z < 0 || a(z))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + z + ".");
    return this._maxListeners = z, this;
  };
  function c(U) {
    return U._maxListeners === void 0 ? i.defaultMaxListeners : U._maxListeners;
  }
  i.prototype.getMaxListeners = function() {
    return c(this);
  }, i.prototype.emit = function(z) {
    for (var K = [], re = 1; re < arguments.length; re++)
      K.push(arguments[re]);
    var oe = z === "error", se = this._events;
    if (se !== void 0)
      oe = oe && se.error === void 0;
    else if (!oe)
      return !1;
    if (oe) {
      var ve;
      if (K.length > 0 && (ve = K[0]), ve instanceof Error)
        throw ve;
      var Q = new Error("Unhandled error." + (ve ? " (" + ve.message + ")" : ""));
      throw Q.context = ve, Q;
    }
    var A = se[z];
    if (A === void 0)
      return !1;
    if (typeof A == "function")
      e(A, this, K);
    else
      for (var b = A.length, f = m(A, b), re = 0; re < b; ++re)
        e(f[re], this, K);
    return !0;
  };
  function h(U, z, K, re) {
    var oe, se, ve;
    if (u(K), se = U._events, se === void 0 ? (se = U._events = /* @__PURE__ */ Object.create(null), U._eventsCount = 0) : (se.newListener !== void 0 && (U.emit(
      "newListener",
      z,
      K.listener ? K.listener : K
    ), se = U._events), ve = se[z]), ve === void 0)
      ve = se[z] = K, ++U._eventsCount;
    else if (typeof ve == "function" ? ve = se[z] = re ? [K, ve] : [ve, K] : re ? ve.unshift(K) : ve.push(K), oe = c(U), oe > 0 && ve.length > oe && !ve.warned) {
      ve.warned = !0;
      var Q = new Error("Possible EventEmitter memory leak detected. " + ve.length + " " + String(z) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      Q.name = "MaxListenersExceededWarning", Q.emitter = U, Q.type = z, Q.count = ve.length, n(Q);
    }
    return U;
  }
  i.prototype.addListener = function(z, K) {
    return h(this, z, K, !1);
  }, i.prototype.on = i.prototype.addListener, i.prototype.prependListener = function(z, K) {
    return h(this, z, K, !0);
  };
  function s() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function d(U, z, K) {
    var re = { fired: !1, wrapFn: void 0, target: U, type: z, listener: K }, oe = s.bind(re);
    return oe.listener = K, re.wrapFn = oe, oe;
  }
  i.prototype.once = function(z, K) {
    return u(K), this.on(z, d(this, z, K)), this;
  }, i.prototype.prependOnceListener = function(z, K) {
    return u(K), this.prependListener(z, d(this, z, K)), this;
  }, i.prototype.removeListener = function(z, K) {
    var re, oe, se, ve, Q;
    if (u(K), oe = this._events, oe === void 0)
      return this;
    if (re = oe[z], re === void 0)
      return this;
    if (re === K || re.listener === K)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete oe[z], oe.removeListener && this.emit("removeListener", z, re.listener || K));
    else if (typeof re != "function") {
      for (se = -1, ve = re.length - 1; ve >= 0; ve--)
        if (re[ve] === K || re[ve].listener === K) {
          Q = re[ve].listener, se = ve;
          break;
        }
      if (se < 0)
        return this;
      se === 0 ? re.shift() : w(re, se), re.length === 1 && (oe[z] = re[0]), oe.removeListener !== void 0 && this.emit("removeListener", z, Q || K);
    }
    return this;
  }, i.prototype.off = i.prototype.removeListener, i.prototype.removeAllListeners = function(z) {
    var K, re, oe;
    if (re = this._events, re === void 0)
      return this;
    if (re.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : re[z] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete re[z]), this;
    if (arguments.length === 0) {
      var se = Object.keys(re), ve;
      for (oe = 0; oe < se.length; ++oe)
        ve = se[oe], ve !== "removeListener" && this.removeAllListeners(ve);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (K = re[z], typeof K == "function")
      this.removeListener(z, K);
    else if (K !== void 0)
      for (oe = K.length - 1; oe >= 0; oe--)
        this.removeListener(z, K[oe]);
    return this;
  };
  function l(U, z, K) {
    var re = U._events;
    if (re === void 0)
      return [];
    var oe = re[z];
    return oe === void 0 ? [] : typeof oe == "function" ? K ? [oe.listener || oe] : [oe] : K ? E(oe) : m(oe, oe.length);
  }
  i.prototype.listeners = function(z) {
    return l(this, z, !0);
  }, i.prototype.rawListeners = function(z) {
    return l(this, z, !1);
  }, i.listenerCount = function(U, z) {
    return typeof U.listenerCount == "function" ? U.listenerCount(z) : y.call(U, z);
  }, i.prototype.listenerCount = y;
  function y(U) {
    var z = this._events;
    if (z !== void 0) {
      var K = z[U];
      if (typeof K == "function")
        return 1;
      if (K !== void 0)
        return K.length;
    }
    return 0;
  }
  i.prototype.eventNames = function() {
    return this._eventsCount > 0 ? t(this._events) : [];
  };
  function m(U, z) {
    for (var K = new Array(z), re = 0; re < z; ++re)
      K[re] = U[re];
    return K;
  }
  function w(U, z) {
    for (; z + 1 < U.length; z++)
      U[z] = U[z + 1];
    U.pop();
  }
  function E(U) {
    for (var z = new Array(U.length), K = 0; K < z.length; ++K)
      z[K] = U[K].listener || U[K];
    return z;
  }
  function S(U, z) {
    return new Promise(function(K, re) {
      function oe(ve) {
        U.removeListener(z, se), re(ve);
      }
      function se() {
        typeof U.removeListener == "function" && U.removeListener("error", oe), K([].slice.call(arguments));
      }
      L(U, z, se, { once: !0 }), z !== "error" && P(U, oe, { once: !0 });
    });
  }
  function P(U, z, K) {
    typeof U.on == "function" && L(U, "error", z, K);
  }
  function L(U, z, K, re) {
    if (typeof U.on == "function")
      re.once ? U.once(z, K) : U.on(z, K);
    else if (typeof U.addEventListener == "function")
      U.addEventListener(z, function oe(se) {
        re.once && U.removeEventListener(z, oe), K(se);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof U);
  }
  return Pa.exports;
}
var Xo, gl;
function l1() {
  return gl || (gl = 1, Xo = zc().EventEmitter), Xo;
}
var Zo = {}, es = {}, ts, wl;
function d1() {
  return wl || (wl = 1, ts = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return !1;
    if (typeof Symbol.iterator == "symbol")
      return !0;
    var e = {}, t = Symbol("test"), n = Object(t);
    if (typeof t == "string" || Object.prototype.toString.call(t) !== "[object Symbol]" || Object.prototype.toString.call(n) !== "[object Symbol]")
      return !1;
    var a = 42;
    e[t] = a;
    for (t in e)
      return !1;
    if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0)
      return !1;
    var i = Object.getOwnPropertySymbols(e);
    if (i.length !== 1 || i[0] !== t || !Object.prototype.propertyIsEnumerable.call(e, t))
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var o = Object.getOwnPropertyDescriptor(e, t);
      if (o.value !== a || o.enumerable !== !0)
        return !1;
    }
    return !0;
  }), ts;
}
var rs, _l;
function Vc() {
  if (_l)
    return rs;
  _l = 1;
  var r = d1();
  return rs = function() {
    return r() && !!Symbol.toStringTag;
  }, rs;
}
var ns, xl;
function I2() {
  return xl || (xl = 1, ns = Error), ns;
}
var is, Sl;
function R2() {
  return Sl || (Sl = 1, is = EvalError), is;
}
var as, El;
function C2() {
  return El || (El = 1, as = RangeError), as;
}
var os, Ml;
function O2() {
  return Ml || (Ml = 1, os = ReferenceError), os;
}
var ss, Al;
function p1() {
  return Al || (Al = 1, ss = SyntaxError), ss;
}
var fs, Tl;
function Eo() {
  return Tl || (Tl = 1, fs = TypeError), fs;
}
var us, kl;
function B2() {
  return kl || (kl = 1, us = URIError), us;
}
var cs, Il;
function P2() {
  if (Il)
    return cs;
  Il = 1;
  var r = typeof Symbol != "undefined" && Symbol, e = d1();
  return cs = function() {
    return typeof r != "function" || typeof Symbol != "function" || typeof r("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : e();
  }, cs;
}
var hs, Rl;
function D2() {
  if (Rl)
    return hs;
  Rl = 1;
  var r = {
    __proto__: null,
    foo: {}
  }, e = Object;
  return hs = function() {
    return { __proto__: r }.foo === r.foo && !(r instanceof e);
  }, hs;
}
var ls, Cl;
function N2() {
  if (Cl)
    return ls;
  Cl = 1;
  var r = "Function.prototype.bind called on incompatible ", e = Object.prototype.toString, t = Math.max, n = "[object Function]", a = function(c, h) {
    for (var s = [], d = 0; d < c.length; d += 1)
      s[d] = c[d];
    for (var l = 0; l < h.length; l += 1)
      s[l + c.length] = h[l];
    return s;
  }, i = function(c, h) {
    for (var s = [], d = h || 0, l = 0; d < c.length; d += 1, l += 1)
      s[l] = c[d];
    return s;
  }, o = function(u, c) {
    for (var h = "", s = 0; s < u.length; s += 1)
      h += u[s], s + 1 < u.length && (h += c);
    return h;
  };
  return ls = function(c) {
    var h = this;
    if (typeof h != "function" || e.apply(h) !== n)
      throw new TypeError(r + h);
    for (var s = i(arguments, 1), d, l = function() {
      if (this instanceof d) {
        var S = h.apply(
          this,
          a(s, arguments)
        );
        return Object(S) === S ? S : this;
      }
      return h.apply(
        c,
        a(s, arguments)
      );
    }, y = t(0, h.length - s.length), m = [], w = 0; w < y; w++)
      m[w] = "$" + w;
    if (d = Function("binder", "return function (" + o(m, ",") + "){ return binder.apply(this,arguments); }")(l), h.prototype) {
      var E = function() {
      };
      E.prototype = h.prototype, d.prototype = new E(), E.prototype = null;
    }
    return d;
  }, ls;
}
var ds, Ol;
function Wc() {
  if (Ol)
    return ds;
  Ol = 1;
  var r = N2();
  return ds = Function.prototype.bind || r, ds;
}
var ps, Bl;
function q2() {
  if (Bl)
    return ps;
  Bl = 1;
  var r = Function.prototype.call, e = Object.prototype.hasOwnProperty, t = Wc();
  return ps = t.call(r, e), ps;
}
var vs, Pl;
function ba() {
  if (Pl)
    return vs;
  Pl = 1;
  var r, e = I2(), t = R2(), n = C2(), a = O2(), i = p1(), o = Eo(), u = B2(), c = Function, h = function(M) {
    try {
      return c('"use strict"; return (' + M + ").constructor;")();
    } catch (I) {
    }
  }, s = Object.getOwnPropertyDescriptor;
  if (s)
    try {
      s({}, "");
    } catch (M) {
      s = null;
    }
  var d = function() {
    throw new o();
  }, l = s ? function() {
    try {
      return arguments.callee, d;
    } catch (M) {
      try {
        return s(arguments, "callee").get;
      } catch (I) {
        return d;
      }
    }
  }() : d, y = P2()(), m = D2()(), w = Object.getPrototypeOf || (m ? function(M) {
    return M.__proto__;
  } : null), E = {}, S = typeof Uint8Array == "undefined" || !w ? r : w(Uint8Array), P = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError == "undefined" ? r : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer == "undefined" ? r : ArrayBuffer,
    "%ArrayIteratorPrototype%": y && w ? w([][Symbol.iterator]()) : r,
    "%AsyncFromSyncIteratorPrototype%": r,
    "%AsyncFunction%": E,
    "%AsyncGenerator%": E,
    "%AsyncGeneratorFunction%": E,
    "%AsyncIteratorPrototype%": E,
    "%Atomics%": typeof Atomics == "undefined" ? r : Atomics,
    "%BigInt%": typeof BigInt == "undefined" ? r : BigInt,
    "%BigInt64Array%": typeof BigInt64Array == "undefined" ? r : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array == "undefined" ? r : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView == "undefined" ? r : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": e,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": t,
    "%Float32Array%": typeof Float32Array == "undefined" ? r : Float32Array,
    "%Float64Array%": typeof Float64Array == "undefined" ? r : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry == "undefined" ? r : FinalizationRegistry,
    "%Function%": c,
    "%GeneratorFunction%": E,
    "%Int8Array%": typeof Int8Array == "undefined" ? r : Int8Array,
    "%Int16Array%": typeof Int16Array == "undefined" ? r : Int16Array,
    "%Int32Array%": typeof Int32Array == "undefined" ? r : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": y && w ? w(w([][Symbol.iterator]())) : r,
    "%JSON%": typeof JSON == "object" ? JSON : r,
    "%Map%": typeof Map == "undefined" ? r : Map,
    "%MapIteratorPrototype%": typeof Map == "undefined" || !y || !w ? r : w((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": Object,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise == "undefined" ? r : Promise,
    "%Proxy%": typeof Proxy == "undefined" ? r : Proxy,
    "%RangeError%": n,
    "%ReferenceError%": a,
    "%Reflect%": typeof Reflect == "undefined" ? r : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set == "undefined" ? r : Set,
    "%SetIteratorPrototype%": typeof Set == "undefined" || !y || !w ? r : w((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer == "undefined" ? r : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": y && w ? w(""[Symbol.iterator]()) : r,
    "%Symbol%": y ? Symbol : r,
    "%SyntaxError%": i,
    "%ThrowTypeError%": l,
    "%TypedArray%": S,
    "%TypeError%": o,
    "%Uint8Array%": typeof Uint8Array == "undefined" ? r : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray == "undefined" ? r : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array == "undefined" ? r : Uint16Array,
    "%Uint32Array%": typeof Uint32Array == "undefined" ? r : Uint32Array,
    "%URIError%": u,
    "%WeakMap%": typeof WeakMap == "undefined" ? r : WeakMap,
    "%WeakRef%": typeof WeakRef == "undefined" ? r : WeakRef,
    "%WeakSet%": typeof WeakSet == "undefined" ? r : WeakSet
  };
  if (w)
    try {
      null.error;
    } catch (M) {
      var L = w(w(M));
      P["%Error.prototype%"] = L;
    }
  var U = function M(I) {
    var R;
    if (I === "%AsyncFunction%")
      R = h("async function () {}");
    else if (I === "%GeneratorFunction%")
      R = h("function* () {}");
    else if (I === "%AsyncGeneratorFunction%")
      R = h("async function* () {}");
    else if (I === "%AsyncGenerator%") {
      var x = M("%AsyncGeneratorFunction%");
      x && (R = x.prototype);
    } else if (I === "%AsyncIteratorPrototype%") {
      var T = M("%AsyncGenerator%");
      T && w && (R = w(T.prototype));
    }
    return P[I] = R, R;
  }, z = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  }, K = Wc(), re = q2(), oe = K.call(Function.call, Array.prototype.concat), se = K.call(Function.apply, Array.prototype.splice), ve = K.call(Function.call, String.prototype.replace), Q = K.call(Function.call, String.prototype.slice), A = K.call(Function.call, RegExp.prototype.exec), b = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, f = /\\(\\)?/g, v = function(I) {
    var R = Q(I, 0, 1), x = Q(I, -1);
    if (R === "%" && x !== "%")
      throw new i("invalid intrinsic syntax, expected closing `%`");
    if (x === "%" && R !== "%")
      throw new i("invalid intrinsic syntax, expected opening `%`");
    var T = [];
    return ve(I, b, function(p, B, ee, ae) {
      T[T.length] = ee ? ve(ae, f, "$1") : B || p;
    }), T;
  }, g = function(I, R) {
    var x = I, T;
    if (re(z, x) && (T = z[x], x = "%" + T[0] + "%"), re(P, x)) {
      var p = P[x];
      if (p === E && (p = U(x)), typeof p == "undefined" && !R)
        throw new o("intrinsic " + I + " exists, but is not available. Please file an issue!");
      return {
        alias: T,
        name: x,
        value: p
      };
    }
    throw new i("intrinsic " + I + " does not exist!");
  };
  return vs = function(I, R) {
    if (typeof I != "string" || I.length === 0)
      throw new o("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof R != "boolean")
      throw new o('"allowMissing" argument must be a boolean');
    if (A(/^%?[^%]*%?$/, I) === null)
      throw new i("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var x = v(I), T = x.length > 0 ? x[0] : "", p = g("%" + T + "%", R), B = p.name, ee = p.value, ae = !1, Z = p.alias;
    Z && (T = Z[0], se(x, oe([0, 1], Z)));
    for (var ne = 1, fe = !0; ne < x.length; ne += 1) {
      var le = x[ne], ke = Q(le, 0, 1), X = Q(le, -1);
      if ((ke === '"' || ke === "'" || ke === "`" || X === '"' || X === "'" || X === "`") && ke !== X)
        throw new i("property names with quotes must have matching quotes");
      if ((le === "constructor" || !fe) && (ae = !0), T += "." + le, B = "%" + T + "%", re(P, B))
        ee = P[B];
      else if (ee != null) {
        if (!(le in ee)) {
          if (!R)
            throw new o("base intrinsic for " + I + " exists, but the property is not available.");
          return;
        }
        if (s && ne + 1 >= x.length) {
          var G = s(ee, le);
          fe = !!G, fe && "get" in G && !("originalValue" in G.get) ? ee = G.get : ee = ee[le];
        } else
          fe = re(ee, le), ee = ee[le];
        fe && !ae && (P[B] = ee);
      }
    }
    return ee;
  }, vs;
}
var ys = { exports: {} }, bs, Dl;
function Kc() {
  if (Dl)
    return bs;
  Dl = 1;
  var r = ba(), e = r("%Object.defineProperty%", !0) || !1;
  if (e)
    try {
      e({}, "a", { value: 1 });
    } catch (t) {
      e = !1;
    }
  return bs = e, bs;
}
var ms, Nl;
function Qc() {
  if (Nl)
    return ms;
  Nl = 1;
  var r = ba(), e = r("%Object.getOwnPropertyDescriptor%", !0);
  if (e)
    try {
      e([], "length");
    } catch (t) {
      e = null;
    }
  return ms = e, ms;
}
var gs, ql;
function L2() {
  if (ql)
    return gs;
  ql = 1;
  var r = Kc(), e = p1(), t = Eo(), n = Qc();
  return gs = function(i, o, u) {
    if (!i || typeof i != "object" && typeof i != "function")
      throw new t("`obj` must be an object or a function`");
    if (typeof o != "string" && typeof o != "symbol")
      throw new t("`property` must be a string or a symbol`");
    if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
      throw new t("`nonEnumerable`, if provided, must be a boolean or null");
    if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
      throw new t("`nonWritable`, if provided, must be a boolean or null");
    if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
      throw new t("`nonConfigurable`, if provided, must be a boolean or null");
    if (arguments.length > 6 && typeof arguments[6] != "boolean")
      throw new t("`loose`, if provided, must be a boolean");
    var c = arguments.length > 3 ? arguments[3] : null, h = arguments.length > 4 ? arguments[4] : null, s = arguments.length > 5 ? arguments[5] : null, d = arguments.length > 6 ? arguments[6] : !1, l = !!n && n(i, o);
    if (r)
      r(i, o, {
        configurable: s === null && l ? l.configurable : !s,
        enumerable: c === null && l ? l.enumerable : !c,
        value: u,
        writable: h === null && l ? l.writable : !h
      });
    else if (d || !c && !h && !s)
      i[o] = u;
    else
      throw new e("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
  }, gs;
}
var ws, Ll;
function F2() {
  if (Ll)
    return ws;
  Ll = 1;
  var r = Kc(), e = function() {
    return !!r;
  };
  return e.hasArrayLengthDefineBug = function() {
    if (!r)
      return null;
    try {
      return r([], "length", { value: 1 }).length !== 1;
    } catch (n) {
      return !0;
    }
  }, ws = e, ws;
}
var _s, Fl;
function U2() {
  if (Fl)
    return _s;
  Fl = 1;
  var r = ba(), e = L2(), t = F2()(), n = Qc(), a = Eo(), i = r("%Math.floor%");
  return _s = function(u, c) {
    if (typeof u != "function")
      throw new a("`fn` is not a function");
    if (typeof c != "number" || c < 0 || c > 4294967295 || i(c) !== c)
      throw new a("`length` must be a positive 32-bit integer");
    var h = arguments.length > 2 && !!arguments[2], s = !0, d = !0;
    if ("length" in u && n) {
      var l = n(u, "length");
      l && !l.configurable && (s = !1), l && !l.writable && (d = !1);
    }
    return (s || d || !h) && (t ? e(
      /** @type {Parameters<define>[0]} */
      u,
      "length",
      c,
      !0,
      !0
    ) : e(
      /** @type {Parameters<define>[0]} */
      u,
      "length",
      c
    )), u;
  }, _s;
}
var Ul;
function v1() {
  return Ul || (Ul = 1, function(r) {
    var e = Wc(), t = ba(), n = U2(), a = Eo(), i = t("%Function.prototype.apply%"), o = t("%Function.prototype.call%"), u = t("%Reflect.apply%", !0) || e.call(o, i), c = Kc(), h = t("%Math.max%");
    r.exports = function(l) {
      if (typeof l != "function")
        throw new a("a function is required");
      var y = u(e, o, arguments);
      return n(
        y,
        1 + h(0, l.length - (arguments.length - 1)),
        !0
      );
    };
    var s = function() {
      return u(e, i, arguments);
    };
    c ? c(r.exports, "apply", { value: s }) : r.exports.apply = s;
  }(ys)), ys.exports;
}
var xs, $l;
function y1() {
  if ($l)
    return xs;
  $l = 1;
  var r = ba(), e = v1(), t = e(r("String.prototype.indexOf"));
  return xs = function(a, i) {
    var o = r(a, !!i);
    return typeof o == "function" && t(a, ".prototype.") > -1 ? e(o) : o;
  }, xs;
}
var Ss, jl;
function $2() {
  if (jl)
    return Ss;
  jl = 1;
  var r = Vc()(), e = y1(), t = e("Object.prototype.toString"), n = function(u) {
    return r && u && typeof u == "object" && Symbol.toStringTag in u ? !1 : t(u) === "[object Arguments]";
  }, a = function(u) {
    return n(u) ? !0 : u !== null && typeof u == "object" && typeof u.length == "number" && u.length >= 0 && t(u) !== "[object Array]" && t(u.callee) === "[object Function]";
  }, i = function() {
    return n(arguments);
  }();
  return n.isLegacyArguments = a, Ss = i ? n : a, Ss;
}
var Es, Hl;
function j2() {
  if (Hl)
    return Es;
  Hl = 1;
  var r = Object.prototype.toString, e = Function.prototype.toString, t = /^\s*(?:function)?\*/, n = Vc()(), a = Object.getPrototypeOf, i = function() {
    if (!n)
      return !1;
    try {
      return Function("return function*() {}")();
    } catch (u) {
    }
  }, o;
  return Es = function(c) {
    if (typeof c != "function")
      return !1;
    if (t.test(e.call(c)))
      return !0;
    if (!n) {
      var h = r.call(c);
      return h === "[object GeneratorFunction]";
    }
    if (!a)
      return !1;
    if (typeof o == "undefined") {
      var s = i();
      o = s ? a(s) : !1;
    }
    return a(c) === o;
  }, Es;
}
var Ms, zl;
function H2() {
  if (zl)
    return Ms;
  zl = 1;
  var r = Function.prototype.toString, e = typeof Reflect == "object" && Reflect !== null && Reflect.apply, t, n;
  if (typeof e == "function" && typeof Object.defineProperty == "function")
    try {
      t = Object.defineProperty({}, "length", {
        get: function() {
          throw n;
        }
      }), n = {}, e(function() {
        throw 42;
      }, null, t);
    } catch (P) {
      P !== n && (e = null);
    }
  else
    e = null;
  var a = /^\s*class\b/, i = function(L) {
    try {
      var U = r.call(L);
      return a.test(U);
    } catch (z) {
      return !1;
    }
  }, o = function(L) {
    try {
      return i(L) ? !1 : (r.call(L), !0);
    } catch (U) {
      return !1;
    }
  }, u = Object.prototype.toString, c = "[object Object]", h = "[object Function]", s = "[object GeneratorFunction]", d = "[object HTMLAllCollection]", l = "[object HTML document.all class]", y = "[object HTMLCollection]", m = typeof Symbol == "function" && !!Symbol.toStringTag, w = !(0 in [,]), E = function() {
    return !1;
  };
  if (typeof document == "object") {
    var S = document.all;
    u.call(S) === u.call(document.all) && (E = function(L) {
      if ((w || !L) && (typeof L == "undefined" || typeof L == "object"))
        try {
          var U = u.call(L);
          return (U === d || U === l || U === y || U === c) && L("") == null;
        } catch (z) {
        }
      return !1;
    });
  }
  return Ms = e ? function(L) {
    if (E(L))
      return !0;
    if (!L || typeof L != "function" && typeof L != "object")
      return !1;
    try {
      e(L, null, t);
    } catch (U) {
      if (U !== n)
        return !1;
    }
    return !i(L) && o(L);
  } : function(L) {
    if (E(L))
      return !0;
    if (!L || typeof L != "function" && typeof L != "object")
      return !1;
    if (m)
      return o(L);
    if (i(L))
      return !1;
    var U = u.call(L);
    return U !== h && U !== s && !/^\[object HTML/.test(U) ? !1 : o(L);
  }, Ms;
}
var As, Vl;
function z2() {
  if (Vl)
    return As;
  Vl = 1;
  var r = H2(), e = Object.prototype.toString, t = Object.prototype.hasOwnProperty, n = function(c, h, s) {
    for (var d = 0, l = c.length; d < l; d++)
      t.call(c, d) && (s == null ? h(c[d], d, c) : h.call(s, c[d], d, c));
  }, a = function(c, h, s) {
    for (var d = 0, l = c.length; d < l; d++)
      s == null ? h(c.charAt(d), d, c) : h.call(s, c.charAt(d), d, c);
  }, i = function(c, h, s) {
    for (var d in c)
      t.call(c, d) && (s == null ? h(c[d], d, c) : h.call(s, c[d], d, c));
  }, o = function(c, h, s) {
    if (!r(h))
      throw new TypeError("iterator must be a function");
    var d;
    arguments.length >= 3 && (d = s), e.call(c) === "[object Array]" ? n(c, h, d) : typeof c == "string" ? a(c, h, d) : i(c, h, d);
  };
  return As = o, As;
}
var Ts, Wl;
function V2() {
  return Wl || (Wl = 1, Ts = [
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Int16Array",
    "Int32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array"
  ]), Ts;
}
var ks, Kl;
function W2() {
  if (Kl)
    return ks;
  Kl = 1;
  var r = V2(), e = typeof globalThis == "undefined" ? Jt : globalThis;
  return ks = function() {
    for (var n = [], a = 0; a < r.length; a++)
      typeof e[r[a]] == "function" && (n[n.length] = r[a]);
    return n;
  }, ks;
}
var Is, Ql;
function b1() {
  if (Ql)
    return Is;
  Ql = 1;
  var r = z2(), e = W2(), t = v1(), n = y1(), a = Qc(), i = n("Object.prototype.toString"), o = Vc()(), u = typeof globalThis == "undefined" ? Jt : globalThis, c = e(), h = n("String.prototype.slice"), s = Object.getPrototypeOf, d = n("Array.prototype.indexOf", !0) || /** @type {(array: readonly unknown[], value: unknown) => keyof array} */
  function(E, S) {
    for (var P = 0; P < E.length; P += 1)
      if (E[P] === S)
        return P;
    return -1;
  }, l = { __proto__: null };
  o && a && s ? r(c, function(w) {
    var E = new u[w]();
    if (Symbol.toStringTag in E) {
      var S = s(E), P = a(S, Symbol.toStringTag);
      if (!P) {
        var L = s(S);
        P = a(L, Symbol.toStringTag);
      }
      l["$" + w] = t(P.get);
    }
  }) : r(c, function(w) {
    var E = new u[w](), S = E.slice || E.set;
    S && (l["$" + w] = t(S));
  });
  var y = function(E) {
    var S = !1;
    return r(
      // eslint-disable-next-line no-extra-parens
      /** @type {Record<`\$${TypedArrayName}`, typeof cache>} */
      /** @type {any} */
      l,
      /** @type {(getter: typeof cache, name: `\$${TypedArrayName}`) => void} */
      function(P, L) {
        if (!S)
          try {
            "$" + P(E) === L && (S = h(L, 1));
          } catch (U) {
          }
      }
    ), S;
  }, m = function(E) {
    var S = !1;
    return r(
      // eslint-disable-next-line no-extra-parens
      /** @type {any} */
      l,
      /** @type {(getter: typeof cache, name: `\$${TypedArrayName}`) => void} */
      function(P, L) {
        if (!S)
          try {
            P(E), S = h(L, 1);
          } catch (U) {
          }
      }
    ), S;
  };
  return Is = function(E) {
    if (!E || typeof E != "object")
      return !1;
    if (!o) {
      var S = h(i(E), 8, -1);
      return d(c, S) > -1 ? S : S !== "Object" ? !1 : m(E);
    }
    return a ? y(E) : null;
  }, Is;
}
var Rs, Gl;
function K2() {
  if (Gl)
    return Rs;
  Gl = 1;
  var r = b1();
  return Rs = function(t) {
    return !!r(t);
  }, Rs;
}
var Jl;
function Q2() {
  return Jl || (Jl = 1, function(r) {
    var e = $2(), t = j2(), n = b1(), a = K2();
    function i(ge) {
      return ge.call.bind(ge);
    }
    var o = typeof BigInt != "undefined", u = typeof Symbol != "undefined", c = i(Object.prototype.toString), h = i(Number.prototype.valueOf), s = i(String.prototype.valueOf), d = i(Boolean.prototype.valueOf);
    if (o)
      var l = i(BigInt.prototype.valueOf);
    if (u)
      var y = i(Symbol.prototype.valueOf);
    function m(ge, ht) {
      if (typeof ge != "object")
        return !1;
      try {
        return ht(ge), !0;
      } catch ($e) {
        return !1;
      }
    }
    r.isArgumentsObject = e, r.isGeneratorFunction = t, r.isTypedArray = a;
    function w(ge) {
      return typeof Promise != "undefined" && ge instanceof Promise || ge !== null && typeof ge == "object" && typeof ge.then == "function" && typeof ge.catch == "function";
    }
    r.isPromise = w;
    function E(ge) {
      return typeof ArrayBuffer != "undefined" && ArrayBuffer.isView ? ArrayBuffer.isView(ge) : a(ge) || B(ge);
    }
    r.isArrayBufferView = E;
    function S(ge) {
      return n(ge) === "Uint8Array";
    }
    r.isUint8Array = S;
    function P(ge) {
      return n(ge) === "Uint8ClampedArray";
    }
    r.isUint8ClampedArray = P;
    function L(ge) {
      return n(ge) === "Uint16Array";
    }
    r.isUint16Array = L;
    function U(ge) {
      return n(ge) === "Uint32Array";
    }
    r.isUint32Array = U;
    function z(ge) {
      return n(ge) === "Int8Array";
    }
    r.isInt8Array = z;
    function K(ge) {
      return n(ge) === "Int16Array";
    }
    r.isInt16Array = K;
    function re(ge) {
      return n(ge) === "Int32Array";
    }
    r.isInt32Array = re;
    function oe(ge) {
      return n(ge) === "Float32Array";
    }
    r.isFloat32Array = oe;
    function se(ge) {
      return n(ge) === "Float64Array";
    }
    r.isFloat64Array = se;
    function ve(ge) {
      return n(ge) === "BigInt64Array";
    }
    r.isBigInt64Array = ve;
    function Q(ge) {
      return n(ge) === "BigUint64Array";
    }
    r.isBigUint64Array = Q;
    function A(ge) {
      return c(ge) === "[object Map]";
    }
    A.working = typeof Map != "undefined" && A(/* @__PURE__ */ new Map());
    function b(ge) {
      return typeof Map == "undefined" ? !1 : A.working ? A(ge) : ge instanceof Map;
    }
    r.isMap = b;
    function f(ge) {
      return c(ge) === "[object Set]";
    }
    f.working = typeof Set != "undefined" && f(/* @__PURE__ */ new Set());
    function v(ge) {
      return typeof Set == "undefined" ? !1 : f.working ? f(ge) : ge instanceof Set;
    }
    r.isSet = v;
    function g(ge) {
      return c(ge) === "[object WeakMap]";
    }
    g.working = typeof WeakMap != "undefined" && g(/* @__PURE__ */ new WeakMap());
    function M(ge) {
      return typeof WeakMap == "undefined" ? !1 : g.working ? g(ge) : ge instanceof WeakMap;
    }
    r.isWeakMap = M;
    function I(ge) {
      return c(ge) === "[object WeakSet]";
    }
    I.working = typeof WeakSet != "undefined" && I(/* @__PURE__ */ new WeakSet());
    function R(ge) {
      return I(ge);
    }
    r.isWeakSet = R;
    function x(ge) {
      return c(ge) === "[object ArrayBuffer]";
    }
    x.working = typeof ArrayBuffer != "undefined" && x(new ArrayBuffer());
    function T(ge) {
      return typeof ArrayBuffer == "undefined" ? !1 : x.working ? x(ge) : ge instanceof ArrayBuffer;
    }
    r.isArrayBuffer = T;
    function p(ge) {
      return c(ge) === "[object DataView]";
    }
    p.working = typeof ArrayBuffer != "undefined" && typeof DataView != "undefined" && p(new DataView(new ArrayBuffer(1), 0, 1));
    function B(ge) {
      return typeof DataView == "undefined" ? !1 : p.working ? p(ge) : ge instanceof DataView;
    }
    r.isDataView = B;
    var ee = typeof SharedArrayBuffer != "undefined" ? SharedArrayBuffer : void 0;
    function ae(ge) {
      return c(ge) === "[object SharedArrayBuffer]";
    }
    function Z(ge) {
      return typeof ee == "undefined" ? !1 : (typeof ae.working == "undefined" && (ae.working = ae(new ee())), ae.working ? ae(ge) : ge instanceof ee);
    }
    r.isSharedArrayBuffer = Z;
    function ne(ge) {
      return c(ge) === "[object AsyncFunction]";
    }
    r.isAsyncFunction = ne;
    function fe(ge) {
      return c(ge) === "[object Map Iterator]";
    }
    r.isMapIterator = fe;
    function le(ge) {
      return c(ge) === "[object Set Iterator]";
    }
    r.isSetIterator = le;
    function ke(ge) {
      return c(ge) === "[object Generator]";
    }
    r.isGeneratorObject = ke;
    function X(ge) {
      return c(ge) === "[object WebAssembly.Module]";
    }
    r.isWebAssemblyCompiledModule = X;
    function G(ge) {
      return m(ge, h);
    }
    r.isNumberObject = G;
    function we(ge) {
      return m(ge, s);
    }
    r.isStringObject = we;
    function Ae(ge) {
      return m(ge, d);
    }
    r.isBooleanObject = Ae;
    function Oe(ge) {
      return o && m(ge, l);
    }
    r.isBigIntObject = Oe;
    function qe(ge) {
      return u && m(ge, y);
    }
    r.isSymbolObject = qe;
    function Ue(ge) {
      return G(ge) || we(ge) || Ae(ge) || Oe(ge) || qe(ge);
    }
    r.isBoxedPrimitive = Ue;
    function ze(ge) {
      return typeof Uint8Array != "undefined" && (T(ge) || Z(ge));
    }
    r.isAnyArrayBuffer = ze, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(ge) {
      Object.defineProperty(r, ge, {
        enumerable: !1,
        value: function() {
          throw new Error(ge + " is not supported in userland");
        }
      });
    });
  }(es)), es;
}
var Cs, Yl;
function G2() {
  return Yl || (Yl = 1, Cs = function(e) {
    return e && typeof e == "object" && typeof e.copy == "function" && typeof e.fill == "function" && typeof e.readUInt8 == "function";
  }), Cs;
}
var Xl;
function m1() {
  return Xl || (Xl = 1, function(r) {
    var e = Object.getOwnPropertyDescriptors || function(B) {
      for (var ee = Object.keys(B), ae = {}, Z = 0; Z < ee.length; Z++)
        ae[ee[Z]] = Object.getOwnPropertyDescriptor(B, ee[Z]);
      return ae;
    }, t = /%[sdj%]/g;
    r.format = function(p) {
      if (!z(p)) {
        for (var B = [], ee = 0; ee < arguments.length; ee++)
          B.push(o(arguments[ee]));
        return B.join(" ");
      }
      for (var ee = 1, ae = arguments, Z = ae.length, ne = String(p).replace(t, function(le) {
        if (le === "%%")
          return "%";
        if (ee >= Z)
          return le;
        switch (le) {
          case "%s":
            return String(ae[ee++]);
          case "%d":
            return Number(ae[ee++]);
          case "%j":
            try {
              return JSON.stringify(ae[ee++]);
            } catch (ke) {
              return "[Circular]";
            }
          default:
            return le;
        }
      }), fe = ae[ee]; ee < Z; fe = ae[++ee])
        P(fe) || !se(fe) ? ne += " " + fe : ne += " " + o(fe);
      return ne;
    }, r.deprecate = function(p, B) {
      if (typeof Bt != "undefined" && Bt.noDeprecation === !0)
        return p;
      if (typeof Bt == "undefined")
        return function() {
          return r.deprecate(p, B).apply(this, arguments);
        };
      var ee = !1;
      function ae() {
        if (!ee) {
          if (Bt.throwDeprecation)
            throw new Error(B);
          Bt.traceDeprecation ? console.trace(B) : console.error(B), ee = !0;
        }
        return p.apply(this, arguments);
      }
      return ae;
    };
    var n = {}, a = /^$/;
    if (Bt.env.NODE_DEBUG) {
      var i = Bt.env.NODE_DEBUG;
      i = i.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), a = new RegExp("^" + i + "$", "i");
    }
    r.debuglog = function(p) {
      if (p = p.toUpperCase(), !n[p])
        if (a.test(p)) {
          var B = Bt.pid;
          n[p] = function() {
            var ee = r.format.apply(r, arguments);
            console.error("%s %d: %s", p, B, ee);
          };
        } else
          n[p] = function() {
          };
      return n[p];
    };
    function o(p, B) {
      var ee = {
        seen: [],
        stylize: c
      };
      return arguments.length >= 3 && (ee.depth = arguments[2]), arguments.length >= 4 && (ee.colors = arguments[3]), S(B) ? ee.showHidden = B : B && r._extend(ee, B), re(ee.showHidden) && (ee.showHidden = !1), re(ee.depth) && (ee.depth = 2), re(ee.colors) && (ee.colors = !1), re(ee.customInspect) && (ee.customInspect = !0), ee.colors && (ee.stylize = u), s(ee, p, ee.depth);
    }
    r.inspect = o, o.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39]
    }, o.styles = {
      special: "cyan",
      number: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      date: "magenta",
      // "name": intentionally not styling
      regexp: "red"
    };
    function u(p, B) {
      var ee = o.styles[B];
      return ee ? "\x1B[" + o.colors[ee][0] + "m" + p + "\x1B[" + o.colors[ee][1] + "m" : p;
    }
    function c(p, B) {
      return p;
    }
    function h(p) {
      var B = {};
      return p.forEach(function(ee, ae) {
        B[ee] = !0;
      }), B;
    }
    function s(p, B, ee) {
      if (p.customInspect && B && A(B.inspect) && // Filter out the util module, it's inspect function is special
      B.inspect !== r.inspect && // Also filter out any prototype objects using the circular check.
      !(B.constructor && B.constructor.prototype === B)) {
        var ae = B.inspect(ee, p);
        return z(ae) || (ae = s(p, ae, ee)), ae;
      }
      var Z = d(p, B);
      if (Z)
        return Z;
      var ne = Object.keys(B), fe = h(ne);
      if (p.showHidden && (ne = Object.getOwnPropertyNames(B)), Q(B) && (ne.indexOf("message") >= 0 || ne.indexOf("description") >= 0))
        return l(B);
      if (ne.length === 0) {
        if (A(B)) {
          var le = B.name ? ": " + B.name : "";
          return p.stylize("[Function" + le + "]", "special");
        }
        if (oe(B))
          return p.stylize(RegExp.prototype.toString.call(B), "regexp");
        if (ve(B))
          return p.stylize(Date.prototype.toString.call(B), "date");
        if (Q(B))
          return l(B);
      }
      var ke = "", X = !1, G = ["{", "}"];
      if (E(B) && (X = !0, G = ["[", "]"]), A(B)) {
        var we = B.name ? ": " + B.name : "";
        ke = " [Function" + we + "]";
      }
      if (oe(B) && (ke = " " + RegExp.prototype.toString.call(B)), ve(B) && (ke = " " + Date.prototype.toUTCString.call(B)), Q(B) && (ke = " " + l(B)), ne.length === 0 && (!X || B.length == 0))
        return G[0] + ke + G[1];
      if (ee < 0)
        return oe(B) ? p.stylize(RegExp.prototype.toString.call(B), "regexp") : p.stylize("[Object]", "special");
      p.seen.push(B);
      var Ae;
      return X ? Ae = y(p, B, ee, fe, ne) : Ae = ne.map(function(Oe) {
        return m(p, B, ee, fe, Oe, X);
      }), p.seen.pop(), w(Ae, ke, G);
    }
    function d(p, B) {
      if (re(B))
        return p.stylize("undefined", "undefined");
      if (z(B)) {
        var ee = "'" + JSON.stringify(B).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return p.stylize(ee, "string");
      }
      if (U(B))
        return p.stylize("" + B, "number");
      if (S(B))
        return p.stylize("" + B, "boolean");
      if (P(B))
        return p.stylize("null", "null");
    }
    function l(p) {
      return "[" + Error.prototype.toString.call(p) + "]";
    }
    function y(p, B, ee, ae, Z) {
      for (var ne = [], fe = 0, le = B.length; fe < le; ++fe)
        I(B, String(fe)) ? ne.push(m(
          p,
          B,
          ee,
          ae,
          String(fe),
          !0
        )) : ne.push("");
      return Z.forEach(function(ke) {
        ke.match(/^\d+$/) || ne.push(m(
          p,
          B,
          ee,
          ae,
          ke,
          !0
        ));
      }), ne;
    }
    function m(p, B, ee, ae, Z, ne) {
      var fe, le, ke;
      if (ke = Object.getOwnPropertyDescriptor(B, Z) || { value: B[Z] }, ke.get ? ke.set ? le = p.stylize("[Getter/Setter]", "special") : le = p.stylize("[Getter]", "special") : ke.set && (le = p.stylize("[Setter]", "special")), I(ae, Z) || (fe = "[" + Z + "]"), le || (p.seen.indexOf(ke.value) < 0 ? (P(ee) ? le = s(p, ke.value, null) : le = s(p, ke.value, ee - 1), le.indexOf(`
`) > -1 && (ne ? le = le.split(`
`).map(function(X) {
        return "  " + X;
      }).join(`
`).slice(2) : le = `
` + le.split(`
`).map(function(X) {
        return "   " + X;
      }).join(`
`))) : le = p.stylize("[Circular]", "special")), re(fe)) {
        if (ne && Z.match(/^\d+$/))
          return le;
        fe = JSON.stringify("" + Z), fe.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (fe = fe.slice(1, -1), fe = p.stylize(fe, "name")) : (fe = fe.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), fe = p.stylize(fe, "string"));
      }
      return fe + ": " + le;
    }
    function w(p, B, ee) {
      var ae = p.reduce(function(Z, ne) {
        return ne.indexOf(`
`) >= 0, Z + ne.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      return ae > 60 ? ee[0] + (B === "" ? "" : B + `
 `) + " " + p.join(`,
  `) + " " + ee[1] : ee[0] + B + " " + p.join(", ") + " " + ee[1];
    }
    r.types = Q2();
    function E(p) {
      return Array.isArray(p);
    }
    r.isArray = E;
    function S(p) {
      return typeof p == "boolean";
    }
    r.isBoolean = S;
    function P(p) {
      return p === null;
    }
    r.isNull = P;
    function L(p) {
      return p == null;
    }
    r.isNullOrUndefined = L;
    function U(p) {
      return typeof p == "number";
    }
    r.isNumber = U;
    function z(p) {
      return typeof p == "string";
    }
    r.isString = z;
    function K(p) {
      return typeof p == "symbol";
    }
    r.isSymbol = K;
    function re(p) {
      return p === void 0;
    }
    r.isUndefined = re;
    function oe(p) {
      return se(p) && f(p) === "[object RegExp]";
    }
    r.isRegExp = oe, r.types.isRegExp = oe;
    function se(p) {
      return typeof p == "object" && p !== null;
    }
    r.isObject = se;
    function ve(p) {
      return se(p) && f(p) === "[object Date]";
    }
    r.isDate = ve, r.types.isDate = ve;
    function Q(p) {
      return se(p) && (f(p) === "[object Error]" || p instanceof Error);
    }
    r.isError = Q, r.types.isNativeError = Q;
    function A(p) {
      return typeof p == "function";
    }
    r.isFunction = A;
    function b(p) {
      return p === null || typeof p == "boolean" || typeof p == "number" || typeof p == "string" || typeof p == "symbol" || // ES6 symbol
      typeof p == "undefined";
    }
    r.isPrimitive = b, r.isBuffer = G2();
    function f(p) {
      return Object.prototype.toString.call(p);
    }
    function v(p) {
      return p < 10 ? "0" + p.toString(10) : p.toString(10);
    }
    var g = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function M() {
      var p = /* @__PURE__ */ new Date(), B = [
        v(p.getHours()),
        v(p.getMinutes()),
        v(p.getSeconds())
      ].join(":");
      return [p.getDate(), g[p.getMonth()], B].join(" ");
    }
    r.log = function() {
      console.log("%s - %s", M(), r.format.apply(r, arguments));
    }, r.inherits = Ft(), r._extend = function(p, B) {
      if (!B || !se(B))
        return p;
      for (var ee = Object.keys(B), ae = ee.length; ae--; )
        p[ee[ae]] = B[ee[ae]];
      return p;
    };
    function I(p, B) {
      return Object.prototype.hasOwnProperty.call(p, B);
    }
    var R = typeof Symbol != "undefined" ? Symbol("util.promisify.custom") : void 0;
    r.promisify = function(B) {
      if (typeof B != "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (R && B[R]) {
        var ee = B[R];
        if (typeof ee != "function")
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(ee, R, {
          value: ee,
          enumerable: !1,
          writable: !1,
          configurable: !0
        }), ee;
      }
      function ee() {
        for (var ae, Z, ne = new Promise(function(ke, X) {
          ae = ke, Z = X;
        }), fe = [], le = 0; le < arguments.length; le++)
          fe.push(arguments[le]);
        fe.push(function(ke, X) {
          ke ? Z(ke) : ae(X);
        });
        try {
          B.apply(this, fe);
        } catch (ke) {
          Z(ke);
        }
        return ne;
      }
      return Object.setPrototypeOf(ee, Object.getPrototypeOf(B)), R && Object.defineProperty(ee, R, {
        value: ee,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), Object.defineProperties(
        ee,
        e(B)
      );
    }, r.promisify.custom = R;
    function x(p, B) {
      if (!p) {
        var ee = new Error("Promise was rejected with a falsy value");
        ee.reason = p, p = ee;
      }
      return B(p);
    }
    function T(p) {
      if (typeof p != "function")
        throw new TypeError('The "original" argument must be of type Function');
      function B() {
        for (var ee = [], ae = 0; ae < arguments.length; ae++)
          ee.push(arguments[ae]);
        var Z = ee.pop();
        if (typeof Z != "function")
          throw new TypeError("The last argument must be of type Function");
        var ne = this, fe = function() {
          return Z.apply(ne, arguments);
        };
        p.apply(this, ee).then(
          function(le) {
            Bt.nextTick(fe.bind(null, null, le));
          },
          function(le) {
            Bt.nextTick(x.bind(null, le, fe));
          }
        );
      }
      return Object.setPrototypeOf(B, Object.getPrototypeOf(p)), Object.defineProperties(
        B,
        e(p)
      ), B;
    }
    r.callbackify = T;
  }(Zo)), Zo;
}
var Os, Zl;
function J2() {
  if (Zl)
    return Os;
  Zl = 1;
  function r(m, w) {
    var E = Object.keys(m);
    if (Object.getOwnPropertySymbols) {
      var S = Object.getOwnPropertySymbols(m);
      w && (S = S.filter(function(P) {
        return Object.getOwnPropertyDescriptor(m, P).enumerable;
      })), E.push.apply(E, S);
    }
    return E;
  }
  function e(m) {
    for (var w = 1; w < arguments.length; w++) {
      var E = arguments[w] != null ? arguments[w] : {};
      w % 2 ? r(Object(E), !0).forEach(function(S) {
        t(m, S, E[S]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(m, Object.getOwnPropertyDescriptors(E)) : r(Object(E)).forEach(function(S) {
        Object.defineProperty(m, S, Object.getOwnPropertyDescriptor(E, S));
      });
    }
    return m;
  }
  function t(m, w, E) {
    return w = o(w), w in m ? Object.defineProperty(m, w, { value: E, enumerable: !0, configurable: !0, writable: !0 }) : m[w] = E, m;
  }
  function n(m, w) {
    if (!(m instanceof w))
      throw new TypeError("Cannot call a class as a function");
  }
  function a(m, w) {
    for (var E = 0; E < w.length; E++) {
      var S = w[E];
      S.enumerable = S.enumerable || !1, S.configurable = !0, "value" in S && (S.writable = !0), Object.defineProperty(m, o(S.key), S);
    }
  }
  function i(m, w, E) {
    return w && a(m.prototype, w), E && a(m, E), Object.defineProperty(m, "prototype", { writable: !1 }), m;
  }
  function o(m) {
    var w = u(m, "string");
    return typeof w == "symbol" ? w : String(w);
  }
  function u(m, w) {
    if (typeof m != "object" || m === null)
      return m;
    var E = m[Symbol.toPrimitive];
    if (E !== void 0) {
      var S = E.call(m, w || "default");
      if (typeof S != "object")
        return S;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (w === "string" ? String : Number)(m);
  }
  var c = Mn, h = c.Buffer, s = m1(), d = s.inspect, l = d && d.custom || "inspect";
  function y(m, w, E) {
    h.prototype.copy.call(m, w, E);
  }
  return Os = /* @__PURE__ */ function() {
    function m() {
      n(this, m), this.head = null, this.tail = null, this.length = 0;
    }
    return i(m, [{
      key: "push",
      value: function(E) {
        var S = {
          data: E,
          next: null
        };
        this.length > 0 ? this.tail.next = S : this.head = S, this.tail = S, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(E) {
        var S = {
          data: E,
          next: this.head
        };
        this.length === 0 && (this.tail = S), this.head = S, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var E = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, E;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(E) {
        if (this.length === 0)
          return "";
        for (var S = this.head, P = "" + S.data; S = S.next; )
          P += E + S.data;
        return P;
      }
    }, {
      key: "concat",
      value: function(E) {
        if (this.length === 0)
          return h.alloc(0);
        for (var S = h.allocUnsafe(E >>> 0), P = this.head, L = 0; P; )
          y(P.data, S, L), L += P.data.length, P = P.next;
        return S;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(E, S) {
        var P;
        return E < this.head.data.length ? (P = this.head.data.slice(0, E), this.head.data = this.head.data.slice(E)) : E === this.head.data.length ? P = this.shift() : P = S ? this._getString(E) : this._getBuffer(E), P;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(E) {
        var S = this.head, P = 1, L = S.data;
        for (E -= L.length; S = S.next; ) {
          var U = S.data, z = E > U.length ? U.length : E;
          if (z === U.length ? L += U : L += U.slice(0, E), E -= z, E === 0) {
            z === U.length ? (++P, S.next ? this.head = S.next : this.head = this.tail = null) : (this.head = S, S.data = U.slice(z));
            break;
          }
          ++P;
        }
        return this.length -= P, L;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(E) {
        var S = h.allocUnsafe(E), P = this.head, L = 1;
        for (P.data.copy(S), E -= P.data.length; P = P.next; ) {
          var U = P.data, z = E > U.length ? U.length : E;
          if (U.copy(S, S.length - E, 0, z), E -= z, E === 0) {
            z === U.length ? (++L, P.next ? this.head = P.next : this.head = this.tail = null) : (this.head = P, P.data = U.slice(z));
            break;
          }
          ++L;
        }
        return this.length -= L, S;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: l,
      value: function(E, S) {
        return d(this, e(e({}, S), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), m;
  }(), Os;
}
var Bs, e0;
function g1() {
  if (e0)
    return Bs;
  e0 = 1;
  function r(o, u) {
    var c = this, h = this._readableState && this._readableState.destroyed, s = this._writableState && this._writableState.destroyed;
    return h || s ? (u ? u(o) : o && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, Bt.nextTick(a, this, o)) : Bt.nextTick(a, this, o)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(o || null, function(d) {
      !u && d ? c._writableState ? c._writableState.errorEmitted ? Bt.nextTick(t, c) : (c._writableState.errorEmitted = !0, Bt.nextTick(e, c, d)) : Bt.nextTick(e, c, d) : u ? (Bt.nextTick(t, c), u(d)) : Bt.nextTick(t, c);
    }), this);
  }
  function e(o, u) {
    a(o, u), t(o);
  }
  function t(o) {
    o._writableState && !o._writableState.emitClose || o._readableState && !o._readableState.emitClose || o.emit("close");
  }
  function n() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function a(o, u) {
    o.emit("error", u);
  }
  function i(o, u) {
    var c = o._readableState, h = o._writableState;
    c && c.autoDestroy || h && h.autoDestroy ? o.destroy(u) : o.emit("error", u);
  }
  return Bs = {
    destroy: r,
    undestroy: n,
    errorOrDestroy: i
  }, Bs;
}
var Ps = {}, t0;
function Ri() {
  if (t0)
    return Ps;
  t0 = 1;
  function r(u, c) {
    u.prototype = Object.create(c.prototype), u.prototype.constructor = u, u.__proto__ = c;
  }
  var e = {};
  function t(u, c, h) {
    h || (h = Error);
    function s(l, y, m) {
      return typeof c == "string" ? c : c(l, y, m);
    }
    var d = /* @__PURE__ */ function(l) {
      r(y, l);
      function y(m, w, E) {
        return l.call(this, s(m, w, E)) || this;
      }
      return y;
    }(h);
    d.prototype.name = h.name, d.prototype.code = u, e[u] = d;
  }
  function n(u, c) {
    if (Array.isArray(u)) {
      var h = u.length;
      return u = u.map(function(s) {
        return String(s);
      }), h > 2 ? "one of ".concat(c, " ").concat(u.slice(0, h - 1).join(", "), ", or ") + u[h - 1] : h === 2 ? "one of ".concat(c, " ").concat(u[0], " or ").concat(u[1]) : "of ".concat(c, " ").concat(u[0]);
    } else
      return "of ".concat(c, " ").concat(String(u));
  }
  function a(u, c, h) {
    return u.substr(!h || h < 0 ? 0 : +h, c.length) === c;
  }
  function i(u, c, h) {
    return (h === void 0 || h > u.length) && (h = u.length), u.substring(h - c.length, h) === c;
  }
  function o(u, c, h) {
    return typeof h != "number" && (h = 0), h + c.length > u.length ? !1 : u.indexOf(c, h) !== -1;
  }
  return t("ERR_INVALID_OPT_VALUE", function(u, c) {
    return 'The value "' + c + '" is invalid for option "' + u + '"';
  }, TypeError), t("ERR_INVALID_ARG_TYPE", function(u, c, h) {
    var s;
    typeof c == "string" && a(c, "not ") ? (s = "must not be", c = c.replace(/^not /, "")) : s = "must be";
    var d;
    if (i(u, " argument"))
      d = "The ".concat(u, " ").concat(s, " ").concat(n(c, "type"));
    else {
      var l = o(u, ".") ? "property" : "argument";
      d = 'The "'.concat(u, '" ').concat(l, " ").concat(s, " ").concat(n(c, "type"));
    }
    return d += ". Received type ".concat(typeof h), d;
  }, TypeError), t("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), t("ERR_METHOD_NOT_IMPLEMENTED", function(u) {
    return "The " + u + " method is not implemented";
  }), t("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), t("ERR_STREAM_DESTROYED", function(u) {
    return "Cannot call " + u + " after a stream was destroyed";
  }), t("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), t("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), t("ERR_STREAM_WRITE_AFTER_END", "write after end"), t("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), t("ERR_UNKNOWN_ENCODING", function(u) {
    return "Unknown encoding: " + u;
  }, TypeError), t("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), Ps.codes = e, Ps;
}
var Ds, r0;
function w1() {
  if (r0)
    return Ds;
  r0 = 1;
  var r = Ri().codes.ERR_INVALID_OPT_VALUE;
  function e(n, a, i) {
    return n.highWaterMark != null ? n.highWaterMark : a ? n[i] : null;
  }
  function t(n, a, i, o) {
    var u = e(a, o, i);
    if (u != null) {
      if (!(isFinite(u) && Math.floor(u) === u) || u < 0) {
        var c = o ? i : "highWaterMark";
        throw new r(c, u);
      }
      return Math.floor(u);
    }
    return n.objectMode ? 16 : 16 * 1024;
  }
  return Ds = {
    getHighWaterMark: t
  }, Ds;
}
var Ns, n0;
function Y2() {
  if (n0)
    return Ns;
  n0 = 1, Ns = r;
  function r(t, n) {
    if (e("noDeprecation"))
      return t;
    var a = !1;
    function i() {
      if (!a) {
        if (e("throwDeprecation"))
          throw new Error(n);
        e("traceDeprecation") ? console.trace(n) : console.warn(n), a = !0;
      }
      return t.apply(this, arguments);
    }
    return i;
  }
  function e(t) {
    try {
      if (!Jt.localStorage)
        return !1;
    } catch (a) {
      return !1;
    }
    var n = Jt.localStorage[t];
    return n == null ? !1 : String(n).toLowerCase() === "true";
  }
  return Ns;
}
var qs, i0;
function Gc() {
  if (i0)
    return qs;
  i0 = 1, qs = oe;
  function r(Z) {
    var ne = this;
    this.next = null, this.entry = null, this.finish = function() {
      ae(ne, Z);
    };
  }
  var e;
  oe.WritableState = K;
  var t = {
    deprecate: Y2()
  }, n = l1(), a = Mn.Buffer, i = (typeof Jt != "undefined" ? Jt : typeof window != "undefined" ? window : typeof self != "undefined" ? self : {}).Uint8Array || function() {
  };
  function o(Z) {
    return a.from(Z);
  }
  function u(Z) {
    return a.isBuffer(Z) || Z instanceof i;
  }
  var c = g1(), h = w1(), s = h.getHighWaterMark, d = Ri().codes, l = d.ERR_INVALID_ARG_TYPE, y = d.ERR_METHOD_NOT_IMPLEMENTED, m = d.ERR_MULTIPLE_CALLBACK, w = d.ERR_STREAM_CANNOT_PIPE, E = d.ERR_STREAM_DESTROYED, S = d.ERR_STREAM_NULL_VALUES, P = d.ERR_STREAM_WRITE_AFTER_END, L = d.ERR_UNKNOWN_ENCODING, U = c.errorOrDestroy;
  Ft()(oe, n);
  function z() {
  }
  function K(Z, ne, fe) {
    e = e || ni(), Z = Z || {}, typeof fe != "boolean" && (fe = ne instanceof e), this.objectMode = !!Z.objectMode, fe && (this.objectMode = this.objectMode || !!Z.writableObjectMode), this.highWaterMark = s(this, Z, "writableHighWaterMark", fe), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var le = Z.decodeStrings === !1;
    this.decodeStrings = !le, this.defaultEncoding = Z.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(ke) {
      g(ne, ke);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = Z.emitClose !== !1, this.autoDestroy = !!Z.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new r(this);
  }
  K.prototype.getBuffer = function() {
    for (var ne = this.bufferedRequest, fe = []; ne; )
      fe.push(ne), ne = ne.next;
    return fe;
  }, function() {
    try {
      Object.defineProperty(K.prototype, "buffer", {
        get: t.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (Z) {
    }
  }();
  var re;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (re = Function.prototype[Symbol.hasInstance], Object.defineProperty(oe, Symbol.hasInstance, {
    value: function(ne) {
      return re.call(this, ne) ? !0 : this !== oe ? !1 : ne && ne._writableState instanceof K;
    }
  })) : re = function(ne) {
    return ne instanceof this;
  };
  function oe(Z) {
    e = e || ni();
    var ne = this instanceof e;
    if (!ne && !re.call(oe, this))
      return new oe(Z);
    this._writableState = new K(Z, this, ne), this.writable = !0, Z && (typeof Z.write == "function" && (this._write = Z.write), typeof Z.writev == "function" && (this._writev = Z.writev), typeof Z.destroy == "function" && (this._destroy = Z.destroy), typeof Z.final == "function" && (this._final = Z.final)), n.call(this);
  }
  oe.prototype.pipe = function() {
    U(this, new w());
  };
  function se(Z, ne) {
    var fe = new P();
    U(Z, fe), Bt.nextTick(ne, fe);
  }
  function ve(Z, ne, fe, le) {
    var ke;
    return fe === null ? ke = new S() : typeof fe != "string" && !ne.objectMode && (ke = new l("chunk", ["string", "Buffer"], fe)), ke ? (U(Z, ke), Bt.nextTick(le, ke), !1) : !0;
  }
  oe.prototype.write = function(Z, ne, fe) {
    var le = this._writableState, ke = !1, X = !le.objectMode && u(Z);
    return X && !a.isBuffer(Z) && (Z = o(Z)), typeof ne == "function" && (fe = ne, ne = null), X ? ne = "buffer" : ne || (ne = le.defaultEncoding), typeof fe != "function" && (fe = z), le.ending ? se(this, fe) : (X || ve(this, le, Z, fe)) && (le.pendingcb++, ke = A(this, le, X, Z, ne, fe)), ke;
  }, oe.prototype.cork = function() {
    this._writableState.corked++;
  }, oe.prototype.uncork = function() {
    var Z = this._writableState;
    Z.corked && (Z.corked--, !Z.writing && !Z.corked && !Z.bufferProcessing && Z.bufferedRequest && R(this, Z));
  }, oe.prototype.setDefaultEncoding = function(ne) {
    if (typeof ne == "string" && (ne = ne.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((ne + "").toLowerCase()) > -1))
      throw new L(ne);
    return this._writableState.defaultEncoding = ne, this;
  }, Object.defineProperty(oe.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function Q(Z, ne, fe) {
    return !Z.objectMode && Z.decodeStrings !== !1 && typeof ne == "string" && (ne = a.from(ne, fe)), ne;
  }
  Object.defineProperty(oe.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function A(Z, ne, fe, le, ke, X) {
    if (!fe) {
      var G = Q(ne, le, ke);
      le !== G && (fe = !0, ke = "buffer", le = G);
    }
    var we = ne.objectMode ? 1 : le.length;
    ne.length += we;
    var Ae = ne.length < ne.highWaterMark;
    if (Ae || (ne.needDrain = !0), ne.writing || ne.corked) {
      var Oe = ne.lastBufferedRequest;
      ne.lastBufferedRequest = {
        chunk: le,
        encoding: ke,
        isBuf: fe,
        callback: X,
        next: null
      }, Oe ? Oe.next = ne.lastBufferedRequest : ne.bufferedRequest = ne.lastBufferedRequest, ne.bufferedRequestCount += 1;
    } else
      b(Z, ne, !1, we, le, ke, X);
    return Ae;
  }
  function b(Z, ne, fe, le, ke, X, G) {
    ne.writelen = le, ne.writecb = G, ne.writing = !0, ne.sync = !0, ne.destroyed ? ne.onwrite(new E("write")) : fe ? Z._writev(ke, ne.onwrite) : Z._write(ke, X, ne.onwrite), ne.sync = !1;
  }
  function f(Z, ne, fe, le, ke) {
    --ne.pendingcb, fe ? (Bt.nextTick(ke, le), Bt.nextTick(B, Z, ne), Z._writableState.errorEmitted = !0, U(Z, le)) : (ke(le), Z._writableState.errorEmitted = !0, U(Z, le), B(Z, ne));
  }
  function v(Z) {
    Z.writing = !1, Z.writecb = null, Z.length -= Z.writelen, Z.writelen = 0;
  }
  function g(Z, ne) {
    var fe = Z._writableState, le = fe.sync, ke = fe.writecb;
    if (typeof ke != "function")
      throw new m();
    if (v(fe), ne)
      f(Z, fe, le, ne, ke);
    else {
      var X = x(fe) || Z.destroyed;
      !X && !fe.corked && !fe.bufferProcessing && fe.bufferedRequest && R(Z, fe), le ? Bt.nextTick(M, Z, fe, X, ke) : M(Z, fe, X, ke);
    }
  }
  function M(Z, ne, fe, le) {
    fe || I(Z, ne), ne.pendingcb--, le(), B(Z, ne);
  }
  function I(Z, ne) {
    ne.length === 0 && ne.needDrain && (ne.needDrain = !1, Z.emit("drain"));
  }
  function R(Z, ne) {
    ne.bufferProcessing = !0;
    var fe = ne.bufferedRequest;
    if (Z._writev && fe && fe.next) {
      var le = ne.bufferedRequestCount, ke = new Array(le), X = ne.corkedRequestsFree;
      X.entry = fe;
      for (var G = 0, we = !0; fe; )
        ke[G] = fe, fe.isBuf || (we = !1), fe = fe.next, G += 1;
      ke.allBuffers = we, b(Z, ne, !0, ne.length, ke, "", X.finish), ne.pendingcb++, ne.lastBufferedRequest = null, X.next ? (ne.corkedRequestsFree = X.next, X.next = null) : ne.corkedRequestsFree = new r(ne), ne.bufferedRequestCount = 0;
    } else {
      for (; fe; ) {
        var Ae = fe.chunk, Oe = fe.encoding, qe = fe.callback, Ue = ne.objectMode ? 1 : Ae.length;
        if (b(Z, ne, !1, Ue, Ae, Oe, qe), fe = fe.next, ne.bufferedRequestCount--, ne.writing)
          break;
      }
      fe === null && (ne.lastBufferedRequest = null);
    }
    ne.bufferedRequest = fe, ne.bufferProcessing = !1;
  }
  oe.prototype._write = function(Z, ne, fe) {
    fe(new y("_write()"));
  }, oe.prototype._writev = null, oe.prototype.end = function(Z, ne, fe) {
    var le = this._writableState;
    return typeof Z == "function" ? (fe = Z, Z = null, ne = null) : typeof ne == "function" && (fe = ne, ne = null), Z != null && this.write(Z, ne), le.corked && (le.corked = 1, this.uncork()), le.ending || ee(this, le, fe), this;
  }, Object.defineProperty(oe.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function x(Z) {
    return Z.ending && Z.length === 0 && Z.bufferedRequest === null && !Z.finished && !Z.writing;
  }
  function T(Z, ne) {
    Z._final(function(fe) {
      ne.pendingcb--, fe && U(Z, fe), ne.prefinished = !0, Z.emit("prefinish"), B(Z, ne);
    });
  }
  function p(Z, ne) {
    !ne.prefinished && !ne.finalCalled && (typeof Z._final == "function" && !ne.destroyed ? (ne.pendingcb++, ne.finalCalled = !0, Bt.nextTick(T, Z, ne)) : (ne.prefinished = !0, Z.emit("prefinish")));
  }
  function B(Z, ne) {
    var fe = x(ne);
    if (fe && (p(Z, ne), ne.pendingcb === 0 && (ne.finished = !0, Z.emit("finish"), ne.autoDestroy))) {
      var le = Z._readableState;
      (!le || le.autoDestroy && le.endEmitted) && Z.destroy();
    }
    return fe;
  }
  function ee(Z, ne, fe) {
    ne.ending = !0, B(Z, ne), fe && (ne.finished ? Bt.nextTick(fe) : Z.once("finish", fe)), ne.ended = !0, Z.writable = !1;
  }
  function ae(Z, ne, fe) {
    var le = Z.entry;
    for (Z.entry = null; le; ) {
      var ke = le.callback;
      ne.pendingcb--, ke(fe), le = le.next;
    }
    ne.corkedRequestsFree.next = Z;
  }
  return Object.defineProperty(oe.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(ne) {
      this._writableState && (this._writableState.destroyed = ne);
    }
  }), oe.prototype.destroy = c.destroy, oe.prototype._undestroy = c.undestroy, oe.prototype._destroy = function(Z, ne) {
    ne(Z);
  }, qs;
}
var Ls, a0;
function ni() {
  if (a0)
    return Ls;
  a0 = 1;
  var r = Object.keys || function(h) {
    var s = [];
    for (var d in h)
      s.push(d);
    return s;
  };
  Ls = o;
  var e = Jc(), t = Gc();
  Ft()(o, e);
  for (var n = r(t.prototype), a = 0; a < n.length; a++) {
    var i = n[a];
    o.prototype[i] || (o.prototype[i] = t.prototype[i]);
  }
  function o(h) {
    if (!(this instanceof o))
      return new o(h);
    e.call(this, h), t.call(this, h), this.allowHalfOpen = !0, h && (h.readable === !1 && (this.readable = !1), h.writable === !1 && (this.writable = !1), h.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", u)));
  }
  Object.defineProperty(o.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(o.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(o.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function u() {
    this._writableState.ended || Bt.nextTick(c, this);
  }
  function c(h) {
    h.end();
  }
  return Object.defineProperty(o.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(s) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = s, this._writableState.destroyed = s);
    }
  }), Ls;
}
var Fs = {}, o0;
function uc() {
  if (o0)
    return Fs;
  o0 = 1;
  var r = $t().Buffer, e = r.isEncoding || function(S) {
    switch (S = "" + S, S && S.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function t(S) {
    if (!S)
      return "utf8";
    for (var P; ; )
      switch (S) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return S;
        default:
          if (P)
            return;
          S = ("" + S).toLowerCase(), P = !0;
      }
  }
  function n(S) {
    var P = t(S);
    if (typeof P != "string" && (r.isEncoding === e || !e(S)))
      throw new Error("Unknown encoding: " + S);
    return P || S;
  }
  Fs.StringDecoder = a;
  function a(S) {
    this.encoding = n(S);
    var P;
    switch (this.encoding) {
      case "utf16le":
        this.text = d, this.end = l, P = 4;
        break;
      case "utf8":
        this.fillLast = c, P = 4;
        break;
      case "base64":
        this.text = y, this.end = m, P = 3;
        break;
      default:
        this.write = w, this.end = E;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = r.allocUnsafe(P);
  }
  a.prototype.write = function(S) {
    if (S.length === 0)
      return "";
    var P, L;
    if (this.lastNeed) {
      if (P = this.fillLast(S), P === void 0)
        return "";
      L = this.lastNeed, this.lastNeed = 0;
    } else
      L = 0;
    return L < S.length ? P ? P + this.text(S, L) : this.text(S, L) : P || "";
  }, a.prototype.end = s, a.prototype.text = h, a.prototype.fillLast = function(S) {
    if (this.lastNeed <= S.length)
      return S.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    S.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, S.length), this.lastNeed -= S.length;
  };
  function i(S) {
    return S <= 127 ? 0 : S >> 5 === 6 ? 2 : S >> 4 === 14 ? 3 : S >> 3 === 30 ? 4 : S >> 6 === 2 ? -1 : -2;
  }
  function o(S, P, L) {
    var U = P.length - 1;
    if (U < L)
      return 0;
    var z = i(P[U]);
    return z >= 0 ? (z > 0 && (S.lastNeed = z - 1), z) : --U < L || z === -2 ? 0 : (z = i(P[U]), z >= 0 ? (z > 0 && (S.lastNeed = z - 2), z) : --U < L || z === -2 ? 0 : (z = i(P[U]), z >= 0 ? (z > 0 && (z === 2 ? z = 0 : S.lastNeed = z - 3), z) : 0));
  }
  function u(S, P, L) {
    if ((P[0] & 192) !== 128)
      return S.lastNeed = 0, "";
    if (S.lastNeed > 1 && P.length > 1) {
      if ((P[1] & 192) !== 128)
        return S.lastNeed = 1, "";
      if (S.lastNeed > 2 && P.length > 2 && (P[2] & 192) !== 128)
        return S.lastNeed = 2, "";
    }
  }
  function c(S) {
    var P = this.lastTotal - this.lastNeed, L = u(this, S);
    if (L !== void 0)
      return L;
    if (this.lastNeed <= S.length)
      return S.copy(this.lastChar, P, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    S.copy(this.lastChar, P, 0, S.length), this.lastNeed -= S.length;
  }
  function h(S, P) {
    var L = o(this, S, P);
    if (!this.lastNeed)
      return S.toString("utf8", P);
    this.lastTotal = L;
    var U = S.length - (L - this.lastNeed);
    return S.copy(this.lastChar, 0, U), S.toString("utf8", P, U);
  }
  function s(S) {
    var P = S && S.length ? this.write(S) : "";
    return this.lastNeed ? P + "" : P;
  }
  function d(S, P) {
    if ((S.length - P) % 2 === 0) {
      var L = S.toString("utf16le", P);
      if (L) {
        var U = L.charCodeAt(L.length - 1);
        if (U >= 55296 && U <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = S[S.length - 2], this.lastChar[1] = S[S.length - 1], L.slice(0, -1);
      }
      return L;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = S[S.length - 1], S.toString("utf16le", P, S.length - 1);
  }
  function l(S) {
    var P = S && S.length ? this.write(S) : "";
    if (this.lastNeed) {
      var L = this.lastTotal - this.lastNeed;
      return P + this.lastChar.toString("utf16le", 0, L);
    }
    return P;
  }
  function y(S, P) {
    var L = (S.length - P) % 3;
    return L === 0 ? S.toString("base64", P) : (this.lastNeed = 3 - L, this.lastTotal = 3, L === 1 ? this.lastChar[0] = S[S.length - 1] : (this.lastChar[0] = S[S.length - 2], this.lastChar[1] = S[S.length - 1]), S.toString("base64", P, S.length - L));
  }
  function m(S) {
    var P = S && S.length ? this.write(S) : "";
    return this.lastNeed ? P + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : P;
  }
  function w(S) {
    return S.toString(this.encoding);
  }
  function E(S) {
    return S && S.length ? this.write(S) : "";
  }
  return Fs;
}
var Us, s0;
function Mo() {
  if (s0)
    return Us;
  s0 = 1;
  var r = Ri().codes.ERR_STREAM_PREMATURE_CLOSE;
  function e(i) {
    var o = !1;
    return function() {
      if (!o) {
        o = !0;
        for (var u = arguments.length, c = new Array(u), h = 0; h < u; h++)
          c[h] = arguments[h];
        i.apply(this, c);
      }
    };
  }
  function t() {
  }
  function n(i) {
    return i.setHeader && typeof i.abort == "function";
  }
  function a(i, o, u) {
    if (typeof o == "function")
      return a(i, null, o);
    o || (o = {}), u = e(u || t);
    var c = o.readable || o.readable !== !1 && i.readable, h = o.writable || o.writable !== !1 && i.writable, s = function() {
      i.writable || l();
    }, d = i._writableState && i._writableState.finished, l = function() {
      h = !1, d = !0, c || u.call(i);
    }, y = i._readableState && i._readableState.endEmitted, m = function() {
      c = !1, y = !0, h || u.call(i);
    }, w = function(L) {
      u.call(i, L);
    }, E = function() {
      var L;
      if (c && !y)
        return (!i._readableState || !i._readableState.ended) && (L = new r()), u.call(i, L);
      if (h && !d)
        return (!i._writableState || !i._writableState.ended) && (L = new r()), u.call(i, L);
    }, S = function() {
      i.req.on("finish", l);
    };
    return n(i) ? (i.on("complete", l), i.on("abort", E), i.req ? S() : i.on("request", S)) : h && !i._writableState && (i.on("end", s), i.on("close", s)), i.on("end", m), i.on("finish", l), o.error !== !1 && i.on("error", w), i.on("close", E), function() {
      i.removeListener("complete", l), i.removeListener("abort", E), i.removeListener("request", S), i.req && i.req.removeListener("finish", l), i.removeListener("end", s), i.removeListener("close", s), i.removeListener("finish", l), i.removeListener("end", m), i.removeListener("error", w), i.removeListener("close", E);
    };
  }
  return Us = a, Us;
}
var $s, f0;
function X2() {
  if (f0)
    return $s;
  f0 = 1;
  var r;
  function e(L, U, z) {
    return U = t(U), U in L ? Object.defineProperty(L, U, { value: z, enumerable: !0, configurable: !0, writable: !0 }) : L[U] = z, L;
  }
  function t(L) {
    var U = n(L, "string");
    return typeof U == "symbol" ? U : String(U);
  }
  function n(L, U) {
    if (typeof L != "object" || L === null)
      return L;
    var z = L[Symbol.toPrimitive];
    if (z !== void 0) {
      var K = z.call(L, U || "default");
      if (typeof K != "object")
        return K;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (U === "string" ? String : Number)(L);
  }
  var a = Mo(), i = Symbol("lastResolve"), o = Symbol("lastReject"), u = Symbol("error"), c = Symbol("ended"), h = Symbol("lastPromise"), s = Symbol("handlePromise"), d = Symbol("stream");
  function l(L, U) {
    return {
      value: L,
      done: U
    };
  }
  function y(L) {
    var U = L[i];
    if (U !== null) {
      var z = L[d].read();
      z !== null && (L[h] = null, L[i] = null, L[o] = null, U(l(z, !1)));
    }
  }
  function m(L) {
    Bt.nextTick(y, L);
  }
  function w(L, U) {
    return function(z, K) {
      L.then(function() {
        if (U[c]) {
          z(l(void 0, !0));
          return;
        }
        U[s](z, K);
      }, K);
    };
  }
  var E = Object.getPrototypeOf(function() {
  }), S = Object.setPrototypeOf((r = {
    get stream() {
      return this[d];
    },
    next: function() {
      var U = this, z = this[u];
      if (z !== null)
        return Promise.reject(z);
      if (this[c])
        return Promise.resolve(l(void 0, !0));
      if (this[d].destroyed)
        return new Promise(function(se, ve) {
          Bt.nextTick(function() {
            U[u] ? ve(U[u]) : se(l(void 0, !0));
          });
        });
      var K = this[h], re;
      if (K)
        re = new Promise(w(K, this));
      else {
        var oe = this[d].read();
        if (oe !== null)
          return Promise.resolve(l(oe, !1));
        re = new Promise(this[s]);
      }
      return this[h] = re, re;
    }
  }, e(r, Symbol.asyncIterator, function() {
    return this;
  }), e(r, "return", function() {
    var U = this;
    return new Promise(function(z, K) {
      U[d].destroy(null, function(re) {
        if (re) {
          K(re);
          return;
        }
        z(l(void 0, !0));
      });
    });
  }), r), E), P = function(U) {
    var z, K = Object.create(S, (z = {}, e(z, d, {
      value: U,
      writable: !0
    }), e(z, i, {
      value: null,
      writable: !0
    }), e(z, o, {
      value: null,
      writable: !0
    }), e(z, u, {
      value: null,
      writable: !0
    }), e(z, c, {
      value: U._readableState.endEmitted,
      writable: !0
    }), e(z, s, {
      value: function(oe, se) {
        var ve = K[d].read();
        ve ? (K[h] = null, K[i] = null, K[o] = null, oe(l(ve, !1))) : (K[i] = oe, K[o] = se);
      },
      writable: !0
    }), z));
    return K[h] = null, a(U, function(re) {
      if (re && re.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var oe = K[o];
        oe !== null && (K[h] = null, K[i] = null, K[o] = null, oe(re)), K[u] = re;
        return;
      }
      var se = K[i];
      se !== null && (K[h] = null, K[i] = null, K[o] = null, se(l(void 0, !0))), K[c] = !0;
    }), U.on("readable", m.bind(null, K)), K;
  };
  return $s = P, $s;
}
var js, u0;
function Z2() {
  return u0 || (u0 = 1, js = function() {
    throw new Error("Readable.from is not available in the browser");
  }), js;
}
var Hs, c0;
function Jc() {
  if (c0)
    return Hs;
  c0 = 1, Hs = se;
  var r;
  se.ReadableState = oe, zc().EventEmitter;
  var e = function(G, we) {
    return G.listeners(we).length;
  }, t = l1(), n = Mn.Buffer, a = (typeof Jt != "undefined" ? Jt : typeof window != "undefined" ? window : typeof self != "undefined" ? self : {}).Uint8Array || function() {
  };
  function i(X) {
    return n.from(X);
  }
  function o(X) {
    return n.isBuffer(X) || X instanceof a;
  }
  var u = m1(), c;
  u && u.debuglog ? c = u.debuglog("stream") : c = function() {
  };
  var h = J2(), s = g1(), d = w1(), l = d.getHighWaterMark, y = Ri().codes, m = y.ERR_INVALID_ARG_TYPE, w = y.ERR_STREAM_PUSH_AFTER_EOF, E = y.ERR_METHOD_NOT_IMPLEMENTED, S = y.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, P, L, U;
  Ft()(se, t);
  var z = s.errorOrDestroy, K = ["error", "close", "destroy", "pause", "resume"];
  function re(X, G, we) {
    if (typeof X.prependListener == "function")
      return X.prependListener(G, we);
    !X._events || !X._events[G] ? X.on(G, we) : Array.isArray(X._events[G]) ? X._events[G].unshift(we) : X._events[G] = [we, X._events[G]];
  }
  function oe(X, G, we) {
    r = r || ni(), X = X || {}, typeof we != "boolean" && (we = G instanceof r), this.objectMode = !!X.objectMode, we && (this.objectMode = this.objectMode || !!X.readableObjectMode), this.highWaterMark = l(this, X, "readableHighWaterMark", we), this.buffer = new h(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = X.emitClose !== !1, this.autoDestroy = !!X.autoDestroy, this.destroyed = !1, this.defaultEncoding = X.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, X.encoding && (P || (P = uc().StringDecoder), this.decoder = new P(X.encoding), this.encoding = X.encoding);
  }
  function se(X) {
    if (r = r || ni(), !(this instanceof se))
      return new se(X);
    var G = this instanceof r;
    this._readableState = new oe(X, this, G), this.readable = !0, X && (typeof X.read == "function" && (this._read = X.read), typeof X.destroy == "function" && (this._destroy = X.destroy)), t.call(this);
  }
  Object.defineProperty(se.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(G) {
      this._readableState && (this._readableState.destroyed = G);
    }
  }), se.prototype.destroy = s.destroy, se.prototype._undestroy = s.undestroy, se.prototype._destroy = function(X, G) {
    G(X);
  }, se.prototype.push = function(X, G) {
    var we = this._readableState, Ae;
    return we.objectMode ? Ae = !0 : typeof X == "string" && (G = G || we.defaultEncoding, G !== we.encoding && (X = n.from(X, G), G = ""), Ae = !0), ve(this, X, G, !1, Ae);
  }, se.prototype.unshift = function(X) {
    return ve(this, X, null, !0, !1);
  };
  function ve(X, G, we, Ae, Oe) {
    c("readableAddChunk", G);
    var qe = X._readableState;
    if (G === null)
      qe.reading = !1, g(X, qe);
    else {
      var Ue;
      if (Oe || (Ue = A(qe, G)), Ue)
        z(X, Ue);
      else if (qe.objectMode || G && G.length > 0)
        if (typeof G != "string" && !qe.objectMode && Object.getPrototypeOf(G) !== n.prototype && (G = i(G)), Ae)
          qe.endEmitted ? z(X, new S()) : Q(X, qe, G, !0);
        else if (qe.ended)
          z(X, new w());
        else {
          if (qe.destroyed)
            return !1;
          qe.reading = !1, qe.decoder && !we ? (G = qe.decoder.write(G), qe.objectMode || G.length !== 0 ? Q(X, qe, G, !1) : R(X, qe)) : Q(X, qe, G, !1);
        }
      else
        Ae || (qe.reading = !1, R(X, qe));
    }
    return !qe.ended && (qe.length < qe.highWaterMark || qe.length === 0);
  }
  function Q(X, G, we, Ae) {
    G.flowing && G.length === 0 && !G.sync ? (G.awaitDrain = 0, X.emit("data", we)) : (G.length += G.objectMode ? 1 : we.length, Ae ? G.buffer.unshift(we) : G.buffer.push(we), G.needReadable && M(X)), R(X, G);
  }
  function A(X, G) {
    var we;
    return !o(G) && typeof G != "string" && G !== void 0 && !X.objectMode && (we = new m("chunk", ["string", "Buffer", "Uint8Array"], G)), we;
  }
  se.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, se.prototype.setEncoding = function(X) {
    P || (P = uc().StringDecoder);
    var G = new P(X);
    this._readableState.decoder = G, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var we = this._readableState.buffer.head, Ae = ""; we !== null; )
      Ae += G.write(we.data), we = we.next;
    return this._readableState.buffer.clear(), Ae !== "" && this._readableState.buffer.push(Ae), this._readableState.length = Ae.length, this;
  };
  var b = 1073741824;
  function f(X) {
    return X >= b ? X = b : (X--, X |= X >>> 1, X |= X >>> 2, X |= X >>> 4, X |= X >>> 8, X |= X >>> 16, X++), X;
  }
  function v(X, G) {
    return X <= 0 || G.length === 0 && G.ended ? 0 : G.objectMode ? 1 : X !== X ? G.flowing && G.length ? G.buffer.head.data.length : G.length : (X > G.highWaterMark && (G.highWaterMark = f(X)), X <= G.length ? X : G.ended ? G.length : (G.needReadable = !0, 0));
  }
  se.prototype.read = function(X) {
    c("read", X), X = parseInt(X, 10);
    var G = this._readableState, we = X;
    if (X !== 0 && (G.emittedReadable = !1), X === 0 && G.needReadable && ((G.highWaterMark !== 0 ? G.length >= G.highWaterMark : G.length > 0) || G.ended))
      return c("read: emitReadable", G.length, G.ended), G.length === 0 && G.ended ? fe(this) : M(this), null;
    if (X = v(X, G), X === 0 && G.ended)
      return G.length === 0 && fe(this), null;
    var Ae = G.needReadable;
    c("need readable", Ae), (G.length === 0 || G.length - X < G.highWaterMark) && (Ae = !0, c("length less than watermark", Ae)), G.ended || G.reading ? (Ae = !1, c("reading or ended", Ae)) : Ae && (c("do read"), G.reading = !0, G.sync = !0, G.length === 0 && (G.needReadable = !0), this._read(G.highWaterMark), G.sync = !1, G.reading || (X = v(we, G)));
    var Oe;
    return X > 0 ? Oe = ne(X, G) : Oe = null, Oe === null ? (G.needReadable = G.length <= G.highWaterMark, X = 0) : (G.length -= X, G.awaitDrain = 0), G.length === 0 && (G.ended || (G.needReadable = !0), we !== X && G.ended && fe(this)), Oe !== null && this.emit("data", Oe), Oe;
  };
  function g(X, G) {
    if (c("onEofChunk"), !G.ended) {
      if (G.decoder) {
        var we = G.decoder.end();
        we && we.length && (G.buffer.push(we), G.length += G.objectMode ? 1 : we.length);
      }
      G.ended = !0, G.sync ? M(X) : (G.needReadable = !1, G.emittedReadable || (G.emittedReadable = !0, I(X)));
    }
  }
  function M(X) {
    var G = X._readableState;
    c("emitReadable", G.needReadable, G.emittedReadable), G.needReadable = !1, G.emittedReadable || (c("emitReadable", G.flowing), G.emittedReadable = !0, Bt.nextTick(I, X));
  }
  function I(X) {
    var G = X._readableState;
    c("emitReadable_", G.destroyed, G.length, G.ended), !G.destroyed && (G.length || G.ended) && (X.emit("readable"), G.emittedReadable = !1), G.needReadable = !G.flowing && !G.ended && G.length <= G.highWaterMark, Z(X);
  }
  function R(X, G) {
    G.readingMore || (G.readingMore = !0, Bt.nextTick(x, X, G));
  }
  function x(X, G) {
    for (; !G.reading && !G.ended && (G.length < G.highWaterMark || G.flowing && G.length === 0); ) {
      var we = G.length;
      if (c("maybeReadMore read 0"), X.read(0), we === G.length)
        break;
    }
    G.readingMore = !1;
  }
  se.prototype._read = function(X) {
    z(this, new E("_read()"));
  }, se.prototype.pipe = function(X, G) {
    var we = this, Ae = this._readableState;
    switch (Ae.pipesCount) {
      case 0:
        Ae.pipes = X;
        break;
      case 1:
        Ae.pipes = [Ae.pipes, X];
        break;
      default:
        Ae.pipes.push(X);
        break;
    }
    Ae.pipesCount += 1, c("pipe count=%d opts=%j", Ae.pipesCount, G);
    var Oe = (!G || G.end !== !1) && X !== Bt.stdout && X !== Bt.stderr, qe = Oe ? ze : lt;
    Ae.endEmitted ? Bt.nextTick(qe) : we.once("end", qe), X.on("unpipe", Ue);
    function Ue(Xe, st) {
      c("onunpipe"), Xe === we && st && st.hasUnpiped === !1 && (st.hasUnpiped = !0, $e());
    }
    function ze() {
      c("onend"), X.end();
    }
    var ge = T(we);
    X.on("drain", ge);
    var ht = !1;
    function $e() {
      c("cleanup"), X.removeListener("close", Ve), X.removeListener("finish", Mt), X.removeListener("drain", ge), X.removeListener("error", ot), X.removeListener("unpipe", Ue), we.removeListener("end", ze), we.removeListener("end", lt), we.removeListener("data", Et), ht = !0, Ae.awaitDrain && (!X._writableState || X._writableState.needDrain) && ge();
    }
    we.on("data", Et);
    function Et(Xe) {
      c("ondata");
      var st = X.write(Xe);
      c("dest.write", st), st === !1 && ((Ae.pipesCount === 1 && Ae.pipes === X || Ae.pipesCount > 1 && ke(Ae.pipes, X) !== -1) && !ht && (c("false write response, pause", Ae.awaitDrain), Ae.awaitDrain++), we.pause());
    }
    function ot(Xe) {
      c("onerror", Xe), lt(), X.removeListener("error", ot), e(X, "error") === 0 && z(X, Xe);
    }
    re(X, "error", ot);
    function Ve() {
      X.removeListener("finish", Mt), lt();
    }
    X.once("close", Ve);
    function Mt() {
      c("onfinish"), X.removeListener("close", Ve), lt();
    }
    X.once("finish", Mt);
    function lt() {
      c("unpipe"), we.unpipe(X);
    }
    return X.emit("pipe", we), Ae.flowing || (c("pipe resume"), we.resume()), X;
  };
  function T(X) {
    return function() {
      var we = X._readableState;
      c("pipeOnDrain", we.awaitDrain), we.awaitDrain && we.awaitDrain--, we.awaitDrain === 0 && e(X, "data") && (we.flowing = !0, Z(X));
    };
  }
  se.prototype.unpipe = function(X) {
    var G = this._readableState, we = {
      hasUnpiped: !1
    };
    if (G.pipesCount === 0)
      return this;
    if (G.pipesCount === 1)
      return X && X !== G.pipes ? this : (X || (X = G.pipes), G.pipes = null, G.pipesCount = 0, G.flowing = !1, X && X.emit("unpipe", this, we), this);
    if (!X) {
      var Ae = G.pipes, Oe = G.pipesCount;
      G.pipes = null, G.pipesCount = 0, G.flowing = !1;
      for (var qe = 0; qe < Oe; qe++)
        Ae[qe].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    var Ue = ke(G.pipes, X);
    return Ue === -1 ? this : (G.pipes.splice(Ue, 1), G.pipesCount -= 1, G.pipesCount === 1 && (G.pipes = G.pipes[0]), X.emit("unpipe", this, we), this);
  }, se.prototype.on = function(X, G) {
    var we = t.prototype.on.call(this, X, G), Ae = this._readableState;
    return X === "data" ? (Ae.readableListening = this.listenerCount("readable") > 0, Ae.flowing !== !1 && this.resume()) : X === "readable" && !Ae.endEmitted && !Ae.readableListening && (Ae.readableListening = Ae.needReadable = !0, Ae.flowing = !1, Ae.emittedReadable = !1, c("on readable", Ae.length, Ae.reading), Ae.length ? M(this) : Ae.reading || Bt.nextTick(B, this)), we;
  }, se.prototype.addListener = se.prototype.on, se.prototype.removeListener = function(X, G) {
    var we = t.prototype.removeListener.call(this, X, G);
    return X === "readable" && Bt.nextTick(p, this), we;
  }, se.prototype.removeAllListeners = function(X) {
    var G = t.prototype.removeAllListeners.apply(this, arguments);
    return (X === "readable" || X === void 0) && Bt.nextTick(p, this), G;
  };
  function p(X) {
    var G = X._readableState;
    G.readableListening = X.listenerCount("readable") > 0, G.resumeScheduled && !G.paused ? G.flowing = !0 : X.listenerCount("data") > 0 && X.resume();
  }
  function B(X) {
    c("readable nexttick read 0"), X.read(0);
  }
  se.prototype.resume = function() {
    var X = this._readableState;
    return X.flowing || (c("resume"), X.flowing = !X.readableListening, ee(this, X)), X.paused = !1, this;
  };
  function ee(X, G) {
    G.resumeScheduled || (G.resumeScheduled = !0, Bt.nextTick(ae, X, G));
  }
  function ae(X, G) {
    c("resume", G.reading), G.reading || X.read(0), G.resumeScheduled = !1, X.emit("resume"), Z(X), G.flowing && !G.reading && X.read(0);
  }
  se.prototype.pause = function() {
    return c("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (c("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function Z(X) {
    var G = X._readableState;
    for (c("flow", G.flowing); G.flowing && X.read() !== null; )
      ;
  }
  se.prototype.wrap = function(X) {
    var G = this, we = this._readableState, Ae = !1;
    X.on("end", function() {
      if (c("wrapped end"), we.decoder && !we.ended) {
        var Ue = we.decoder.end();
        Ue && Ue.length && G.push(Ue);
      }
      G.push(null);
    }), X.on("data", function(Ue) {
      if (c("wrapped data"), we.decoder && (Ue = we.decoder.write(Ue)), !(we.objectMode && Ue == null) && !(!we.objectMode && (!Ue || !Ue.length))) {
        var ze = G.push(Ue);
        ze || (Ae = !0, X.pause());
      }
    });
    for (var Oe in X)
      this[Oe] === void 0 && typeof X[Oe] == "function" && (this[Oe] = /* @__PURE__ */ function(ze) {
        return function() {
          return X[ze].apply(X, arguments);
        };
      }(Oe));
    for (var qe = 0; qe < K.length; qe++)
      X.on(K[qe], this.emit.bind(this, K[qe]));
    return this._read = function(Ue) {
      c("wrapped _read", Ue), Ae && (Ae = !1, X.resume());
    }, this;
  }, typeof Symbol == "function" && (se.prototype[Symbol.asyncIterator] = function() {
    return L === void 0 && (L = X2()), L(this);
  }), Object.defineProperty(se.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(se.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(se.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(G) {
      this._readableState && (this._readableState.flowing = G);
    }
  }), se._fromList = ne, Object.defineProperty(se.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function ne(X, G) {
    if (G.length === 0)
      return null;
    var we;
    return G.objectMode ? we = G.buffer.shift() : !X || X >= G.length ? (G.decoder ? we = G.buffer.join("") : G.buffer.length === 1 ? we = G.buffer.first() : we = G.buffer.concat(G.length), G.buffer.clear()) : we = G.buffer.consume(X, G.decoder), we;
  }
  function fe(X) {
    var G = X._readableState;
    c("endReadable", G.endEmitted), G.endEmitted || (G.ended = !0, Bt.nextTick(le, G, X));
  }
  function le(X, G) {
    if (c("endReadableNT", X.endEmitted, X.length), !X.endEmitted && X.length === 0 && (X.endEmitted = !0, G.readable = !1, G.emit("end"), X.autoDestroy)) {
      var we = G._writableState;
      (!we || we.autoDestroy && we.finished) && G.destroy();
    }
  }
  typeof Symbol == "function" && (se.from = function(X, G) {
    return U === void 0 && (U = Z2()), U(se, X, G);
  });
  function ke(X, G) {
    for (var we = 0, Ae = X.length; we < Ae; we++)
      if (X[we] === G)
        return we;
    return -1;
  }
  return Hs;
}
var zs, h0;
function Yc() {
  if (h0)
    return zs;
  h0 = 1, zs = u;
  var r = Ri().codes, e = r.ERR_METHOD_NOT_IMPLEMENTED, t = r.ERR_MULTIPLE_CALLBACK, n = r.ERR_TRANSFORM_ALREADY_TRANSFORMING, a = r.ERR_TRANSFORM_WITH_LENGTH_0, i = ni();
  Ft()(u, i);
  function o(s, d) {
    var l = this._transformState;
    l.transforming = !1;
    var y = l.writecb;
    if (y === null)
      return this.emit("error", new t());
    l.writechunk = null, l.writecb = null, d != null && this.push(d), y(s);
    var m = this._readableState;
    m.reading = !1, (m.needReadable || m.length < m.highWaterMark) && this._read(m.highWaterMark);
  }
  function u(s) {
    if (!(this instanceof u))
      return new u(s);
    i.call(this, s), this._transformState = {
      afterTransform: o.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, s && (typeof s.transform == "function" && (this._transform = s.transform), typeof s.flush == "function" && (this._flush = s.flush)), this.on("prefinish", c);
  }
  function c() {
    var s = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(d, l) {
      h(s, d, l);
    }) : h(this, null, null);
  }
  u.prototype.push = function(s, d) {
    return this._transformState.needTransform = !1, i.prototype.push.call(this, s, d);
  }, u.prototype._transform = function(s, d, l) {
    l(new e("_transform()"));
  }, u.prototype._write = function(s, d, l) {
    var y = this._transformState;
    if (y.writecb = l, y.writechunk = s, y.writeencoding = d, !y.transforming) {
      var m = this._readableState;
      (y.needTransform || m.needReadable || m.length < m.highWaterMark) && this._read(m.highWaterMark);
    }
  }, u.prototype._read = function(s) {
    var d = this._transformState;
    d.writechunk !== null && !d.transforming ? (d.transforming = !0, this._transform(d.writechunk, d.writeencoding, d.afterTransform)) : d.needTransform = !0;
  }, u.prototype._destroy = function(s, d) {
    i.prototype._destroy.call(this, s, function(l) {
      d(l);
    });
  };
  function h(s, d, l) {
    if (d)
      return s.emit("error", d);
    if (l != null && s.push(l), s._writableState.length)
      throw new a();
    if (s._transformState.transforming)
      throw new n();
    return s.push(null);
  }
  return zs;
}
var Vs, l0;
function _1() {
  if (l0)
    return Vs;
  l0 = 1, Vs = e;
  var r = Yc();
  Ft()(e, r);
  function e(t) {
    if (!(this instanceof e))
      return new e(t);
    r.call(this, t);
  }
  return e.prototype._transform = function(t, n, a) {
    a(null, t);
  }, Vs;
}
var Ws, d0;
function x1() {
  if (d0)
    return Ws;
  d0 = 1;
  var r;
  function e(l) {
    var y = !1;
    return function() {
      y || (y = !0, l.apply(void 0, arguments));
    };
  }
  var t = Ri().codes, n = t.ERR_MISSING_ARGS, a = t.ERR_STREAM_DESTROYED;
  function i(l) {
    if (l)
      throw l;
  }
  function o(l) {
    return l.setHeader && typeof l.abort == "function";
  }
  function u(l, y, m, w) {
    w = e(w);
    var E = !1;
    l.on("close", function() {
      E = !0;
    }), r === void 0 && (r = Mo()), r(l, {
      readable: y,
      writable: m
    }, function(P) {
      if (P)
        return w(P);
      E = !0, w();
    });
    var S = !1;
    return function(P) {
      if (!E && !S) {
        if (S = !0, o(l))
          return l.abort();
        if (typeof l.destroy == "function")
          return l.destroy();
        w(P || new a("pipe"));
      }
    };
  }
  function c(l) {
    l();
  }
  function h(l, y) {
    return l.pipe(y);
  }
  function s(l) {
    return !l.length || typeof l[l.length - 1] != "function" ? i : l.pop();
  }
  function d() {
    for (var l = arguments.length, y = new Array(l), m = 0; m < l; m++)
      y[m] = arguments[m];
    var w = s(y);
    if (Array.isArray(y[0]) && (y = y[0]), y.length < 2)
      throw new n("streams");
    var E, S = y.map(function(P, L) {
      var U = L < y.length - 1, z = L > 0;
      return u(P, U, z, function(K) {
        E || (E = K), K && S.forEach(c), !U && (S.forEach(c), w(E));
      });
    });
    return y.reduce(h);
  }
  return Ws = d, Ws;
}
var p0;
function S1() {
  return p0 || (p0 = 1, function(r, e) {
    e = r.exports = Jc(), e.Stream = e, e.Readable = e, e.Writable = Gc(), e.Duplex = ni(), e.Transform = Yc(), e.PassThrough = _1(), e.finished = Mo(), e.pipeline = x1();
  }(Ba, Ba.exports)), Ba.exports;
}
var Ks, v0;
function E1() {
  if (v0)
    return Ks;
  v0 = 1;
  var r = $t().Buffer, e = S1().Transform, t = Ft();
  function n(i, o) {
    if (!r.isBuffer(i) && typeof i != "string")
      throw new TypeError(o + " must be a string or a buffer");
  }
  function a(i) {
    e.call(this), this._block = r.allocUnsafe(i), this._blockSize = i, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
  }
  return t(a, e), a.prototype._transform = function(i, o, u) {
    var c = null;
    try {
      this.update(i, o);
    } catch (h) {
      c = h;
    }
    u(c);
  }, a.prototype._flush = function(i) {
    var o = null;
    try {
      this.push(this.digest());
    } catch (u) {
      o = u;
    }
    i(o);
  }, a.prototype.update = function(i, o) {
    if (n(i, "Data"), this._finalized)
      throw new Error("Digest already called");
    r.isBuffer(i) || (i = r.from(i, o));
    for (var u = this._block, c = 0; this._blockOffset + i.length - c >= this._blockSize; ) {
      for (var h = this._blockOffset; h < this._blockSize; )
        u[h++] = i[c++];
      this._update(), this._blockOffset = 0;
    }
    for (; c < i.length; )
      u[this._blockOffset++] = i[c++];
    for (var s = 0, d = i.length * 8; d > 0; ++s)
      this._length[s] += d, d = this._length[s] / 4294967296 | 0, d > 0 && (this._length[s] -= 4294967296 * d);
    return this;
  }, a.prototype._update = function() {
    throw new Error("_update is not implemented");
  }, a.prototype.digest = function(i) {
    if (this._finalized)
      throw new Error("Digest already called");
    this._finalized = !0;
    var o = this._digest();
    i !== void 0 && (o = o.toString(i)), this._block.fill(0), this._blockOffset = 0;
    for (var u = 0; u < 4; ++u)
      this._length[u] = 0;
    return o;
  }, a.prototype._digest = function() {
    throw new Error("_digest is not implemented");
  }, Ks = a, Ks;
}
var Qs, y0;
function Xc() {
  if (y0)
    return Qs;
  y0 = 1;
  var r = Ft(), e = E1(), t = $t().Buffer, n = new Array(16);
  function a() {
    e.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
  }
  r(a, e), a.prototype._update = function() {
    for (var s = n, d = 0; d < 16; ++d)
      s[d] = this._block.readInt32LE(d * 4);
    var l = this._a, y = this._b, m = this._c, w = this._d;
    l = o(l, y, m, w, s[0], 3614090360, 7), w = o(w, l, y, m, s[1], 3905402710, 12), m = o(m, w, l, y, s[2], 606105819, 17), y = o(y, m, w, l, s[3], 3250441966, 22), l = o(l, y, m, w, s[4], 4118548399, 7), w = o(w, l, y, m, s[5], 1200080426, 12), m = o(m, w, l, y, s[6], 2821735955, 17), y = o(y, m, w, l, s[7], 4249261313, 22), l = o(l, y, m, w, s[8], 1770035416, 7), w = o(w, l, y, m, s[9], 2336552879, 12), m = o(m, w, l, y, s[10], 4294925233, 17), y = o(y, m, w, l, s[11], 2304563134, 22), l = o(l, y, m, w, s[12], 1804603682, 7), w = o(w, l, y, m, s[13], 4254626195, 12), m = o(m, w, l, y, s[14], 2792965006, 17), y = o(y, m, w, l, s[15], 1236535329, 22), l = u(l, y, m, w, s[1], 4129170786, 5), w = u(w, l, y, m, s[6], 3225465664, 9), m = u(m, w, l, y, s[11], 643717713, 14), y = u(y, m, w, l, s[0], 3921069994, 20), l = u(l, y, m, w, s[5], 3593408605, 5), w = u(w, l, y, m, s[10], 38016083, 9), m = u(m, w, l, y, s[15], 3634488961, 14), y = u(y, m, w, l, s[4], 3889429448, 20), l = u(l, y, m, w, s[9], 568446438, 5), w = u(w, l, y, m, s[14], 3275163606, 9), m = u(m, w, l, y, s[3], 4107603335, 14), y = u(y, m, w, l, s[8], 1163531501, 20), l = u(l, y, m, w, s[13], 2850285829, 5), w = u(w, l, y, m, s[2], 4243563512, 9), m = u(m, w, l, y, s[7], 1735328473, 14), y = u(y, m, w, l, s[12], 2368359562, 20), l = c(l, y, m, w, s[5], 4294588738, 4), w = c(w, l, y, m, s[8], 2272392833, 11), m = c(m, w, l, y, s[11], 1839030562, 16), y = c(y, m, w, l, s[14], 4259657740, 23), l = c(l, y, m, w, s[1], 2763975236, 4), w = c(w, l, y, m, s[4], 1272893353, 11), m = c(m, w, l, y, s[7], 4139469664, 16), y = c(y, m, w, l, s[10], 3200236656, 23), l = c(l, y, m, w, s[13], 681279174, 4), w = c(w, l, y, m, s[0], 3936430074, 11), m = c(m, w, l, y, s[3], 3572445317, 16), y = c(y, m, w, l, s[6], 76029189, 23), l = c(l, y, m, w, s[9], 3654602809, 4), w = c(w, l, y, m, s[12], 3873151461, 11), m = c(m, w, l, y, s[15], 530742520, 16), y = c(y, m, w, l, s[2], 3299628645, 23), l = h(l, y, m, w, s[0], 4096336452, 6), w = h(w, l, y, m, s[7], 1126891415, 10), m = h(m, w, l, y, s[14], 2878612391, 15), y = h(y, m, w, l, s[5], 4237533241, 21), l = h(l, y, m, w, s[12], 1700485571, 6), w = h(w, l, y, m, s[3], 2399980690, 10), m = h(m, w, l, y, s[10], 4293915773, 15), y = h(y, m, w, l, s[1], 2240044497, 21), l = h(l, y, m, w, s[8], 1873313359, 6), w = h(w, l, y, m, s[15], 4264355552, 10), m = h(m, w, l, y, s[6], 2734768916, 15), y = h(y, m, w, l, s[13], 1309151649, 21), l = h(l, y, m, w, s[4], 4149444226, 6), w = h(w, l, y, m, s[11], 3174756917, 10), m = h(m, w, l, y, s[2], 718787259, 15), y = h(y, m, w, l, s[9], 3951481745, 21), this._a = this._a + l | 0, this._b = this._b + y | 0, this._c = this._c + m | 0, this._d = this._d + w | 0;
  }, a.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var s = t.allocUnsafe(16);
    return s.writeInt32LE(this._a, 0), s.writeInt32LE(this._b, 4), s.writeInt32LE(this._c, 8), s.writeInt32LE(this._d, 12), s;
  };
  function i(s, d) {
    return s << d | s >>> 32 - d;
  }
  function o(s, d, l, y, m, w, E) {
    return i(s + (d & l | ~d & y) + m + w | 0, E) + d | 0;
  }
  function u(s, d, l, y, m, w, E) {
    return i(s + (d & y | l & ~y) + m + w | 0, E) + d | 0;
  }
  function c(s, d, l, y, m, w, E) {
    return i(s + (d ^ l ^ y) + m + w | 0, E) + d | 0;
  }
  function h(s, d, l, y, m, w, E) {
    return i(s + (l ^ (d | ~y)) + m + w | 0, E) + d | 0;
  }
  return Qs = a, Qs;
}
var Gs, b0;
function Zc() {
  if (b0)
    return Gs;
  b0 = 1;
  var r = Mn.Buffer, e = Ft(), t = E1(), n = new Array(16), a = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], i = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], o = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], u = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ], c = [0, 1518500249, 1859775393, 2400959708, 2840853838], h = [1352829926, 1548603684, 1836072691, 2053994217, 0];
  function s() {
    t.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
  }
  e(s, t), s.prototype._update = function() {
    for (var S = n, P = 0; P < 16; ++P)
      S[P] = this._block.readInt32LE(P * 4);
    for (var L = this._a | 0, U = this._b | 0, z = this._c | 0, K = this._d | 0, re = this._e | 0, oe = this._a | 0, se = this._b | 0, ve = this._c | 0, Q = this._d | 0, A = this._e | 0, b = 0; b < 80; b += 1) {
      var f, v;
      b < 16 ? (f = l(L, U, z, K, re, S[a[b]], c[0], o[b]), v = E(oe, se, ve, Q, A, S[i[b]], h[0], u[b])) : b < 32 ? (f = y(L, U, z, K, re, S[a[b]], c[1], o[b]), v = w(oe, se, ve, Q, A, S[i[b]], h[1], u[b])) : b < 48 ? (f = m(L, U, z, K, re, S[a[b]], c[2], o[b]), v = m(oe, se, ve, Q, A, S[i[b]], h[2], u[b])) : b < 64 ? (f = w(L, U, z, K, re, S[a[b]], c[3], o[b]), v = y(oe, se, ve, Q, A, S[i[b]], h[3], u[b])) : (f = E(L, U, z, K, re, S[a[b]], c[4], o[b]), v = l(oe, se, ve, Q, A, S[i[b]], h[4], u[b])), L = re, re = K, K = d(z, 10), z = U, U = f, oe = A, A = Q, Q = d(ve, 10), ve = se, se = v;
    }
    var g = this._b + z + Q | 0;
    this._b = this._c + K + A | 0, this._c = this._d + re + oe | 0, this._d = this._e + L + se | 0, this._e = this._a + U + ve | 0, this._a = g;
  }, s.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var S = r.alloc ? r.alloc(20) : new r(20);
    return S.writeInt32LE(this._a, 0), S.writeInt32LE(this._b, 4), S.writeInt32LE(this._c, 8), S.writeInt32LE(this._d, 12), S.writeInt32LE(this._e, 16), S;
  };
  function d(S, P) {
    return S << P | S >>> 32 - P;
  }
  function l(S, P, L, U, z, K, re, oe) {
    return d(S + (P ^ L ^ U) + K + re | 0, oe) + z | 0;
  }
  function y(S, P, L, U, z, K, re, oe) {
    return d(S + (P & L | ~P & U) + K + re | 0, oe) + z | 0;
  }
  function m(S, P, L, U, z, K, re, oe) {
    return d(S + ((P | ~L) ^ U) + K + re | 0, oe) + z | 0;
  }
  function w(S, P, L, U, z, K, re, oe) {
    return d(S + (P & U | L & ~U) + K + re | 0, oe) + z | 0;
  }
  function E(S, P, L, U, z, K, re, oe) {
    return d(S + (P ^ (L | ~U)) + K + re | 0, oe) + z | 0;
  }
  return Gs = s, Gs;
}
var Js = { exports: {} }, Ys, m0;
function Ci() {
  if (m0)
    return Ys;
  m0 = 1;
  var r = $t().Buffer;
  function e(t, n) {
    this._block = r.alloc(t), this._finalSize = n, this._blockSize = t, this._len = 0;
  }
  return e.prototype.update = function(t, n) {
    typeof t == "string" && (n = n || "utf8", t = r.from(t, n));
    for (var a = this._block, i = this._blockSize, o = t.length, u = this._len, c = 0; c < o; ) {
      for (var h = u % i, s = Math.min(o - c, i - h), d = 0; d < s; d++)
        a[h + d] = t[c + d];
      u += s, c += s, u % i === 0 && this._update(a);
    }
    return this._len += o, this;
  }, e.prototype.digest = function(t) {
    var n = this._len % this._blockSize;
    this._block[n] = 128, this._block.fill(0, n + 1), n >= this._finalSize && (this._update(this._block), this._block.fill(0));
    var a = this._len * 8;
    if (a <= 4294967295)
      this._block.writeUInt32BE(a, this._blockSize - 4);
    else {
      var i = (a & 4294967295) >>> 0, o = (a - i) / 4294967296;
      this._block.writeUInt32BE(o, this._blockSize - 8), this._block.writeUInt32BE(i, this._blockSize - 4);
    }
    this._update(this._block);
    var u = this._hash();
    return t ? u.toString(t) : u;
  }, e.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  }, Ys = e, Ys;
}
var Xs, g0;
function e6() {
  if (g0)
    return Xs;
  g0 = 1;
  var r = Ft(), e = Ci(), t = $t().Buffer, n = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], a = new Array(80);
  function i() {
    this.init(), this._w = a, e.call(this, 64, 56);
  }
  r(i, e), i.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function o(h) {
    return h << 5 | h >>> 27;
  }
  function u(h) {
    return h << 30 | h >>> 2;
  }
  function c(h, s, d, l) {
    return h === 0 ? s & d | ~s & l : h === 2 ? s & d | s & l | d & l : s ^ d ^ l;
  }
  return i.prototype._update = function(h) {
    for (var s = this._w, d = this._a | 0, l = this._b | 0, y = this._c | 0, m = this._d | 0, w = this._e | 0, E = 0; E < 16; ++E)
      s[E] = h.readInt32BE(E * 4);
    for (; E < 80; ++E)
      s[E] = s[E - 3] ^ s[E - 8] ^ s[E - 14] ^ s[E - 16];
    for (var S = 0; S < 80; ++S) {
      var P = ~~(S / 20), L = o(d) + c(P, l, y, m) + w + s[S] + n[P] | 0;
      w = m, m = y, y = u(l), l = d, d = L;
    }
    this._a = d + this._a | 0, this._b = l + this._b | 0, this._c = y + this._c | 0, this._d = m + this._d | 0, this._e = w + this._e | 0;
  }, i.prototype._hash = function() {
    var h = t.allocUnsafe(20);
    return h.writeInt32BE(this._a | 0, 0), h.writeInt32BE(this._b | 0, 4), h.writeInt32BE(this._c | 0, 8), h.writeInt32BE(this._d | 0, 12), h.writeInt32BE(this._e | 0, 16), h;
  }, Xs = i, Xs;
}
var Zs, w0;
function t6() {
  if (w0)
    return Zs;
  w0 = 1;
  var r = Ft(), e = Ci(), t = $t().Buffer, n = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], a = new Array(80);
  function i() {
    this.init(), this._w = a, e.call(this, 64, 56);
  }
  r(i, e), i.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function o(s) {
    return s << 1 | s >>> 31;
  }
  function u(s) {
    return s << 5 | s >>> 27;
  }
  function c(s) {
    return s << 30 | s >>> 2;
  }
  function h(s, d, l, y) {
    return s === 0 ? d & l | ~d & y : s === 2 ? d & l | d & y | l & y : d ^ l ^ y;
  }
  return i.prototype._update = function(s) {
    for (var d = this._w, l = this._a | 0, y = this._b | 0, m = this._c | 0, w = this._d | 0, E = this._e | 0, S = 0; S < 16; ++S)
      d[S] = s.readInt32BE(S * 4);
    for (; S < 80; ++S)
      d[S] = o(d[S - 3] ^ d[S - 8] ^ d[S - 14] ^ d[S - 16]);
    for (var P = 0; P < 80; ++P) {
      var L = ~~(P / 20), U = u(l) + h(L, y, m, w) + E + d[P] + n[L] | 0;
      E = w, w = m, m = c(y), y = l, l = U;
    }
    this._a = l + this._a | 0, this._b = y + this._b | 0, this._c = m + this._c | 0, this._d = w + this._d | 0, this._e = E + this._e | 0;
  }, i.prototype._hash = function() {
    var s = t.allocUnsafe(20);
    return s.writeInt32BE(this._a | 0, 0), s.writeInt32BE(this._b | 0, 4), s.writeInt32BE(this._c | 0, 8), s.writeInt32BE(this._d | 0, 12), s.writeInt32BE(this._e | 0, 16), s;
  }, Zs = i, Zs;
}
var ef, _0;
function M1() {
  if (_0)
    return ef;
  _0 = 1;
  var r = Ft(), e = Ci(), t = $t().Buffer, n = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ], a = new Array(64);
  function i() {
    this.init(), this._w = a, e.call(this, 64, 56);
  }
  r(i, e), i.prototype.init = function() {
    return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
  };
  function o(l, y, m) {
    return m ^ l & (y ^ m);
  }
  function u(l, y, m) {
    return l & y | m & (l | y);
  }
  function c(l) {
    return (l >>> 2 | l << 30) ^ (l >>> 13 | l << 19) ^ (l >>> 22 | l << 10);
  }
  function h(l) {
    return (l >>> 6 | l << 26) ^ (l >>> 11 | l << 21) ^ (l >>> 25 | l << 7);
  }
  function s(l) {
    return (l >>> 7 | l << 25) ^ (l >>> 18 | l << 14) ^ l >>> 3;
  }
  function d(l) {
    return (l >>> 17 | l << 15) ^ (l >>> 19 | l << 13) ^ l >>> 10;
  }
  return i.prototype._update = function(l) {
    for (var y = this._w, m = this._a | 0, w = this._b | 0, E = this._c | 0, S = this._d | 0, P = this._e | 0, L = this._f | 0, U = this._g | 0, z = this._h | 0, K = 0; K < 16; ++K)
      y[K] = l.readInt32BE(K * 4);
    for (; K < 64; ++K)
      y[K] = d(y[K - 2]) + y[K - 7] + s(y[K - 15]) + y[K - 16] | 0;
    for (var re = 0; re < 64; ++re) {
      var oe = z + h(P) + o(P, L, U) + n[re] + y[re] | 0, se = c(m) + u(m, w, E) | 0;
      z = U, U = L, L = P, P = S + oe | 0, S = E, E = w, w = m, m = oe + se | 0;
    }
    this._a = m + this._a | 0, this._b = w + this._b | 0, this._c = E + this._c | 0, this._d = S + this._d | 0, this._e = P + this._e | 0, this._f = L + this._f | 0, this._g = U + this._g | 0, this._h = z + this._h | 0;
  }, i.prototype._hash = function() {
    var l = t.allocUnsafe(32);
    return l.writeInt32BE(this._a, 0), l.writeInt32BE(this._b, 4), l.writeInt32BE(this._c, 8), l.writeInt32BE(this._d, 12), l.writeInt32BE(this._e, 16), l.writeInt32BE(this._f, 20), l.writeInt32BE(this._g, 24), l.writeInt32BE(this._h, 28), l;
  }, ef = i, ef;
}
var tf, x0;
function r6() {
  if (x0)
    return tf;
  x0 = 1;
  var r = Ft(), e = M1(), t = Ci(), n = $t().Buffer, a = new Array(64);
  function i() {
    this.init(), this._w = a, t.call(this, 64, 56);
  }
  return r(i, e), i.prototype.init = function() {
    return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
  }, i.prototype._hash = function() {
    var o = n.allocUnsafe(28);
    return o.writeInt32BE(this._a, 0), o.writeInt32BE(this._b, 4), o.writeInt32BE(this._c, 8), o.writeInt32BE(this._d, 12), o.writeInt32BE(this._e, 16), o.writeInt32BE(this._f, 20), o.writeInt32BE(this._g, 24), o;
  }, tf = i, tf;
}
var rf, S0;
function A1() {
  if (S0)
    return rf;
  S0 = 1;
  var r = Ft(), e = Ci(), t = $t().Buffer, n = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ], a = new Array(160);
  function i() {
    this.init(), this._w = a, e.call(this, 128, 112);
  }
  r(i, e), i.prototype.init = function() {
    return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
  };
  function o(w, E, S) {
    return S ^ w & (E ^ S);
  }
  function u(w, E, S) {
    return w & E | S & (w | E);
  }
  function c(w, E) {
    return (w >>> 28 | E << 4) ^ (E >>> 2 | w << 30) ^ (E >>> 7 | w << 25);
  }
  function h(w, E) {
    return (w >>> 14 | E << 18) ^ (w >>> 18 | E << 14) ^ (E >>> 9 | w << 23);
  }
  function s(w, E) {
    return (w >>> 1 | E << 31) ^ (w >>> 8 | E << 24) ^ w >>> 7;
  }
  function d(w, E) {
    return (w >>> 1 | E << 31) ^ (w >>> 8 | E << 24) ^ (w >>> 7 | E << 25);
  }
  function l(w, E) {
    return (w >>> 19 | E << 13) ^ (E >>> 29 | w << 3) ^ w >>> 6;
  }
  function y(w, E) {
    return (w >>> 19 | E << 13) ^ (E >>> 29 | w << 3) ^ (w >>> 6 | E << 26);
  }
  function m(w, E) {
    return w >>> 0 < E >>> 0 ? 1 : 0;
  }
  return i.prototype._update = function(w) {
    for (var E = this._w, S = this._ah | 0, P = this._bh | 0, L = this._ch | 0, U = this._dh | 0, z = this._eh | 0, K = this._fh | 0, re = this._gh | 0, oe = this._hh | 0, se = this._al | 0, ve = this._bl | 0, Q = this._cl | 0, A = this._dl | 0, b = this._el | 0, f = this._fl | 0, v = this._gl | 0, g = this._hl | 0, M = 0; M < 32; M += 2)
      E[M] = w.readInt32BE(M * 4), E[M + 1] = w.readInt32BE(M * 4 + 4);
    for (; M < 160; M += 2) {
      var I = E[M - 30], R = E[M - 15 * 2 + 1], x = s(I, R), T = d(R, I);
      I = E[M - 2 * 2], R = E[M - 2 * 2 + 1];
      var p = l(I, R), B = y(R, I), ee = E[M - 7 * 2], ae = E[M - 7 * 2 + 1], Z = E[M - 16 * 2], ne = E[M - 16 * 2 + 1], fe = T + ae | 0, le = x + ee + m(fe, T) | 0;
      fe = fe + B | 0, le = le + p + m(fe, B) | 0, fe = fe + ne | 0, le = le + Z + m(fe, ne) | 0, E[M] = le, E[M + 1] = fe;
    }
    for (var ke = 0; ke < 160; ke += 2) {
      le = E[ke], fe = E[ke + 1];
      var X = u(S, P, L), G = u(se, ve, Q), we = c(S, se), Ae = c(se, S), Oe = h(z, b), qe = h(b, z), Ue = n[ke], ze = n[ke + 1], ge = o(z, K, re), ht = o(b, f, v), $e = g + qe | 0, Et = oe + Oe + m($e, g) | 0;
      $e = $e + ht | 0, Et = Et + ge + m($e, ht) | 0, $e = $e + ze | 0, Et = Et + Ue + m($e, ze) | 0, $e = $e + fe | 0, Et = Et + le + m($e, fe) | 0;
      var ot = Ae + G | 0, Ve = we + X + m(ot, Ae) | 0;
      oe = re, g = v, re = K, v = f, K = z, f = b, b = A + $e | 0, z = U + Et + m(b, A) | 0, U = L, A = Q, L = P, Q = ve, P = S, ve = se, se = $e + ot | 0, S = Et + Ve + m(se, $e) | 0;
    }
    this._al = this._al + se | 0, this._bl = this._bl + ve | 0, this._cl = this._cl + Q | 0, this._dl = this._dl + A | 0, this._el = this._el + b | 0, this._fl = this._fl + f | 0, this._gl = this._gl + v | 0, this._hl = this._hl + g | 0, this._ah = this._ah + S + m(this._al, se) | 0, this._bh = this._bh + P + m(this._bl, ve) | 0, this._ch = this._ch + L + m(this._cl, Q) | 0, this._dh = this._dh + U + m(this._dl, A) | 0, this._eh = this._eh + z + m(this._el, b) | 0, this._fh = this._fh + K + m(this._fl, f) | 0, this._gh = this._gh + re + m(this._gl, v) | 0, this._hh = this._hh + oe + m(this._hl, g) | 0;
  }, i.prototype._hash = function() {
    var w = t.allocUnsafe(64);
    function E(S, P, L) {
      w.writeInt32BE(S, L), w.writeInt32BE(P, L + 4);
    }
    return E(this._ah, this._al, 0), E(this._bh, this._bl, 8), E(this._ch, this._cl, 16), E(this._dh, this._dl, 24), E(this._eh, this._el, 32), E(this._fh, this._fl, 40), E(this._gh, this._gl, 48), E(this._hh, this._hl, 56), w;
  }, rf = i, rf;
}
var nf, E0;
function n6() {
  if (E0)
    return nf;
  E0 = 1;
  var r = Ft(), e = A1(), t = Ci(), n = $t().Buffer, a = new Array(160);
  function i() {
    this.init(), this._w = a, t.call(this, 128, 112);
  }
  return r(i, e), i.prototype.init = function() {
    return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
  }, i.prototype._hash = function() {
    var o = n.allocUnsafe(48);
    function u(c, h, s) {
      o.writeInt32BE(c, s), o.writeInt32BE(h, s + 4);
    }
    return u(this._ah, this._al, 0), u(this._bh, this._bl, 8), u(this._ch, this._cl, 16), u(this._dh, this._dl, 24), u(this._eh, this._el, 32), u(this._fh, this._fl, 40), o;
  }, nf = i, nf;
}
var M0;
function eh() {
  if (M0)
    return Js.exports;
  M0 = 1;
  var r = Js.exports = function(t) {
    t = t.toLowerCase();
    var n = r[t];
    if (!n)
      throw new Error(t + " is not supported (we accept pull requests)");
    return new n();
  };
  return r.sha = e6(), r.sha1 = t6(), r.sha224 = r6(), r.sha256 = M1(), r.sha384 = n6(), r.sha512 = A1(), Js.exports;
}
var af, A0;
function i6() {
  if (A0)
    return af;
  A0 = 1, af = t;
  var r = zc().EventEmitter, e = Ft();
  e(t, r), t.Readable = Jc(), t.Writable = Gc(), t.Duplex = ni(), t.Transform = Yc(), t.PassThrough = _1(), t.finished = Mo(), t.pipeline = x1(), t.Stream = t;
  function t() {
    r.call(this);
  }
  return t.prototype.pipe = function(n, a) {
    var i = this;
    function o(y) {
      n.writable && n.write(y) === !1 && i.pause && i.pause();
    }
    i.on("data", o);
    function u() {
      i.readable && i.resume && i.resume();
    }
    n.on("drain", u), !n._isStdio && (!a || a.end !== !1) && (i.on("end", h), i.on("close", s));
    var c = !1;
    function h() {
      c || (c = !0, n.end());
    }
    function s() {
      c || (c = !0, typeof n.destroy == "function" && n.destroy());
    }
    function d(y) {
      if (l(), r.listenerCount(this, "error") === 0)
        throw y;
    }
    i.on("error", d), n.on("error", d);
    function l() {
      i.removeListener("data", o), n.removeListener("drain", u), i.removeListener("end", h), i.removeListener("close", s), i.removeListener("error", d), n.removeListener("error", d), i.removeListener("end", l), i.removeListener("close", l), n.removeListener("close", l);
    }
    return i.on("end", l), i.on("close", l), n.on("close", l), n.emit("pipe", i), n;
  }, af;
}
var of, T0;
function Hn() {
  if (T0)
    return of;
  T0 = 1;
  var r = $t().Buffer, e = i6().Transform, t = uc().StringDecoder, n = Ft();
  function a(i) {
    e.call(this), this.hashMode = typeof i == "string", this.hashMode ? this[i] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
  }
  return n(a, e), a.prototype.update = function(i, o, u) {
    typeof i == "string" && (i = r.from(i, o));
    var c = this._update(i);
    return this.hashMode ? this : (u && (c = this._toString(c, u)), c);
  }, a.prototype.setAutoPadding = function() {
  }, a.prototype.getAuthTag = function() {
    throw new Error("trying to get auth tag in unsupported state");
  }, a.prototype.setAuthTag = function() {
    throw new Error("trying to set auth tag in unsupported state");
  }, a.prototype.setAAD = function() {
    throw new Error("trying to set aad in unsupported state");
  }, a.prototype._transform = function(i, o, u) {
    var c;
    try {
      this.hashMode ? this._update(i) : this.push(this._update(i));
    } catch (h) {
      c = h;
    } finally {
      u(c);
    }
  }, a.prototype._flush = function(i) {
    var o;
    try {
      this.push(this.__final());
    } catch (u) {
      o = u;
    }
    i(o);
  }, a.prototype._finalOrDigest = function(i) {
    var o = this.__final() || r.alloc(0);
    return i && (o = this._toString(o, i, !0)), o;
  }, a.prototype._toString = function(i, o, u) {
    if (this._decoder || (this._decoder = new t(o), this._encoding = o), this._encoding !== o)
      throw new Error("can't switch encodings");
    var c = this._decoder.write(i);
    return u && (c += this._decoder.end()), c;
  }, of = a, of;
}
var sf, k0;
function ma() {
  if (k0)
    return sf;
  k0 = 1;
  var r = Ft(), e = Xc(), t = Zc(), n = eh(), a = Hn();
  function i(o) {
    a.call(this, "digest"), this._hash = o;
  }
  return r(i, a), i.prototype._update = function(o) {
    this._hash.update(o);
  }, i.prototype._final = function() {
    return this._hash.digest();
  }, sf = function(u) {
    return u = u.toLowerCase(), u === "md5" ? new e() : u === "rmd160" || u === "ripemd160" ? new t() : new i(n(u));
  }, sf;
}
var ff, I0;
function a6() {
  if (I0)
    return ff;
  I0 = 1;
  var r = Ft(), e = $t().Buffer, t = Hn(), n = e.alloc(128), a = 64;
  function i(o, u) {
    t.call(this, "digest"), typeof u == "string" && (u = e.from(u)), this._alg = o, this._key = u, u.length > a ? u = o(u) : u.length < a && (u = e.concat([u, n], a));
    for (var c = this._ipad = e.allocUnsafe(a), h = this._opad = e.allocUnsafe(a), s = 0; s < a; s++)
      c[s] = u[s] ^ 54, h[s] = u[s] ^ 92;
    this._hash = [c];
  }
  return r(i, t), i.prototype._update = function(o) {
    this._hash.push(o);
  }, i.prototype._final = function() {
    var o = this._alg(e.concat(this._hash));
    return this._alg(e.concat([this._opad, o]));
  }, ff = i, ff;
}
var uf, R0;
function T1() {
  if (R0)
    return uf;
  R0 = 1;
  var r = Xc();
  return uf = function(e) {
    return new r().update(e).digest();
  }, uf;
}
var cf, C0;
function k1() {
  if (C0)
    return cf;
  C0 = 1;
  var r = Ft(), e = a6(), t = Hn(), n = $t().Buffer, a = T1(), i = Zc(), o = eh(), u = n.alloc(128);
  function c(h, s) {
    t.call(this, "digest"), typeof s == "string" && (s = n.from(s));
    var d = h === "sha512" || h === "sha384" ? 128 : 64;
    if (this._alg = h, this._key = s, s.length > d) {
      var l = h === "rmd160" ? new i() : o(h);
      s = l.update(s).digest();
    } else
      s.length < d && (s = n.concat([s, u], d));
    for (var y = this._ipad = n.allocUnsafe(d), m = this._opad = n.allocUnsafe(d), w = 0; w < d; w++)
      y[w] = s[w] ^ 54, m[w] = s[w] ^ 92;
    this._hash = h === "rmd160" ? new i() : o(h), this._hash.update(y);
  }
  return r(c, t), c.prototype._update = function(h) {
    this._hash.update(h);
  }, c.prototype._final = function() {
    var h = this._hash.digest(), s = this._alg === "rmd160" ? new i() : o(this._alg);
    return s.update(this._opad).update(h).digest();
  }, cf = function(s, d) {
    return s = s.toLowerCase(), s === "rmd160" || s === "ripemd160" ? new c("rmd160", d) : s === "md5" ? new e(a, d) : new c(s, d);
  }, cf;
}
const o6 = {
  sign: "rsa",
  hash: "sha224",
  id: "302d300d06096086480165030402040500041c"
}, s6 = {
  sign: "rsa",
  hash: "sha256",
  id: "3031300d060960864801650304020105000420"
}, f6 = {
  sign: "rsa",
  hash: "sha384",
  id: "3041300d060960864801650304020205000430"
}, u6 = {
  sign: "rsa",
  hash: "sha512",
  id: "3051300d060960864801650304020305000440"
}, c6 = {
  sign: "ecdsa",
  hash: "sha256",
  id: ""
}, h6 = {
  sign: "ecdsa",
  hash: "sha224",
  id: ""
}, l6 = {
  sign: "ecdsa",
  hash: "sha384",
  id: ""
}, d6 = {
  sign: "ecdsa",
  hash: "sha512",
  id: ""
}, p6 = {
  sign: "dsa",
  hash: "sha1",
  id: ""
}, v6 = {
  sign: "rsa",
  hash: "rmd160",
  id: "3021300906052b2403020105000414"
}, y6 = {
  sign: "rsa",
  hash: "md5",
  id: "3020300c06082a864886f70d020505000410"
}, I1 = {
  sha224WithRSAEncryption: o6,
  "RSA-SHA224": {
    sign: "ecdsa/rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  sha256WithRSAEncryption: s6,
  "RSA-SHA256": {
    sign: "ecdsa/rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  sha384WithRSAEncryption: f6,
  "RSA-SHA384": {
    sign: "ecdsa/rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  sha512WithRSAEncryption: u6,
  "RSA-SHA512": {
    sign: "ecdsa/rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    sign: "rsa",
    hash: "sha1",
    id: "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    sign: "ecdsa",
    hash: "sha1",
    id: ""
  },
  sha256: c6,
  sha224: h6,
  sha384: l6,
  sha512: d6,
  "DSA-SHA": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-SHA1": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  DSA: p6,
  "DSA-WITH-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-WITH-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-WITH-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-WITH-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-RIPEMD160": {
    sign: "dsa",
    hash: "rmd160",
    id: ""
  },
  ripemd160WithRSA: v6,
  "RSA-RIPEMD160": {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  md5WithRSAEncryption: y6,
  "RSA-MD5": {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  }
};
var hf, O0;
function b6() {
  return O0 || (O0 = 1, hf = I1), hf;
}
var Da = {}, lf, B0;
function R1() {
  if (B0)
    return lf;
  B0 = 1;
  var r = Math.pow(2, 30) - 1;
  return lf = function(e, t) {
    if (typeof e != "number")
      throw new TypeError("Iterations not a number");
    if (e < 0)
      throw new TypeError("Bad iterations");
    if (typeof t != "number")
      throw new TypeError("Key length not a number");
    if (t < 0 || t > r || t !== t)
      throw new TypeError("Bad key length");
  }, lf;
}
var df, P0;
function C1() {
  if (P0)
    return df;
  P0 = 1;
  var r;
  if (Jt.process && Jt.process.browser)
    r = "utf-8";
  else if (Jt.process && Jt.process.version) {
    var e = parseInt(Bt.version.split(".")[0].slice(1), 10);
    r = e >= 6 ? "utf-8" : "binary";
  } else
    r = "utf-8";
  return df = r, df;
}
var pf, D0;
function O1() {
  if (D0)
    return pf;
  D0 = 1;
  var r = $t().Buffer;
  return pf = function(e, t, n) {
    if (r.isBuffer(e))
      return e;
    if (typeof e == "string")
      return r.from(e, t);
    if (ArrayBuffer.isView(e))
      return r.from(e.buffer);
    throw new TypeError(n + " must be a string, a Buffer, a typed array or a DataView");
  }, pf;
}
var vf, N0;
function B1() {
  if (N0)
    return vf;
  N0 = 1;
  var r = T1(), e = Zc(), t = eh(), n = $t().Buffer, a = R1(), i = C1(), o = O1(), u = n.alloc(128), c = {
    md5: 16,
    sha1: 20,
    sha224: 28,
    sha256: 32,
    sha384: 48,
    sha512: 64,
    rmd160: 20,
    ripemd160: 20
  };
  function h(l, y, m) {
    var w = s(l), E = l === "sha512" || l === "sha384" ? 128 : 64;
    y.length > E ? y = w(y) : y.length < E && (y = n.concat([y, u], E));
    for (var S = n.allocUnsafe(E + c[l]), P = n.allocUnsafe(E + c[l]), L = 0; L < E; L++)
      S[L] = y[L] ^ 54, P[L] = y[L] ^ 92;
    var U = n.allocUnsafe(E + m + 4);
    S.copy(U, 0, 0, E), this.ipad1 = U, this.ipad2 = S, this.opad = P, this.alg = l, this.blocksize = E, this.hash = w, this.size = c[l];
  }
  h.prototype.run = function(l, y) {
    l.copy(y, this.blocksize);
    var m = this.hash(y);
    return m.copy(this.opad, this.blocksize), this.hash(this.opad);
  };
  function s(l) {
    function y(w) {
      return t(l).update(w).digest();
    }
    function m(w) {
      return new e().update(w).digest();
    }
    return l === "rmd160" || l === "ripemd160" ? m : l === "md5" ? r : y;
  }
  function d(l, y, m, w, E) {
    a(m, w), l = o(l, i, "Password"), y = o(y, i, "Salt"), E = E || "sha1";
    var S = new h(E, l, y.length), P = n.allocUnsafe(w), L = n.allocUnsafe(y.length + 4);
    y.copy(L, 0, 0, y.length);
    for (var U = 0, z = c[E], K = Math.ceil(w / z), re = 1; re <= K; re++) {
      L.writeUInt32BE(re, y.length);
      for (var oe = S.run(L, S.ipad1), se = oe, ve = 1; ve < m; ve++) {
        se = S.run(se, S.ipad2);
        for (var Q = 0; Q < z; Q++)
          oe[Q] ^= se[Q];
      }
      oe.copy(P, U), U += z;
    }
    return P;
  }
  return vf = d, vf;
}
var yf, q0;
function m6() {
  if (q0)
    return yf;
  q0 = 1;
  var r = $t().Buffer, e = R1(), t = C1(), n = B1(), a = O1(), i, o = Jt.crypto && Jt.crypto.subtle, u = {
    sha: "SHA-1",
    "sha-1": "SHA-1",
    sha1: "SHA-1",
    sha256: "SHA-256",
    "sha-256": "SHA-256",
    sha384: "SHA-384",
    "sha-384": "SHA-384",
    "sha-512": "SHA-512",
    sha512: "SHA-512"
  }, c = [];
  function h(m) {
    if (Jt.process && !Jt.process.browser || !o || !o.importKey || !o.deriveBits)
      return Promise.resolve(!1);
    if (c[m] !== void 0)
      return c[m];
    i = i || r.alloc(8);
    var w = l(i, i, 10, 128, m).then(function() {
      return !0;
    }).catch(function() {
      return !1;
    });
    return c[m] = w, w;
  }
  var s;
  function d() {
    return s || (Jt.process && Jt.process.nextTick ? s = Jt.process.nextTick : Jt.queueMicrotask ? s = Jt.queueMicrotask : Jt.setImmediate ? s = Jt.setImmediate : s = Jt.setTimeout, s);
  }
  function l(m, w, E, S, P) {
    return o.importKey(
      "raw",
      m,
      { name: "PBKDF2" },
      !1,
      ["deriveBits"]
    ).then(function(L) {
      return o.deriveBits({
        name: "PBKDF2",
        salt: w,
        iterations: E,
        hash: {
          name: P
        }
      }, L, S << 3);
    }).then(function(L) {
      return r.from(L);
    });
  }
  function y(m, w) {
    m.then(function(E) {
      d()(function() {
        w(null, E);
      });
    }, function(E) {
      d()(function() {
        w(E);
      });
    });
  }
  return yf = function(m, w, E, S, P, L) {
    typeof P == "function" && (L = P, P = void 0), P = P || "sha1";
    var U = u[P.toLowerCase()];
    if (!U || typeof Jt.Promise != "function") {
      d()(function() {
        var z;
        try {
          z = n(m, w, E, S, P);
        } catch (K) {
          return L(K);
        }
        L(null, z);
      });
      return;
    }
    if (e(E, S), m = a(m, t, "Password"), w = a(w, t, "Salt"), typeof L != "function")
      throw new Error("No callback provided to pbkdf2");
    y(h(U).then(function(z) {
      return z ? l(m, w, E, S, U) : n(m, w, E, S, P);
    }), L);
  }, yf;
}
var L0;
function P1() {
  return L0 || (L0 = 1, Da.pbkdf2 = m6(), Da.pbkdf2Sync = B1()), Da;
}
var jr = {}, Kn = {}, Ur = {}, F0;
function D1() {
  if (F0)
    return Ur;
  F0 = 1, Ur.readUInt32BE = function(a, i) {
    var o = a[0 + i] << 24 | a[1 + i] << 16 | a[2 + i] << 8 | a[3 + i];
    return o >>> 0;
  }, Ur.writeUInt32BE = function(a, i, o) {
    a[0 + o] = i >>> 24, a[1 + o] = i >>> 16 & 255, a[2 + o] = i >>> 8 & 255, a[3 + o] = i & 255;
  }, Ur.ip = function(a, i, o, u) {
    for (var c = 0, h = 0, s = 6; s >= 0; s -= 2) {
      for (var d = 0; d <= 24; d += 8)
        c <<= 1, c |= i >>> d + s & 1;
      for (var d = 0; d <= 24; d += 8)
        c <<= 1, c |= a >>> d + s & 1;
    }
    for (var s = 6; s >= 0; s -= 2) {
      for (var d = 1; d <= 25; d += 8)
        h <<= 1, h |= i >>> d + s & 1;
      for (var d = 1; d <= 25; d += 8)
        h <<= 1, h |= a >>> d + s & 1;
    }
    o[u + 0] = c >>> 0, o[u + 1] = h >>> 0;
  }, Ur.rip = function(a, i, o, u) {
    for (var c = 0, h = 0, s = 0; s < 4; s++)
      for (var d = 24; d >= 0; d -= 8)
        c <<= 1, c |= i >>> d + s & 1, c <<= 1, c |= a >>> d + s & 1;
    for (var s = 4; s < 8; s++)
      for (var d = 24; d >= 0; d -= 8)
        h <<= 1, h |= i >>> d + s & 1, h <<= 1, h |= a >>> d + s & 1;
    o[u + 0] = c >>> 0, o[u + 1] = h >>> 0;
  }, Ur.pc1 = function(a, i, o, u) {
    for (var c = 0, h = 0, s = 7; s >= 5; s--) {
      for (var d = 0; d <= 24; d += 8)
        c <<= 1, c |= i >> d + s & 1;
      for (var d = 0; d <= 24; d += 8)
        c <<= 1, c |= a >> d + s & 1;
    }
    for (var d = 0; d <= 24; d += 8)
      c <<= 1, c |= i >> d + s & 1;
    for (var s = 1; s <= 3; s++) {
      for (var d = 0; d <= 24; d += 8)
        h <<= 1, h |= i >> d + s & 1;
      for (var d = 0; d <= 24; d += 8)
        h <<= 1, h |= a >> d + s & 1;
    }
    for (var d = 0; d <= 24; d += 8)
      h <<= 1, h |= a >> d + s & 1;
    o[u + 0] = c >>> 0, o[u + 1] = h >>> 0;
  }, Ur.r28shl = function(a, i) {
    return a << i & 268435455 | a >>> 28 - i;
  };
  var r = [
    // inL => outL
    14,
    11,
    17,
    4,
    27,
    23,
    25,
    0,
    13,
    22,
    7,
    18,
    5,
    9,
    16,
    24,
    2,
    20,
    12,
    21,
    1,
    8,
    15,
    26,
    // inR => outR
    15,
    4,
    25,
    19,
    9,
    1,
    26,
    16,
    5,
    11,
    23,
    8,
    12,
    7,
    17,
    0,
    22,
    3,
    10,
    14,
    6,
    20,
    27,
    24
  ];
  Ur.pc2 = function(a, i, o, u) {
    for (var c = 0, h = 0, s = r.length >>> 1, d = 0; d < s; d++)
      c <<= 1, c |= a >>> r[d] & 1;
    for (var d = s; d < r.length; d++)
      h <<= 1, h |= i >>> r[d] & 1;
    o[u + 0] = c >>> 0, o[u + 1] = h >>> 0;
  }, Ur.expand = function(a, i, o) {
    var u = 0, c = 0;
    u = (a & 1) << 5 | a >>> 27;
    for (var h = 23; h >= 15; h -= 4)
      u <<= 6, u |= a >>> h & 63;
    for (var h = 11; h >= 3; h -= 4)
      c |= a >>> h & 63, c <<= 6;
    c |= (a & 31) << 1 | a >>> 31, i[o + 0] = u >>> 0, i[o + 1] = c >>> 0;
  };
  var e = [
    14,
    0,
    4,
    15,
    13,
    7,
    1,
    4,
    2,
    14,
    15,
    2,
    11,
    13,
    8,
    1,
    3,
    10,
    10,
    6,
    6,
    12,
    12,
    11,
    5,
    9,
    9,
    5,
    0,
    3,
    7,
    8,
    4,
    15,
    1,
    12,
    14,
    8,
    8,
    2,
    13,
    4,
    6,
    9,
    2,
    1,
    11,
    7,
    15,
    5,
    12,
    11,
    9,
    3,
    7,
    14,
    3,
    10,
    10,
    0,
    5,
    6,
    0,
    13,
    15,
    3,
    1,
    13,
    8,
    4,
    14,
    7,
    6,
    15,
    11,
    2,
    3,
    8,
    4,
    14,
    9,
    12,
    7,
    0,
    2,
    1,
    13,
    10,
    12,
    6,
    0,
    9,
    5,
    11,
    10,
    5,
    0,
    13,
    14,
    8,
    7,
    10,
    11,
    1,
    10,
    3,
    4,
    15,
    13,
    4,
    1,
    2,
    5,
    11,
    8,
    6,
    12,
    7,
    6,
    12,
    9,
    0,
    3,
    5,
    2,
    14,
    15,
    9,
    10,
    13,
    0,
    7,
    9,
    0,
    14,
    9,
    6,
    3,
    3,
    4,
    15,
    6,
    5,
    10,
    1,
    2,
    13,
    8,
    12,
    5,
    7,
    14,
    11,
    12,
    4,
    11,
    2,
    15,
    8,
    1,
    13,
    1,
    6,
    10,
    4,
    13,
    9,
    0,
    8,
    6,
    15,
    9,
    3,
    8,
    0,
    7,
    11,
    4,
    1,
    15,
    2,
    14,
    12,
    3,
    5,
    11,
    10,
    5,
    14,
    2,
    7,
    12,
    7,
    13,
    13,
    8,
    14,
    11,
    3,
    5,
    0,
    6,
    6,
    15,
    9,
    0,
    10,
    3,
    1,
    4,
    2,
    7,
    8,
    2,
    5,
    12,
    11,
    1,
    12,
    10,
    4,
    14,
    15,
    9,
    10,
    3,
    6,
    15,
    9,
    0,
    0,
    6,
    12,
    10,
    11,
    1,
    7,
    13,
    13,
    8,
    15,
    9,
    1,
    4,
    3,
    5,
    14,
    11,
    5,
    12,
    2,
    7,
    8,
    2,
    4,
    14,
    2,
    14,
    12,
    11,
    4,
    2,
    1,
    12,
    7,
    4,
    10,
    7,
    11,
    13,
    6,
    1,
    8,
    5,
    5,
    0,
    3,
    15,
    15,
    10,
    13,
    3,
    0,
    9,
    14,
    8,
    9,
    6,
    4,
    11,
    2,
    8,
    1,
    12,
    11,
    7,
    10,
    1,
    13,
    14,
    7,
    2,
    8,
    13,
    15,
    6,
    9,
    15,
    12,
    0,
    5,
    9,
    6,
    10,
    3,
    4,
    0,
    5,
    14,
    3,
    12,
    10,
    1,
    15,
    10,
    4,
    15,
    2,
    9,
    7,
    2,
    12,
    6,
    9,
    8,
    5,
    0,
    6,
    13,
    1,
    3,
    13,
    4,
    14,
    14,
    0,
    7,
    11,
    5,
    3,
    11,
    8,
    9,
    4,
    14,
    3,
    15,
    2,
    5,
    12,
    2,
    9,
    8,
    5,
    12,
    15,
    3,
    10,
    7,
    11,
    0,
    14,
    4,
    1,
    10,
    7,
    1,
    6,
    13,
    0,
    11,
    8,
    6,
    13,
    4,
    13,
    11,
    0,
    2,
    11,
    14,
    7,
    15,
    4,
    0,
    9,
    8,
    1,
    13,
    10,
    3,
    14,
    12,
    3,
    9,
    5,
    7,
    12,
    5,
    2,
    10,
    15,
    6,
    8,
    1,
    6,
    1,
    6,
    4,
    11,
    11,
    13,
    13,
    8,
    12,
    1,
    3,
    4,
    7,
    10,
    14,
    7,
    10,
    9,
    15,
    5,
    6,
    0,
    8,
    15,
    0,
    14,
    5,
    2,
    9,
    3,
    2,
    12,
    13,
    1,
    2,
    15,
    8,
    13,
    4,
    8,
    6,
    10,
    15,
    3,
    11,
    7,
    1,
    4,
    10,
    12,
    9,
    5,
    3,
    6,
    14,
    11,
    5,
    0,
    0,
    14,
    12,
    9,
    7,
    2,
    7,
    2,
    11,
    1,
    4,
    14,
    1,
    7,
    9,
    4,
    12,
    10,
    14,
    8,
    2,
    13,
    0,
    15,
    6,
    12,
    10,
    9,
    13,
    0,
    15,
    3,
    3,
    5,
    5,
    6,
    8,
    11
  ];
  Ur.substitute = function(a, i) {
    for (var o = 0, u = 0; u < 4; u++) {
      var c = a >>> 18 - u * 6 & 63, h = e[u * 64 + c];
      o <<= 4, o |= h;
    }
    for (var u = 0; u < 4; u++) {
      var c = i >>> 18 - u * 6 & 63, h = e[4 * 64 + u * 64 + c];
      o <<= 4, o |= h;
    }
    return o >>> 0;
  };
  var t = [
    16,
    25,
    12,
    11,
    3,
    20,
    4,
    15,
    31,
    17,
    9,
    6,
    27,
    14,
    1,
    22,
    30,
    24,
    8,
    18,
    0,
    5,
    29,
    23,
    13,
    19,
    2,
    26,
    10,
    21,
    28,
    7
  ];
  return Ur.permute = function(a) {
    for (var i = 0, o = 0; o < t.length; o++)
      i <<= 1, i |= a >>> t[o] & 1;
    return i >>> 0;
  }, Ur.padSplit = function(a, i, o) {
    for (var u = a.toString(2); u.length < i; )
      u = "0" + u;
    for (var c = [], h = 0; h < i; h += o)
      c.push(u.slice(h, h + o));
    return c.join(" ");
  }, Ur;
}
var bf, U0;
function Wr() {
  if (U0)
    return bf;
  U0 = 1, bf = r;
  function r(e, t) {
    if (!e)
      throw new Error(t || "Assertion failed");
  }
  return r.equal = function(t, n, a) {
    if (t != n)
      throw new Error(a || "Assertion failed: " + t + " != " + n);
  }, bf;
}
var mf, $0;
function th() {
  if ($0)
    return mf;
  $0 = 1;
  var r = Wr();
  function e(t) {
    this.options = t, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = t.padding !== !1;
  }
  return mf = e, e.prototype._init = function() {
  }, e.prototype.update = function(n) {
    return n.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(n) : this._updateEncrypt(n);
  }, e.prototype._buffer = function(n, a) {
    for (var i = Math.min(this.buffer.length - this.bufferOff, n.length - a), o = 0; o < i; o++)
      this.buffer[this.bufferOff + o] = n[a + o];
    return this.bufferOff += i, i;
  }, e.prototype._flushBuffer = function(n, a) {
    return this._update(this.buffer, 0, n, a), this.bufferOff = 0, this.blockSize;
  }, e.prototype._updateEncrypt = function(n) {
    var a = 0, i = 0, o = (this.bufferOff + n.length) / this.blockSize | 0, u = new Array(o * this.blockSize);
    this.bufferOff !== 0 && (a += this._buffer(n, a), this.bufferOff === this.buffer.length && (i += this._flushBuffer(u, i)));
    for (var c = n.length - (n.length - a) % this.blockSize; a < c; a += this.blockSize)
      this._update(n, a, u, i), i += this.blockSize;
    for (; a < n.length; a++, this.bufferOff++)
      this.buffer[this.bufferOff] = n[a];
    return u;
  }, e.prototype._updateDecrypt = function(n) {
    for (var a = 0, i = 0, o = Math.ceil((this.bufferOff + n.length) / this.blockSize) - 1, u = new Array(o * this.blockSize); o > 0; o--)
      a += this._buffer(n, a), i += this._flushBuffer(u, i);
    return a += this._buffer(n, a), u;
  }, e.prototype.final = function(n) {
    var a;
    n && (a = this.update(n));
    var i;
    return this.type === "encrypt" ? i = this._finalEncrypt() : i = this._finalDecrypt(), a ? a.concat(i) : i;
  }, e.prototype._pad = function(n, a) {
    if (a === 0)
      return !1;
    for (; a < n.length; )
      n[a++] = 0;
    return !0;
  }, e.prototype._finalEncrypt = function() {
    if (!this._pad(this.buffer, this.bufferOff))
      return [];
    var n = new Array(this.blockSize);
    return this._update(this.buffer, 0, n, 0), n;
  }, e.prototype._unpad = function(n) {
    return n;
  }, e.prototype._finalDecrypt = function() {
    r.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
    var n = new Array(this.blockSize);
    return this._flushBuffer(n, 0), this._unpad(n);
  }, mf;
}
var gf, j0;
function N1() {
  if (j0)
    return gf;
  j0 = 1;
  var r = Wr(), e = Ft(), t = D1(), n = th();
  function a() {
    this.tmp = new Array(2), this.keys = null;
  }
  function i(u) {
    n.call(this, u);
    var c = new a();
    this._desState = c, this.deriveKeys(c, u.key);
  }
  e(i, n), gf = i, i.create = function(c) {
    return new i(c);
  };
  var o = [
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1
  ];
  return i.prototype.deriveKeys = function(c, h) {
    c.keys = new Array(16 * 2), r.equal(h.length, this.blockSize, "Invalid key length");
    var s = t.readUInt32BE(h, 0), d = t.readUInt32BE(h, 4);
    t.pc1(s, d, c.tmp, 0), s = c.tmp[0], d = c.tmp[1];
    for (var l = 0; l < c.keys.length; l += 2) {
      var y = o[l >>> 1];
      s = t.r28shl(s, y), d = t.r28shl(d, y), t.pc2(s, d, c.keys, l);
    }
  }, i.prototype._update = function(c, h, s, d) {
    var l = this._desState, y = t.readUInt32BE(c, h), m = t.readUInt32BE(c, h + 4);
    t.ip(y, m, l.tmp, 0), y = l.tmp[0], m = l.tmp[1], this.type === "encrypt" ? this._encrypt(l, y, m, l.tmp, 0) : this._decrypt(l, y, m, l.tmp, 0), y = l.tmp[0], m = l.tmp[1], t.writeUInt32BE(s, y, d), t.writeUInt32BE(s, m, d + 4);
  }, i.prototype._pad = function(c, h) {
    if (this.padding === !1)
      return !1;
    for (var s = c.length - h, d = h; d < c.length; d++)
      c[d] = s;
    return !0;
  }, i.prototype._unpad = function(c) {
    if (this.padding === !1)
      return c;
    for (var h = c[c.length - 1], s = c.length - h; s < c.length; s++)
      r.equal(c[s], h);
    return c.slice(0, c.length - h);
  }, i.prototype._encrypt = function(c, h, s, d, l) {
    for (var y = h, m = s, w = 0; w < c.keys.length; w += 2) {
      var E = c.keys[w], S = c.keys[w + 1];
      t.expand(m, c.tmp, 0), E ^= c.tmp[0], S ^= c.tmp[1];
      var P = t.substitute(E, S), L = t.permute(P), U = m;
      m = (y ^ L) >>> 0, y = U;
    }
    t.rip(m, y, d, l);
  }, i.prototype._decrypt = function(c, h, s, d, l) {
    for (var y = s, m = h, w = c.keys.length - 2; w >= 0; w -= 2) {
      var E = c.keys[w], S = c.keys[w + 1];
      t.expand(y, c.tmp, 0), E ^= c.tmp[0], S ^= c.tmp[1];
      var P = t.substitute(E, S), L = t.permute(P), U = y;
      y = (m ^ L) >>> 0, m = U;
    }
    t.rip(y, m, d, l);
  }, gf;
}
var wf = {}, H0;
function g6() {
  if (H0)
    return wf;
  H0 = 1;
  var r = Wr(), e = Ft(), t = {};
  function n(i) {
    r.equal(i.length, 8, "Invalid IV length"), this.iv = new Array(8);
    for (var o = 0; o < this.iv.length; o++)
      this.iv[o] = i[o];
  }
  function a(i) {
    function o(s) {
      i.call(this, s), this._cbcInit();
    }
    e(o, i);
    for (var u = Object.keys(t), c = 0; c < u.length; c++) {
      var h = u[c];
      o.prototype[h] = t[h];
    }
    return o.create = function(d) {
      return new o(d);
    }, o;
  }
  return wf.instantiate = a, t._cbcInit = function() {
    var o = new n(this.options.iv);
    this._cbcState = o;
  }, t._update = function(o, u, c, h) {
    var s = this._cbcState, d = this.constructor.super_.prototype, l = s.iv;
    if (this.type === "encrypt") {
      for (var y = 0; y < this.blockSize; y++)
        l[y] ^= o[u + y];
      d._update.call(this, l, 0, c, h);
      for (var y = 0; y < this.blockSize; y++)
        l[y] = c[h + y];
    } else {
      d._update.call(this, o, u, c, h);
      for (var y = 0; y < this.blockSize; y++)
        c[h + y] ^= l[y];
      for (var y = 0; y < this.blockSize; y++)
        l[y] = o[u + y];
    }
  }, wf;
}
var _f, z0;
function w6() {
  if (z0)
    return _f;
  z0 = 1;
  var r = Wr(), e = Ft(), t = th(), n = N1();
  function a(o, u) {
    r.equal(u.length, 24, "Invalid key length");
    var c = u.slice(0, 8), h = u.slice(8, 16), s = u.slice(16, 24);
    o === "encrypt" ? this.ciphers = [
      n.create({ type: "encrypt", key: c }),
      n.create({ type: "decrypt", key: h }),
      n.create({ type: "encrypt", key: s })
    ] : this.ciphers = [
      n.create({ type: "decrypt", key: s }),
      n.create({ type: "encrypt", key: h }),
      n.create({ type: "decrypt", key: c })
    ];
  }
  function i(o) {
    t.call(this, o);
    var u = new a(this.type, this.options.key);
    this._edeState = u;
  }
  return e(i, t), _f = i, i.create = function(u) {
    return new i(u);
  }, i.prototype._update = function(u, c, h, s) {
    var d = this._edeState;
    d.ciphers[0]._update(u, c, h, s), d.ciphers[1]._update(h, s, h, s), d.ciphers[2]._update(h, s, h, s);
  }, i.prototype._pad = n.prototype._pad, i.prototype._unpad = n.prototype._unpad, _f;
}
var V0;
function _6() {
  return V0 || (V0 = 1, Kn.utils = D1(), Kn.Cipher = th(), Kn.DES = N1(), Kn.CBC = g6(), Kn.EDE = w6()), Kn;
}
var xf, W0;
function x6() {
  if (W0)
    return xf;
  W0 = 1;
  var r = Hn(), e = _6(), t = Ft(), n = $t().Buffer, a = {
    "des-ede3-cbc": e.CBC.instantiate(e.EDE),
    "des-ede3": e.EDE,
    "des-ede-cbc": e.CBC.instantiate(e.EDE),
    "des-ede": e.EDE,
    "des-cbc": e.CBC.instantiate(e.DES),
    "des-ecb": e.DES
  };
  a.des = a["des-cbc"], a.des3 = a["des-ede3-cbc"], xf = i, t(i, r);
  function i(o) {
    r.call(this);
    var u = o.mode.toLowerCase(), c = a[u], h;
    o.decrypt ? h = "decrypt" : h = "encrypt";
    var s = o.key;
    n.isBuffer(s) || (s = n.from(s)), (u === "des-ede" || u === "des-ede-cbc") && (s = n.concat([s, s.slice(0, 8)]));
    var d = o.iv;
    n.isBuffer(d) || (d = n.from(d)), this._des = c.create({
      key: s,
      iv: d,
      type: h
    });
  }
  return i.prototype._update = function(o) {
    return n.from(this._des.update(o));
  }, i.prototype._final = function() {
    return n.from(this._des.final());
  }, xf;
}
var Hr = {}, Na = {}, qa = {}, K0;
function S6() {
  return K0 || (K0 = 1, qa.encrypt = function(r, e) {
    return r._cipher.encryptBlock(e);
  }, qa.decrypt = function(r, e) {
    return r._cipher.decryptBlock(e);
  }), qa;
}
var La = {}, Sf, Q0;
function ga() {
  return Q0 || (Q0 = 1, Sf = function(e, t) {
    for (var n = Math.min(e.length, t.length), a = new Xt(n), i = 0; i < n; ++i)
      a[i] = e[i] ^ t[i];
    return a;
  }), Sf;
}
var G0;
function E6() {
  if (G0)
    return La;
  G0 = 1;
  var r = ga();
  return La.encrypt = function(e, t) {
    var n = r(t, e._prev);
    return e._prev = e._cipher.encryptBlock(n), e._prev;
  }, La.decrypt = function(e, t) {
    var n = e._prev;
    e._prev = t;
    var a = e._cipher.decryptBlock(t);
    return r(a, n);
  }, La;
}
var Ef = {}, J0;
function M6() {
  if (J0)
    return Ef;
  J0 = 1;
  var r = $t().Buffer, e = ga();
  function t(n, a, i) {
    var o = a.length, u = e(a, n._cache);
    return n._cache = n._cache.slice(o), n._prev = r.concat([n._prev, i ? a : u]), u;
  }
  return Ef.encrypt = function(n, a, i) {
    for (var o = r.allocUnsafe(0), u; a.length; )
      if (n._cache.length === 0 && (n._cache = n._cipher.encryptBlock(n._prev), n._prev = r.allocUnsafe(0)), n._cache.length <= a.length)
        u = n._cache.length, o = r.concat([o, t(n, a.slice(0, u), i)]), a = a.slice(u);
      else {
        o = r.concat([o, t(n, a, i)]);
        break;
      }
    return o;
  }, Ef;
}
var Mf = {}, Y0;
function A6() {
  if (Y0)
    return Mf;
  Y0 = 1;
  var r = $t().Buffer;
  function e(t, n, a) {
    var i = t._cipher.encryptBlock(t._prev), o = i[0] ^ n;
    return t._prev = r.concat([
      t._prev.slice(1),
      r.from([a ? n : o])
    ]), o;
  }
  return Mf.encrypt = function(t, n, a) {
    for (var i = n.length, o = r.allocUnsafe(i), u = -1; ++u < i; )
      o[u] = e(t, n[u], a);
    return o;
  }, Mf;
}
var Af = {}, X0;
function T6() {
  if (X0)
    return Af;
  X0 = 1;
  var r = $t().Buffer;
  function e(n, a, i) {
    for (var o, u = -1, c = 8, h = 0, s, d; ++u < c; )
      o = n._cipher.encryptBlock(n._prev), s = a & 1 << 7 - u ? 128 : 0, d = o[0] ^ s, h += (d & 128) >> u % 8, n._prev = t(n._prev, i ? s : d);
    return h;
  }
  function t(n, a) {
    var i = n.length, o = -1, u = r.allocUnsafe(n.length);
    for (n = r.concat([n, r.from([a])]); ++o < i; )
      u[o] = n[o] << 1 | n[o + 1] >> 7;
    return u;
  }
  return Af.encrypt = function(n, a, i) {
    for (var o = a.length, u = r.allocUnsafe(o), c = -1; ++c < o; )
      u[c] = e(n, a[c], i);
    return u;
  }, Af;
}
var Tf = {}, Z0;
function k6() {
  if (Z0)
    return Tf;
  Z0 = 1;
  var r = ga();
  function e(t) {
    return t._prev = t._cipher.encryptBlock(t._prev), t._prev;
  }
  return Tf.encrypt = function(t, n) {
    for (; t._cache.length < n.length; )
      t._cache = Xt.concat([t._cache, e(t)]);
    var a = t._cache.slice(0, n.length);
    return t._cache = t._cache.slice(n.length), r(n, a);
  }, Tf;
}
var kf = {}, If, ed;
function q1() {
  if (ed)
    return If;
  ed = 1;
  function r(e) {
    for (var t = e.length, n; t--; )
      if (n = e.readUInt8(t), n === 255)
        e.writeUInt8(0, t);
      else {
        n++, e.writeUInt8(n, t);
        break;
      }
  }
  return If = r, If;
}
var td;
function rd() {
  if (td)
    return kf;
  td = 1;
  var r = ga(), e = $t().Buffer, t = q1();
  function n(i) {
    var o = i._cipher.encryptBlockRaw(i._prev);
    return t(i._prev), o;
  }
  var a = 16;
  return kf.encrypt = function(i, o) {
    var u = Math.ceil(o.length / a), c = i._cache.length;
    i._cache = e.concat([
      i._cache,
      e.allocUnsafe(u * a)
    ]);
    for (var h = 0; h < u; h++) {
      var s = n(i), d = c + h * a;
      i._cache.writeUInt32BE(s[0], d + 0), i._cache.writeUInt32BE(s[1], d + 4), i._cache.writeUInt32BE(s[2], d + 8), i._cache.writeUInt32BE(s[3], d + 12);
    }
    var l = i._cache.slice(0, o.length);
    return i._cache = i._cache.slice(o.length), r(o, l);
  }, kf;
}
const I6 = {
  cipher: "AES",
  key: 128,
  iv: 16,
  mode: "CBC",
  type: "block"
}, R6 = {
  cipher: "AES",
  key: 192,
  iv: 16,
  mode: "CBC",
  type: "block"
}, C6 = {
  cipher: "AES",
  key: 256,
  iv: 16,
  mode: "CBC",
  type: "block"
}, L1 = {
  "aes-128-ecb": {
    cipher: "AES",
    key: 128,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-192-ecb": {
    cipher: "AES",
    key: 192,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-256-ecb": {
    cipher: "AES",
    key: 256,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-128-cbc": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-192-cbc": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-256-cbc": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes128: I6,
  aes192: R6,
  aes256: C6,
  "aes-128-cfb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-192-cfb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-256-cfb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-128-cfb8": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-192-cfb8": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-256-cfb8": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-128-cfb1": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-192-cfb1": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-256-cfb1": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-128-ofb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-192-ofb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-256-ofb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-128-ctr": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-192-ctr": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-256-ctr": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-128-gcm": {
    cipher: "AES",
    key: 128,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-192-gcm": {
    cipher: "AES",
    key: 192,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-256-gcm": {
    cipher: "AES",
    key: 256,
    iv: 12,
    mode: "GCM",
    type: "auth"
  }
};
var Rf, nd;
function rh() {
  if (nd)
    return Rf;
  nd = 1;
  var r = {
    ECB: S6(),
    CBC: E6(),
    CFB: M6(),
    CFB8: A6(),
    CFB1: T6(),
    OFB: k6(),
    CTR: rd(),
    GCM: rd()
  }, e = L1;
  for (var t in e)
    e[t].module = r[e[t].mode];
  return Rf = e, Rf;
}
var Cf = {}, id;
function Ao() {
  if (id)
    return Cf;
  id = 1;
  var r = $t().Buffer;
  function e(u) {
    r.isBuffer(u) || (u = r.from(u));
    for (var c = u.length / 4 | 0, h = new Array(c), s = 0; s < c; s++)
      h[s] = u.readUInt32BE(s * 4);
    return h;
  }
  function t(u) {
    for (var c = 0; c < u.length; u++)
      u[c] = 0;
  }
  function n(u, c, h, s, d) {
    for (var l = h[0], y = h[1], m = h[2], w = h[3], E = u[0] ^ c[0], S = u[1] ^ c[1], P = u[2] ^ c[2], L = u[3] ^ c[3], U, z, K, re, oe = 4, se = 1; se < d; se++)
      U = l[E >>> 24] ^ y[S >>> 16 & 255] ^ m[P >>> 8 & 255] ^ w[L & 255] ^ c[oe++], z = l[S >>> 24] ^ y[P >>> 16 & 255] ^ m[L >>> 8 & 255] ^ w[E & 255] ^ c[oe++], K = l[P >>> 24] ^ y[L >>> 16 & 255] ^ m[E >>> 8 & 255] ^ w[S & 255] ^ c[oe++], re = l[L >>> 24] ^ y[E >>> 16 & 255] ^ m[S >>> 8 & 255] ^ w[P & 255] ^ c[oe++], E = U, S = z, P = K, L = re;
    return U = (s[E >>> 24] << 24 | s[S >>> 16 & 255] << 16 | s[P >>> 8 & 255] << 8 | s[L & 255]) ^ c[oe++], z = (s[S >>> 24] << 24 | s[P >>> 16 & 255] << 16 | s[L >>> 8 & 255] << 8 | s[E & 255]) ^ c[oe++], K = (s[P >>> 24] << 24 | s[L >>> 16 & 255] << 16 | s[E >>> 8 & 255] << 8 | s[S & 255]) ^ c[oe++], re = (s[L >>> 24] << 24 | s[E >>> 16 & 255] << 16 | s[S >>> 8 & 255] << 8 | s[P & 255]) ^ c[oe++], U = U >>> 0, z = z >>> 0, K = K >>> 0, re = re >>> 0, [U, z, K, re];
  }
  var a = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], i = function() {
    for (var u = new Array(256), c = 0; c < 256; c++)
      c < 128 ? u[c] = c << 1 : u[c] = c << 1 ^ 283;
    for (var h = [], s = [], d = [[], [], [], []], l = [[], [], [], []], y = 0, m = 0, w = 0; w < 256; ++w) {
      var E = m ^ m << 1 ^ m << 2 ^ m << 3 ^ m << 4;
      E = E >>> 8 ^ E & 255 ^ 99, h[y] = E, s[E] = y;
      var S = u[y], P = u[S], L = u[P], U = u[E] * 257 ^ E * 16843008;
      d[0][y] = U << 24 | U >>> 8, d[1][y] = U << 16 | U >>> 16, d[2][y] = U << 8 | U >>> 24, d[3][y] = U, U = L * 16843009 ^ P * 65537 ^ S * 257 ^ y * 16843008, l[0][E] = U << 24 | U >>> 8, l[1][E] = U << 16 | U >>> 16, l[2][E] = U << 8 | U >>> 24, l[3][E] = U, y === 0 ? y = m = 1 : (y = S ^ u[u[u[L ^ S]]], m ^= u[u[m]]);
    }
    return {
      SBOX: h,
      INV_SBOX: s,
      SUB_MIX: d,
      INV_SUB_MIX: l
    };
  }();
  function o(u) {
    this._key = e(u), this._reset();
  }
  return o.blockSize = 4 * 4, o.keySize = 256 / 8, o.prototype.blockSize = o.blockSize, o.prototype.keySize = o.keySize, o.prototype._reset = function() {
    for (var u = this._key, c = u.length, h = c + 6, s = (h + 1) * 4, d = [], l = 0; l < c; l++)
      d[l] = u[l];
    for (l = c; l < s; l++) {
      var y = d[l - 1];
      l % c === 0 ? (y = y << 8 | y >>> 24, y = i.SBOX[y >>> 24] << 24 | i.SBOX[y >>> 16 & 255] << 16 | i.SBOX[y >>> 8 & 255] << 8 | i.SBOX[y & 255], y ^= a[l / c | 0] << 24) : c > 6 && l % c === 4 && (y = i.SBOX[y >>> 24] << 24 | i.SBOX[y >>> 16 & 255] << 16 | i.SBOX[y >>> 8 & 255] << 8 | i.SBOX[y & 255]), d[l] = d[l - c] ^ y;
    }
    for (var m = [], w = 0; w < s; w++) {
      var E = s - w, S = d[E - (w % 4 ? 0 : 4)];
      w < 4 || E <= 4 ? m[w] = S : m[w] = i.INV_SUB_MIX[0][i.SBOX[S >>> 24]] ^ i.INV_SUB_MIX[1][i.SBOX[S >>> 16 & 255]] ^ i.INV_SUB_MIX[2][i.SBOX[S >>> 8 & 255]] ^ i.INV_SUB_MIX[3][i.SBOX[S & 255]];
    }
    this._nRounds = h, this._keySchedule = d, this._invKeySchedule = m;
  }, o.prototype.encryptBlockRaw = function(u) {
    return u = e(u), n(u, this._keySchedule, i.SUB_MIX, i.SBOX, this._nRounds);
  }, o.prototype.encryptBlock = function(u) {
    var c = this.encryptBlockRaw(u), h = r.allocUnsafe(16);
    return h.writeUInt32BE(c[0], 0), h.writeUInt32BE(c[1], 4), h.writeUInt32BE(c[2], 8), h.writeUInt32BE(c[3], 12), h;
  }, o.prototype.decryptBlock = function(u) {
    u = e(u);
    var c = u[1];
    u[1] = u[3], u[3] = c;
    var h = n(u, this._invKeySchedule, i.INV_SUB_MIX, i.INV_SBOX, this._nRounds), s = r.allocUnsafe(16);
    return s.writeUInt32BE(h[0], 0), s.writeUInt32BE(h[3], 4), s.writeUInt32BE(h[2], 8), s.writeUInt32BE(h[1], 12), s;
  }, o.prototype.scrub = function() {
    t(this._keySchedule), t(this._invKeySchedule), t(this._key);
  }, Cf.AES = o, Cf;
}
var Of, ad;
function O6() {
  if (ad)
    return Of;
  ad = 1;
  var r = $t().Buffer, e = r.alloc(16, 0);
  function t(i) {
    return [
      i.readUInt32BE(0),
      i.readUInt32BE(4),
      i.readUInt32BE(8),
      i.readUInt32BE(12)
    ];
  }
  function n(i) {
    var o = r.allocUnsafe(16);
    return o.writeUInt32BE(i[0] >>> 0, 0), o.writeUInt32BE(i[1] >>> 0, 4), o.writeUInt32BE(i[2] >>> 0, 8), o.writeUInt32BE(i[3] >>> 0, 12), o;
  }
  function a(i) {
    this.h = i, this.state = r.alloc(16, 0), this.cache = r.allocUnsafe(0);
  }
  return a.prototype.ghash = function(i) {
    for (var o = -1; ++o < i.length; )
      this.state[o] ^= i[o];
    this._multiply();
  }, a.prototype._multiply = function() {
    for (var i = t(this.h), o = [0, 0, 0, 0], u, c, h, s = -1; ++s < 128; ) {
      for (c = (this.state[~~(s / 8)] & 1 << 7 - s % 8) !== 0, c && (o[0] ^= i[0], o[1] ^= i[1], o[2] ^= i[2], o[3] ^= i[3]), h = (i[3] & 1) !== 0, u = 3; u > 0; u--)
        i[u] = i[u] >>> 1 | (i[u - 1] & 1) << 31;
      i[0] = i[0] >>> 1, h && (i[0] = i[0] ^ 225 << 24);
    }
    this.state = n(o);
  }, a.prototype.update = function(i) {
    this.cache = r.concat([this.cache, i]);
    for (var o; this.cache.length >= 16; )
      o = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(o);
  }, a.prototype.final = function(i, o) {
    return this.cache.length && this.ghash(r.concat([this.cache, e], 16)), this.ghash(n([0, i, 0, o])), this.state;
  }, Of = a, Of;
}
var Bf, od;
function F1() {
  if (od)
    return Bf;
  od = 1;
  var r = Ao(), e = $t().Buffer, t = Hn(), n = Ft(), a = O6(), i = ga(), o = q1();
  function u(s, d) {
    var l = 0;
    s.length !== d.length && l++;
    for (var y = Math.min(s.length, d.length), m = 0; m < y; ++m)
      l += s[m] ^ d[m];
    return l;
  }
  function c(s, d, l) {
    if (d.length === 12)
      return s._finID = e.concat([d, e.from([0, 0, 0, 1])]), e.concat([d, e.from([0, 0, 0, 2])]);
    var y = new a(l), m = d.length, w = m % 16;
    y.update(d), w && (w = 16 - w, y.update(e.alloc(w, 0))), y.update(e.alloc(8, 0));
    var E = m * 8, S = e.alloc(8);
    S.writeUIntBE(E, 0, 8), y.update(S), s._finID = y.state;
    var P = e.from(s._finID);
    return o(P), P;
  }
  function h(s, d, l, y) {
    t.call(this);
    var m = e.alloc(4, 0);
    this._cipher = new r.AES(d);
    var w = this._cipher.encryptBlock(m);
    this._ghash = new a(w), l = c(this, l, w), this._prev = e.from(l), this._cache = e.allocUnsafe(0), this._secCache = e.allocUnsafe(0), this._decrypt = y, this._alen = 0, this._len = 0, this._mode = s, this._authTag = null, this._called = !1;
  }
  return n(h, t), h.prototype._update = function(s) {
    if (!this._called && this._alen) {
      var d = 16 - this._alen % 16;
      d < 16 && (d = e.alloc(d, 0), this._ghash.update(d));
    }
    this._called = !0;
    var l = this._mode.encrypt(this, s);
    return this._decrypt ? this._ghash.update(s) : this._ghash.update(l), this._len += s.length, l;
  }, h.prototype._final = function() {
    if (this._decrypt && !this._authTag)
      throw new Error("Unsupported state or unable to authenticate data");
    var s = i(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
    if (this._decrypt && u(s, this._authTag))
      throw new Error("Unsupported state or unable to authenticate data");
    this._authTag = s, this._cipher.scrub();
  }, h.prototype.getAuthTag = function() {
    if (this._decrypt || !e.isBuffer(this._authTag))
      throw new Error("Attempting to get auth tag in unsupported state");
    return this._authTag;
  }, h.prototype.setAuthTag = function(d) {
    if (!this._decrypt)
      throw new Error("Attempting to set auth tag in unsupported state");
    this._authTag = d;
  }, h.prototype.setAAD = function(d) {
    if (this._called)
      throw new Error("Attempting to set AAD in unsupported state");
    this._ghash.update(d), this._alen += d.length;
  }, Bf = h, Bf;
}
var Pf, sd;
function U1() {
  if (sd)
    return Pf;
  sd = 1;
  var r = Ao(), e = $t().Buffer, t = Hn(), n = Ft();
  function a(i, o, u, c) {
    t.call(this), this._cipher = new r.AES(o), this._prev = e.from(u), this._cache = e.allocUnsafe(0), this._secCache = e.allocUnsafe(0), this._decrypt = c, this._mode = i;
  }
  return n(a, t), a.prototype._update = function(i) {
    return this._mode.encrypt(this, i, this._decrypt);
  }, a.prototype._final = function() {
    this._cipher.scrub();
  }, Pf = a, Pf;
}
var Df, fd;
function To() {
  if (fd)
    return Df;
  fd = 1;
  var r = $t().Buffer, e = Xc();
  function t(n, a, i, o) {
    if (r.isBuffer(n) || (n = r.from(n, "binary")), a && (r.isBuffer(a) || (a = r.from(a, "binary")), a.length !== 8))
      throw new RangeError("salt should be Buffer with 8 byte length");
    for (var u = i / 8, c = r.alloc(u), h = r.alloc(o || 0), s = r.alloc(0); u > 0 || o > 0; ) {
      var d = new e();
      d.update(s), d.update(n), a && d.update(a), s = d.digest();
      var l = 0;
      if (u > 0) {
        var y = c.length - u;
        l = Math.min(u, s.length), s.copy(c, y, 0, l), u -= l;
      }
      if (l < s.length && o > 0) {
        var m = h.length - o, w = Math.min(o, s.length - l);
        s.copy(h, m, l, l + w), o -= w;
      }
    }
    return s.fill(0), { key: c, iv: h };
  }
  return Df = t, Df;
}
var ud;
function B6() {
  if (ud)
    return Na;
  ud = 1;
  var r = rh(), e = F1(), t = $t().Buffer, n = U1(), a = Hn(), i = Ao(), o = To(), u = Ft();
  function c(y, m, w) {
    a.call(this), this._cache = new s(), this._cipher = new i.AES(m), this._prev = t.from(w), this._mode = y, this._autopadding = !0;
  }
  u(c, a), c.prototype._update = function(y) {
    this._cache.add(y);
    for (var m, w, E = []; m = this._cache.get(); )
      w = this._mode.encrypt(this, m), E.push(w);
    return t.concat(E);
  };
  var h = t.alloc(16, 16);
  c.prototype._final = function() {
    var y = this._cache.flush();
    if (this._autopadding)
      return y = this._mode.encrypt(this, y), this._cipher.scrub(), y;
    if (!y.equals(h))
      throw this._cipher.scrub(), new Error("data not multiple of block length");
  }, c.prototype.setAutoPadding = function(y) {
    return this._autopadding = !!y, this;
  };
  function s() {
    this.cache = t.allocUnsafe(0);
  }
  s.prototype.add = function(y) {
    this.cache = t.concat([this.cache, y]);
  }, s.prototype.get = function() {
    if (this.cache.length > 15) {
      var y = this.cache.slice(0, 16);
      return this.cache = this.cache.slice(16), y;
    }
    return null;
  }, s.prototype.flush = function() {
    for (var y = 16 - this.cache.length, m = t.allocUnsafe(y), w = -1; ++w < y; )
      m.writeUInt8(y, w);
    return t.concat([this.cache, m]);
  };
  function d(y, m, w) {
    var E = r[y.toLowerCase()];
    if (!E)
      throw new TypeError("invalid suite type");
    if (typeof m == "string" && (m = t.from(m)), m.length !== E.key / 8)
      throw new TypeError("invalid key length " + m.length);
    if (typeof w == "string" && (w = t.from(w)), E.mode !== "GCM" && w.length !== E.iv)
      throw new TypeError("invalid iv length " + w.length);
    return E.type === "stream" ? new n(E.module, m, w) : E.type === "auth" ? new e(E.module, m, w) : new c(E.module, m, w);
  }
  function l(y, m) {
    var w = r[y.toLowerCase()];
    if (!w)
      throw new TypeError("invalid suite type");
    var E = o(m, !1, w.key, w.iv);
    return d(y, E.key, E.iv);
  }
  return Na.createCipheriv = d, Na.createCipher = l, Na;
}
var Fa = {}, cd;
function P6() {
  if (cd)
    return Fa;
  cd = 1;
  var r = F1(), e = $t().Buffer, t = rh(), n = U1(), a = Hn(), i = Ao(), o = To(), u = Ft();
  function c(y, m, w) {
    a.call(this), this._cache = new h(), this._last = void 0, this._cipher = new i.AES(m), this._prev = e.from(w), this._mode = y, this._autopadding = !0;
  }
  u(c, a), c.prototype._update = function(y) {
    this._cache.add(y);
    for (var m, w, E = []; m = this._cache.get(this._autopadding); )
      w = this._mode.decrypt(this, m), E.push(w);
    return e.concat(E);
  }, c.prototype._final = function() {
    var y = this._cache.flush();
    if (this._autopadding)
      return s(this._mode.decrypt(this, y));
    if (y)
      throw new Error("data not multiple of block length");
  }, c.prototype.setAutoPadding = function(y) {
    return this._autopadding = !!y, this;
  };
  function h() {
    this.cache = e.allocUnsafe(0);
  }
  h.prototype.add = function(y) {
    this.cache = e.concat([this.cache, y]);
  }, h.prototype.get = function(y) {
    var m;
    if (y) {
      if (this.cache.length > 16)
        return m = this.cache.slice(0, 16), this.cache = this.cache.slice(16), m;
    } else if (this.cache.length >= 16)
      return m = this.cache.slice(0, 16), this.cache = this.cache.slice(16), m;
    return null;
  }, h.prototype.flush = function() {
    if (this.cache.length)
      return this.cache;
  };
  function s(y) {
    var m = y[15];
    if (m < 1 || m > 16)
      throw new Error("unable to decrypt data");
    for (var w = -1; ++w < m; )
      if (y[w + (16 - m)] !== m)
        throw new Error("unable to decrypt data");
    if (m !== 16)
      return y.slice(0, 16 - m);
  }
  function d(y, m, w) {
    var E = t[y.toLowerCase()];
    if (!E)
      throw new TypeError("invalid suite type");
    if (typeof w == "string" && (w = e.from(w)), E.mode !== "GCM" && w.length !== E.iv)
      throw new TypeError("invalid iv length " + w.length);
    if (typeof m == "string" && (m = e.from(m)), m.length !== E.key / 8)
      throw new TypeError("invalid key length " + m.length);
    return E.type === "stream" ? new n(E.module, m, w, !0) : E.type === "auth" ? new r(E.module, m, w, !0) : new c(E.module, m, w);
  }
  function l(y, m) {
    var w = t[y.toLowerCase()];
    if (!w)
      throw new TypeError("invalid suite type");
    var E = o(m, !1, w.key, w.iv);
    return d(y, E.key, E.iv);
  }
  return Fa.createDecipher = l, Fa.createDecipheriv = d, Fa;
}
var hd;
function nh() {
  if (hd)
    return Hr;
  hd = 1;
  var r = B6(), e = P6(), t = L1;
  function n() {
    return Object.keys(t);
  }
  return Hr.createCipher = Hr.Cipher = r.createCipher, Hr.createCipheriv = Hr.Cipheriv = r.createCipheriv, Hr.createDecipher = Hr.Decipher = e.createDecipher, Hr.createDecipheriv = Hr.Decipheriv = e.createDecipheriv, Hr.listCiphers = Hr.getCiphers = n, Hr;
}
var Nf = {}, ld;
function D6() {
  return ld || (ld = 1, function(r) {
    r["des-ecb"] = {
      key: 8,
      iv: 0
    }, r["des-cbc"] = r.des = {
      key: 8,
      iv: 8
    }, r["des-ede3-cbc"] = r.des3 = {
      key: 24,
      iv: 8
    }, r["des-ede3"] = {
      key: 24,
      iv: 0
    }, r["des-ede-cbc"] = {
      key: 16,
      iv: 8
    }, r["des-ede"] = {
      key: 16,
      iv: 0
    };
  }(Nf)), Nf;
}
var dd;
function N6() {
  if (dd)
    return jr;
  dd = 1;
  var r = x6(), e = nh(), t = rh(), n = D6(), a = To();
  function i(s, d) {
    s = s.toLowerCase();
    var l, y;
    if (t[s])
      l = t[s].key, y = t[s].iv;
    else if (n[s])
      l = n[s].key * 8, y = n[s].iv;
    else
      throw new TypeError("invalid suite type");
    var m = a(d, !1, l, y);
    return u(s, m.key, m.iv);
  }
  function o(s, d) {
    s = s.toLowerCase();
    var l, y;
    if (t[s])
      l = t[s].key, y = t[s].iv;
    else if (n[s])
      l = n[s].key * 8, y = n[s].iv;
    else
      throw new TypeError("invalid suite type");
    var m = a(d, !1, l, y);
    return c(s, m.key, m.iv);
  }
  function u(s, d, l) {
    if (s = s.toLowerCase(), t[s])
      return e.createCipheriv(s, d, l);
    if (n[s])
      return new r({ key: d, iv: l, mode: s });
    throw new TypeError("invalid suite type");
  }
  function c(s, d, l) {
    if (s = s.toLowerCase(), t[s])
      return e.createDecipheriv(s, d, l);
    if (n[s])
      return new r({ key: d, iv: l, mode: s, decrypt: !0 });
    throw new TypeError("invalid suite type");
  }
  function h() {
    return Object.keys(n).concat(e.getCiphers());
  }
  return jr.createCipher = jr.Cipher = i, jr.createCipheriv = jr.Cipheriv = u, jr.createDecipher = jr.Decipher = o, jr.createDecipheriv = jr.Decipheriv = c, jr.listCiphers = jr.getCiphers = h, jr;
}
var Qn = {}, Xa = { exports: {} };
Xa.exports;
var pd;
function Ir() {
  return pd || (pd = 1, function(r) {
    (function(e, t) {
      function n(Q, A) {
        if (!Q)
          throw new Error(A || "Assertion failed");
      }
      function a(Q, A) {
        Q.super_ = A;
        var b = function() {
        };
        b.prototype = A.prototype, Q.prototype = new b(), Q.prototype.constructor = Q;
      }
      function i(Q, A, b) {
        if (i.isBN(Q))
          return Q;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, Q !== null && ((A === "le" || A === "be") && (b = A, A = 10), this._init(Q || 0, A || 10, b || "be"));
      }
      typeof e == "object" ? e.exports = i : t.BN = i, i.BN = i, i.wordSize = 26;
      var o;
      try {
        typeof window != "undefined" && typeof window.Buffer != "undefined" ? o = window.Buffer : o = Mn.Buffer;
      } catch (Q) {
      }
      i.isBN = function(A) {
        return A instanceof i ? !0 : A !== null && typeof A == "object" && A.constructor.wordSize === i.wordSize && Array.isArray(A.words);
      }, i.max = function(A, b) {
        return A.cmp(b) > 0 ? A : b;
      }, i.min = function(A, b) {
        return A.cmp(b) < 0 ? A : b;
      }, i.prototype._init = function(A, b, f) {
        if (typeof A == "number")
          return this._initNumber(A, b, f);
        if (typeof A == "object")
          return this._initArray(A, b, f);
        b === "hex" && (b = 16), n(b === (b | 0) && b >= 2 && b <= 36), A = A.toString().replace(/\s+/g, "");
        var v = 0;
        A[0] === "-" && (v++, this.negative = 1), v < A.length && (b === 16 ? this._parseHex(A, v, f) : (this._parseBase(A, b, v), f === "le" && this._initArray(this.toArray(), b, f)));
      }, i.prototype._initNumber = function(A, b, f) {
        A < 0 && (this.negative = 1, A = -A), A < 67108864 ? (this.words = [A & 67108863], this.length = 1) : A < 4503599627370496 ? (this.words = [
          A & 67108863,
          A / 67108864 & 67108863
        ], this.length = 2) : (n(A < 9007199254740992), this.words = [
          A & 67108863,
          A / 67108864 & 67108863,
          1
        ], this.length = 3), f === "le" && this._initArray(this.toArray(), b, f);
      }, i.prototype._initArray = function(A, b, f) {
        if (n(typeof A.length == "number"), A.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(A.length / 3), this.words = new Array(this.length);
        for (var v = 0; v < this.length; v++)
          this.words[v] = 0;
        var g, M, I = 0;
        if (f === "be")
          for (v = A.length - 1, g = 0; v >= 0; v -= 3)
            M = A[v] | A[v - 1] << 8 | A[v - 2] << 16, this.words[g] |= M << I & 67108863, this.words[g + 1] = M >>> 26 - I & 67108863, I += 24, I >= 26 && (I -= 26, g++);
        else if (f === "le")
          for (v = 0, g = 0; v < A.length; v += 3)
            M = A[v] | A[v + 1] << 8 | A[v + 2] << 16, this.words[g] |= M << I & 67108863, this.words[g + 1] = M >>> 26 - I & 67108863, I += 24, I >= 26 && (I -= 26, g++);
        return this.strip();
      };
      function u(Q, A) {
        var b = Q.charCodeAt(A);
        return b >= 65 && b <= 70 ? b - 55 : b >= 97 && b <= 102 ? b - 87 : b - 48 & 15;
      }
      function c(Q, A, b) {
        var f = u(Q, b);
        return b - 1 >= A && (f |= u(Q, b - 1) << 4), f;
      }
      i.prototype._parseHex = function(A, b, f) {
        this.length = Math.ceil((A.length - b) / 6), this.words = new Array(this.length);
        for (var v = 0; v < this.length; v++)
          this.words[v] = 0;
        var g = 0, M = 0, I;
        if (f === "be")
          for (v = A.length - 1; v >= b; v -= 2)
            I = c(A, b, v) << g, this.words[M] |= I & 67108863, g >= 18 ? (g -= 18, M += 1, this.words[M] |= I >>> 26) : g += 8;
        else {
          var R = A.length - b;
          for (v = R % 2 === 0 ? b + 1 : b; v < A.length; v += 2)
            I = c(A, b, v) << g, this.words[M] |= I & 67108863, g >= 18 ? (g -= 18, M += 1, this.words[M] |= I >>> 26) : g += 8;
        }
        this.strip();
      };
      function h(Q, A, b, f) {
        for (var v = 0, g = Math.min(Q.length, b), M = A; M < g; M++) {
          var I = Q.charCodeAt(M) - 48;
          v *= f, I >= 49 ? v += I - 49 + 10 : I >= 17 ? v += I - 17 + 10 : v += I;
        }
        return v;
      }
      i.prototype._parseBase = function(A, b, f) {
        this.words = [0], this.length = 1;
        for (var v = 0, g = 1; g <= 67108863; g *= b)
          v++;
        v--, g = g / b | 0;
        for (var M = A.length - f, I = M % v, R = Math.min(M, M - I) + f, x = 0, T = f; T < R; T += v)
          x = h(A, T, T + v, b), this.imuln(g), this.words[0] + x < 67108864 ? this.words[0] += x : this._iaddn(x);
        if (I !== 0) {
          var p = 1;
          for (x = h(A, T, A.length, b), T = 0; T < I; T++)
            p *= b;
          this.imuln(p), this.words[0] + x < 67108864 ? this.words[0] += x : this._iaddn(x);
        }
        this.strip();
      }, i.prototype.copy = function(A) {
        A.words = new Array(this.length);
        for (var b = 0; b < this.length; b++)
          A.words[b] = this.words[b];
        A.length = this.length, A.negative = this.negative, A.red = this.red;
      }, i.prototype.clone = function() {
        var A = new i(null);
        return this.copy(A), A;
      }, i.prototype._expand = function(A) {
        for (; this.length < A; )
          this.words[this.length++] = 0;
        return this;
      }, i.prototype.strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, i.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, i.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var s = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], d = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], l = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      i.prototype.toString = function(A, b) {
        A = A || 10, b = b | 0 || 1;
        var f;
        if (A === 16 || A === "hex") {
          f = "";
          for (var v = 0, g = 0, M = 0; M < this.length; M++) {
            var I = this.words[M], R = ((I << v | g) & 16777215).toString(16);
            g = I >>> 24 - v & 16777215, g !== 0 || M !== this.length - 1 ? f = s[6 - R.length] + R + f : f = R + f, v += 2, v >= 26 && (v -= 26, M--);
          }
          for (g !== 0 && (f = g.toString(16) + f); f.length % b !== 0; )
            f = "0" + f;
          return this.negative !== 0 && (f = "-" + f), f;
        }
        if (A === (A | 0) && A >= 2 && A <= 36) {
          var x = d[A], T = l[A];
          f = "";
          var p = this.clone();
          for (p.negative = 0; !p.isZero(); ) {
            var B = p.modn(T).toString(A);
            p = p.idivn(T), p.isZero() ? f = B + f : f = s[x - B.length] + B + f;
          }
          for (this.isZero() && (f = "0" + f); f.length % b !== 0; )
            f = "0" + f;
          return this.negative !== 0 && (f = "-" + f), f;
        }
        n(!1, "Base should be between 2 and 36");
      }, i.prototype.toNumber = function() {
        var A = this.words[0];
        return this.length === 2 ? A += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? A += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -A : A;
      }, i.prototype.toJSON = function() {
        return this.toString(16);
      }, i.prototype.toBuffer = function(A, b) {
        return n(typeof o != "undefined"), this.toArrayLike(o, A, b);
      }, i.prototype.toArray = function(A, b) {
        return this.toArrayLike(Array, A, b);
      }, i.prototype.toArrayLike = function(A, b, f) {
        var v = this.byteLength(), g = f || Math.max(1, v);
        n(v <= g, "byte array longer than desired length"), n(g > 0, "Requested array length <= 0"), this.strip();
        var M = b === "le", I = new A(g), R, x, T = this.clone();
        if (M) {
          for (x = 0; !T.isZero(); x++)
            R = T.andln(255), T.iushrn(8), I[x] = R;
          for (; x < g; x++)
            I[x] = 0;
        } else {
          for (x = 0; x < g - v; x++)
            I[x] = 0;
          for (x = 0; !T.isZero(); x++)
            R = T.andln(255), T.iushrn(8), I[g - x - 1] = R;
        }
        return I;
      }, Math.clz32 ? i.prototype._countBits = function(A) {
        return 32 - Math.clz32(A);
      } : i.prototype._countBits = function(A) {
        var b = A, f = 0;
        return b >= 4096 && (f += 13, b >>>= 13), b >= 64 && (f += 7, b >>>= 7), b >= 8 && (f += 4, b >>>= 4), b >= 2 && (f += 2, b >>>= 2), f + b;
      }, i.prototype._zeroBits = function(A) {
        if (A === 0)
          return 26;
        var b = A, f = 0;
        return b & 8191 || (f += 13, b >>>= 13), b & 127 || (f += 7, b >>>= 7), b & 15 || (f += 4, b >>>= 4), b & 3 || (f += 2, b >>>= 2), b & 1 || f++, f;
      }, i.prototype.bitLength = function() {
        var A = this.words[this.length - 1], b = this._countBits(A);
        return (this.length - 1) * 26 + b;
      };
      function y(Q) {
        for (var A = new Array(Q.bitLength()), b = 0; b < A.length; b++) {
          var f = b / 26 | 0, v = b % 26;
          A[b] = (Q.words[f] & 1 << v) >>> v;
        }
        return A;
      }
      i.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var A = 0, b = 0; b < this.length; b++) {
          var f = this._zeroBits(this.words[b]);
          if (A += f, f !== 26)
            break;
        }
        return A;
      }, i.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, i.prototype.toTwos = function(A) {
        return this.negative !== 0 ? this.abs().inotn(A).iaddn(1) : this.clone();
      }, i.prototype.fromTwos = function(A) {
        return this.testn(A - 1) ? this.notn(A).iaddn(1).ineg() : this.clone();
      }, i.prototype.isNeg = function() {
        return this.negative !== 0;
      }, i.prototype.neg = function() {
        return this.clone().ineg();
      }, i.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, i.prototype.iuor = function(A) {
        for (; this.length < A.length; )
          this.words[this.length++] = 0;
        for (var b = 0; b < A.length; b++)
          this.words[b] = this.words[b] | A.words[b];
        return this.strip();
      }, i.prototype.ior = function(A) {
        return n((this.negative | A.negative) === 0), this.iuor(A);
      }, i.prototype.or = function(A) {
        return this.length > A.length ? this.clone().ior(A) : A.clone().ior(this);
      }, i.prototype.uor = function(A) {
        return this.length > A.length ? this.clone().iuor(A) : A.clone().iuor(this);
      }, i.prototype.iuand = function(A) {
        var b;
        this.length > A.length ? b = A : b = this;
        for (var f = 0; f < b.length; f++)
          this.words[f] = this.words[f] & A.words[f];
        return this.length = b.length, this.strip();
      }, i.prototype.iand = function(A) {
        return n((this.negative | A.negative) === 0), this.iuand(A);
      }, i.prototype.and = function(A) {
        return this.length > A.length ? this.clone().iand(A) : A.clone().iand(this);
      }, i.prototype.uand = function(A) {
        return this.length > A.length ? this.clone().iuand(A) : A.clone().iuand(this);
      }, i.prototype.iuxor = function(A) {
        var b, f;
        this.length > A.length ? (b = this, f = A) : (b = A, f = this);
        for (var v = 0; v < f.length; v++)
          this.words[v] = b.words[v] ^ f.words[v];
        if (this !== b)
          for (; v < b.length; v++)
            this.words[v] = b.words[v];
        return this.length = b.length, this.strip();
      }, i.prototype.ixor = function(A) {
        return n((this.negative | A.negative) === 0), this.iuxor(A);
      }, i.prototype.xor = function(A) {
        return this.length > A.length ? this.clone().ixor(A) : A.clone().ixor(this);
      }, i.prototype.uxor = function(A) {
        return this.length > A.length ? this.clone().iuxor(A) : A.clone().iuxor(this);
      }, i.prototype.inotn = function(A) {
        n(typeof A == "number" && A >= 0);
        var b = Math.ceil(A / 26) | 0, f = A % 26;
        this._expand(b), f > 0 && b--;
        for (var v = 0; v < b; v++)
          this.words[v] = ~this.words[v] & 67108863;
        return f > 0 && (this.words[v] = ~this.words[v] & 67108863 >> 26 - f), this.strip();
      }, i.prototype.notn = function(A) {
        return this.clone().inotn(A);
      }, i.prototype.setn = function(A, b) {
        n(typeof A == "number" && A >= 0);
        var f = A / 26 | 0, v = A % 26;
        return this._expand(f + 1), b ? this.words[f] = this.words[f] | 1 << v : this.words[f] = this.words[f] & ~(1 << v), this.strip();
      }, i.prototype.iadd = function(A) {
        var b;
        if (this.negative !== 0 && A.negative === 0)
          return this.negative = 0, b = this.isub(A), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && A.negative !== 0)
          return A.negative = 0, b = this.isub(A), A.negative = 1, b._normSign();
        var f, v;
        this.length > A.length ? (f = this, v = A) : (f = A, v = this);
        for (var g = 0, M = 0; M < v.length; M++)
          b = (f.words[M] | 0) + (v.words[M] | 0) + g, this.words[M] = b & 67108863, g = b >>> 26;
        for (; g !== 0 && M < f.length; M++)
          b = (f.words[M] | 0) + g, this.words[M] = b & 67108863, g = b >>> 26;
        if (this.length = f.length, g !== 0)
          this.words[this.length] = g, this.length++;
        else if (f !== this)
          for (; M < f.length; M++)
            this.words[M] = f.words[M];
        return this;
      }, i.prototype.add = function(A) {
        var b;
        return A.negative !== 0 && this.negative === 0 ? (A.negative = 0, b = this.sub(A), A.negative ^= 1, b) : A.negative === 0 && this.negative !== 0 ? (this.negative = 0, b = A.sub(this), this.negative = 1, b) : this.length > A.length ? this.clone().iadd(A) : A.clone().iadd(this);
      }, i.prototype.isub = function(A) {
        if (A.negative !== 0) {
          A.negative = 0;
          var b = this.iadd(A);
          return A.negative = 1, b._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(A), this.negative = 1, this._normSign();
        var f = this.cmp(A);
        if (f === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var v, g;
        f > 0 ? (v = this, g = A) : (v = A, g = this);
        for (var M = 0, I = 0; I < g.length; I++)
          b = (v.words[I] | 0) - (g.words[I] | 0) + M, M = b >> 26, this.words[I] = b & 67108863;
        for (; M !== 0 && I < v.length; I++)
          b = (v.words[I] | 0) + M, M = b >> 26, this.words[I] = b & 67108863;
        if (M === 0 && I < v.length && v !== this)
          for (; I < v.length; I++)
            this.words[I] = v.words[I];
        return this.length = Math.max(this.length, I), v !== this && (this.negative = 1), this.strip();
      }, i.prototype.sub = function(A) {
        return this.clone().isub(A);
      };
      function m(Q, A, b) {
        b.negative = A.negative ^ Q.negative;
        var f = Q.length + A.length | 0;
        b.length = f, f = f - 1 | 0;
        var v = Q.words[0] | 0, g = A.words[0] | 0, M = v * g, I = M & 67108863, R = M / 67108864 | 0;
        b.words[0] = I;
        for (var x = 1; x < f; x++) {
          for (var T = R >>> 26, p = R & 67108863, B = Math.min(x, A.length - 1), ee = Math.max(0, x - Q.length + 1); ee <= B; ee++) {
            var ae = x - ee | 0;
            v = Q.words[ae] | 0, g = A.words[ee] | 0, M = v * g + p, T += M / 67108864 | 0, p = M & 67108863;
          }
          b.words[x] = p | 0, R = T | 0;
        }
        return R !== 0 ? b.words[x] = R | 0 : b.length--, b.strip();
      }
      var w = function(A, b, f) {
        var v = A.words, g = b.words, M = f.words, I = 0, R, x, T, p = v[0] | 0, B = p & 8191, ee = p >>> 13, ae = v[1] | 0, Z = ae & 8191, ne = ae >>> 13, fe = v[2] | 0, le = fe & 8191, ke = fe >>> 13, X = v[3] | 0, G = X & 8191, we = X >>> 13, Ae = v[4] | 0, Oe = Ae & 8191, qe = Ae >>> 13, Ue = v[5] | 0, ze = Ue & 8191, ge = Ue >>> 13, ht = v[6] | 0, $e = ht & 8191, Et = ht >>> 13, ot = v[7] | 0, Ve = ot & 8191, Mt = ot >>> 13, lt = v[8] | 0, Xe = lt & 8191, st = lt >>> 13, gt = v[9] | 0, W = gt & 8191, q = gt >>> 13, F = g[0] | 0, J = F & 8191, he = F >>> 13, de = g[1] | 0, pe = de & 8191, Je = de >>> 13, tt = g[2] | 0, Ne = tt & 8191, St = tt >>> 13, rt = g[3] | 0, dt = rt & 8191, Zt = rt >>> 13, bt = g[4] | 0, at = bt & 8191, jt = bt >>> 13, _t = g[5] | 0, ft = _t & 8191, Yt = _t >>> 13, kt = g[6] | 0, Ze = kt & 8191, Ht = kt >>> 13, j = g[7] | 0, N = j & 8191, D = j >>> 13, _ = g[8] | 0, $ = _ & 8191, Y = _ >>> 13, ie = g[9] | 0, ce = ie & 8191, me = ie >>> 13;
        f.negative = A.negative ^ b.negative, f.length = 19, R = Math.imul(B, J), x = Math.imul(B, he), x = x + Math.imul(ee, J) | 0, T = Math.imul(ee, he);
        var Me = (I + R | 0) + ((x & 8191) << 13) | 0;
        I = (T + (x >>> 13) | 0) + (Me >>> 26) | 0, Me &= 67108863, R = Math.imul(Z, J), x = Math.imul(Z, he), x = x + Math.imul(ne, J) | 0, T = Math.imul(ne, he), R = R + Math.imul(B, pe) | 0, x = x + Math.imul(B, Je) | 0, x = x + Math.imul(ee, pe) | 0, T = T + Math.imul(ee, Je) | 0;
        var Se = (I + R | 0) + ((x & 8191) << 13) | 0;
        I = (T + (x >>> 13) | 0) + (Se >>> 26) | 0, Se &= 67108863, R = Math.imul(le, J), x = Math.imul(le, he), x = x + Math.imul(ke, J) | 0, T = Math.imul(ke, he), R = R + Math.imul(Z, pe) | 0, x = x + Math.imul(Z, Je) | 0, x = x + Math.imul(ne, pe) | 0, T = T + Math.imul(ne, Je) | 0, R = R + Math.imul(B, Ne) | 0, x = x + Math.imul(B, St) | 0, x = x + Math.imul(ee, Ne) | 0, T = T + Math.imul(ee, St) | 0;
        var Ge = (I + R | 0) + ((x & 8191) << 13) | 0;
        I = (T + (x >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, R = Math.imul(G, J), x = Math.imul(G, he), x = x + Math.imul(we, J) | 0, T = Math.imul(we, he), R = R + Math.imul(le, pe) | 0, x = x + Math.imul(le, Je) | 0, x = x + Math.imul(ke, pe) | 0, T = T + Math.imul(ke, Je) | 0, R = R + Math.imul(Z, Ne) | 0, x = x + Math.imul(Z, St) | 0, x = x + Math.imul(ne, Ne) | 0, T = T + Math.imul(ne, St) | 0, R = R + Math.imul(B, dt) | 0, x = x + Math.imul(B, Zt) | 0, x = x + Math.imul(ee, dt) | 0, T = T + Math.imul(ee, Zt) | 0;
        var Be = (I + R | 0) + ((x & 8191) << 13) | 0;
        I = (T + (x >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, R = Math.imul(Oe, J), x = Math.imul(Oe, he), x = x + Math.imul(qe, J) | 0, T = Math.imul(qe, he), R = R + Math.imul(G, pe) | 0, x = x + Math.imul(G, Je) | 0, x = x + Math.imul(we, pe) | 0, T = T + Math.imul(we, Je) | 0, R = R + Math.imul(le, Ne) | 0, x = x + Math.imul(le, St) | 0, x = x + Math.imul(ke, Ne) | 0, T = T + Math.imul(ke, St) | 0, R = R + Math.imul(Z, dt) | 0, x = x + Math.imul(Z, Zt) | 0, x = x + Math.imul(ne, dt) | 0, T = T + Math.imul(ne, Zt) | 0, R = R + Math.imul(B, at) | 0, x = x + Math.imul(B, jt) | 0, x = x + Math.imul(ee, at) | 0, T = T + Math.imul(ee, jt) | 0;
        var Ye = (I + R | 0) + ((x & 8191) << 13) | 0;
        I = (T + (x >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, R = Math.imul(ze, J), x = Math.imul(ze, he), x = x + Math.imul(ge, J) | 0, T = Math.imul(ge, he), R = R + Math.imul(Oe, pe) | 0, x = x + Math.imul(Oe, Je) | 0, x = x + Math.imul(qe, pe) | 0, T = T + Math.imul(qe, Je) | 0, R = R + Math.imul(G, Ne) | 0, x = x + Math.imul(G, St) | 0, x = x + Math.imul(we, Ne) | 0, T = T + Math.imul(we, St) | 0, R = R + Math.imul(le, dt) | 0, x = x + Math.imul(le, Zt) | 0, x = x + Math.imul(ke, dt) | 0, T = T + Math.imul(ke, Zt) | 0, R = R + Math.imul(Z, at) | 0, x = x + Math.imul(Z, jt) | 0, x = x + Math.imul(ne, at) | 0, T = T + Math.imul(ne, jt) | 0, R = R + Math.imul(B, ft) | 0, x = x + Math.imul(B, Yt) | 0, x = x + Math.imul(ee, ft) | 0, T = T + Math.imul(ee, Yt) | 0;
        var Pe = (I + R | 0) + ((x & 8191) << 13) | 0;
        I = (T + (x >>> 13) | 0) + (Pe >>> 26) | 0, Pe &= 67108863, R = Math.imul($e, J), x = Math.imul($e, he), x = x + Math.imul(Et, J) | 0, T = Math.imul(Et, he), R = R + Math.imul(ze, pe) | 0, x = x + Math.imul(ze, Je) | 0, x = x + Math.imul(ge, pe) | 0, T = T + Math.imul(ge, Je) | 0, R = R + Math.imul(Oe, Ne) | 0, x = x + Math.imul(Oe, St) | 0, x = x + Math.imul(qe, Ne) | 0, T = T + Math.imul(qe, St) | 0, R = R + Math.imul(G, dt) | 0, x = x + Math.imul(G, Zt) | 0, x = x + Math.imul(we, dt) | 0, T = T + Math.imul(we, Zt) | 0, R = R + Math.imul(le, at) | 0, x = x + Math.imul(le, jt) | 0, x = x + Math.imul(ke, at) | 0, T = T + Math.imul(ke, jt) | 0, R = R + Math.imul(Z, ft) | 0, x = x + Math.imul(Z, Yt) | 0, x = x + Math.imul(ne, ft) | 0, T = T + Math.imul(ne, Yt) | 0, R = R + Math.imul(B, Ze) | 0, x = x + Math.imul(B, Ht) | 0, x = x + Math.imul(ee, Ze) | 0, T = T + Math.imul(ee, Ht) | 0;
        var et = (I + R | 0) + ((x & 8191) << 13) | 0;
        I = (T + (x >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, R = Math.imul(Ve, J), x = Math.imul(Ve, he), x = x + Math.imul(Mt, J) | 0, T = Math.imul(Mt, he), R = R + Math.imul($e, pe) | 0, x = x + Math.imul($e, Je) | 0, x = x + Math.imul(Et, pe) | 0, T = T + Math.imul(Et, Je) | 0, R = R + Math.imul(ze, Ne) | 0, x = x + Math.imul(ze, St) | 0, x = x + Math.imul(ge, Ne) | 0, T = T + Math.imul(ge, St) | 0, R = R + Math.imul(Oe, dt) | 0, x = x + Math.imul(Oe, Zt) | 0, x = x + Math.imul(qe, dt) | 0, T = T + Math.imul(qe, Zt) | 0, R = R + Math.imul(G, at) | 0, x = x + Math.imul(G, jt) | 0, x = x + Math.imul(we, at) | 0, T = T + Math.imul(we, jt) | 0, R = R + Math.imul(le, ft) | 0, x = x + Math.imul(le, Yt) | 0, x = x + Math.imul(ke, ft) | 0, T = T + Math.imul(ke, Yt) | 0, R = R + Math.imul(Z, Ze) | 0, x = x + Math.imul(Z, Ht) | 0, x = x + Math.imul(ne, Ze) | 0, T = T + Math.imul(ne, Ht) | 0, R = R + Math.imul(B, N) | 0, x = x + Math.imul(B, D) | 0, x = x + Math.imul(ee, N) | 0, T = T + Math.imul(ee, D) | 0;
        var nt = (I + R | 0) + ((x & 8191) << 13) | 0;
        I = (T + (x >>> 13) | 0) + (nt >>> 26) | 0, nt &= 67108863, R = Math.imul(Xe, J), x = Math.imul(Xe, he), x = x + Math.imul(st, J) | 0, T = Math.imul(st, he), R = R + Math.imul(Ve, pe) | 0, x = x + Math.imul(Ve, Je) | 0, x = x + Math.imul(Mt, pe) | 0, T = T + Math.imul(Mt, Je) | 0, R = R + Math.imul($e, Ne) | 0, x = x + Math.imul($e, St) | 0, x = x + Math.imul(Et, Ne) | 0, T = T + Math.imul(Et, St) | 0, R = R + Math.imul(ze, dt) | 0, x = x + Math.imul(ze, Zt) | 0, x = x + Math.imul(ge, dt) | 0, T = T + Math.imul(ge, Zt) | 0, R = R + Math.imul(Oe, at) | 0, x = x + Math.imul(Oe, jt) | 0, x = x + Math.imul(qe, at) | 0, T = T + Math.imul(qe, jt) | 0, R = R + Math.imul(G, ft) | 0, x = x + Math.imul(G, Yt) | 0, x = x + Math.imul(we, ft) | 0, T = T + Math.imul(we, Yt) | 0, R = R + Math.imul(le, Ze) | 0, x = x + Math.imul(le, Ht) | 0, x = x + Math.imul(ke, Ze) | 0, T = T + Math.imul(ke, Ht) | 0, R = R + Math.imul(Z, N) | 0, x = x + Math.imul(Z, D) | 0, x = x + Math.imul(ne, N) | 0, T = T + Math.imul(ne, D) | 0, R = R + Math.imul(B, $) | 0, x = x + Math.imul(B, Y) | 0, x = x + Math.imul(ee, $) | 0, T = T + Math.imul(ee, Y) | 0;
        var Qe = (I + R | 0) + ((x & 8191) << 13) | 0;
        I = (T + (x >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, R = Math.imul(W, J), x = Math.imul(W, he), x = x + Math.imul(q, J) | 0, T = Math.imul(q, he), R = R + Math.imul(Xe, pe) | 0, x = x + Math.imul(Xe, Je) | 0, x = x + Math.imul(st, pe) | 0, T = T + Math.imul(st, Je) | 0, R = R + Math.imul(Ve, Ne) | 0, x = x + Math.imul(Ve, St) | 0, x = x + Math.imul(Mt, Ne) | 0, T = T + Math.imul(Mt, St) | 0, R = R + Math.imul($e, dt) | 0, x = x + Math.imul($e, Zt) | 0, x = x + Math.imul(Et, dt) | 0, T = T + Math.imul(Et, Zt) | 0, R = R + Math.imul(ze, at) | 0, x = x + Math.imul(ze, jt) | 0, x = x + Math.imul(ge, at) | 0, T = T + Math.imul(ge, jt) | 0, R = R + Math.imul(Oe, ft) | 0, x = x + Math.imul(Oe, Yt) | 0, x = x + Math.imul(qe, ft) | 0, T = T + Math.imul(qe, Yt) | 0, R = R + Math.imul(G, Ze) | 0, x = x + Math.imul(G, Ht) | 0, x = x + Math.imul(we, Ze) | 0, T = T + Math.imul(we, Ht) | 0, R = R + Math.imul(le, N) | 0, x = x + Math.imul(le, D) | 0, x = x + Math.imul(ke, N) | 0, T = T + Math.imul(ke, D) | 0, R = R + Math.imul(Z, $) | 0, x = x + Math.imul(Z, Y) | 0, x = x + Math.imul(ne, $) | 0, T = T + Math.imul(ne, Y) | 0, R = R + Math.imul(B, ce) | 0, x = x + Math.imul(B, me) | 0, x = x + Math.imul(ee, ce) | 0, T = T + Math.imul(ee, me) | 0;
        var pt = (I + R | 0) + ((x & 8191) << 13) | 0;
        I = (T + (x >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, R = Math.imul(W, pe), x = Math.imul(W, Je), x = x + Math.imul(q, pe) | 0, T = Math.imul(q, Je), R = R + Math.imul(Xe, Ne) | 0, x = x + Math.imul(Xe, St) | 0, x = x + Math.imul(st, Ne) | 0, T = T + Math.imul(st, St) | 0, R = R + Math.imul(Ve, dt) | 0, x = x + Math.imul(Ve, Zt) | 0, x = x + Math.imul(Mt, dt) | 0, T = T + Math.imul(Mt, Zt) | 0, R = R + Math.imul($e, at) | 0, x = x + Math.imul($e, jt) | 0, x = x + Math.imul(Et, at) | 0, T = T + Math.imul(Et, jt) | 0, R = R + Math.imul(ze, ft) | 0, x = x + Math.imul(ze, Yt) | 0, x = x + Math.imul(ge, ft) | 0, T = T + Math.imul(ge, Yt) | 0, R = R + Math.imul(Oe, Ze) | 0, x = x + Math.imul(Oe, Ht) | 0, x = x + Math.imul(qe, Ze) | 0, T = T + Math.imul(qe, Ht) | 0, R = R + Math.imul(G, N) | 0, x = x + Math.imul(G, D) | 0, x = x + Math.imul(we, N) | 0, T = T + Math.imul(we, D) | 0, R = R + Math.imul(le, $) | 0, x = x + Math.imul(le, Y) | 0, x = x + Math.imul(ke, $) | 0, T = T + Math.imul(ke, Y) | 0, R = R + Math.imul(Z, ce) | 0, x = x + Math.imul(Z, me) | 0, x = x + Math.imul(ne, ce) | 0, T = T + Math.imul(ne, me) | 0;
        var ut = (I + R | 0) + ((x & 8191) << 13) | 0;
        I = (T + (x >>> 13) | 0) + (ut >>> 26) | 0, ut &= 67108863, R = Math.imul(W, Ne), x = Math.imul(W, St), x = x + Math.imul(q, Ne) | 0, T = Math.imul(q, St), R = R + Math.imul(Xe, dt) | 0, x = x + Math.imul(Xe, Zt) | 0, x = x + Math.imul(st, dt) | 0, T = T + Math.imul(st, Zt) | 0, R = R + Math.imul(Ve, at) | 0, x = x + Math.imul(Ve, jt) | 0, x = x + Math.imul(Mt, at) | 0, T = T + Math.imul(Mt, jt) | 0, R = R + Math.imul($e, ft) | 0, x = x + Math.imul($e, Yt) | 0, x = x + Math.imul(Et, ft) | 0, T = T + Math.imul(Et, Yt) | 0, R = R + Math.imul(ze, Ze) | 0, x = x + Math.imul(ze, Ht) | 0, x = x + Math.imul(ge, Ze) | 0, T = T + Math.imul(ge, Ht) | 0, R = R + Math.imul(Oe, N) | 0, x = x + Math.imul(Oe, D) | 0, x = x + Math.imul(qe, N) | 0, T = T + Math.imul(qe, D) | 0, R = R + Math.imul(G, $) | 0, x = x + Math.imul(G, Y) | 0, x = x + Math.imul(we, $) | 0, T = T + Math.imul(we, Y) | 0, R = R + Math.imul(le, ce) | 0, x = x + Math.imul(le, me) | 0, x = x + Math.imul(ke, ce) | 0, T = T + Math.imul(ke, me) | 0;
        var Le = (I + R | 0) + ((x & 8191) << 13) | 0;
        I = (T + (x >>> 13) | 0) + (Le >>> 26) | 0, Le &= 67108863, R = Math.imul(W, dt), x = Math.imul(W, Zt), x = x + Math.imul(q, dt) | 0, T = Math.imul(q, Zt), R = R + Math.imul(Xe, at) | 0, x = x + Math.imul(Xe, jt) | 0, x = x + Math.imul(st, at) | 0, T = T + Math.imul(st, jt) | 0, R = R + Math.imul(Ve, ft) | 0, x = x + Math.imul(Ve, Yt) | 0, x = x + Math.imul(Mt, ft) | 0, T = T + Math.imul(Mt, Yt) | 0, R = R + Math.imul($e, Ze) | 0, x = x + Math.imul($e, Ht) | 0, x = x + Math.imul(Et, Ze) | 0, T = T + Math.imul(Et, Ht) | 0, R = R + Math.imul(ze, N) | 0, x = x + Math.imul(ze, D) | 0, x = x + Math.imul(ge, N) | 0, T = T + Math.imul(ge, D) | 0, R = R + Math.imul(Oe, $) | 0, x = x + Math.imul(Oe, Y) | 0, x = x + Math.imul(qe, $) | 0, T = T + Math.imul(qe, Y) | 0, R = R + Math.imul(G, ce) | 0, x = x + Math.imul(G, me) | 0, x = x + Math.imul(we, ce) | 0, T = T + Math.imul(we, me) | 0;
        var it = (I + R | 0) + ((x & 8191) << 13) | 0;
        I = (T + (x >>> 13) | 0) + (it >>> 26) | 0, it &= 67108863, R = Math.imul(W, at), x = Math.imul(W, jt), x = x + Math.imul(q, at) | 0, T = Math.imul(q, jt), R = R + Math.imul(Xe, ft) | 0, x = x + Math.imul(Xe, Yt) | 0, x = x + Math.imul(st, ft) | 0, T = T + Math.imul(st, Yt) | 0, R = R + Math.imul(Ve, Ze) | 0, x = x + Math.imul(Ve, Ht) | 0, x = x + Math.imul(Mt, Ze) | 0, T = T + Math.imul(Mt, Ht) | 0, R = R + Math.imul($e, N) | 0, x = x + Math.imul($e, D) | 0, x = x + Math.imul(Et, N) | 0, T = T + Math.imul(Et, D) | 0, R = R + Math.imul(ze, $) | 0, x = x + Math.imul(ze, Y) | 0, x = x + Math.imul(ge, $) | 0, T = T + Math.imul(ge, Y) | 0, R = R + Math.imul(Oe, ce) | 0, x = x + Math.imul(Oe, me) | 0, x = x + Math.imul(qe, ce) | 0, T = T + Math.imul(qe, me) | 0;
        var je = (I + R | 0) + ((x & 8191) << 13) | 0;
        I = (T + (x >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, R = Math.imul(W, ft), x = Math.imul(W, Yt), x = x + Math.imul(q, ft) | 0, T = Math.imul(q, Yt), R = R + Math.imul(Xe, Ze) | 0, x = x + Math.imul(Xe, Ht) | 0, x = x + Math.imul(st, Ze) | 0, T = T + Math.imul(st, Ht) | 0, R = R + Math.imul(Ve, N) | 0, x = x + Math.imul(Ve, D) | 0, x = x + Math.imul(Mt, N) | 0, T = T + Math.imul(Mt, D) | 0, R = R + Math.imul($e, $) | 0, x = x + Math.imul($e, Y) | 0, x = x + Math.imul(Et, $) | 0, T = T + Math.imul(Et, Y) | 0, R = R + Math.imul(ze, ce) | 0, x = x + Math.imul(ze, me) | 0, x = x + Math.imul(ge, ce) | 0, T = T + Math.imul(ge, me) | 0;
        var He = (I + R | 0) + ((x & 8191) << 13) | 0;
        I = (T + (x >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, R = Math.imul(W, Ze), x = Math.imul(W, Ht), x = x + Math.imul(q, Ze) | 0, T = Math.imul(q, Ht), R = R + Math.imul(Xe, N) | 0, x = x + Math.imul(Xe, D) | 0, x = x + Math.imul(st, N) | 0, T = T + Math.imul(st, D) | 0, R = R + Math.imul(Ve, $) | 0, x = x + Math.imul(Ve, Y) | 0, x = x + Math.imul(Mt, $) | 0, T = T + Math.imul(Mt, Y) | 0, R = R + Math.imul($e, ce) | 0, x = x + Math.imul($e, me) | 0, x = x + Math.imul(Et, ce) | 0, T = T + Math.imul(Et, me) | 0;
        var We = (I + R | 0) + ((x & 8191) << 13) | 0;
        I = (T + (x >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, R = Math.imul(W, N), x = Math.imul(W, D), x = x + Math.imul(q, N) | 0, T = Math.imul(q, D), R = R + Math.imul(Xe, $) | 0, x = x + Math.imul(Xe, Y) | 0, x = x + Math.imul(st, $) | 0, T = T + Math.imul(st, Y) | 0, R = R + Math.imul(Ve, ce) | 0, x = x + Math.imul(Ve, me) | 0, x = x + Math.imul(Mt, ce) | 0, T = T + Math.imul(Mt, me) | 0;
        var Fe = (I + R | 0) + ((x & 8191) << 13) | 0;
        I = (T + (x >>> 13) | 0) + (Fe >>> 26) | 0, Fe &= 67108863, R = Math.imul(W, $), x = Math.imul(W, Y), x = x + Math.imul(q, $) | 0, T = Math.imul(q, Y), R = R + Math.imul(Xe, ce) | 0, x = x + Math.imul(Xe, me) | 0, x = x + Math.imul(st, ce) | 0, T = T + Math.imul(st, me) | 0;
        var ye = (I + R | 0) + ((x & 8191) << 13) | 0;
        I = (T + (x >>> 13) | 0) + (ye >>> 26) | 0, ye &= 67108863, R = Math.imul(W, ce), x = Math.imul(W, me), x = x + Math.imul(q, ce) | 0, T = Math.imul(q, me);
        var be = (I + R | 0) + ((x & 8191) << 13) | 0;
        return I = (T + (x >>> 13) | 0) + (be >>> 26) | 0, be &= 67108863, M[0] = Me, M[1] = Se, M[2] = Ge, M[3] = Be, M[4] = Ye, M[5] = Pe, M[6] = et, M[7] = nt, M[8] = Qe, M[9] = pt, M[10] = ut, M[11] = Le, M[12] = it, M[13] = je, M[14] = He, M[15] = We, M[16] = Fe, M[17] = ye, M[18] = be, I !== 0 && (M[19] = I, f.length++), f;
      };
      Math.imul || (w = m);
      function E(Q, A, b) {
        b.negative = A.negative ^ Q.negative, b.length = Q.length + A.length;
        for (var f = 0, v = 0, g = 0; g < b.length - 1; g++) {
          var M = v;
          v = 0;
          for (var I = f & 67108863, R = Math.min(g, A.length - 1), x = Math.max(0, g - Q.length + 1); x <= R; x++) {
            var T = g - x, p = Q.words[T] | 0, B = A.words[x] | 0, ee = p * B, ae = ee & 67108863;
            M = M + (ee / 67108864 | 0) | 0, ae = ae + I | 0, I = ae & 67108863, M = M + (ae >>> 26) | 0, v += M >>> 26, M &= 67108863;
          }
          b.words[g] = I, f = M, M = v;
        }
        return f !== 0 ? b.words[g] = f : b.length--, b.strip();
      }
      function S(Q, A, b) {
        var f = new P();
        return f.mulp(Q, A, b);
      }
      i.prototype.mulTo = function(A, b) {
        var f, v = this.length + A.length;
        return this.length === 10 && A.length === 10 ? f = w(this, A, b) : v < 63 ? f = m(this, A, b) : v < 1024 ? f = E(this, A, b) : f = S(this, A, b), f;
      };
      function P(Q, A) {
        this.x = Q, this.y = A;
      }
      P.prototype.makeRBT = function(A) {
        for (var b = new Array(A), f = i.prototype._countBits(A) - 1, v = 0; v < A; v++)
          b[v] = this.revBin(v, f, A);
        return b;
      }, P.prototype.revBin = function(A, b, f) {
        if (A === 0 || A === f - 1)
          return A;
        for (var v = 0, g = 0; g < b; g++)
          v |= (A & 1) << b - g - 1, A >>= 1;
        return v;
      }, P.prototype.permute = function(A, b, f, v, g, M) {
        for (var I = 0; I < M; I++)
          v[I] = b[A[I]], g[I] = f[A[I]];
      }, P.prototype.transform = function(A, b, f, v, g, M) {
        this.permute(M, A, b, f, v, g);
        for (var I = 1; I < g; I <<= 1)
          for (var R = I << 1, x = Math.cos(2 * Math.PI / R), T = Math.sin(2 * Math.PI / R), p = 0; p < g; p += R)
            for (var B = x, ee = T, ae = 0; ae < I; ae++) {
              var Z = f[p + ae], ne = v[p + ae], fe = f[p + ae + I], le = v[p + ae + I], ke = B * fe - ee * le;
              le = B * le + ee * fe, fe = ke, f[p + ae] = Z + fe, v[p + ae] = ne + le, f[p + ae + I] = Z - fe, v[p + ae + I] = ne - le, ae !== R && (ke = x * B - T * ee, ee = x * ee + T * B, B = ke);
            }
      }, P.prototype.guessLen13b = function(A, b) {
        var f = Math.max(b, A) | 1, v = f & 1, g = 0;
        for (f = f / 2 | 0; f; f = f >>> 1)
          g++;
        return 1 << g + 1 + v;
      }, P.prototype.conjugate = function(A, b, f) {
        if (!(f <= 1))
          for (var v = 0; v < f / 2; v++) {
            var g = A[v];
            A[v] = A[f - v - 1], A[f - v - 1] = g, g = b[v], b[v] = -b[f - v - 1], b[f - v - 1] = -g;
          }
      }, P.prototype.normalize13b = function(A, b) {
        for (var f = 0, v = 0; v < b / 2; v++) {
          var g = Math.round(A[2 * v + 1] / b) * 8192 + Math.round(A[2 * v] / b) + f;
          A[v] = g & 67108863, g < 67108864 ? f = 0 : f = g / 67108864 | 0;
        }
        return A;
      }, P.prototype.convert13b = function(A, b, f, v) {
        for (var g = 0, M = 0; M < b; M++)
          g = g + (A[M] | 0), f[2 * M] = g & 8191, g = g >>> 13, f[2 * M + 1] = g & 8191, g = g >>> 13;
        for (M = 2 * b; M < v; ++M)
          f[M] = 0;
        n(g === 0), n((g & -8192) === 0);
      }, P.prototype.stub = function(A) {
        for (var b = new Array(A), f = 0; f < A; f++)
          b[f] = 0;
        return b;
      }, P.prototype.mulp = function(A, b, f) {
        var v = 2 * this.guessLen13b(A.length, b.length), g = this.makeRBT(v), M = this.stub(v), I = new Array(v), R = new Array(v), x = new Array(v), T = new Array(v), p = new Array(v), B = new Array(v), ee = f.words;
        ee.length = v, this.convert13b(A.words, A.length, I, v), this.convert13b(b.words, b.length, T, v), this.transform(I, M, R, x, v, g), this.transform(T, M, p, B, v, g);
        for (var ae = 0; ae < v; ae++) {
          var Z = R[ae] * p[ae] - x[ae] * B[ae];
          x[ae] = R[ae] * B[ae] + x[ae] * p[ae], R[ae] = Z;
        }
        return this.conjugate(R, x, v), this.transform(R, x, ee, M, v, g), this.conjugate(ee, M, v), this.normalize13b(ee, v), f.negative = A.negative ^ b.negative, f.length = A.length + b.length, f.strip();
      }, i.prototype.mul = function(A) {
        var b = new i(null);
        return b.words = new Array(this.length + A.length), this.mulTo(A, b);
      }, i.prototype.mulf = function(A) {
        var b = new i(null);
        return b.words = new Array(this.length + A.length), S(this, A, b);
      }, i.prototype.imul = function(A) {
        return this.clone().mulTo(A, this);
      }, i.prototype.imuln = function(A) {
        n(typeof A == "number"), n(A < 67108864);
        for (var b = 0, f = 0; f < this.length; f++) {
          var v = (this.words[f] | 0) * A, g = (v & 67108863) + (b & 67108863);
          b >>= 26, b += v / 67108864 | 0, b += g >>> 26, this.words[f] = g & 67108863;
        }
        return b !== 0 && (this.words[f] = b, this.length++), this;
      }, i.prototype.muln = function(A) {
        return this.clone().imuln(A);
      }, i.prototype.sqr = function() {
        return this.mul(this);
      }, i.prototype.isqr = function() {
        return this.imul(this.clone());
      }, i.prototype.pow = function(A) {
        var b = y(A);
        if (b.length === 0)
          return new i(1);
        for (var f = this, v = 0; v < b.length && b[v] === 0; v++, f = f.sqr())
          ;
        if (++v < b.length)
          for (var g = f.sqr(); v < b.length; v++, g = g.sqr())
            b[v] !== 0 && (f = f.mul(g));
        return f;
      }, i.prototype.iushln = function(A) {
        n(typeof A == "number" && A >= 0);
        var b = A % 26, f = (A - b) / 26, v = 67108863 >>> 26 - b << 26 - b, g;
        if (b !== 0) {
          var M = 0;
          for (g = 0; g < this.length; g++) {
            var I = this.words[g] & v, R = (this.words[g] | 0) - I << b;
            this.words[g] = R | M, M = I >>> 26 - b;
          }
          M && (this.words[g] = M, this.length++);
        }
        if (f !== 0) {
          for (g = this.length - 1; g >= 0; g--)
            this.words[g + f] = this.words[g];
          for (g = 0; g < f; g++)
            this.words[g] = 0;
          this.length += f;
        }
        return this.strip();
      }, i.prototype.ishln = function(A) {
        return n(this.negative === 0), this.iushln(A);
      }, i.prototype.iushrn = function(A, b, f) {
        n(typeof A == "number" && A >= 0);
        var v;
        b ? v = (b - b % 26) / 26 : v = 0;
        var g = A % 26, M = Math.min((A - g) / 26, this.length), I = 67108863 ^ 67108863 >>> g << g, R = f;
        if (v -= M, v = Math.max(0, v), R) {
          for (var x = 0; x < M; x++)
            R.words[x] = this.words[x];
          R.length = M;
        }
        if (M !== 0)
          if (this.length > M)
            for (this.length -= M, x = 0; x < this.length; x++)
              this.words[x] = this.words[x + M];
          else
            this.words[0] = 0, this.length = 1;
        var T = 0;
        for (x = this.length - 1; x >= 0 && (T !== 0 || x >= v); x--) {
          var p = this.words[x] | 0;
          this.words[x] = T << 26 - g | p >>> g, T = p & I;
        }
        return R && T !== 0 && (R.words[R.length++] = T), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, i.prototype.ishrn = function(A, b, f) {
        return n(this.negative === 0), this.iushrn(A, b, f);
      }, i.prototype.shln = function(A) {
        return this.clone().ishln(A);
      }, i.prototype.ushln = function(A) {
        return this.clone().iushln(A);
      }, i.prototype.shrn = function(A) {
        return this.clone().ishrn(A);
      }, i.prototype.ushrn = function(A) {
        return this.clone().iushrn(A);
      }, i.prototype.testn = function(A) {
        n(typeof A == "number" && A >= 0);
        var b = A % 26, f = (A - b) / 26, v = 1 << b;
        if (this.length <= f)
          return !1;
        var g = this.words[f];
        return !!(g & v);
      }, i.prototype.imaskn = function(A) {
        n(typeof A == "number" && A >= 0);
        var b = A % 26, f = (A - b) / 26;
        if (n(this.negative === 0, "imaskn works only with positive numbers"), this.length <= f)
          return this;
        if (b !== 0 && f++, this.length = Math.min(f, this.length), b !== 0) {
          var v = 67108863 ^ 67108863 >>> b << b;
          this.words[this.length - 1] &= v;
        }
        return this.strip();
      }, i.prototype.maskn = function(A) {
        return this.clone().imaskn(A);
      }, i.prototype.iaddn = function(A) {
        return n(typeof A == "number"), n(A < 67108864), A < 0 ? this.isubn(-A) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < A ? (this.words[0] = A - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(A), this.negative = 1, this) : this._iaddn(A);
      }, i.prototype._iaddn = function(A) {
        this.words[0] += A;
        for (var b = 0; b < this.length && this.words[b] >= 67108864; b++)
          this.words[b] -= 67108864, b === this.length - 1 ? this.words[b + 1] = 1 : this.words[b + 1]++;
        return this.length = Math.max(this.length, b + 1), this;
      }, i.prototype.isubn = function(A) {
        if (n(typeof A == "number"), n(A < 67108864), A < 0)
          return this.iaddn(-A);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(A), this.negative = 1, this;
        if (this.words[0] -= A, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var b = 0; b < this.length && this.words[b] < 0; b++)
            this.words[b] += 67108864, this.words[b + 1] -= 1;
        return this.strip();
      }, i.prototype.addn = function(A) {
        return this.clone().iaddn(A);
      }, i.prototype.subn = function(A) {
        return this.clone().isubn(A);
      }, i.prototype.iabs = function() {
        return this.negative = 0, this;
      }, i.prototype.abs = function() {
        return this.clone().iabs();
      }, i.prototype._ishlnsubmul = function(A, b, f) {
        var v = A.length + f, g;
        this._expand(v);
        var M, I = 0;
        for (g = 0; g < A.length; g++) {
          M = (this.words[g + f] | 0) + I;
          var R = (A.words[g] | 0) * b;
          M -= R & 67108863, I = (M >> 26) - (R / 67108864 | 0), this.words[g + f] = M & 67108863;
        }
        for (; g < this.length - f; g++)
          M = (this.words[g + f] | 0) + I, I = M >> 26, this.words[g + f] = M & 67108863;
        if (I === 0)
          return this.strip();
        for (n(I === -1), I = 0, g = 0; g < this.length; g++)
          M = -(this.words[g] | 0) + I, I = M >> 26, this.words[g] = M & 67108863;
        return this.negative = 1, this.strip();
      }, i.prototype._wordDiv = function(A, b) {
        var f = this.length - A.length, v = this.clone(), g = A, M = g.words[g.length - 1] | 0, I = this._countBits(M);
        f = 26 - I, f !== 0 && (g = g.ushln(f), v.iushln(f), M = g.words[g.length - 1] | 0);
        var R = v.length - g.length, x;
        if (b !== "mod") {
          x = new i(null), x.length = R + 1, x.words = new Array(x.length);
          for (var T = 0; T < x.length; T++)
            x.words[T] = 0;
        }
        var p = v.clone()._ishlnsubmul(g, 1, R);
        p.negative === 0 && (v = p, x && (x.words[R] = 1));
        for (var B = R - 1; B >= 0; B--) {
          var ee = (v.words[g.length + B] | 0) * 67108864 + (v.words[g.length + B - 1] | 0);
          for (ee = Math.min(ee / M | 0, 67108863), v._ishlnsubmul(g, ee, B); v.negative !== 0; )
            ee--, v.negative = 0, v._ishlnsubmul(g, 1, B), v.isZero() || (v.negative ^= 1);
          x && (x.words[B] = ee);
        }
        return x && x.strip(), v.strip(), b !== "div" && f !== 0 && v.iushrn(f), {
          div: x || null,
          mod: v
        };
      }, i.prototype.divmod = function(A, b, f) {
        if (n(!A.isZero()), this.isZero())
          return {
            div: new i(0),
            mod: new i(0)
          };
        var v, g, M;
        return this.negative !== 0 && A.negative === 0 ? (M = this.neg().divmod(A, b), b !== "mod" && (v = M.div.neg()), b !== "div" && (g = M.mod.neg(), f && g.negative !== 0 && g.iadd(A)), {
          div: v,
          mod: g
        }) : this.negative === 0 && A.negative !== 0 ? (M = this.divmod(A.neg(), b), b !== "mod" && (v = M.div.neg()), {
          div: v,
          mod: M.mod
        }) : this.negative & A.negative ? (M = this.neg().divmod(A.neg(), b), b !== "div" && (g = M.mod.neg(), f && g.negative !== 0 && g.isub(A)), {
          div: M.div,
          mod: g
        }) : A.length > this.length || this.cmp(A) < 0 ? {
          div: new i(0),
          mod: this
        } : A.length === 1 ? b === "div" ? {
          div: this.divn(A.words[0]),
          mod: null
        } : b === "mod" ? {
          div: null,
          mod: new i(this.modn(A.words[0]))
        } : {
          div: this.divn(A.words[0]),
          mod: new i(this.modn(A.words[0]))
        } : this._wordDiv(A, b);
      }, i.prototype.div = function(A) {
        return this.divmod(A, "div", !1).div;
      }, i.prototype.mod = function(A) {
        return this.divmod(A, "mod", !1).mod;
      }, i.prototype.umod = function(A) {
        return this.divmod(A, "mod", !0).mod;
      }, i.prototype.divRound = function(A) {
        var b = this.divmod(A);
        if (b.mod.isZero())
          return b.div;
        var f = b.div.negative !== 0 ? b.mod.isub(A) : b.mod, v = A.ushrn(1), g = A.andln(1), M = f.cmp(v);
        return M < 0 || g === 1 && M === 0 ? b.div : b.div.negative !== 0 ? b.div.isubn(1) : b.div.iaddn(1);
      }, i.prototype.modn = function(A) {
        n(A <= 67108863);
        for (var b = (1 << 26) % A, f = 0, v = this.length - 1; v >= 0; v--)
          f = (b * f + (this.words[v] | 0)) % A;
        return f;
      }, i.prototype.idivn = function(A) {
        n(A <= 67108863);
        for (var b = 0, f = this.length - 1; f >= 0; f--) {
          var v = (this.words[f] | 0) + b * 67108864;
          this.words[f] = v / A | 0, b = v % A;
        }
        return this.strip();
      }, i.prototype.divn = function(A) {
        return this.clone().idivn(A);
      }, i.prototype.egcd = function(A) {
        n(A.negative === 0), n(!A.isZero());
        var b = this, f = A.clone();
        b.negative !== 0 ? b = b.umod(A) : b = b.clone();
        for (var v = new i(1), g = new i(0), M = new i(0), I = new i(1), R = 0; b.isEven() && f.isEven(); )
          b.iushrn(1), f.iushrn(1), ++R;
        for (var x = f.clone(), T = b.clone(); !b.isZero(); ) {
          for (var p = 0, B = 1; !(b.words[0] & B) && p < 26; ++p, B <<= 1)
            ;
          if (p > 0)
            for (b.iushrn(p); p-- > 0; )
              (v.isOdd() || g.isOdd()) && (v.iadd(x), g.isub(T)), v.iushrn(1), g.iushrn(1);
          for (var ee = 0, ae = 1; !(f.words[0] & ae) && ee < 26; ++ee, ae <<= 1)
            ;
          if (ee > 0)
            for (f.iushrn(ee); ee-- > 0; )
              (M.isOdd() || I.isOdd()) && (M.iadd(x), I.isub(T)), M.iushrn(1), I.iushrn(1);
          b.cmp(f) >= 0 ? (b.isub(f), v.isub(M), g.isub(I)) : (f.isub(b), M.isub(v), I.isub(g));
        }
        return {
          a: M,
          b: I,
          gcd: f.iushln(R)
        };
      }, i.prototype._invmp = function(A) {
        n(A.negative === 0), n(!A.isZero());
        var b = this, f = A.clone();
        b.negative !== 0 ? b = b.umod(A) : b = b.clone();
        for (var v = new i(1), g = new i(0), M = f.clone(); b.cmpn(1) > 0 && f.cmpn(1) > 0; ) {
          for (var I = 0, R = 1; !(b.words[0] & R) && I < 26; ++I, R <<= 1)
            ;
          if (I > 0)
            for (b.iushrn(I); I-- > 0; )
              v.isOdd() && v.iadd(M), v.iushrn(1);
          for (var x = 0, T = 1; !(f.words[0] & T) && x < 26; ++x, T <<= 1)
            ;
          if (x > 0)
            for (f.iushrn(x); x-- > 0; )
              g.isOdd() && g.iadd(M), g.iushrn(1);
          b.cmp(f) >= 0 ? (b.isub(f), v.isub(g)) : (f.isub(b), g.isub(v));
        }
        var p;
        return b.cmpn(1) === 0 ? p = v : p = g, p.cmpn(0) < 0 && p.iadd(A), p;
      }, i.prototype.gcd = function(A) {
        if (this.isZero())
          return A.abs();
        if (A.isZero())
          return this.abs();
        var b = this.clone(), f = A.clone();
        b.negative = 0, f.negative = 0;
        for (var v = 0; b.isEven() && f.isEven(); v++)
          b.iushrn(1), f.iushrn(1);
        do {
          for (; b.isEven(); )
            b.iushrn(1);
          for (; f.isEven(); )
            f.iushrn(1);
          var g = b.cmp(f);
          if (g < 0) {
            var M = b;
            b = f, f = M;
          } else if (g === 0 || f.cmpn(1) === 0)
            break;
          b.isub(f);
        } while (!0);
        return f.iushln(v);
      }, i.prototype.invm = function(A) {
        return this.egcd(A).a.umod(A);
      }, i.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, i.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, i.prototype.andln = function(A) {
        return this.words[0] & A;
      }, i.prototype.bincn = function(A) {
        n(typeof A == "number");
        var b = A % 26, f = (A - b) / 26, v = 1 << b;
        if (this.length <= f)
          return this._expand(f + 1), this.words[f] |= v, this;
        for (var g = v, M = f; g !== 0 && M < this.length; M++) {
          var I = this.words[M] | 0;
          I += g, g = I >>> 26, I &= 67108863, this.words[M] = I;
        }
        return g !== 0 && (this.words[M] = g, this.length++), this;
      }, i.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, i.prototype.cmpn = function(A) {
        var b = A < 0;
        if (this.negative !== 0 && !b)
          return -1;
        if (this.negative === 0 && b)
          return 1;
        this.strip();
        var f;
        if (this.length > 1)
          f = 1;
        else {
          b && (A = -A), n(A <= 67108863, "Number is too big");
          var v = this.words[0] | 0;
          f = v === A ? 0 : v < A ? -1 : 1;
        }
        return this.negative !== 0 ? -f | 0 : f;
      }, i.prototype.cmp = function(A) {
        if (this.negative !== 0 && A.negative === 0)
          return -1;
        if (this.negative === 0 && A.negative !== 0)
          return 1;
        var b = this.ucmp(A);
        return this.negative !== 0 ? -b | 0 : b;
      }, i.prototype.ucmp = function(A) {
        if (this.length > A.length)
          return 1;
        if (this.length < A.length)
          return -1;
        for (var b = 0, f = this.length - 1; f >= 0; f--) {
          var v = this.words[f] | 0, g = A.words[f] | 0;
          if (v !== g) {
            v < g ? b = -1 : v > g && (b = 1);
            break;
          }
        }
        return b;
      }, i.prototype.gtn = function(A) {
        return this.cmpn(A) === 1;
      }, i.prototype.gt = function(A) {
        return this.cmp(A) === 1;
      }, i.prototype.gten = function(A) {
        return this.cmpn(A) >= 0;
      }, i.prototype.gte = function(A) {
        return this.cmp(A) >= 0;
      }, i.prototype.ltn = function(A) {
        return this.cmpn(A) === -1;
      }, i.prototype.lt = function(A) {
        return this.cmp(A) === -1;
      }, i.prototype.lten = function(A) {
        return this.cmpn(A) <= 0;
      }, i.prototype.lte = function(A) {
        return this.cmp(A) <= 0;
      }, i.prototype.eqn = function(A) {
        return this.cmpn(A) === 0;
      }, i.prototype.eq = function(A) {
        return this.cmp(A) === 0;
      }, i.red = function(A) {
        return new se(A);
      }, i.prototype.toRed = function(A) {
        return n(!this.red, "Already a number in reduction context"), n(this.negative === 0, "red works only with positives"), A.convertTo(this)._forceRed(A);
      }, i.prototype.fromRed = function() {
        return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, i.prototype._forceRed = function(A) {
        return this.red = A, this;
      }, i.prototype.forceRed = function(A) {
        return n(!this.red, "Already a number in reduction context"), this._forceRed(A);
      }, i.prototype.redAdd = function(A) {
        return n(this.red, "redAdd works only with red numbers"), this.red.add(this, A);
      }, i.prototype.redIAdd = function(A) {
        return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, A);
      }, i.prototype.redSub = function(A) {
        return n(this.red, "redSub works only with red numbers"), this.red.sub(this, A);
      }, i.prototype.redISub = function(A) {
        return n(this.red, "redISub works only with red numbers"), this.red.isub(this, A);
      }, i.prototype.redShl = function(A) {
        return n(this.red, "redShl works only with red numbers"), this.red.shl(this, A);
      }, i.prototype.redMul = function(A) {
        return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, A), this.red.mul(this, A);
      }, i.prototype.redIMul = function(A) {
        return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, A), this.red.imul(this, A);
      }, i.prototype.redSqr = function() {
        return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, i.prototype.redISqr = function() {
        return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, i.prototype.redSqrt = function() {
        return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, i.prototype.redInvm = function() {
        return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, i.prototype.redNeg = function() {
        return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, i.prototype.redPow = function(A) {
        return n(this.red && !A.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, A);
      };
      var L = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function U(Q, A) {
        this.name = Q, this.p = new i(A, 16), this.n = this.p.bitLength(), this.k = new i(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      U.prototype._tmp = function() {
        var A = new i(null);
        return A.words = new Array(Math.ceil(this.n / 13)), A;
      }, U.prototype.ireduce = function(A) {
        var b = A, f;
        do
          this.split(b, this.tmp), b = this.imulK(b), b = b.iadd(this.tmp), f = b.bitLength();
        while (f > this.n);
        var v = f < this.n ? -1 : b.ucmp(this.p);
        return v === 0 ? (b.words[0] = 0, b.length = 1) : v > 0 ? b.isub(this.p) : b.strip !== void 0 ? b.strip() : b._strip(), b;
      }, U.prototype.split = function(A, b) {
        A.iushrn(this.n, 0, b);
      }, U.prototype.imulK = function(A) {
        return A.imul(this.k);
      };
      function z() {
        U.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      a(z, U), z.prototype.split = function(A, b) {
        for (var f = 4194303, v = Math.min(A.length, 9), g = 0; g < v; g++)
          b.words[g] = A.words[g];
        if (b.length = v, A.length <= 9) {
          A.words[0] = 0, A.length = 1;
          return;
        }
        var M = A.words[9];
        for (b.words[b.length++] = M & f, g = 10; g < A.length; g++) {
          var I = A.words[g] | 0;
          A.words[g - 10] = (I & f) << 4 | M >>> 22, M = I;
        }
        M >>>= 22, A.words[g - 10] = M, M === 0 && A.length > 10 ? A.length -= 10 : A.length -= 9;
      }, z.prototype.imulK = function(A) {
        A.words[A.length] = 0, A.words[A.length + 1] = 0, A.length += 2;
        for (var b = 0, f = 0; f < A.length; f++) {
          var v = A.words[f] | 0;
          b += v * 977, A.words[f] = b & 67108863, b = v * 64 + (b / 67108864 | 0);
        }
        return A.words[A.length - 1] === 0 && (A.length--, A.words[A.length - 1] === 0 && A.length--), A;
      };
      function K() {
        U.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      a(K, U);
      function re() {
        U.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      a(re, U);
      function oe() {
        U.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      a(oe, U), oe.prototype.imulK = function(A) {
        for (var b = 0, f = 0; f < A.length; f++) {
          var v = (A.words[f] | 0) * 19 + b, g = v & 67108863;
          v >>>= 26, A.words[f] = g, b = v;
        }
        return b !== 0 && (A.words[A.length++] = b), A;
      }, i._prime = function(A) {
        if (L[A])
          return L[A];
        var b;
        if (A === "k256")
          b = new z();
        else if (A === "p224")
          b = new K();
        else if (A === "p192")
          b = new re();
        else if (A === "p25519")
          b = new oe();
        else
          throw new Error("Unknown prime " + A);
        return L[A] = b, b;
      };
      function se(Q) {
        if (typeof Q == "string") {
          var A = i._prime(Q);
          this.m = A.p, this.prime = A;
        } else
          n(Q.gtn(1), "modulus must be greater than 1"), this.m = Q, this.prime = null;
      }
      se.prototype._verify1 = function(A) {
        n(A.negative === 0, "red works only with positives"), n(A.red, "red works only with red numbers");
      }, se.prototype._verify2 = function(A, b) {
        n((A.negative | b.negative) === 0, "red works only with positives"), n(
          A.red && A.red === b.red,
          "red works only with red numbers"
        );
      }, se.prototype.imod = function(A) {
        return this.prime ? this.prime.ireduce(A)._forceRed(this) : A.umod(this.m)._forceRed(this);
      }, se.prototype.neg = function(A) {
        return A.isZero() ? A.clone() : this.m.sub(A)._forceRed(this);
      }, se.prototype.add = function(A, b) {
        this._verify2(A, b);
        var f = A.add(b);
        return f.cmp(this.m) >= 0 && f.isub(this.m), f._forceRed(this);
      }, se.prototype.iadd = function(A, b) {
        this._verify2(A, b);
        var f = A.iadd(b);
        return f.cmp(this.m) >= 0 && f.isub(this.m), f;
      }, se.prototype.sub = function(A, b) {
        this._verify2(A, b);
        var f = A.sub(b);
        return f.cmpn(0) < 0 && f.iadd(this.m), f._forceRed(this);
      }, se.prototype.isub = function(A, b) {
        this._verify2(A, b);
        var f = A.isub(b);
        return f.cmpn(0) < 0 && f.iadd(this.m), f;
      }, se.prototype.shl = function(A, b) {
        return this._verify1(A), this.imod(A.ushln(b));
      }, se.prototype.imul = function(A, b) {
        return this._verify2(A, b), this.imod(A.imul(b));
      }, se.prototype.mul = function(A, b) {
        return this._verify2(A, b), this.imod(A.mul(b));
      }, se.prototype.isqr = function(A) {
        return this.imul(A, A.clone());
      }, se.prototype.sqr = function(A) {
        return this.mul(A, A);
      }, se.prototype.sqrt = function(A) {
        if (A.isZero())
          return A.clone();
        var b = this.m.andln(3);
        if (n(b % 2 === 1), b === 3) {
          var f = this.m.add(new i(1)).iushrn(2);
          return this.pow(A, f);
        }
        for (var v = this.m.subn(1), g = 0; !v.isZero() && v.andln(1) === 0; )
          g++, v.iushrn(1);
        n(!v.isZero());
        var M = new i(1).toRed(this), I = M.redNeg(), R = this.m.subn(1).iushrn(1), x = this.m.bitLength();
        for (x = new i(2 * x * x).toRed(this); this.pow(x, R).cmp(I) !== 0; )
          x.redIAdd(I);
        for (var T = this.pow(x, v), p = this.pow(A, v.addn(1).iushrn(1)), B = this.pow(A, v), ee = g; B.cmp(M) !== 0; ) {
          for (var ae = B, Z = 0; ae.cmp(M) !== 0; Z++)
            ae = ae.redSqr();
          n(Z < ee);
          var ne = this.pow(T, new i(1).iushln(ee - Z - 1));
          p = p.redMul(ne), T = ne.redSqr(), B = B.redMul(T), ee = Z;
        }
        return p;
      }, se.prototype.invm = function(A) {
        var b = A._invmp(this.m);
        return b.negative !== 0 ? (b.negative = 0, this.imod(b).redNeg()) : this.imod(b);
      }, se.prototype.pow = function(A, b) {
        if (b.isZero())
          return new i(1).toRed(this);
        if (b.cmpn(1) === 0)
          return A.clone();
        var f = 4, v = new Array(1 << f);
        v[0] = new i(1).toRed(this), v[1] = A;
        for (var g = 2; g < v.length; g++)
          v[g] = this.mul(v[g - 1], A);
        var M = v[0], I = 0, R = 0, x = b.bitLength() % 26;
        for (x === 0 && (x = 26), g = b.length - 1; g >= 0; g--) {
          for (var T = b.words[g], p = x - 1; p >= 0; p--) {
            var B = T >> p & 1;
            if (M !== v[0] && (M = this.sqr(M)), B === 0 && I === 0) {
              R = 0;
              continue;
            }
            I <<= 1, I |= B, R++, !(R !== f && (g !== 0 || p !== 0)) && (M = this.mul(M, v[I]), R = 0, I = 0);
          }
          x = 26;
        }
        return M;
      }, se.prototype.convertTo = function(A) {
        var b = A.umod(this.m);
        return b === A ? b.clone() : b;
      }, se.prototype.convertFrom = function(A) {
        var b = A.clone();
        return b.red = null, b;
      }, i.mont = function(A) {
        return new ve(A);
      };
      function ve(Q) {
        se.call(this, Q), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new i(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      a(ve, se), ve.prototype.convertTo = function(A) {
        return this.imod(A.ushln(this.shift));
      }, ve.prototype.convertFrom = function(A) {
        var b = this.imod(A.mul(this.rinv));
        return b.red = null, b;
      }, ve.prototype.imul = function(A, b) {
        if (A.isZero() || b.isZero())
          return A.words[0] = 0, A.length = 1, A;
        var f = A.imul(b), v = f.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), g = f.isub(v).iushrn(this.shift), M = g;
        return g.cmp(this.m) >= 0 ? M = g.isub(this.m) : g.cmpn(0) < 0 && (M = g.iadd(this.m)), M._forceRed(this);
      }, ve.prototype.mul = function(A, b) {
        if (A.isZero() || b.isZero())
          return new i(0)._forceRed(this);
        var f = A.mul(b), v = f.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), g = f.isub(v).iushrn(this.shift), M = g;
        return g.cmp(this.m) >= 0 ? M = g.isub(this.m) : g.cmpn(0) < 0 && (M = g.iadd(this.m)), M._forceRed(this);
      }, ve.prototype.invm = function(A) {
        var b = this.imod(A._invmp(this.m).mul(this.r2));
        return b._forceRed(this);
      };
    })(r, Jt);
  }(Xa)), Xa.exports;
}
var Ua = { exports: {} }, vd;
function ih() {
  if (vd)
    return Ua.exports;
  vd = 1;
  var r;
  Ua.exports = function(a) {
    return r || (r = new e(null)), r.generate(a);
  };
  function e(n) {
    this.rand = n;
  }
  if (Ua.exports.Rand = e, e.prototype.generate = function(a) {
    return this._rand(a);
  }, e.prototype._rand = function(a) {
    if (this.rand.getBytes)
      return this.rand.getBytes(a);
    for (var i = new Uint8Array(a), o = 0; o < i.length; o++)
      i[o] = this.rand.getByte();
    return i;
  }, typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? e.prototype._rand = function(a) {
      var i = new Uint8Array(a);
      return self.crypto.getRandomValues(i), i;
    } : self.msCrypto && self.msCrypto.getRandomValues ? e.prototype._rand = function(a) {
      var i = new Uint8Array(a);
      return self.msCrypto.getRandomValues(i), i;
    } : typeof window == "object" && (e.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      var t = iy();
      if (typeof t.randomBytes != "function")
        throw new Error("Not supported");
      e.prototype._rand = function(a) {
        return t.randomBytes(a);
      };
    } catch (n) {
    }
  return Ua.exports;
}
var qf, yd;
function $1() {
  if (yd)
    return qf;
  yd = 1;
  var r = Ir(), e = ih();
  function t(n) {
    this.rand = n || new e.Rand();
  }
  return qf = t, t.create = function(a) {
    return new t(a);
  }, t.prototype._randbelow = function(a) {
    var i = a.bitLength(), o = Math.ceil(i / 8);
    do
      var u = new r(this.rand.generate(o));
    while (u.cmp(a) >= 0);
    return u;
  }, t.prototype._randrange = function(a, i) {
    var o = i.sub(a);
    return a.add(this._randbelow(o));
  }, t.prototype.test = function(a, i, o) {
    var u = a.bitLength(), c = r.mont(a), h = new r(1).toRed(c);
    i || (i = Math.max(1, u / 48 | 0));
    for (var s = a.subn(1), d = 0; !s.testn(d); d++)
      ;
    for (var l = a.shrn(d), y = s.toRed(c), m = !0; i > 0; i--) {
      var w = this._randrange(new r(2), s);
      o && o(w);
      var E = w.toRed(c).redPow(l);
      if (!(E.cmp(h) === 0 || E.cmp(y) === 0)) {
        for (var S = 1; S < d; S++) {
          if (E = E.redSqr(), E.cmp(h) === 0)
            return !1;
          if (E.cmp(y) === 0)
            break;
        }
        if (S === d)
          return !1;
      }
    }
    return m;
  }, t.prototype.getDivisor = function(a, i) {
    var o = a.bitLength(), u = r.mont(a), c = new r(1).toRed(u);
    i || (i = Math.max(1, o / 48 | 0));
    for (var h = a.subn(1), s = 0; !h.testn(s); s++)
      ;
    for (var d = a.shrn(s), l = h.toRed(u); i > 0; i--) {
      var y = this._randrange(new r(2), h), m = a.gcd(y);
      if (m.cmpn(1) !== 0)
        return m;
      var w = y.toRed(u).redPow(d);
      if (!(w.cmp(c) === 0 || w.cmp(l) === 0)) {
        for (var E = 1; E < s; E++) {
          if (w = w.redSqr(), w.cmp(c) === 0)
            return w.fromRed().subn(1).gcd(a);
          if (w.cmp(l) === 0)
            break;
        }
        if (E === s)
          return w = w.redSqr(), w.fromRed().subn(1).gcd(a);
      }
    }
    return !1;
  }, qf;
}
var Lf, bd;
function j1() {
  if (bd)
    return Lf;
  bd = 1;
  var r = Ii();
  Lf = E, E.simpleSieve = m, E.fermatTest = w;
  var e = Ir(), t = new e(24), n = $1(), a = new n(), i = new e(1), o = new e(2), u = new e(5);
  new e(16), new e(8);
  var c = new e(10), h = new e(3);
  new e(7);
  var s = new e(11), d = new e(4);
  new e(12);
  var l = null;
  function y() {
    if (l !== null)
      return l;
    var S = 1048576, P = [];
    P[0] = 2;
    for (var L = 1, U = 3; U < S; U += 2) {
      for (var z = Math.ceil(Math.sqrt(U)), K = 0; K < L && P[K] <= z && U % P[K] !== 0; K++)
        ;
      L !== K && P[K] <= z || (P[L++] = U);
    }
    return l = P, P;
  }
  function m(S) {
    for (var P = y(), L = 0; L < P.length; L++)
      if (S.modn(P[L]) === 0)
        return S.cmpn(P[L]) === 0;
    return !0;
  }
  function w(S) {
    var P = e.mont(S);
    return o.toRed(P).redPow(S.subn(1)).fromRed().cmpn(1) === 0;
  }
  function E(S, P) {
    if (S < 16)
      return P === 2 || P === 5 ? new e([140, 123]) : new e([140, 39]);
    P = new e(P);
    for (var L, U; ; ) {
      for (L = new e(r(Math.ceil(S / 8))); L.bitLength() > S; )
        L.ishrn(1);
      if (L.isEven() && L.iadd(i), L.testn(1) || L.iadd(o), P.cmp(o)) {
        if (!P.cmp(u))
          for (; L.mod(c).cmp(h); )
            L.iadd(d);
      } else
        for (; L.mod(t).cmp(s); )
          L.iadd(d);
      if (U = L.shrn(1), m(U) && m(L) && w(U) && w(L) && a.test(U) && a.test(L))
        return L;
    }
  }
  return Lf;
}
const q6 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}, L6 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}, F6 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}, U6 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}, $6 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}, j6 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}, H6 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}, z6 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}, V6 = {
  modp1: q6,
  modp2: L6,
  modp5: F6,
  modp14: U6,
  modp15: $6,
  modp16: j6,
  modp17: H6,
  modp18: z6
};
var Ff, md;
function W6() {
  if (md)
    return Ff;
  md = 1;
  var r = Ir(), e = $1(), t = new e(), n = new r(24), a = new r(11), i = new r(10), o = new r(3), u = new r(7), c = j1(), h = Ii();
  Ff = m;
  function s(E, S) {
    return S = S || "utf8", Xt.isBuffer(E) || (E = new Xt(E, S)), this._pub = new r(E), this;
  }
  function d(E, S) {
    return S = S || "utf8", Xt.isBuffer(E) || (E = new Xt(E, S)), this._priv = new r(E), this;
  }
  var l = {};
  function y(E, S) {
    var P = S.toString("hex"), L = [P, E.toString(16)].join("_");
    if (L in l)
      return l[L];
    var U = 0;
    if (E.isEven() || !c.simpleSieve || !c.fermatTest(E) || !t.test(E))
      return U += 1, P === "02" || P === "05" ? U += 8 : U += 4, l[L] = U, U;
    t.test(E.shrn(1)) || (U += 2);
    var z;
    switch (P) {
      case "02":
        E.mod(n).cmp(a) && (U += 8);
        break;
      case "05":
        z = E.mod(i), z.cmp(o) && z.cmp(u) && (U += 8);
        break;
      default:
        U += 4;
    }
    return l[L] = U, U;
  }
  function m(E, S, P) {
    this.setGenerator(S), this.__prime = new r(E), this._prime = r.mont(this.__prime), this._primeLen = E.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, P ? (this.setPublicKey = s, this.setPrivateKey = d) : this._primeCode = 8;
  }
  Object.defineProperty(m.prototype, "verifyError", {
    enumerable: !0,
    get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = y(this.__prime, this.__gen)), this._primeCode;
    }
  }), m.prototype.generateKeys = function() {
    return this._priv || (this._priv = new r(h(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  }, m.prototype.computeSecret = function(E) {
    E = new r(E), E = E.toRed(this._prime);
    var S = E.redPow(this._priv).fromRed(), P = new Xt(S.toArray()), L = this.getPrime();
    if (P.length < L.length) {
      var U = new Xt(L.length - P.length);
      U.fill(0), P = Xt.concat([U, P]);
    }
    return P;
  }, m.prototype.getPublicKey = function(S) {
    return w(this._pub, S);
  }, m.prototype.getPrivateKey = function(S) {
    return w(this._priv, S);
  }, m.prototype.getPrime = function(E) {
    return w(this.__prime, E);
  }, m.prototype.getGenerator = function(E) {
    return w(this._gen, E);
  }, m.prototype.setGenerator = function(E, S) {
    return S = S || "utf8", Xt.isBuffer(E) || (E = new Xt(E, S)), this.__gen = E, this._gen = new r(E), this;
  };
  function w(E, S) {
    var P = new Xt(E.toArray());
    return S ? P.toString(S) : P;
  }
  return Ff;
}
var gd;
function K6() {
  if (gd)
    return Qn;
  gd = 1;
  var r = j1(), e = V6, t = W6();
  function n(o) {
    var u = new Xt(e[o].prime, "hex"), c = new Xt(e[o].gen, "hex");
    return new t(u, c);
  }
  var a = {
    binary: !0,
    hex: !0,
    base64: !0
  };
  function i(o, u, c, h) {
    return Xt.isBuffer(u) || a[u] === void 0 ? i(o, "binary", u, c) : (u = u || "binary", h = h || "binary", c = c || new Xt([2]), Xt.isBuffer(c) || (c = new Xt(c, h)), typeof o == "number" ? new t(r(o, c), c, !0) : (Xt.isBuffer(o) || (o = new Xt(o, u)), new t(o, c, !0)));
  }
  return Qn.DiffieHellmanGroup = Qn.createDiffieHellmanGroup = Qn.getDiffieHellman = n, Qn.createDiffieHellman = Qn.DiffieHellman = i, Qn;
}
var Fi = { exports: {} }, Za = { exports: {} };
Za.exports;
var wd;
function Q6() {
  return wd || (wd = 1, function(r) {
    (function(e, t) {
      function n(b, f) {
        if (!b)
          throw new Error(f || "Assertion failed");
      }
      function a(b, f) {
        b.super_ = f;
        var v = function() {
        };
        v.prototype = f.prototype, b.prototype = new v(), b.prototype.constructor = b;
      }
      function i(b, f, v) {
        if (i.isBN(b))
          return b;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, b !== null && ((f === "le" || f === "be") && (v = f, f = 10), this._init(b || 0, f || 10, v || "be"));
      }
      typeof e == "object" ? e.exports = i : t.BN = i, i.BN = i, i.wordSize = 26;
      var o;
      try {
        typeof window != "undefined" && typeof window.Buffer != "undefined" ? o = window.Buffer : o = Mn.Buffer;
      } catch (b) {
      }
      i.isBN = function(f) {
        return f instanceof i ? !0 : f !== null && typeof f == "object" && f.constructor.wordSize === i.wordSize && Array.isArray(f.words);
      }, i.max = function(f, v) {
        return f.cmp(v) > 0 ? f : v;
      }, i.min = function(f, v) {
        return f.cmp(v) < 0 ? f : v;
      }, i.prototype._init = function(f, v, g) {
        if (typeof f == "number")
          return this._initNumber(f, v, g);
        if (typeof f == "object")
          return this._initArray(f, v, g);
        v === "hex" && (v = 16), n(v === (v | 0) && v >= 2 && v <= 36), f = f.toString().replace(/\s+/g, "");
        var M = 0;
        f[0] === "-" && (M++, this.negative = 1), M < f.length && (v === 16 ? this._parseHex(f, M, g) : (this._parseBase(f, v, M), g === "le" && this._initArray(this.toArray(), v, g)));
      }, i.prototype._initNumber = function(f, v, g) {
        f < 0 && (this.negative = 1, f = -f), f < 67108864 ? (this.words = [f & 67108863], this.length = 1) : f < 4503599627370496 ? (this.words = [
          f & 67108863,
          f / 67108864 & 67108863
        ], this.length = 2) : (n(f < 9007199254740992), this.words = [
          f & 67108863,
          f / 67108864 & 67108863,
          1
        ], this.length = 3), g === "le" && this._initArray(this.toArray(), v, g);
      }, i.prototype._initArray = function(f, v, g) {
        if (n(typeof f.length == "number"), f.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(f.length / 3), this.words = new Array(this.length);
        for (var M = 0; M < this.length; M++)
          this.words[M] = 0;
        var I, R, x = 0;
        if (g === "be")
          for (M = f.length - 1, I = 0; M >= 0; M -= 3)
            R = f[M] | f[M - 1] << 8 | f[M - 2] << 16, this.words[I] |= R << x & 67108863, this.words[I + 1] = R >>> 26 - x & 67108863, x += 24, x >= 26 && (x -= 26, I++);
        else if (g === "le")
          for (M = 0, I = 0; M < f.length; M += 3)
            R = f[M] | f[M + 1] << 8 | f[M + 2] << 16, this.words[I] |= R << x & 67108863, this.words[I + 1] = R >>> 26 - x & 67108863, x += 24, x >= 26 && (x -= 26, I++);
        return this._strip();
      };
      function u(b, f) {
        var v = b.charCodeAt(f);
        if (v >= 48 && v <= 57)
          return v - 48;
        if (v >= 65 && v <= 70)
          return v - 55;
        if (v >= 97 && v <= 102)
          return v - 87;
        n(!1, "Invalid character in " + b);
      }
      function c(b, f, v) {
        var g = u(b, v);
        return v - 1 >= f && (g |= u(b, v - 1) << 4), g;
      }
      i.prototype._parseHex = function(f, v, g) {
        this.length = Math.ceil((f.length - v) / 6), this.words = new Array(this.length);
        for (var M = 0; M < this.length; M++)
          this.words[M] = 0;
        var I = 0, R = 0, x;
        if (g === "be")
          for (M = f.length - 1; M >= v; M -= 2)
            x = c(f, v, M) << I, this.words[R] |= x & 67108863, I >= 18 ? (I -= 18, R += 1, this.words[R] |= x >>> 26) : I += 8;
        else {
          var T = f.length - v;
          for (M = T % 2 === 0 ? v + 1 : v; M < f.length; M += 2)
            x = c(f, v, M) << I, this.words[R] |= x & 67108863, I >= 18 ? (I -= 18, R += 1, this.words[R] |= x >>> 26) : I += 8;
        }
        this._strip();
      };
      function h(b, f, v, g) {
        for (var M = 0, I = 0, R = Math.min(b.length, v), x = f; x < R; x++) {
          var T = b.charCodeAt(x) - 48;
          M *= g, T >= 49 ? I = T - 49 + 10 : T >= 17 ? I = T - 17 + 10 : I = T, n(T >= 0 && I < g, "Invalid character"), M += I;
        }
        return M;
      }
      i.prototype._parseBase = function(f, v, g) {
        this.words = [0], this.length = 1;
        for (var M = 0, I = 1; I <= 67108863; I *= v)
          M++;
        M--, I = I / v | 0;
        for (var R = f.length - g, x = R % M, T = Math.min(R, R - x) + g, p = 0, B = g; B < T; B += M)
          p = h(f, B, B + M, v), this.imuln(I), this.words[0] + p < 67108864 ? this.words[0] += p : this._iaddn(p);
        if (x !== 0) {
          var ee = 1;
          for (p = h(f, B, f.length, v), B = 0; B < x; B++)
            ee *= v;
          this.imuln(ee), this.words[0] + p < 67108864 ? this.words[0] += p : this._iaddn(p);
        }
        this._strip();
      }, i.prototype.copy = function(f) {
        f.words = new Array(this.length);
        for (var v = 0; v < this.length; v++)
          f.words[v] = this.words[v];
        f.length = this.length, f.negative = this.negative, f.red = this.red;
      };
      function s(b, f) {
        b.words = f.words, b.length = f.length, b.negative = f.negative, b.red = f.red;
      }
      if (i.prototype._move = function(f) {
        s(f, this);
      }, i.prototype.clone = function() {
        var f = new i(null);
        return this.copy(f), f;
      }, i.prototype._expand = function(f) {
        for (; this.length < f; )
          this.words[this.length++] = 0;
        return this;
      }, i.prototype._strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, i.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, typeof Symbol != "undefined" && typeof Symbol.for == "function")
        try {
          i.prototype[Symbol.for("nodejs.util.inspect.custom")] = d;
        } catch (b) {
          i.prototype.inspect = d;
        }
      else
        i.prototype.inspect = d;
      function d() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var l = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], y = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], m = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      i.prototype.toString = function(f, v) {
        f = f || 10, v = v | 0 || 1;
        var g;
        if (f === 16 || f === "hex") {
          g = "";
          for (var M = 0, I = 0, R = 0; R < this.length; R++) {
            var x = this.words[R], T = ((x << M | I) & 16777215).toString(16);
            I = x >>> 24 - M & 16777215, M += 2, M >= 26 && (M -= 26, R--), I !== 0 || R !== this.length - 1 ? g = l[6 - T.length] + T + g : g = T + g;
          }
          for (I !== 0 && (g = I.toString(16) + g); g.length % v !== 0; )
            g = "0" + g;
          return this.negative !== 0 && (g = "-" + g), g;
        }
        if (f === (f | 0) && f >= 2 && f <= 36) {
          var p = y[f], B = m[f];
          g = "";
          var ee = this.clone();
          for (ee.negative = 0; !ee.isZero(); ) {
            var ae = ee.modrn(B).toString(f);
            ee = ee.idivn(B), ee.isZero() ? g = ae + g : g = l[p - ae.length] + ae + g;
          }
          for (this.isZero() && (g = "0" + g); g.length % v !== 0; )
            g = "0" + g;
          return this.negative !== 0 && (g = "-" + g), g;
        }
        n(!1, "Base should be between 2 and 36");
      }, i.prototype.toNumber = function() {
        var f = this.words[0];
        return this.length === 2 ? f += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? f += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -f : f;
      }, i.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, o && (i.prototype.toBuffer = function(f, v) {
        return this.toArrayLike(o, f, v);
      }), i.prototype.toArray = function(f, v) {
        return this.toArrayLike(Array, f, v);
      };
      var w = function(f, v) {
        return f.allocUnsafe ? f.allocUnsafe(v) : new f(v);
      };
      i.prototype.toArrayLike = function(f, v, g) {
        this._strip();
        var M = this.byteLength(), I = g || Math.max(1, M);
        n(M <= I, "byte array longer than desired length"), n(I > 0, "Requested array length <= 0");
        var R = w(f, I), x = v === "le" ? "LE" : "BE";
        return this["_toArrayLike" + x](R, M), R;
      }, i.prototype._toArrayLikeLE = function(f, v) {
        for (var g = 0, M = 0, I = 0, R = 0; I < this.length; I++) {
          var x = this.words[I] << R | M;
          f[g++] = x & 255, g < f.length && (f[g++] = x >> 8 & 255), g < f.length && (f[g++] = x >> 16 & 255), R === 6 ? (g < f.length && (f[g++] = x >> 24 & 255), M = 0, R = 0) : (M = x >>> 24, R += 2);
        }
        if (g < f.length)
          for (f[g++] = M; g < f.length; )
            f[g++] = 0;
      }, i.prototype._toArrayLikeBE = function(f, v) {
        for (var g = f.length - 1, M = 0, I = 0, R = 0; I < this.length; I++) {
          var x = this.words[I] << R | M;
          f[g--] = x & 255, g >= 0 && (f[g--] = x >> 8 & 255), g >= 0 && (f[g--] = x >> 16 & 255), R === 6 ? (g >= 0 && (f[g--] = x >> 24 & 255), M = 0, R = 0) : (M = x >>> 24, R += 2);
        }
        if (g >= 0)
          for (f[g--] = M; g >= 0; )
            f[g--] = 0;
      }, Math.clz32 ? i.prototype._countBits = function(f) {
        return 32 - Math.clz32(f);
      } : i.prototype._countBits = function(f) {
        var v = f, g = 0;
        return v >= 4096 && (g += 13, v >>>= 13), v >= 64 && (g += 7, v >>>= 7), v >= 8 && (g += 4, v >>>= 4), v >= 2 && (g += 2, v >>>= 2), g + v;
      }, i.prototype._zeroBits = function(f) {
        if (f === 0)
          return 26;
        var v = f, g = 0;
        return v & 8191 || (g += 13, v >>>= 13), v & 127 || (g += 7, v >>>= 7), v & 15 || (g += 4, v >>>= 4), v & 3 || (g += 2, v >>>= 2), v & 1 || g++, g;
      }, i.prototype.bitLength = function() {
        var f = this.words[this.length - 1], v = this._countBits(f);
        return (this.length - 1) * 26 + v;
      };
      function E(b) {
        for (var f = new Array(b.bitLength()), v = 0; v < f.length; v++) {
          var g = v / 26 | 0, M = v % 26;
          f[v] = b.words[g] >>> M & 1;
        }
        return f;
      }
      i.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var f = 0, v = 0; v < this.length; v++) {
          var g = this._zeroBits(this.words[v]);
          if (f += g, g !== 26)
            break;
        }
        return f;
      }, i.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, i.prototype.toTwos = function(f) {
        return this.negative !== 0 ? this.abs().inotn(f).iaddn(1) : this.clone();
      }, i.prototype.fromTwos = function(f) {
        return this.testn(f - 1) ? this.notn(f).iaddn(1).ineg() : this.clone();
      }, i.prototype.isNeg = function() {
        return this.negative !== 0;
      }, i.prototype.neg = function() {
        return this.clone().ineg();
      }, i.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, i.prototype.iuor = function(f) {
        for (; this.length < f.length; )
          this.words[this.length++] = 0;
        for (var v = 0; v < f.length; v++)
          this.words[v] = this.words[v] | f.words[v];
        return this._strip();
      }, i.prototype.ior = function(f) {
        return n((this.negative | f.negative) === 0), this.iuor(f);
      }, i.prototype.or = function(f) {
        return this.length > f.length ? this.clone().ior(f) : f.clone().ior(this);
      }, i.prototype.uor = function(f) {
        return this.length > f.length ? this.clone().iuor(f) : f.clone().iuor(this);
      }, i.prototype.iuand = function(f) {
        var v;
        this.length > f.length ? v = f : v = this;
        for (var g = 0; g < v.length; g++)
          this.words[g] = this.words[g] & f.words[g];
        return this.length = v.length, this._strip();
      }, i.prototype.iand = function(f) {
        return n((this.negative | f.negative) === 0), this.iuand(f);
      }, i.prototype.and = function(f) {
        return this.length > f.length ? this.clone().iand(f) : f.clone().iand(this);
      }, i.prototype.uand = function(f) {
        return this.length > f.length ? this.clone().iuand(f) : f.clone().iuand(this);
      }, i.prototype.iuxor = function(f) {
        var v, g;
        this.length > f.length ? (v = this, g = f) : (v = f, g = this);
        for (var M = 0; M < g.length; M++)
          this.words[M] = v.words[M] ^ g.words[M];
        if (this !== v)
          for (; M < v.length; M++)
            this.words[M] = v.words[M];
        return this.length = v.length, this._strip();
      }, i.prototype.ixor = function(f) {
        return n((this.negative | f.negative) === 0), this.iuxor(f);
      }, i.prototype.xor = function(f) {
        return this.length > f.length ? this.clone().ixor(f) : f.clone().ixor(this);
      }, i.prototype.uxor = function(f) {
        return this.length > f.length ? this.clone().iuxor(f) : f.clone().iuxor(this);
      }, i.prototype.inotn = function(f) {
        n(typeof f == "number" && f >= 0);
        var v = Math.ceil(f / 26) | 0, g = f % 26;
        this._expand(v), g > 0 && v--;
        for (var M = 0; M < v; M++)
          this.words[M] = ~this.words[M] & 67108863;
        return g > 0 && (this.words[M] = ~this.words[M] & 67108863 >> 26 - g), this._strip();
      }, i.prototype.notn = function(f) {
        return this.clone().inotn(f);
      }, i.prototype.setn = function(f, v) {
        n(typeof f == "number" && f >= 0);
        var g = f / 26 | 0, M = f % 26;
        return this._expand(g + 1), v ? this.words[g] = this.words[g] | 1 << M : this.words[g] = this.words[g] & ~(1 << M), this._strip();
      }, i.prototype.iadd = function(f) {
        var v;
        if (this.negative !== 0 && f.negative === 0)
          return this.negative = 0, v = this.isub(f), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && f.negative !== 0)
          return f.negative = 0, v = this.isub(f), f.negative = 1, v._normSign();
        var g, M;
        this.length > f.length ? (g = this, M = f) : (g = f, M = this);
        for (var I = 0, R = 0; R < M.length; R++)
          v = (g.words[R] | 0) + (M.words[R] | 0) + I, this.words[R] = v & 67108863, I = v >>> 26;
        for (; I !== 0 && R < g.length; R++)
          v = (g.words[R] | 0) + I, this.words[R] = v & 67108863, I = v >>> 26;
        if (this.length = g.length, I !== 0)
          this.words[this.length] = I, this.length++;
        else if (g !== this)
          for (; R < g.length; R++)
            this.words[R] = g.words[R];
        return this;
      }, i.prototype.add = function(f) {
        var v;
        return f.negative !== 0 && this.negative === 0 ? (f.negative = 0, v = this.sub(f), f.negative ^= 1, v) : f.negative === 0 && this.negative !== 0 ? (this.negative = 0, v = f.sub(this), this.negative = 1, v) : this.length > f.length ? this.clone().iadd(f) : f.clone().iadd(this);
      }, i.prototype.isub = function(f) {
        if (f.negative !== 0) {
          f.negative = 0;
          var v = this.iadd(f);
          return f.negative = 1, v._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(f), this.negative = 1, this._normSign();
        var g = this.cmp(f);
        if (g === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var M, I;
        g > 0 ? (M = this, I = f) : (M = f, I = this);
        for (var R = 0, x = 0; x < I.length; x++)
          v = (M.words[x] | 0) - (I.words[x] | 0) + R, R = v >> 26, this.words[x] = v & 67108863;
        for (; R !== 0 && x < M.length; x++)
          v = (M.words[x] | 0) + R, R = v >> 26, this.words[x] = v & 67108863;
        if (R === 0 && x < M.length && M !== this)
          for (; x < M.length; x++)
            this.words[x] = M.words[x];
        return this.length = Math.max(this.length, x), M !== this && (this.negative = 1), this._strip();
      }, i.prototype.sub = function(f) {
        return this.clone().isub(f);
      };
      function S(b, f, v) {
        v.negative = f.negative ^ b.negative;
        var g = b.length + f.length | 0;
        v.length = g, g = g - 1 | 0;
        var M = b.words[0] | 0, I = f.words[0] | 0, R = M * I, x = R & 67108863, T = R / 67108864 | 0;
        v.words[0] = x;
        for (var p = 1; p < g; p++) {
          for (var B = T >>> 26, ee = T & 67108863, ae = Math.min(p, f.length - 1), Z = Math.max(0, p - b.length + 1); Z <= ae; Z++) {
            var ne = p - Z | 0;
            M = b.words[ne] | 0, I = f.words[Z] | 0, R = M * I + ee, B += R / 67108864 | 0, ee = R & 67108863;
          }
          v.words[p] = ee | 0, T = B | 0;
        }
        return T !== 0 ? v.words[p] = T | 0 : v.length--, v._strip();
      }
      var P = function(f, v, g) {
        var M = f.words, I = v.words, R = g.words, x = 0, T, p, B, ee = M[0] | 0, ae = ee & 8191, Z = ee >>> 13, ne = M[1] | 0, fe = ne & 8191, le = ne >>> 13, ke = M[2] | 0, X = ke & 8191, G = ke >>> 13, we = M[3] | 0, Ae = we & 8191, Oe = we >>> 13, qe = M[4] | 0, Ue = qe & 8191, ze = qe >>> 13, ge = M[5] | 0, ht = ge & 8191, $e = ge >>> 13, Et = M[6] | 0, ot = Et & 8191, Ve = Et >>> 13, Mt = M[7] | 0, lt = Mt & 8191, Xe = Mt >>> 13, st = M[8] | 0, gt = st & 8191, W = st >>> 13, q = M[9] | 0, F = q & 8191, J = q >>> 13, he = I[0] | 0, de = he & 8191, pe = he >>> 13, Je = I[1] | 0, tt = Je & 8191, Ne = Je >>> 13, St = I[2] | 0, rt = St & 8191, dt = St >>> 13, Zt = I[3] | 0, bt = Zt & 8191, at = Zt >>> 13, jt = I[4] | 0, _t = jt & 8191, ft = jt >>> 13, Yt = I[5] | 0, kt = Yt & 8191, Ze = Yt >>> 13, Ht = I[6] | 0, j = Ht & 8191, N = Ht >>> 13, D = I[7] | 0, _ = D & 8191, $ = D >>> 13, Y = I[8] | 0, ie = Y & 8191, ce = Y >>> 13, me = I[9] | 0, Me = me & 8191, Se = me >>> 13;
        g.negative = f.negative ^ v.negative, g.length = 19, T = Math.imul(ae, de), p = Math.imul(ae, pe), p = p + Math.imul(Z, de) | 0, B = Math.imul(Z, pe);
        var Ge = (x + T | 0) + ((p & 8191) << 13) | 0;
        x = (B + (p >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, T = Math.imul(fe, de), p = Math.imul(fe, pe), p = p + Math.imul(le, de) | 0, B = Math.imul(le, pe), T = T + Math.imul(ae, tt) | 0, p = p + Math.imul(ae, Ne) | 0, p = p + Math.imul(Z, tt) | 0, B = B + Math.imul(Z, Ne) | 0;
        var Be = (x + T | 0) + ((p & 8191) << 13) | 0;
        x = (B + (p >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, T = Math.imul(X, de), p = Math.imul(X, pe), p = p + Math.imul(G, de) | 0, B = Math.imul(G, pe), T = T + Math.imul(fe, tt) | 0, p = p + Math.imul(fe, Ne) | 0, p = p + Math.imul(le, tt) | 0, B = B + Math.imul(le, Ne) | 0, T = T + Math.imul(ae, rt) | 0, p = p + Math.imul(ae, dt) | 0, p = p + Math.imul(Z, rt) | 0, B = B + Math.imul(Z, dt) | 0;
        var Ye = (x + T | 0) + ((p & 8191) << 13) | 0;
        x = (B + (p >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, T = Math.imul(Ae, de), p = Math.imul(Ae, pe), p = p + Math.imul(Oe, de) | 0, B = Math.imul(Oe, pe), T = T + Math.imul(X, tt) | 0, p = p + Math.imul(X, Ne) | 0, p = p + Math.imul(G, tt) | 0, B = B + Math.imul(G, Ne) | 0, T = T + Math.imul(fe, rt) | 0, p = p + Math.imul(fe, dt) | 0, p = p + Math.imul(le, rt) | 0, B = B + Math.imul(le, dt) | 0, T = T + Math.imul(ae, bt) | 0, p = p + Math.imul(ae, at) | 0, p = p + Math.imul(Z, bt) | 0, B = B + Math.imul(Z, at) | 0;
        var Pe = (x + T | 0) + ((p & 8191) << 13) | 0;
        x = (B + (p >>> 13) | 0) + (Pe >>> 26) | 0, Pe &= 67108863, T = Math.imul(Ue, de), p = Math.imul(Ue, pe), p = p + Math.imul(ze, de) | 0, B = Math.imul(ze, pe), T = T + Math.imul(Ae, tt) | 0, p = p + Math.imul(Ae, Ne) | 0, p = p + Math.imul(Oe, tt) | 0, B = B + Math.imul(Oe, Ne) | 0, T = T + Math.imul(X, rt) | 0, p = p + Math.imul(X, dt) | 0, p = p + Math.imul(G, rt) | 0, B = B + Math.imul(G, dt) | 0, T = T + Math.imul(fe, bt) | 0, p = p + Math.imul(fe, at) | 0, p = p + Math.imul(le, bt) | 0, B = B + Math.imul(le, at) | 0, T = T + Math.imul(ae, _t) | 0, p = p + Math.imul(ae, ft) | 0, p = p + Math.imul(Z, _t) | 0, B = B + Math.imul(Z, ft) | 0;
        var et = (x + T | 0) + ((p & 8191) << 13) | 0;
        x = (B + (p >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, T = Math.imul(ht, de), p = Math.imul(ht, pe), p = p + Math.imul($e, de) | 0, B = Math.imul($e, pe), T = T + Math.imul(Ue, tt) | 0, p = p + Math.imul(Ue, Ne) | 0, p = p + Math.imul(ze, tt) | 0, B = B + Math.imul(ze, Ne) | 0, T = T + Math.imul(Ae, rt) | 0, p = p + Math.imul(Ae, dt) | 0, p = p + Math.imul(Oe, rt) | 0, B = B + Math.imul(Oe, dt) | 0, T = T + Math.imul(X, bt) | 0, p = p + Math.imul(X, at) | 0, p = p + Math.imul(G, bt) | 0, B = B + Math.imul(G, at) | 0, T = T + Math.imul(fe, _t) | 0, p = p + Math.imul(fe, ft) | 0, p = p + Math.imul(le, _t) | 0, B = B + Math.imul(le, ft) | 0, T = T + Math.imul(ae, kt) | 0, p = p + Math.imul(ae, Ze) | 0, p = p + Math.imul(Z, kt) | 0, B = B + Math.imul(Z, Ze) | 0;
        var nt = (x + T | 0) + ((p & 8191) << 13) | 0;
        x = (B + (p >>> 13) | 0) + (nt >>> 26) | 0, nt &= 67108863, T = Math.imul(ot, de), p = Math.imul(ot, pe), p = p + Math.imul(Ve, de) | 0, B = Math.imul(Ve, pe), T = T + Math.imul(ht, tt) | 0, p = p + Math.imul(ht, Ne) | 0, p = p + Math.imul($e, tt) | 0, B = B + Math.imul($e, Ne) | 0, T = T + Math.imul(Ue, rt) | 0, p = p + Math.imul(Ue, dt) | 0, p = p + Math.imul(ze, rt) | 0, B = B + Math.imul(ze, dt) | 0, T = T + Math.imul(Ae, bt) | 0, p = p + Math.imul(Ae, at) | 0, p = p + Math.imul(Oe, bt) | 0, B = B + Math.imul(Oe, at) | 0, T = T + Math.imul(X, _t) | 0, p = p + Math.imul(X, ft) | 0, p = p + Math.imul(G, _t) | 0, B = B + Math.imul(G, ft) | 0, T = T + Math.imul(fe, kt) | 0, p = p + Math.imul(fe, Ze) | 0, p = p + Math.imul(le, kt) | 0, B = B + Math.imul(le, Ze) | 0, T = T + Math.imul(ae, j) | 0, p = p + Math.imul(ae, N) | 0, p = p + Math.imul(Z, j) | 0, B = B + Math.imul(Z, N) | 0;
        var Qe = (x + T | 0) + ((p & 8191) << 13) | 0;
        x = (B + (p >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, T = Math.imul(lt, de), p = Math.imul(lt, pe), p = p + Math.imul(Xe, de) | 0, B = Math.imul(Xe, pe), T = T + Math.imul(ot, tt) | 0, p = p + Math.imul(ot, Ne) | 0, p = p + Math.imul(Ve, tt) | 0, B = B + Math.imul(Ve, Ne) | 0, T = T + Math.imul(ht, rt) | 0, p = p + Math.imul(ht, dt) | 0, p = p + Math.imul($e, rt) | 0, B = B + Math.imul($e, dt) | 0, T = T + Math.imul(Ue, bt) | 0, p = p + Math.imul(Ue, at) | 0, p = p + Math.imul(ze, bt) | 0, B = B + Math.imul(ze, at) | 0, T = T + Math.imul(Ae, _t) | 0, p = p + Math.imul(Ae, ft) | 0, p = p + Math.imul(Oe, _t) | 0, B = B + Math.imul(Oe, ft) | 0, T = T + Math.imul(X, kt) | 0, p = p + Math.imul(X, Ze) | 0, p = p + Math.imul(G, kt) | 0, B = B + Math.imul(G, Ze) | 0, T = T + Math.imul(fe, j) | 0, p = p + Math.imul(fe, N) | 0, p = p + Math.imul(le, j) | 0, B = B + Math.imul(le, N) | 0, T = T + Math.imul(ae, _) | 0, p = p + Math.imul(ae, $) | 0, p = p + Math.imul(Z, _) | 0, B = B + Math.imul(Z, $) | 0;
        var pt = (x + T | 0) + ((p & 8191) << 13) | 0;
        x = (B + (p >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, T = Math.imul(gt, de), p = Math.imul(gt, pe), p = p + Math.imul(W, de) | 0, B = Math.imul(W, pe), T = T + Math.imul(lt, tt) | 0, p = p + Math.imul(lt, Ne) | 0, p = p + Math.imul(Xe, tt) | 0, B = B + Math.imul(Xe, Ne) | 0, T = T + Math.imul(ot, rt) | 0, p = p + Math.imul(ot, dt) | 0, p = p + Math.imul(Ve, rt) | 0, B = B + Math.imul(Ve, dt) | 0, T = T + Math.imul(ht, bt) | 0, p = p + Math.imul(ht, at) | 0, p = p + Math.imul($e, bt) | 0, B = B + Math.imul($e, at) | 0, T = T + Math.imul(Ue, _t) | 0, p = p + Math.imul(Ue, ft) | 0, p = p + Math.imul(ze, _t) | 0, B = B + Math.imul(ze, ft) | 0, T = T + Math.imul(Ae, kt) | 0, p = p + Math.imul(Ae, Ze) | 0, p = p + Math.imul(Oe, kt) | 0, B = B + Math.imul(Oe, Ze) | 0, T = T + Math.imul(X, j) | 0, p = p + Math.imul(X, N) | 0, p = p + Math.imul(G, j) | 0, B = B + Math.imul(G, N) | 0, T = T + Math.imul(fe, _) | 0, p = p + Math.imul(fe, $) | 0, p = p + Math.imul(le, _) | 0, B = B + Math.imul(le, $) | 0, T = T + Math.imul(ae, ie) | 0, p = p + Math.imul(ae, ce) | 0, p = p + Math.imul(Z, ie) | 0, B = B + Math.imul(Z, ce) | 0;
        var ut = (x + T | 0) + ((p & 8191) << 13) | 0;
        x = (B + (p >>> 13) | 0) + (ut >>> 26) | 0, ut &= 67108863, T = Math.imul(F, de), p = Math.imul(F, pe), p = p + Math.imul(J, de) | 0, B = Math.imul(J, pe), T = T + Math.imul(gt, tt) | 0, p = p + Math.imul(gt, Ne) | 0, p = p + Math.imul(W, tt) | 0, B = B + Math.imul(W, Ne) | 0, T = T + Math.imul(lt, rt) | 0, p = p + Math.imul(lt, dt) | 0, p = p + Math.imul(Xe, rt) | 0, B = B + Math.imul(Xe, dt) | 0, T = T + Math.imul(ot, bt) | 0, p = p + Math.imul(ot, at) | 0, p = p + Math.imul(Ve, bt) | 0, B = B + Math.imul(Ve, at) | 0, T = T + Math.imul(ht, _t) | 0, p = p + Math.imul(ht, ft) | 0, p = p + Math.imul($e, _t) | 0, B = B + Math.imul($e, ft) | 0, T = T + Math.imul(Ue, kt) | 0, p = p + Math.imul(Ue, Ze) | 0, p = p + Math.imul(ze, kt) | 0, B = B + Math.imul(ze, Ze) | 0, T = T + Math.imul(Ae, j) | 0, p = p + Math.imul(Ae, N) | 0, p = p + Math.imul(Oe, j) | 0, B = B + Math.imul(Oe, N) | 0, T = T + Math.imul(X, _) | 0, p = p + Math.imul(X, $) | 0, p = p + Math.imul(G, _) | 0, B = B + Math.imul(G, $) | 0, T = T + Math.imul(fe, ie) | 0, p = p + Math.imul(fe, ce) | 0, p = p + Math.imul(le, ie) | 0, B = B + Math.imul(le, ce) | 0, T = T + Math.imul(ae, Me) | 0, p = p + Math.imul(ae, Se) | 0, p = p + Math.imul(Z, Me) | 0, B = B + Math.imul(Z, Se) | 0;
        var Le = (x + T | 0) + ((p & 8191) << 13) | 0;
        x = (B + (p >>> 13) | 0) + (Le >>> 26) | 0, Le &= 67108863, T = Math.imul(F, tt), p = Math.imul(F, Ne), p = p + Math.imul(J, tt) | 0, B = Math.imul(J, Ne), T = T + Math.imul(gt, rt) | 0, p = p + Math.imul(gt, dt) | 0, p = p + Math.imul(W, rt) | 0, B = B + Math.imul(W, dt) | 0, T = T + Math.imul(lt, bt) | 0, p = p + Math.imul(lt, at) | 0, p = p + Math.imul(Xe, bt) | 0, B = B + Math.imul(Xe, at) | 0, T = T + Math.imul(ot, _t) | 0, p = p + Math.imul(ot, ft) | 0, p = p + Math.imul(Ve, _t) | 0, B = B + Math.imul(Ve, ft) | 0, T = T + Math.imul(ht, kt) | 0, p = p + Math.imul(ht, Ze) | 0, p = p + Math.imul($e, kt) | 0, B = B + Math.imul($e, Ze) | 0, T = T + Math.imul(Ue, j) | 0, p = p + Math.imul(Ue, N) | 0, p = p + Math.imul(ze, j) | 0, B = B + Math.imul(ze, N) | 0, T = T + Math.imul(Ae, _) | 0, p = p + Math.imul(Ae, $) | 0, p = p + Math.imul(Oe, _) | 0, B = B + Math.imul(Oe, $) | 0, T = T + Math.imul(X, ie) | 0, p = p + Math.imul(X, ce) | 0, p = p + Math.imul(G, ie) | 0, B = B + Math.imul(G, ce) | 0, T = T + Math.imul(fe, Me) | 0, p = p + Math.imul(fe, Se) | 0, p = p + Math.imul(le, Me) | 0, B = B + Math.imul(le, Se) | 0;
        var it = (x + T | 0) + ((p & 8191) << 13) | 0;
        x = (B + (p >>> 13) | 0) + (it >>> 26) | 0, it &= 67108863, T = Math.imul(F, rt), p = Math.imul(F, dt), p = p + Math.imul(J, rt) | 0, B = Math.imul(J, dt), T = T + Math.imul(gt, bt) | 0, p = p + Math.imul(gt, at) | 0, p = p + Math.imul(W, bt) | 0, B = B + Math.imul(W, at) | 0, T = T + Math.imul(lt, _t) | 0, p = p + Math.imul(lt, ft) | 0, p = p + Math.imul(Xe, _t) | 0, B = B + Math.imul(Xe, ft) | 0, T = T + Math.imul(ot, kt) | 0, p = p + Math.imul(ot, Ze) | 0, p = p + Math.imul(Ve, kt) | 0, B = B + Math.imul(Ve, Ze) | 0, T = T + Math.imul(ht, j) | 0, p = p + Math.imul(ht, N) | 0, p = p + Math.imul($e, j) | 0, B = B + Math.imul($e, N) | 0, T = T + Math.imul(Ue, _) | 0, p = p + Math.imul(Ue, $) | 0, p = p + Math.imul(ze, _) | 0, B = B + Math.imul(ze, $) | 0, T = T + Math.imul(Ae, ie) | 0, p = p + Math.imul(Ae, ce) | 0, p = p + Math.imul(Oe, ie) | 0, B = B + Math.imul(Oe, ce) | 0, T = T + Math.imul(X, Me) | 0, p = p + Math.imul(X, Se) | 0, p = p + Math.imul(G, Me) | 0, B = B + Math.imul(G, Se) | 0;
        var je = (x + T | 0) + ((p & 8191) << 13) | 0;
        x = (B + (p >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, T = Math.imul(F, bt), p = Math.imul(F, at), p = p + Math.imul(J, bt) | 0, B = Math.imul(J, at), T = T + Math.imul(gt, _t) | 0, p = p + Math.imul(gt, ft) | 0, p = p + Math.imul(W, _t) | 0, B = B + Math.imul(W, ft) | 0, T = T + Math.imul(lt, kt) | 0, p = p + Math.imul(lt, Ze) | 0, p = p + Math.imul(Xe, kt) | 0, B = B + Math.imul(Xe, Ze) | 0, T = T + Math.imul(ot, j) | 0, p = p + Math.imul(ot, N) | 0, p = p + Math.imul(Ve, j) | 0, B = B + Math.imul(Ve, N) | 0, T = T + Math.imul(ht, _) | 0, p = p + Math.imul(ht, $) | 0, p = p + Math.imul($e, _) | 0, B = B + Math.imul($e, $) | 0, T = T + Math.imul(Ue, ie) | 0, p = p + Math.imul(Ue, ce) | 0, p = p + Math.imul(ze, ie) | 0, B = B + Math.imul(ze, ce) | 0, T = T + Math.imul(Ae, Me) | 0, p = p + Math.imul(Ae, Se) | 0, p = p + Math.imul(Oe, Me) | 0, B = B + Math.imul(Oe, Se) | 0;
        var He = (x + T | 0) + ((p & 8191) << 13) | 0;
        x = (B + (p >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, T = Math.imul(F, _t), p = Math.imul(F, ft), p = p + Math.imul(J, _t) | 0, B = Math.imul(J, ft), T = T + Math.imul(gt, kt) | 0, p = p + Math.imul(gt, Ze) | 0, p = p + Math.imul(W, kt) | 0, B = B + Math.imul(W, Ze) | 0, T = T + Math.imul(lt, j) | 0, p = p + Math.imul(lt, N) | 0, p = p + Math.imul(Xe, j) | 0, B = B + Math.imul(Xe, N) | 0, T = T + Math.imul(ot, _) | 0, p = p + Math.imul(ot, $) | 0, p = p + Math.imul(Ve, _) | 0, B = B + Math.imul(Ve, $) | 0, T = T + Math.imul(ht, ie) | 0, p = p + Math.imul(ht, ce) | 0, p = p + Math.imul($e, ie) | 0, B = B + Math.imul($e, ce) | 0, T = T + Math.imul(Ue, Me) | 0, p = p + Math.imul(Ue, Se) | 0, p = p + Math.imul(ze, Me) | 0, B = B + Math.imul(ze, Se) | 0;
        var We = (x + T | 0) + ((p & 8191) << 13) | 0;
        x = (B + (p >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, T = Math.imul(F, kt), p = Math.imul(F, Ze), p = p + Math.imul(J, kt) | 0, B = Math.imul(J, Ze), T = T + Math.imul(gt, j) | 0, p = p + Math.imul(gt, N) | 0, p = p + Math.imul(W, j) | 0, B = B + Math.imul(W, N) | 0, T = T + Math.imul(lt, _) | 0, p = p + Math.imul(lt, $) | 0, p = p + Math.imul(Xe, _) | 0, B = B + Math.imul(Xe, $) | 0, T = T + Math.imul(ot, ie) | 0, p = p + Math.imul(ot, ce) | 0, p = p + Math.imul(Ve, ie) | 0, B = B + Math.imul(Ve, ce) | 0, T = T + Math.imul(ht, Me) | 0, p = p + Math.imul(ht, Se) | 0, p = p + Math.imul($e, Me) | 0, B = B + Math.imul($e, Se) | 0;
        var Fe = (x + T | 0) + ((p & 8191) << 13) | 0;
        x = (B + (p >>> 13) | 0) + (Fe >>> 26) | 0, Fe &= 67108863, T = Math.imul(F, j), p = Math.imul(F, N), p = p + Math.imul(J, j) | 0, B = Math.imul(J, N), T = T + Math.imul(gt, _) | 0, p = p + Math.imul(gt, $) | 0, p = p + Math.imul(W, _) | 0, B = B + Math.imul(W, $) | 0, T = T + Math.imul(lt, ie) | 0, p = p + Math.imul(lt, ce) | 0, p = p + Math.imul(Xe, ie) | 0, B = B + Math.imul(Xe, ce) | 0, T = T + Math.imul(ot, Me) | 0, p = p + Math.imul(ot, Se) | 0, p = p + Math.imul(Ve, Me) | 0, B = B + Math.imul(Ve, Se) | 0;
        var ye = (x + T | 0) + ((p & 8191) << 13) | 0;
        x = (B + (p >>> 13) | 0) + (ye >>> 26) | 0, ye &= 67108863, T = Math.imul(F, _), p = Math.imul(F, $), p = p + Math.imul(J, _) | 0, B = Math.imul(J, $), T = T + Math.imul(gt, ie) | 0, p = p + Math.imul(gt, ce) | 0, p = p + Math.imul(W, ie) | 0, B = B + Math.imul(W, ce) | 0, T = T + Math.imul(lt, Me) | 0, p = p + Math.imul(lt, Se) | 0, p = p + Math.imul(Xe, Me) | 0, B = B + Math.imul(Xe, Se) | 0;
        var be = (x + T | 0) + ((p & 8191) << 13) | 0;
        x = (B + (p >>> 13) | 0) + (be >>> 26) | 0, be &= 67108863, T = Math.imul(F, ie), p = Math.imul(F, ce), p = p + Math.imul(J, ie) | 0, B = Math.imul(J, ce), T = T + Math.imul(gt, Me) | 0, p = p + Math.imul(gt, Se) | 0, p = p + Math.imul(W, Me) | 0, B = B + Math.imul(W, Se) | 0;
        var Re = (x + T | 0) + ((p & 8191) << 13) | 0;
        x = (B + (p >>> 13) | 0) + (Re >>> 26) | 0, Re &= 67108863, T = Math.imul(F, Me), p = Math.imul(F, Se), p = p + Math.imul(J, Me) | 0, B = Math.imul(J, Se);
        var Te = (x + T | 0) + ((p & 8191) << 13) | 0;
        return x = (B + (p >>> 13) | 0) + (Te >>> 26) | 0, Te &= 67108863, R[0] = Ge, R[1] = Be, R[2] = Ye, R[3] = Pe, R[4] = et, R[5] = nt, R[6] = Qe, R[7] = pt, R[8] = ut, R[9] = Le, R[10] = it, R[11] = je, R[12] = He, R[13] = We, R[14] = Fe, R[15] = ye, R[16] = be, R[17] = Re, R[18] = Te, x !== 0 && (R[19] = x, g.length++), g;
      };
      Math.imul || (P = S);
      function L(b, f, v) {
        v.negative = f.negative ^ b.negative, v.length = b.length + f.length;
        for (var g = 0, M = 0, I = 0; I < v.length - 1; I++) {
          var R = M;
          M = 0;
          for (var x = g & 67108863, T = Math.min(I, f.length - 1), p = Math.max(0, I - b.length + 1); p <= T; p++) {
            var B = I - p, ee = b.words[B] | 0, ae = f.words[p] | 0, Z = ee * ae, ne = Z & 67108863;
            R = R + (Z / 67108864 | 0) | 0, ne = ne + x | 0, x = ne & 67108863, R = R + (ne >>> 26) | 0, M += R >>> 26, R &= 67108863;
          }
          v.words[I] = x, g = R, R = M;
        }
        return g !== 0 ? v.words[I] = g : v.length--, v._strip();
      }
      function U(b, f, v) {
        return L(b, f, v);
      }
      i.prototype.mulTo = function(f, v) {
        var g, M = this.length + f.length;
        return this.length === 10 && f.length === 10 ? g = P(this, f, v) : M < 63 ? g = S(this, f, v) : M < 1024 ? g = L(this, f, v) : g = U(this, f, v), g;
      }, i.prototype.mul = function(f) {
        var v = new i(null);
        return v.words = new Array(this.length + f.length), this.mulTo(f, v);
      }, i.prototype.mulf = function(f) {
        var v = new i(null);
        return v.words = new Array(this.length + f.length), U(this, f, v);
      }, i.prototype.imul = function(f) {
        return this.clone().mulTo(f, this);
      }, i.prototype.imuln = function(f) {
        var v = f < 0;
        v && (f = -f), n(typeof f == "number"), n(f < 67108864);
        for (var g = 0, M = 0; M < this.length; M++) {
          var I = (this.words[M] | 0) * f, R = (I & 67108863) + (g & 67108863);
          g >>= 26, g += I / 67108864 | 0, g += R >>> 26, this.words[M] = R & 67108863;
        }
        return g !== 0 && (this.words[M] = g, this.length++), v ? this.ineg() : this;
      }, i.prototype.muln = function(f) {
        return this.clone().imuln(f);
      }, i.prototype.sqr = function() {
        return this.mul(this);
      }, i.prototype.isqr = function() {
        return this.imul(this.clone());
      }, i.prototype.pow = function(f) {
        var v = E(f);
        if (v.length === 0)
          return new i(1);
        for (var g = this, M = 0; M < v.length && v[M] === 0; M++, g = g.sqr())
          ;
        if (++M < v.length)
          for (var I = g.sqr(); M < v.length; M++, I = I.sqr())
            v[M] !== 0 && (g = g.mul(I));
        return g;
      }, i.prototype.iushln = function(f) {
        n(typeof f == "number" && f >= 0);
        var v = f % 26, g = (f - v) / 26, M = 67108863 >>> 26 - v << 26 - v, I;
        if (v !== 0) {
          var R = 0;
          for (I = 0; I < this.length; I++) {
            var x = this.words[I] & M, T = (this.words[I] | 0) - x << v;
            this.words[I] = T | R, R = x >>> 26 - v;
          }
          R && (this.words[I] = R, this.length++);
        }
        if (g !== 0) {
          for (I = this.length - 1; I >= 0; I--)
            this.words[I + g] = this.words[I];
          for (I = 0; I < g; I++)
            this.words[I] = 0;
          this.length += g;
        }
        return this._strip();
      }, i.prototype.ishln = function(f) {
        return n(this.negative === 0), this.iushln(f);
      }, i.prototype.iushrn = function(f, v, g) {
        n(typeof f == "number" && f >= 0);
        var M;
        v ? M = (v - v % 26) / 26 : M = 0;
        var I = f % 26, R = Math.min((f - I) / 26, this.length), x = 67108863 ^ 67108863 >>> I << I, T = g;
        if (M -= R, M = Math.max(0, M), T) {
          for (var p = 0; p < R; p++)
            T.words[p] = this.words[p];
          T.length = R;
        }
        if (R !== 0)
          if (this.length > R)
            for (this.length -= R, p = 0; p < this.length; p++)
              this.words[p] = this.words[p + R];
          else
            this.words[0] = 0, this.length = 1;
        var B = 0;
        for (p = this.length - 1; p >= 0 && (B !== 0 || p >= M); p--) {
          var ee = this.words[p] | 0;
          this.words[p] = B << 26 - I | ee >>> I, B = ee & x;
        }
        return T && B !== 0 && (T.words[T.length++] = B), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
      }, i.prototype.ishrn = function(f, v, g) {
        return n(this.negative === 0), this.iushrn(f, v, g);
      }, i.prototype.shln = function(f) {
        return this.clone().ishln(f);
      }, i.prototype.ushln = function(f) {
        return this.clone().iushln(f);
      }, i.prototype.shrn = function(f) {
        return this.clone().ishrn(f);
      }, i.prototype.ushrn = function(f) {
        return this.clone().iushrn(f);
      }, i.prototype.testn = function(f) {
        n(typeof f == "number" && f >= 0);
        var v = f % 26, g = (f - v) / 26, M = 1 << v;
        if (this.length <= g)
          return !1;
        var I = this.words[g];
        return !!(I & M);
      }, i.prototype.imaskn = function(f) {
        n(typeof f == "number" && f >= 0);
        var v = f % 26, g = (f - v) / 26;
        if (n(this.negative === 0, "imaskn works only with positive numbers"), this.length <= g)
          return this;
        if (v !== 0 && g++, this.length = Math.min(g, this.length), v !== 0) {
          var M = 67108863 ^ 67108863 >>> v << v;
          this.words[this.length - 1] &= M;
        }
        return this._strip();
      }, i.prototype.maskn = function(f) {
        return this.clone().imaskn(f);
      }, i.prototype.iaddn = function(f) {
        return n(typeof f == "number"), n(f < 67108864), f < 0 ? this.isubn(-f) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= f ? (this.words[0] = f - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(f), this.negative = 1, this) : this._iaddn(f);
      }, i.prototype._iaddn = function(f) {
        this.words[0] += f;
        for (var v = 0; v < this.length && this.words[v] >= 67108864; v++)
          this.words[v] -= 67108864, v === this.length - 1 ? this.words[v + 1] = 1 : this.words[v + 1]++;
        return this.length = Math.max(this.length, v + 1), this;
      }, i.prototype.isubn = function(f) {
        if (n(typeof f == "number"), n(f < 67108864), f < 0)
          return this.iaddn(-f);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(f), this.negative = 1, this;
        if (this.words[0] -= f, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var v = 0; v < this.length && this.words[v] < 0; v++)
            this.words[v] += 67108864, this.words[v + 1] -= 1;
        return this._strip();
      }, i.prototype.addn = function(f) {
        return this.clone().iaddn(f);
      }, i.prototype.subn = function(f) {
        return this.clone().isubn(f);
      }, i.prototype.iabs = function() {
        return this.negative = 0, this;
      }, i.prototype.abs = function() {
        return this.clone().iabs();
      }, i.prototype._ishlnsubmul = function(f, v, g) {
        var M = f.length + g, I;
        this._expand(M);
        var R, x = 0;
        for (I = 0; I < f.length; I++) {
          R = (this.words[I + g] | 0) + x;
          var T = (f.words[I] | 0) * v;
          R -= T & 67108863, x = (R >> 26) - (T / 67108864 | 0), this.words[I + g] = R & 67108863;
        }
        for (; I < this.length - g; I++)
          R = (this.words[I + g] | 0) + x, x = R >> 26, this.words[I + g] = R & 67108863;
        if (x === 0)
          return this._strip();
        for (n(x === -1), x = 0, I = 0; I < this.length; I++)
          R = -(this.words[I] | 0) + x, x = R >> 26, this.words[I] = R & 67108863;
        return this.negative = 1, this._strip();
      }, i.prototype._wordDiv = function(f, v) {
        var g = this.length - f.length, M = this.clone(), I = f, R = I.words[I.length - 1] | 0, x = this._countBits(R);
        g = 26 - x, g !== 0 && (I = I.ushln(g), M.iushln(g), R = I.words[I.length - 1] | 0);
        var T = M.length - I.length, p;
        if (v !== "mod") {
          p = new i(null), p.length = T + 1, p.words = new Array(p.length);
          for (var B = 0; B < p.length; B++)
            p.words[B] = 0;
        }
        var ee = M.clone()._ishlnsubmul(I, 1, T);
        ee.negative === 0 && (M = ee, p && (p.words[T] = 1));
        for (var ae = T - 1; ae >= 0; ae--) {
          var Z = (M.words[I.length + ae] | 0) * 67108864 + (M.words[I.length + ae - 1] | 0);
          for (Z = Math.min(Z / R | 0, 67108863), M._ishlnsubmul(I, Z, ae); M.negative !== 0; )
            Z--, M.negative = 0, M._ishlnsubmul(I, 1, ae), M.isZero() || (M.negative ^= 1);
          p && (p.words[ae] = Z);
        }
        return p && p._strip(), M._strip(), v !== "div" && g !== 0 && M.iushrn(g), {
          div: p || null,
          mod: M
        };
      }, i.prototype.divmod = function(f, v, g) {
        if (n(!f.isZero()), this.isZero())
          return {
            div: new i(0),
            mod: new i(0)
          };
        var M, I, R;
        return this.negative !== 0 && f.negative === 0 ? (R = this.neg().divmod(f, v), v !== "mod" && (M = R.div.neg()), v !== "div" && (I = R.mod.neg(), g && I.negative !== 0 && I.iadd(f)), {
          div: M,
          mod: I
        }) : this.negative === 0 && f.negative !== 0 ? (R = this.divmod(f.neg(), v), v !== "mod" && (M = R.div.neg()), {
          div: M,
          mod: R.mod
        }) : this.negative & f.negative ? (R = this.neg().divmod(f.neg(), v), v !== "div" && (I = R.mod.neg(), g && I.negative !== 0 && I.isub(f)), {
          div: R.div,
          mod: I
        }) : f.length > this.length || this.cmp(f) < 0 ? {
          div: new i(0),
          mod: this
        } : f.length === 1 ? v === "div" ? {
          div: this.divn(f.words[0]),
          mod: null
        } : v === "mod" ? {
          div: null,
          mod: new i(this.modrn(f.words[0]))
        } : {
          div: this.divn(f.words[0]),
          mod: new i(this.modrn(f.words[0]))
        } : this._wordDiv(f, v);
      }, i.prototype.div = function(f) {
        return this.divmod(f, "div", !1).div;
      }, i.prototype.mod = function(f) {
        return this.divmod(f, "mod", !1).mod;
      }, i.prototype.umod = function(f) {
        return this.divmod(f, "mod", !0).mod;
      }, i.prototype.divRound = function(f) {
        var v = this.divmod(f);
        if (v.mod.isZero())
          return v.div;
        var g = v.div.negative !== 0 ? v.mod.isub(f) : v.mod, M = f.ushrn(1), I = f.andln(1), R = g.cmp(M);
        return R < 0 || I === 1 && R === 0 ? v.div : v.div.negative !== 0 ? v.div.isubn(1) : v.div.iaddn(1);
      }, i.prototype.modrn = function(f) {
        var v = f < 0;
        v && (f = -f), n(f <= 67108863);
        for (var g = (1 << 26) % f, M = 0, I = this.length - 1; I >= 0; I--)
          M = (g * M + (this.words[I] | 0)) % f;
        return v ? -M : M;
      }, i.prototype.modn = function(f) {
        return this.modrn(f);
      }, i.prototype.idivn = function(f) {
        var v = f < 0;
        v && (f = -f), n(f <= 67108863);
        for (var g = 0, M = this.length - 1; M >= 0; M--) {
          var I = (this.words[M] | 0) + g * 67108864;
          this.words[M] = I / f | 0, g = I % f;
        }
        return this._strip(), v ? this.ineg() : this;
      }, i.prototype.divn = function(f) {
        return this.clone().idivn(f);
      }, i.prototype.egcd = function(f) {
        n(f.negative === 0), n(!f.isZero());
        var v = this, g = f.clone();
        v.negative !== 0 ? v = v.umod(f) : v = v.clone();
        for (var M = new i(1), I = new i(0), R = new i(0), x = new i(1), T = 0; v.isEven() && g.isEven(); )
          v.iushrn(1), g.iushrn(1), ++T;
        for (var p = g.clone(), B = v.clone(); !v.isZero(); ) {
          for (var ee = 0, ae = 1; !(v.words[0] & ae) && ee < 26; ++ee, ae <<= 1)
            ;
          if (ee > 0)
            for (v.iushrn(ee); ee-- > 0; )
              (M.isOdd() || I.isOdd()) && (M.iadd(p), I.isub(B)), M.iushrn(1), I.iushrn(1);
          for (var Z = 0, ne = 1; !(g.words[0] & ne) && Z < 26; ++Z, ne <<= 1)
            ;
          if (Z > 0)
            for (g.iushrn(Z); Z-- > 0; )
              (R.isOdd() || x.isOdd()) && (R.iadd(p), x.isub(B)), R.iushrn(1), x.iushrn(1);
          v.cmp(g) >= 0 ? (v.isub(g), M.isub(R), I.isub(x)) : (g.isub(v), R.isub(M), x.isub(I));
        }
        return {
          a: R,
          b: x,
          gcd: g.iushln(T)
        };
      }, i.prototype._invmp = function(f) {
        n(f.negative === 0), n(!f.isZero());
        var v = this, g = f.clone();
        v.negative !== 0 ? v = v.umod(f) : v = v.clone();
        for (var M = new i(1), I = new i(0), R = g.clone(); v.cmpn(1) > 0 && g.cmpn(1) > 0; ) {
          for (var x = 0, T = 1; !(v.words[0] & T) && x < 26; ++x, T <<= 1)
            ;
          if (x > 0)
            for (v.iushrn(x); x-- > 0; )
              M.isOdd() && M.iadd(R), M.iushrn(1);
          for (var p = 0, B = 1; !(g.words[0] & B) && p < 26; ++p, B <<= 1)
            ;
          if (p > 0)
            for (g.iushrn(p); p-- > 0; )
              I.isOdd() && I.iadd(R), I.iushrn(1);
          v.cmp(g) >= 0 ? (v.isub(g), M.isub(I)) : (g.isub(v), I.isub(M));
        }
        var ee;
        return v.cmpn(1) === 0 ? ee = M : ee = I, ee.cmpn(0) < 0 && ee.iadd(f), ee;
      }, i.prototype.gcd = function(f) {
        if (this.isZero())
          return f.abs();
        if (f.isZero())
          return this.abs();
        var v = this.clone(), g = f.clone();
        v.negative = 0, g.negative = 0;
        for (var M = 0; v.isEven() && g.isEven(); M++)
          v.iushrn(1), g.iushrn(1);
        do {
          for (; v.isEven(); )
            v.iushrn(1);
          for (; g.isEven(); )
            g.iushrn(1);
          var I = v.cmp(g);
          if (I < 0) {
            var R = v;
            v = g, g = R;
          } else if (I === 0 || g.cmpn(1) === 0)
            break;
          v.isub(g);
        } while (!0);
        return g.iushln(M);
      }, i.prototype.invm = function(f) {
        return this.egcd(f).a.umod(f);
      }, i.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, i.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, i.prototype.andln = function(f) {
        return this.words[0] & f;
      }, i.prototype.bincn = function(f) {
        n(typeof f == "number");
        var v = f % 26, g = (f - v) / 26, M = 1 << v;
        if (this.length <= g)
          return this._expand(g + 1), this.words[g] |= M, this;
        for (var I = M, R = g; I !== 0 && R < this.length; R++) {
          var x = this.words[R] | 0;
          x += I, I = x >>> 26, x &= 67108863, this.words[R] = x;
        }
        return I !== 0 && (this.words[R] = I, this.length++), this;
      }, i.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, i.prototype.cmpn = function(f) {
        var v = f < 0;
        if (this.negative !== 0 && !v)
          return -1;
        if (this.negative === 0 && v)
          return 1;
        this._strip();
        var g;
        if (this.length > 1)
          g = 1;
        else {
          v && (f = -f), n(f <= 67108863, "Number is too big");
          var M = this.words[0] | 0;
          g = M === f ? 0 : M < f ? -1 : 1;
        }
        return this.negative !== 0 ? -g | 0 : g;
      }, i.prototype.cmp = function(f) {
        if (this.negative !== 0 && f.negative === 0)
          return -1;
        if (this.negative === 0 && f.negative !== 0)
          return 1;
        var v = this.ucmp(f);
        return this.negative !== 0 ? -v | 0 : v;
      }, i.prototype.ucmp = function(f) {
        if (this.length > f.length)
          return 1;
        if (this.length < f.length)
          return -1;
        for (var v = 0, g = this.length - 1; g >= 0; g--) {
          var M = this.words[g] | 0, I = f.words[g] | 0;
          if (M !== I) {
            M < I ? v = -1 : M > I && (v = 1);
            break;
          }
        }
        return v;
      }, i.prototype.gtn = function(f) {
        return this.cmpn(f) === 1;
      }, i.prototype.gt = function(f) {
        return this.cmp(f) === 1;
      }, i.prototype.gten = function(f) {
        return this.cmpn(f) >= 0;
      }, i.prototype.gte = function(f) {
        return this.cmp(f) >= 0;
      }, i.prototype.ltn = function(f) {
        return this.cmpn(f) === -1;
      }, i.prototype.lt = function(f) {
        return this.cmp(f) === -1;
      }, i.prototype.lten = function(f) {
        return this.cmpn(f) <= 0;
      }, i.prototype.lte = function(f) {
        return this.cmp(f) <= 0;
      }, i.prototype.eqn = function(f) {
        return this.cmpn(f) === 0;
      }, i.prototype.eq = function(f) {
        return this.cmp(f) === 0;
      }, i.red = function(f) {
        return new Q(f);
      }, i.prototype.toRed = function(f) {
        return n(!this.red, "Already a number in reduction context"), n(this.negative === 0, "red works only with positives"), f.convertTo(this)._forceRed(f);
      }, i.prototype.fromRed = function() {
        return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, i.prototype._forceRed = function(f) {
        return this.red = f, this;
      }, i.prototype.forceRed = function(f) {
        return n(!this.red, "Already a number in reduction context"), this._forceRed(f);
      }, i.prototype.redAdd = function(f) {
        return n(this.red, "redAdd works only with red numbers"), this.red.add(this, f);
      }, i.prototype.redIAdd = function(f) {
        return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, f);
      }, i.prototype.redSub = function(f) {
        return n(this.red, "redSub works only with red numbers"), this.red.sub(this, f);
      }, i.prototype.redISub = function(f) {
        return n(this.red, "redISub works only with red numbers"), this.red.isub(this, f);
      }, i.prototype.redShl = function(f) {
        return n(this.red, "redShl works only with red numbers"), this.red.shl(this, f);
      }, i.prototype.redMul = function(f) {
        return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, f), this.red.mul(this, f);
      }, i.prototype.redIMul = function(f) {
        return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, f), this.red.imul(this, f);
      }, i.prototype.redSqr = function() {
        return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, i.prototype.redISqr = function() {
        return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, i.prototype.redSqrt = function() {
        return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, i.prototype.redInvm = function() {
        return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, i.prototype.redNeg = function() {
        return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, i.prototype.redPow = function(f) {
        return n(this.red && !f.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, f);
      };
      var z = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function K(b, f) {
        this.name = b, this.p = new i(f, 16), this.n = this.p.bitLength(), this.k = new i(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      K.prototype._tmp = function() {
        var f = new i(null);
        return f.words = new Array(Math.ceil(this.n / 13)), f;
      }, K.prototype.ireduce = function(f) {
        var v = f, g;
        do
          this.split(v, this.tmp), v = this.imulK(v), v = v.iadd(this.tmp), g = v.bitLength();
        while (g > this.n);
        var M = g < this.n ? -1 : v.ucmp(this.p);
        return M === 0 ? (v.words[0] = 0, v.length = 1) : M > 0 ? v.isub(this.p) : v.strip !== void 0 ? v.strip() : v._strip(), v;
      }, K.prototype.split = function(f, v) {
        f.iushrn(this.n, 0, v);
      }, K.prototype.imulK = function(f) {
        return f.imul(this.k);
      };
      function re() {
        K.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      a(re, K), re.prototype.split = function(f, v) {
        for (var g = 4194303, M = Math.min(f.length, 9), I = 0; I < M; I++)
          v.words[I] = f.words[I];
        if (v.length = M, f.length <= 9) {
          f.words[0] = 0, f.length = 1;
          return;
        }
        var R = f.words[9];
        for (v.words[v.length++] = R & g, I = 10; I < f.length; I++) {
          var x = f.words[I] | 0;
          f.words[I - 10] = (x & g) << 4 | R >>> 22, R = x;
        }
        R >>>= 22, f.words[I - 10] = R, R === 0 && f.length > 10 ? f.length -= 10 : f.length -= 9;
      }, re.prototype.imulK = function(f) {
        f.words[f.length] = 0, f.words[f.length + 1] = 0, f.length += 2;
        for (var v = 0, g = 0; g < f.length; g++) {
          var M = f.words[g] | 0;
          v += M * 977, f.words[g] = v & 67108863, v = M * 64 + (v / 67108864 | 0);
        }
        return f.words[f.length - 1] === 0 && (f.length--, f.words[f.length - 1] === 0 && f.length--), f;
      };
      function oe() {
        K.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      a(oe, K);
      function se() {
        K.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      a(se, K);
      function ve() {
        K.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      a(ve, K), ve.prototype.imulK = function(f) {
        for (var v = 0, g = 0; g < f.length; g++) {
          var M = (f.words[g] | 0) * 19 + v, I = M & 67108863;
          M >>>= 26, f.words[g] = I, v = M;
        }
        return v !== 0 && (f.words[f.length++] = v), f;
      }, i._prime = function(f) {
        if (z[f])
          return z[f];
        var v;
        if (f === "k256")
          v = new re();
        else if (f === "p224")
          v = new oe();
        else if (f === "p192")
          v = new se();
        else if (f === "p25519")
          v = new ve();
        else
          throw new Error("Unknown prime " + f);
        return z[f] = v, v;
      };
      function Q(b) {
        if (typeof b == "string") {
          var f = i._prime(b);
          this.m = f.p, this.prime = f;
        } else
          n(b.gtn(1), "modulus must be greater than 1"), this.m = b, this.prime = null;
      }
      Q.prototype._verify1 = function(f) {
        n(f.negative === 0, "red works only with positives"), n(f.red, "red works only with red numbers");
      }, Q.prototype._verify2 = function(f, v) {
        n((f.negative | v.negative) === 0, "red works only with positives"), n(
          f.red && f.red === v.red,
          "red works only with red numbers"
        );
      }, Q.prototype.imod = function(f) {
        return this.prime ? this.prime.ireduce(f)._forceRed(this) : (s(f, f.umod(this.m)._forceRed(this)), f);
      }, Q.prototype.neg = function(f) {
        return f.isZero() ? f.clone() : this.m.sub(f)._forceRed(this);
      }, Q.prototype.add = function(f, v) {
        this._verify2(f, v);
        var g = f.add(v);
        return g.cmp(this.m) >= 0 && g.isub(this.m), g._forceRed(this);
      }, Q.prototype.iadd = function(f, v) {
        this._verify2(f, v);
        var g = f.iadd(v);
        return g.cmp(this.m) >= 0 && g.isub(this.m), g;
      }, Q.prototype.sub = function(f, v) {
        this._verify2(f, v);
        var g = f.sub(v);
        return g.cmpn(0) < 0 && g.iadd(this.m), g._forceRed(this);
      }, Q.prototype.isub = function(f, v) {
        this._verify2(f, v);
        var g = f.isub(v);
        return g.cmpn(0) < 0 && g.iadd(this.m), g;
      }, Q.prototype.shl = function(f, v) {
        return this._verify1(f), this.imod(f.ushln(v));
      }, Q.prototype.imul = function(f, v) {
        return this._verify2(f, v), this.imod(f.imul(v));
      }, Q.prototype.mul = function(f, v) {
        return this._verify2(f, v), this.imod(f.mul(v));
      }, Q.prototype.isqr = function(f) {
        return this.imul(f, f.clone());
      }, Q.prototype.sqr = function(f) {
        return this.mul(f, f);
      }, Q.prototype.sqrt = function(f) {
        if (f.isZero())
          return f.clone();
        var v = this.m.andln(3);
        if (n(v % 2 === 1), v === 3) {
          var g = this.m.add(new i(1)).iushrn(2);
          return this.pow(f, g);
        }
        for (var M = this.m.subn(1), I = 0; !M.isZero() && M.andln(1) === 0; )
          I++, M.iushrn(1);
        n(!M.isZero());
        var R = new i(1).toRed(this), x = R.redNeg(), T = this.m.subn(1).iushrn(1), p = this.m.bitLength();
        for (p = new i(2 * p * p).toRed(this); this.pow(p, T).cmp(x) !== 0; )
          p.redIAdd(x);
        for (var B = this.pow(p, M), ee = this.pow(f, M.addn(1).iushrn(1)), ae = this.pow(f, M), Z = I; ae.cmp(R) !== 0; ) {
          for (var ne = ae, fe = 0; ne.cmp(R) !== 0; fe++)
            ne = ne.redSqr();
          n(fe < Z);
          var le = this.pow(B, new i(1).iushln(Z - fe - 1));
          ee = ee.redMul(le), B = le.redSqr(), ae = ae.redMul(B), Z = fe;
        }
        return ee;
      }, Q.prototype.invm = function(f) {
        var v = f._invmp(this.m);
        return v.negative !== 0 ? (v.negative = 0, this.imod(v).redNeg()) : this.imod(v);
      }, Q.prototype.pow = function(f, v) {
        if (v.isZero())
          return new i(1).toRed(this);
        if (v.cmpn(1) === 0)
          return f.clone();
        var g = 4, M = new Array(1 << g);
        M[0] = new i(1).toRed(this), M[1] = f;
        for (var I = 2; I < M.length; I++)
          M[I] = this.mul(M[I - 1], f);
        var R = M[0], x = 0, T = 0, p = v.bitLength() % 26;
        for (p === 0 && (p = 26), I = v.length - 1; I >= 0; I--) {
          for (var B = v.words[I], ee = p - 1; ee >= 0; ee--) {
            var ae = B >> ee & 1;
            if (R !== M[0] && (R = this.sqr(R)), ae === 0 && x === 0) {
              T = 0;
              continue;
            }
            x <<= 1, x |= ae, T++, !(T !== g && (I !== 0 || ee !== 0)) && (R = this.mul(R, M[x]), T = 0, x = 0);
          }
          p = 26;
        }
        return R;
      }, Q.prototype.convertTo = function(f) {
        var v = f.umod(this.m);
        return v === f ? v.clone() : v;
      }, Q.prototype.convertFrom = function(f) {
        var v = f.clone();
        return v.red = null, v;
      }, i.mont = function(f) {
        return new A(f);
      };
      function A(b) {
        Q.call(this, b), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new i(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      a(A, Q), A.prototype.convertTo = function(f) {
        return this.imod(f.ushln(this.shift));
      }, A.prototype.convertFrom = function(f) {
        var v = this.imod(f.mul(this.rinv));
        return v.red = null, v;
      }, A.prototype.imul = function(f, v) {
        if (f.isZero() || v.isZero())
          return f.words[0] = 0, f.length = 1, f;
        var g = f.imul(v), M = g.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), I = g.isub(M).iushrn(this.shift), R = I;
        return I.cmp(this.m) >= 0 ? R = I.isub(this.m) : I.cmpn(0) < 0 && (R = I.iadd(this.m)), R._forceRed(this);
      }, A.prototype.mul = function(f, v) {
        if (f.isZero() || v.isZero())
          return new i(0)._forceRed(this);
        var g = f.mul(v), M = g.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), I = g.isub(M).iushrn(this.shift), R = I;
        return I.cmp(this.m) >= 0 ? R = I.isub(this.m) : I.cmpn(0) < 0 && (R = I.iadd(this.m)), R._forceRed(this);
      }, A.prototype.invm = function(f) {
        var v = this.imod(f._invmp(this.m).mul(this.r2));
        return v._forceRed(this);
      };
    })(r, Jt);
  }(Za)), Za.exports;
}
var Uf, _d;
function ah() {
  if (_d)
    return Uf;
  _d = 1;
  var r = Q6(), e = Ii();
  function t(i) {
    var o = n(i), u = o.toRed(r.mont(i.modulus)).redPow(new r(i.publicExponent)).fromRed();
    return { blinder: u, unblinder: o.invm(i.modulus) };
  }
  function n(i) {
    var o = i.modulus.byteLength(), u;
    do
      u = new r(e(o));
    while (u.cmp(i.modulus) >= 0 || !u.umod(i.prime1) || !u.umod(i.prime2));
    return u;
  }
  function a(i, o) {
    var u = t(o), c = o.modulus.byteLength(), h = new r(i).mul(u.blinder).umod(o.modulus), s = h.toRed(r.mont(o.prime1)), d = h.toRed(r.mont(o.prime2)), l = o.coefficient, y = o.prime1, m = o.prime2, w = s.redPow(o.exponent1).fromRed(), E = d.redPow(o.exponent2).fromRed(), S = w.isub(E).imul(l).umod(y).imul(m);
    return E.iadd(S).imul(u.unblinder).umod(o.modulus).toArrayLike(Xt, "be", c);
  }
  return a.getr = n, Uf = a, Uf;
}
var $f = {};
const G6 = "elliptic", J6 = "6.5.4", Y6 = "EC cryptography", X6 = "lib/elliptic.js", Z6 = [
  "lib"
], e3 = {
  lint: "eslint lib test",
  "lint:fix": "npm run lint -- --fix",
  unit: "istanbul test _mocha --reporter=spec test/index.js",
  test: "npm run lint && npm run unit",
  version: "grunt dist && git add dist/"
}, t3 = {
  type: "git",
  url: "git@github.com:indutny/elliptic"
}, r3 = [
  "EC",
  "Elliptic",
  "curve",
  "Cryptography"
], n3 = "Fedor Indutny <fedor@indutny.com>", i3 = "MIT", a3 = {
  url: "https://github.com/indutny/elliptic/issues"
}, o3 = "https://github.com/indutny/elliptic", s3 = {
  brfs: "^2.0.2",
  coveralls: "^3.1.0",
  eslint: "^7.6.0",
  grunt: "^1.2.1",
  "grunt-browserify": "^5.3.0",
  "grunt-cli": "^1.3.2",
  "grunt-contrib-connect": "^3.0.0",
  "grunt-contrib-copy": "^1.0.0",
  "grunt-contrib-uglify": "^5.0.0",
  "grunt-mocha-istanbul": "^5.0.2",
  "grunt-saucelabs": "^9.0.1",
  istanbul: "^0.4.5",
  mocha: "^8.0.1"
}, f3 = {
  "bn.js": "^4.11.9",
  brorand: "^1.1.0",
  "hash.js": "^1.0.0",
  "hmac-drbg": "^1.0.1",
  inherits: "^2.0.4",
  "minimalistic-assert": "^1.0.1",
  "minimalistic-crypto-utils": "^1.0.1"
}, u3 = {
  name: G6,
  version: J6,
  description: Y6,
  main: X6,
  files: Z6,
  scripts: e3,
  repository: t3,
  keywords: r3,
  author: n3,
  license: i3,
  bugs: a3,
  homepage: o3,
  devDependencies: s3,
  dependencies: f3
};
var jf = {}, Hf = {}, xd;
function H1() {
  return xd || (xd = 1, function(r) {
    var e = r;
    function t(i, o) {
      if (Array.isArray(i))
        return i.slice();
      if (!i)
        return [];
      var u = [];
      if (typeof i != "string") {
        for (var c = 0; c < i.length; c++)
          u[c] = i[c] | 0;
        return u;
      }
      if (o === "hex") {
        i = i.replace(/[^a-z0-9]+/ig, ""), i.length % 2 !== 0 && (i = "0" + i);
        for (var c = 0; c < i.length; c += 2)
          u.push(parseInt(i[c] + i[c + 1], 16));
      } else
        for (var c = 0; c < i.length; c++) {
          var h = i.charCodeAt(c), s = h >> 8, d = h & 255;
          s ? u.push(s, d) : u.push(d);
        }
      return u;
    }
    e.toArray = t;
    function n(i) {
      return i.length === 1 ? "0" + i : i;
    }
    e.zero2 = n;
    function a(i) {
      for (var o = "", u = 0; u < i.length; u++)
        o += n(i[u].toString(16));
      return o;
    }
    e.toHex = a, e.encode = function(o, u) {
      return u === "hex" ? a(o) : o;
    };
  }(Hf)), Hf;
}
var Sd;
function Kr() {
  return Sd || (Sd = 1, function(r) {
    var e = r, t = Ir(), n = Wr(), a = H1();
    e.assert = n, e.toArray = a.toArray, e.zero2 = a.zero2, e.toHex = a.toHex, e.encode = a.encode;
    function i(s, d, l) {
      var y = new Array(Math.max(s.bitLength(), l) + 1);
      y.fill(0);
      for (var m = 1 << d + 1, w = s.clone(), E = 0; E < y.length; E++) {
        var S, P = w.andln(m - 1);
        w.isOdd() ? (P > (m >> 1) - 1 ? S = (m >> 1) - P : S = P, w.isubn(S)) : S = 0, y[E] = S, w.iushrn(1);
      }
      return y;
    }
    e.getNAF = i;
    function o(s, d) {
      var l = [
        [],
        []
      ];
      s = s.clone(), d = d.clone();
      for (var y = 0, m = 0, w; s.cmpn(-y) > 0 || d.cmpn(-m) > 0; ) {
        var E = s.andln(3) + y & 3, S = d.andln(3) + m & 3;
        E === 3 && (E = -1), S === 3 && (S = -1);
        var P;
        E & 1 ? (w = s.andln(7) + y & 7, (w === 3 || w === 5) && S === 2 ? P = -E : P = E) : P = 0, l[0].push(P);
        var L;
        S & 1 ? (w = d.andln(7) + m & 7, (w === 3 || w === 5) && E === 2 ? L = -S : L = S) : L = 0, l[1].push(L), 2 * y === P + 1 && (y = 1 - y), 2 * m === L + 1 && (m = 1 - m), s.iushrn(1), d.iushrn(1);
      }
      return l;
    }
    e.getJSF = o;
    function u(s, d, l) {
      var y = "_" + d;
      s.prototype[d] = function() {
        return this[y] !== void 0 ? this[y] : this[y] = l.call(this);
      };
    }
    e.cachedProperty = u;
    function c(s) {
      return typeof s == "string" ? e.toArray(s, "hex") : s;
    }
    e.parseBytes = c;
    function h(s) {
      return new t(s, "hex", "le");
    }
    e.intFromLE = h;
  }(jf)), jf;
}
var zf = {}, Vf, Ed;
function ko() {
  if (Ed)
    return Vf;
  Ed = 1;
  var r = Ir(), e = Kr(), t = e.getNAF, n = e.getJSF, a = e.assert;
  function i(u, c) {
    this.type = u, this.p = new r(c.p, 16), this.red = c.prime ? r.red(c.prime) : r.mont(this.p), this.zero = new r(0).toRed(this.red), this.one = new r(1).toRed(this.red), this.two = new r(2).toRed(this.red), this.n = c.n && new r(c.n, 16), this.g = c.g && this.pointFromJSON(c.g, c.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
    var h = this.n && this.p.div(this.n);
    !h || h.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
  }
  Vf = i, i.prototype.point = function() {
    throw new Error("Not implemented");
  }, i.prototype.validate = function() {
    throw new Error("Not implemented");
  }, i.prototype._fixedNafMul = function(c, h) {
    a(c.precomputed);
    var s = c._getDoubles(), d = t(h, 1, this._bitLength), l = (1 << s.step + 1) - (s.step % 2 === 0 ? 2 : 1);
    l /= 3;
    var y = [], m, w;
    for (m = 0; m < d.length; m += s.step) {
      w = 0;
      for (var E = m + s.step - 1; E >= m; E--)
        w = (w << 1) + d[E];
      y.push(w);
    }
    for (var S = this.jpoint(null, null, null), P = this.jpoint(null, null, null), L = l; L > 0; L--) {
      for (m = 0; m < y.length; m++)
        w = y[m], w === L ? P = P.mixedAdd(s.points[m]) : w === -L && (P = P.mixedAdd(s.points[m].neg()));
      S = S.add(P);
    }
    return S.toP();
  }, i.prototype._wnafMul = function(c, h) {
    var s = 4, d = c._getNAFPoints(s);
    s = d.wnd;
    for (var l = d.points, y = t(h, s, this._bitLength), m = this.jpoint(null, null, null), w = y.length - 1; w >= 0; w--) {
      for (var E = 0; w >= 0 && y[w] === 0; w--)
        E++;
      if (w >= 0 && E++, m = m.dblp(E), w < 0)
        break;
      var S = y[w];
      a(S !== 0), c.type === "affine" ? S > 0 ? m = m.mixedAdd(l[S - 1 >> 1]) : m = m.mixedAdd(l[-S - 1 >> 1].neg()) : S > 0 ? m = m.add(l[S - 1 >> 1]) : m = m.add(l[-S - 1 >> 1].neg());
    }
    return c.type === "affine" ? m.toP() : m;
  }, i.prototype._wnafMulAdd = function(c, h, s, d, l) {
    var y = this._wnafT1, m = this._wnafT2, w = this._wnafT3, E = 0, S, P, L;
    for (S = 0; S < d; S++) {
      L = h[S];
      var U = L._getNAFPoints(c);
      y[S] = U.wnd, m[S] = U.points;
    }
    for (S = d - 1; S >= 1; S -= 2) {
      var z = S - 1, K = S;
      if (y[z] !== 1 || y[K] !== 1) {
        w[z] = t(s[z], y[z], this._bitLength), w[K] = t(s[K], y[K], this._bitLength), E = Math.max(w[z].length, E), E = Math.max(w[K].length, E);
        continue;
      }
      var re = [
        h[z],
        /* 1 */
        null,
        /* 3 */
        null,
        /* 5 */
        h[K]
        /* 7 */
      ];
      h[z].y.cmp(h[K].y) === 0 ? (re[1] = h[z].add(h[K]), re[2] = h[z].toJ().mixedAdd(h[K].neg())) : h[z].y.cmp(h[K].y.redNeg()) === 0 ? (re[1] = h[z].toJ().mixedAdd(h[K]), re[2] = h[z].add(h[K].neg())) : (re[1] = h[z].toJ().mixedAdd(h[K]), re[2] = h[z].toJ().mixedAdd(h[K].neg()));
      var oe = [
        -3,
        /* -1 -1 */
        -1,
        /* -1 0 */
        -5,
        /* -1 1 */
        -7,
        /* 0 -1 */
        0,
        /* 0 0 */
        7,
        /* 0 1 */
        5,
        /* 1 -1 */
        1,
        /* 1 0 */
        3
        /* 1 1 */
      ], se = n(s[z], s[K]);
      for (E = Math.max(se[0].length, E), w[z] = new Array(E), w[K] = new Array(E), P = 0; P < E; P++) {
        var ve = se[0][P] | 0, Q = se[1][P] | 0;
        w[z][P] = oe[(ve + 1) * 3 + (Q + 1)], w[K][P] = 0, m[z] = re;
      }
    }
    var A = this.jpoint(null, null, null), b = this._wnafT4;
    for (S = E; S >= 0; S--) {
      for (var f = 0; S >= 0; ) {
        var v = !0;
        for (P = 0; P < d; P++)
          b[P] = w[P][S] | 0, b[P] !== 0 && (v = !1);
        if (!v)
          break;
        f++, S--;
      }
      if (S >= 0 && f++, A = A.dblp(f), S < 0)
        break;
      for (P = 0; P < d; P++) {
        var g = b[P];
        g !== 0 && (g > 0 ? L = m[P][g - 1 >> 1] : g < 0 && (L = m[P][-g - 1 >> 1].neg()), L.type === "affine" ? A = A.mixedAdd(L) : A = A.add(L));
      }
    }
    for (S = 0; S < d; S++)
      m[S] = null;
    return l ? A : A.toP();
  };
  function o(u, c) {
    this.curve = u, this.type = c, this.precomputed = null;
  }
  return i.BasePoint = o, o.prototype.eq = function() {
    throw new Error("Not implemented");
  }, o.prototype.validate = function() {
    return this.curve.validate(this);
  }, i.prototype.decodePoint = function(c, h) {
    c = e.toArray(c, h);
    var s = this.p.byteLength();
    if ((c[0] === 4 || c[0] === 6 || c[0] === 7) && c.length - 1 === 2 * s) {
      c[0] === 6 ? a(c[c.length - 1] % 2 === 0) : c[0] === 7 && a(c[c.length - 1] % 2 === 1);
      var d = this.point(
        c.slice(1, 1 + s),
        c.slice(1 + s, 1 + 2 * s)
      );
      return d;
    } else if ((c[0] === 2 || c[0] === 3) && c.length - 1 === s)
      return this.pointFromX(c.slice(1, 1 + s), c[0] === 3);
    throw new Error("Unknown point format");
  }, o.prototype.encodeCompressed = function(c) {
    return this.encode(c, !0);
  }, o.prototype._encode = function(c) {
    var h = this.curve.p.byteLength(), s = this.getX().toArray("be", h);
    return c ? [this.getY().isEven() ? 2 : 3].concat(s) : [4].concat(s, this.getY().toArray("be", h));
  }, o.prototype.encode = function(c, h) {
    return e.encode(this._encode(h), c);
  }, o.prototype.precompute = function(c) {
    if (this.precomputed)
      return this;
    var h = {
      doubles: null,
      naf: null,
      beta: null
    };
    return h.naf = this._getNAFPoints(8), h.doubles = this._getDoubles(4, c), h.beta = this._getBeta(), this.precomputed = h, this;
  }, o.prototype._hasDoubles = function(c) {
    if (!this.precomputed)
      return !1;
    var h = this.precomputed.doubles;
    return h ? h.points.length >= Math.ceil((c.bitLength() + 1) / h.step) : !1;
  }, o.prototype._getDoubles = function(c, h) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;
    for (var s = [this], d = this, l = 0; l < h; l += c) {
      for (var y = 0; y < c; y++)
        d = d.dbl();
      s.push(d);
    }
    return {
      step: c,
      points: s
    };
  }, o.prototype._getNAFPoints = function(c) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;
    for (var h = [this], s = (1 << c) - 1, d = s === 1 ? null : this.dbl(), l = 1; l < s; l++)
      h[l] = h[l - 1].add(d);
    return {
      wnd: c,
      points: h
    };
  }, o.prototype._getBeta = function() {
    return null;
  }, o.prototype.dblp = function(c) {
    for (var h = this, s = 0; s < c; s++)
      h = h.dbl();
    return h;
  }, Vf;
}
var Wf, Md;
function c3() {
  if (Md)
    return Wf;
  Md = 1;
  var r = Kr(), e = Ir(), t = Ft(), n = ko(), a = r.assert;
  function i(c) {
    n.call(this, "short", c), this.a = new e(c.a, 16).toRed(this.red), this.b = new e(c.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(c), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
  }
  t(i, n), Wf = i, i.prototype._getEndomorphism = function(h) {
    if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
      var s, d;
      if (h.beta)
        s = new e(h.beta, 16).toRed(this.red);
      else {
        var l = this._getEndoRoots(this.p);
        s = l[0].cmp(l[1]) < 0 ? l[0] : l[1], s = s.toRed(this.red);
      }
      if (h.lambda)
        d = new e(h.lambda, 16);
      else {
        var y = this._getEndoRoots(this.n);
        this.g.mul(y[0]).x.cmp(this.g.x.redMul(s)) === 0 ? d = y[0] : (d = y[1], a(this.g.mul(d).x.cmp(this.g.x.redMul(s)) === 0));
      }
      var m;
      return h.basis ? m = h.basis.map(function(w) {
        return {
          a: new e(w.a, 16),
          b: new e(w.b, 16)
        };
      }) : m = this._getEndoBasis(d), {
        beta: s,
        lambda: d,
        basis: m
      };
    }
  }, i.prototype._getEndoRoots = function(h) {
    var s = h === this.p ? this.red : e.mont(h), d = new e(2).toRed(s).redInvm(), l = d.redNeg(), y = new e(3).toRed(s).redNeg().redSqrt().redMul(d), m = l.redAdd(y).fromRed(), w = l.redSub(y).fromRed();
    return [m, w];
  }, i.prototype._getEndoBasis = function(h) {
    for (var s = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), d = h, l = this.n.clone(), y = new e(1), m = new e(0), w = new e(0), E = new e(1), S, P, L, U, z, K, re, oe = 0, se, ve; d.cmpn(0) !== 0; ) {
      var Q = l.div(d);
      se = l.sub(Q.mul(d)), ve = w.sub(Q.mul(y));
      var A = E.sub(Q.mul(m));
      if (!L && se.cmp(s) < 0)
        S = re.neg(), P = y, L = se.neg(), U = ve;
      else if (L && ++oe === 2)
        break;
      re = se, l = d, d = se, w = y, y = ve, E = m, m = A;
    }
    z = se.neg(), K = ve;
    var b = L.sqr().add(U.sqr()), f = z.sqr().add(K.sqr());
    return f.cmp(b) >= 0 && (z = S, K = P), L.negative && (L = L.neg(), U = U.neg()), z.negative && (z = z.neg(), K = K.neg()), [
      { a: L, b: U },
      { a: z, b: K }
    ];
  }, i.prototype._endoSplit = function(h) {
    var s = this.endo.basis, d = s[0], l = s[1], y = l.b.mul(h).divRound(this.n), m = d.b.neg().mul(h).divRound(this.n), w = y.mul(d.a), E = m.mul(l.a), S = y.mul(d.b), P = m.mul(l.b), L = h.sub(w).sub(E), U = S.add(P).neg();
    return { k1: L, k2: U };
  }, i.prototype.pointFromX = function(h, s) {
    h = new e(h, 16), h.red || (h = h.toRed(this.red));
    var d = h.redSqr().redMul(h).redIAdd(h.redMul(this.a)).redIAdd(this.b), l = d.redSqrt();
    if (l.redSqr().redSub(d).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var y = l.fromRed().isOdd();
    return (s && !y || !s && y) && (l = l.redNeg()), this.point(h, l);
  }, i.prototype.validate = function(h) {
    if (h.inf)
      return !0;
    var s = h.x, d = h.y, l = this.a.redMul(s), y = s.redSqr().redMul(s).redIAdd(l).redIAdd(this.b);
    return d.redSqr().redISub(y).cmpn(0) === 0;
  }, i.prototype._endoWnafMulAdd = function(h, s, d) {
    for (var l = this._endoWnafT1, y = this._endoWnafT2, m = 0; m < h.length; m++) {
      var w = this._endoSplit(s[m]), E = h[m], S = E._getBeta();
      w.k1.negative && (w.k1.ineg(), E = E.neg(!0)), w.k2.negative && (w.k2.ineg(), S = S.neg(!0)), l[m * 2] = E, l[m * 2 + 1] = S, y[m * 2] = w.k1, y[m * 2 + 1] = w.k2;
    }
    for (var P = this._wnafMulAdd(1, l, y, m * 2, d), L = 0; L < m * 2; L++)
      l[L] = null, y[L] = null;
    return P;
  };
  function o(c, h, s, d) {
    n.BasePoint.call(this, c, "affine"), h === null && s === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new e(h, 16), this.y = new e(s, 16), d && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
  }
  t(o, n.BasePoint), i.prototype.point = function(h, s, d) {
    return new o(this, h, s, d);
  }, i.prototype.pointFromJSON = function(h, s) {
    return o.fromJSON(this, h, s);
  }, o.prototype._getBeta = function() {
    if (this.curve.endo) {
      var h = this.precomputed;
      if (h && h.beta)
        return h.beta;
      var s = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (h) {
        var d = this.curve, l = function(y) {
          return d.point(y.x.redMul(d.endo.beta), y.y);
        };
        h.beta = s, s.precomputed = {
          beta: null,
          naf: h.naf && {
            wnd: h.naf.wnd,
            points: h.naf.points.map(l)
          },
          doubles: h.doubles && {
            step: h.doubles.step,
            points: h.doubles.points.map(l)
          }
        };
      }
      return s;
    }
  }, o.prototype.toJSON = function() {
    return this.precomputed ? [this.x, this.y, this.precomputed && {
      doubles: this.precomputed.doubles && {
        step: this.precomputed.doubles.step,
        points: this.precomputed.doubles.points.slice(1)
      },
      naf: this.precomputed.naf && {
        wnd: this.precomputed.naf.wnd,
        points: this.precomputed.naf.points.slice(1)
      }
    }] : [this.x, this.y];
  }, o.fromJSON = function(h, s, d) {
    typeof s == "string" && (s = JSON.parse(s));
    var l = h.point(s[0], s[1], d);
    if (!s[2])
      return l;
    function y(w) {
      return h.point(w[0], w[1], d);
    }
    var m = s[2];
    return l.precomputed = {
      beta: null,
      doubles: m.doubles && {
        step: m.doubles.step,
        points: [l].concat(m.doubles.points.map(y))
      },
      naf: m.naf && {
        wnd: m.naf.wnd,
        points: [l].concat(m.naf.points.map(y))
      }
    }, l;
  }, o.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
  }, o.prototype.isInfinity = function() {
    return this.inf;
  }, o.prototype.add = function(h) {
    if (this.inf)
      return h;
    if (h.inf)
      return this;
    if (this.eq(h))
      return this.dbl();
    if (this.neg().eq(h))
      return this.curve.point(null, null);
    if (this.x.cmp(h.x) === 0)
      return this.curve.point(null, null);
    var s = this.y.redSub(h.y);
    s.cmpn(0) !== 0 && (s = s.redMul(this.x.redSub(h.x).redInvm()));
    var d = s.redSqr().redISub(this.x).redISub(h.x), l = s.redMul(this.x.redSub(d)).redISub(this.y);
    return this.curve.point(d, l);
  }, o.prototype.dbl = function() {
    if (this.inf)
      return this;
    var h = this.y.redAdd(this.y);
    if (h.cmpn(0) === 0)
      return this.curve.point(null, null);
    var s = this.curve.a, d = this.x.redSqr(), l = h.redInvm(), y = d.redAdd(d).redIAdd(d).redIAdd(s).redMul(l), m = y.redSqr().redISub(this.x.redAdd(this.x)), w = y.redMul(this.x.redSub(m)).redISub(this.y);
    return this.curve.point(m, w);
  }, o.prototype.getX = function() {
    return this.x.fromRed();
  }, o.prototype.getY = function() {
    return this.y.fromRed();
  }, o.prototype.mul = function(h) {
    return h = new e(h, 16), this.isInfinity() ? this : this._hasDoubles(h) ? this.curve._fixedNafMul(this, h) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [h]) : this.curve._wnafMul(this, h);
  }, o.prototype.mulAdd = function(h, s, d) {
    var l = [this, s], y = [h, d];
    return this.curve.endo ? this.curve._endoWnafMulAdd(l, y) : this.curve._wnafMulAdd(1, l, y, 2);
  }, o.prototype.jmulAdd = function(h, s, d) {
    var l = [this, s], y = [h, d];
    return this.curve.endo ? this.curve._endoWnafMulAdd(l, y, !0) : this.curve._wnafMulAdd(1, l, y, 2, !0);
  }, o.prototype.eq = function(h) {
    return this === h || this.inf === h.inf && (this.inf || this.x.cmp(h.x) === 0 && this.y.cmp(h.y) === 0);
  }, o.prototype.neg = function(h) {
    if (this.inf)
      return this;
    var s = this.curve.point(this.x, this.y.redNeg());
    if (h && this.precomputed) {
      var d = this.precomputed, l = function(y) {
        return y.neg();
      };
      s.precomputed = {
        naf: d.naf && {
          wnd: d.naf.wnd,
          points: d.naf.points.map(l)
        },
        doubles: d.doubles && {
          step: d.doubles.step,
          points: d.doubles.points.map(l)
        }
      };
    }
    return s;
  }, o.prototype.toJ = function() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);
    var h = this.curve.jpoint(this.x, this.y, this.curve.one);
    return h;
  };
  function u(c, h, s, d) {
    n.BasePoint.call(this, c, "jacobian"), h === null && s === null && d === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new e(0)) : (this.x = new e(h, 16), this.y = new e(s, 16), this.z = new e(d, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
  }
  return t(u, n.BasePoint), i.prototype.jpoint = function(h, s, d) {
    return new u(this, h, s, d);
  }, u.prototype.toP = function() {
    if (this.isInfinity())
      return this.curve.point(null, null);
    var h = this.z.redInvm(), s = h.redSqr(), d = this.x.redMul(s), l = this.y.redMul(s).redMul(h);
    return this.curve.point(d, l);
  }, u.prototype.neg = function() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  }, u.prototype.add = function(h) {
    if (this.isInfinity())
      return h;
    if (h.isInfinity())
      return this;
    var s = h.z.redSqr(), d = this.z.redSqr(), l = this.x.redMul(s), y = h.x.redMul(d), m = this.y.redMul(s.redMul(h.z)), w = h.y.redMul(d.redMul(this.z)), E = l.redSub(y), S = m.redSub(w);
    if (E.cmpn(0) === 0)
      return S.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var P = E.redSqr(), L = P.redMul(E), U = l.redMul(P), z = S.redSqr().redIAdd(L).redISub(U).redISub(U), K = S.redMul(U.redISub(z)).redISub(m.redMul(L)), re = this.z.redMul(h.z).redMul(E);
    return this.curve.jpoint(z, K, re);
  }, u.prototype.mixedAdd = function(h) {
    if (this.isInfinity())
      return h.toJ();
    if (h.isInfinity())
      return this;
    var s = this.z.redSqr(), d = this.x, l = h.x.redMul(s), y = this.y, m = h.y.redMul(s).redMul(this.z), w = d.redSub(l), E = y.redSub(m);
    if (w.cmpn(0) === 0)
      return E.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var S = w.redSqr(), P = S.redMul(w), L = d.redMul(S), U = E.redSqr().redIAdd(P).redISub(L).redISub(L), z = E.redMul(L.redISub(U)).redISub(y.redMul(P)), K = this.z.redMul(w);
    return this.curve.jpoint(U, z, K);
  }, u.prototype.dblp = function(h) {
    if (h === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!h)
      return this.dbl();
    var s;
    if (this.curve.zeroA || this.curve.threeA) {
      var d = this;
      for (s = 0; s < h; s++)
        d = d.dbl();
      return d;
    }
    var l = this.curve.a, y = this.curve.tinv, m = this.x, w = this.y, E = this.z, S = E.redSqr().redSqr(), P = w.redAdd(w);
    for (s = 0; s < h; s++) {
      var L = m.redSqr(), U = P.redSqr(), z = U.redSqr(), K = L.redAdd(L).redIAdd(L).redIAdd(l.redMul(S)), re = m.redMul(U), oe = K.redSqr().redISub(re.redAdd(re)), se = re.redISub(oe), ve = K.redMul(se);
      ve = ve.redIAdd(ve).redISub(z);
      var Q = P.redMul(E);
      s + 1 < h && (S = S.redMul(z)), m = oe, E = Q, P = ve;
    }
    return this.curve.jpoint(m, P.redMul(y), E);
  }, u.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
  }, u.prototype._zeroDbl = function() {
    var h, s, d;
    if (this.zOne) {
      var l = this.x.redSqr(), y = this.y.redSqr(), m = y.redSqr(), w = this.x.redAdd(y).redSqr().redISub(l).redISub(m);
      w = w.redIAdd(w);
      var E = l.redAdd(l).redIAdd(l), S = E.redSqr().redISub(w).redISub(w), P = m.redIAdd(m);
      P = P.redIAdd(P), P = P.redIAdd(P), h = S, s = E.redMul(w.redISub(S)).redISub(P), d = this.y.redAdd(this.y);
    } else {
      var L = this.x.redSqr(), U = this.y.redSqr(), z = U.redSqr(), K = this.x.redAdd(U).redSqr().redISub(L).redISub(z);
      K = K.redIAdd(K);
      var re = L.redAdd(L).redIAdd(L), oe = re.redSqr(), se = z.redIAdd(z);
      se = se.redIAdd(se), se = se.redIAdd(se), h = oe.redISub(K).redISub(K), s = re.redMul(K.redISub(h)).redISub(se), d = this.y.redMul(this.z), d = d.redIAdd(d);
    }
    return this.curve.jpoint(h, s, d);
  }, u.prototype._threeDbl = function() {
    var h, s, d;
    if (this.zOne) {
      var l = this.x.redSqr(), y = this.y.redSqr(), m = y.redSqr(), w = this.x.redAdd(y).redSqr().redISub(l).redISub(m);
      w = w.redIAdd(w);
      var E = l.redAdd(l).redIAdd(l).redIAdd(this.curve.a), S = E.redSqr().redISub(w).redISub(w);
      h = S;
      var P = m.redIAdd(m);
      P = P.redIAdd(P), P = P.redIAdd(P), s = E.redMul(w.redISub(S)).redISub(P), d = this.y.redAdd(this.y);
    } else {
      var L = this.z.redSqr(), U = this.y.redSqr(), z = this.x.redMul(U), K = this.x.redSub(L).redMul(this.x.redAdd(L));
      K = K.redAdd(K).redIAdd(K);
      var re = z.redIAdd(z);
      re = re.redIAdd(re);
      var oe = re.redAdd(re);
      h = K.redSqr().redISub(oe), d = this.y.redAdd(this.z).redSqr().redISub(U).redISub(L);
      var se = U.redSqr();
      se = se.redIAdd(se), se = se.redIAdd(se), se = se.redIAdd(se), s = K.redMul(re.redISub(h)).redISub(se);
    }
    return this.curve.jpoint(h, s, d);
  }, u.prototype._dbl = function() {
    var h = this.curve.a, s = this.x, d = this.y, l = this.z, y = l.redSqr().redSqr(), m = s.redSqr(), w = d.redSqr(), E = m.redAdd(m).redIAdd(m).redIAdd(h.redMul(y)), S = s.redAdd(s);
    S = S.redIAdd(S);
    var P = S.redMul(w), L = E.redSqr().redISub(P.redAdd(P)), U = P.redISub(L), z = w.redSqr();
    z = z.redIAdd(z), z = z.redIAdd(z), z = z.redIAdd(z);
    var K = E.redMul(U).redISub(z), re = d.redAdd(d).redMul(l);
    return this.curve.jpoint(L, K, re);
  }, u.prototype.trpl = function() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);
    var h = this.x.redSqr(), s = this.y.redSqr(), d = this.z.redSqr(), l = s.redSqr(), y = h.redAdd(h).redIAdd(h), m = y.redSqr(), w = this.x.redAdd(s).redSqr().redISub(h).redISub(l);
    w = w.redIAdd(w), w = w.redAdd(w).redIAdd(w), w = w.redISub(m);
    var E = w.redSqr(), S = l.redIAdd(l);
    S = S.redIAdd(S), S = S.redIAdd(S), S = S.redIAdd(S);
    var P = y.redIAdd(w).redSqr().redISub(m).redISub(E).redISub(S), L = s.redMul(P);
    L = L.redIAdd(L), L = L.redIAdd(L);
    var U = this.x.redMul(E).redISub(L);
    U = U.redIAdd(U), U = U.redIAdd(U);
    var z = this.y.redMul(P.redMul(S.redISub(P)).redISub(w.redMul(E)));
    z = z.redIAdd(z), z = z.redIAdd(z), z = z.redIAdd(z);
    var K = this.z.redAdd(w).redSqr().redISub(d).redISub(E);
    return this.curve.jpoint(U, z, K);
  }, u.prototype.mul = function(h, s) {
    return h = new e(h, s), this.curve._wnafMul(this, h);
  }, u.prototype.eq = function(h) {
    if (h.type === "affine")
      return this.eq(h.toJ());
    if (this === h)
      return !0;
    var s = this.z.redSqr(), d = h.z.redSqr();
    if (this.x.redMul(d).redISub(h.x.redMul(s)).cmpn(0) !== 0)
      return !1;
    var l = s.redMul(this.z), y = d.redMul(h.z);
    return this.y.redMul(y).redISub(h.y.redMul(l)).cmpn(0) === 0;
  }, u.prototype.eqXToP = function(h) {
    var s = this.z.redSqr(), d = h.toRed(this.curve.red).redMul(s);
    if (this.x.cmp(d) === 0)
      return !0;
    for (var l = h.clone(), y = this.curve.redN.redMul(s); ; ) {
      if (l.iadd(this.curve.n), l.cmp(this.curve.p) >= 0)
        return !1;
      if (d.redIAdd(y), this.x.cmp(d) === 0)
        return !0;
    }
  }, u.prototype.inspect = function() {
    return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
  }, u.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, Wf;
}
var Kf, Ad;
function h3() {
  if (Ad)
    return Kf;
  Ad = 1;
  var r = Ir(), e = Ft(), t = ko(), n = Kr();
  function a(o) {
    t.call(this, "mont", o), this.a = new r(o.a, 16).toRed(this.red), this.b = new r(o.b, 16).toRed(this.red), this.i4 = new r(4).toRed(this.red).redInvm(), this.two = new r(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }
  e(a, t), Kf = a, a.prototype.validate = function(u) {
    var c = u.normalize().x, h = c.redSqr(), s = h.redMul(c).redAdd(h.redMul(this.a)).redAdd(c), d = s.redSqrt();
    return d.redSqr().cmp(s) === 0;
  };
  function i(o, u, c) {
    t.BasePoint.call(this, o, "projective"), u === null && c === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new r(u, 16), this.z = new r(c, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
  }
  return e(i, t.BasePoint), a.prototype.decodePoint = function(u, c) {
    return this.point(n.toArray(u, c), 1);
  }, a.prototype.point = function(u, c) {
    return new i(this, u, c);
  }, a.prototype.pointFromJSON = function(u) {
    return i.fromJSON(this, u);
  }, i.prototype.precompute = function() {
  }, i.prototype._encode = function() {
    return this.getX().toArray("be", this.curve.p.byteLength());
  }, i.fromJSON = function(u, c) {
    return new i(u, c[0], c[1] || u.one);
  }, i.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, i.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, i.prototype.dbl = function() {
    var u = this.x.redAdd(this.z), c = u.redSqr(), h = this.x.redSub(this.z), s = h.redSqr(), d = c.redSub(s), l = c.redMul(s), y = d.redMul(s.redAdd(this.curve.a24.redMul(d)));
    return this.curve.point(l, y);
  }, i.prototype.add = function() {
    throw new Error("Not supported on Montgomery curve");
  }, i.prototype.diffAdd = function(u, c) {
    var h = this.x.redAdd(this.z), s = this.x.redSub(this.z), d = u.x.redAdd(u.z), l = u.x.redSub(u.z), y = l.redMul(h), m = d.redMul(s), w = c.z.redMul(y.redAdd(m).redSqr()), E = c.x.redMul(y.redISub(m).redSqr());
    return this.curve.point(w, E);
  }, i.prototype.mul = function(u) {
    for (var c = u.clone(), h = this, s = this.curve.point(null, null), d = this, l = []; c.cmpn(0) !== 0; c.iushrn(1))
      l.push(c.andln(1));
    for (var y = l.length - 1; y >= 0; y--)
      l[y] === 0 ? (h = h.diffAdd(s, d), s = s.dbl()) : (s = h.diffAdd(s, d), h = h.dbl());
    return s;
  }, i.prototype.mulAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, i.prototype.jumlAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, i.prototype.eq = function(u) {
    return this.getX().cmp(u.getX()) === 0;
  }, i.prototype.normalize = function() {
    return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
  }, i.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, Kf;
}
var Qf, Td;
function l3() {
  if (Td)
    return Qf;
  Td = 1;
  var r = Kr(), e = Ir(), t = Ft(), n = ko(), a = r.assert;
  function i(u) {
    this.twisted = (u.a | 0) !== 1, this.mOneA = this.twisted && (u.a | 0) === -1, this.extended = this.mOneA, n.call(this, "edwards", u), this.a = new e(u.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new e(u.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new e(u.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), a(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (u.c | 0) === 1;
  }
  t(i, n), Qf = i, i.prototype._mulA = function(c) {
    return this.mOneA ? c.redNeg() : this.a.redMul(c);
  }, i.prototype._mulC = function(c) {
    return this.oneC ? c : this.c.redMul(c);
  }, i.prototype.jpoint = function(c, h, s, d) {
    return this.point(c, h, s, d);
  }, i.prototype.pointFromX = function(c, h) {
    c = new e(c, 16), c.red || (c = c.toRed(this.red));
    var s = c.redSqr(), d = this.c2.redSub(this.a.redMul(s)), l = this.one.redSub(this.c2.redMul(this.d).redMul(s)), y = d.redMul(l.redInvm()), m = y.redSqrt();
    if (m.redSqr().redSub(y).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var w = m.fromRed().isOdd();
    return (h && !w || !h && w) && (m = m.redNeg()), this.point(c, m);
  }, i.prototype.pointFromY = function(c, h) {
    c = new e(c, 16), c.red || (c = c.toRed(this.red));
    var s = c.redSqr(), d = s.redSub(this.c2), l = s.redMul(this.d).redMul(this.c2).redSub(this.a), y = d.redMul(l.redInvm());
    if (y.cmp(this.zero) === 0) {
      if (h)
        throw new Error("invalid point");
      return this.point(this.zero, c);
    }
    var m = y.redSqrt();
    if (m.redSqr().redSub(y).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    return m.fromRed().isOdd() !== h && (m = m.redNeg()), this.point(m, c);
  }, i.prototype.validate = function(c) {
    if (c.isInfinity())
      return !0;
    c.normalize();
    var h = c.x.redSqr(), s = c.y.redSqr(), d = h.redMul(this.a).redAdd(s), l = this.c2.redMul(this.one.redAdd(this.d.redMul(h).redMul(s)));
    return d.cmp(l) === 0;
  };
  function o(u, c, h, s, d) {
    n.BasePoint.call(this, u, "projective"), c === null && h === null && s === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new e(c, 16), this.y = new e(h, 16), this.z = s ? new e(s, 16) : this.curve.one, this.t = d && new e(d, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
  }
  return t(o, n.BasePoint), i.prototype.pointFromJSON = function(c) {
    return o.fromJSON(this, c);
  }, i.prototype.point = function(c, h, s, d) {
    return new o(this, c, h, s, d);
  }, o.fromJSON = function(c, h) {
    return new o(c, h[0], h[1], h[2]);
  }, o.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, o.prototype.isInfinity = function() {
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
  }, o.prototype._extDbl = function() {
    var c = this.x.redSqr(), h = this.y.redSqr(), s = this.z.redSqr();
    s = s.redIAdd(s);
    var d = this.curve._mulA(c), l = this.x.redAdd(this.y).redSqr().redISub(c).redISub(h), y = d.redAdd(h), m = y.redSub(s), w = d.redSub(h), E = l.redMul(m), S = y.redMul(w), P = l.redMul(w), L = m.redMul(y);
    return this.curve.point(E, S, L, P);
  }, o.prototype._projDbl = function() {
    var c = this.x.redAdd(this.y).redSqr(), h = this.x.redSqr(), s = this.y.redSqr(), d, l, y, m, w, E;
    if (this.curve.twisted) {
      m = this.curve._mulA(h);
      var S = m.redAdd(s);
      this.zOne ? (d = c.redSub(h).redSub(s).redMul(S.redSub(this.curve.two)), l = S.redMul(m.redSub(s)), y = S.redSqr().redSub(S).redSub(S)) : (w = this.z.redSqr(), E = S.redSub(w).redISub(w), d = c.redSub(h).redISub(s).redMul(E), l = S.redMul(m.redSub(s)), y = S.redMul(E));
    } else
      m = h.redAdd(s), w = this.curve._mulC(this.z).redSqr(), E = m.redSub(w).redSub(w), d = this.curve._mulC(c.redISub(m)).redMul(E), l = this.curve._mulC(m).redMul(h.redISub(s)), y = m.redMul(E);
    return this.curve.point(d, l, y);
  }, o.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
  }, o.prototype._extAdd = function(c) {
    var h = this.y.redSub(this.x).redMul(c.y.redSub(c.x)), s = this.y.redAdd(this.x).redMul(c.y.redAdd(c.x)), d = this.t.redMul(this.curve.dd).redMul(c.t), l = this.z.redMul(c.z.redAdd(c.z)), y = s.redSub(h), m = l.redSub(d), w = l.redAdd(d), E = s.redAdd(h), S = y.redMul(m), P = w.redMul(E), L = y.redMul(E), U = m.redMul(w);
    return this.curve.point(S, P, U, L);
  }, o.prototype._projAdd = function(c) {
    var h = this.z.redMul(c.z), s = h.redSqr(), d = this.x.redMul(c.x), l = this.y.redMul(c.y), y = this.curve.d.redMul(d).redMul(l), m = s.redSub(y), w = s.redAdd(y), E = this.x.redAdd(this.y).redMul(c.x.redAdd(c.y)).redISub(d).redISub(l), S = h.redMul(m).redMul(E), P, L;
    return this.curve.twisted ? (P = h.redMul(w).redMul(l.redSub(this.curve._mulA(d))), L = m.redMul(w)) : (P = h.redMul(w).redMul(l.redSub(d)), L = this.curve._mulC(m).redMul(w)), this.curve.point(S, P, L);
  }, o.prototype.add = function(c) {
    return this.isInfinity() ? c : c.isInfinity() ? this : this.curve.extended ? this._extAdd(c) : this._projAdd(c);
  }, o.prototype.mul = function(c) {
    return this._hasDoubles(c) ? this.curve._fixedNafMul(this, c) : this.curve._wnafMul(this, c);
  }, o.prototype.mulAdd = function(c, h, s) {
    return this.curve._wnafMulAdd(1, [this, h], [c, s], 2, !1);
  }, o.prototype.jmulAdd = function(c, h, s) {
    return this.curve._wnafMulAdd(1, [this, h], [c, s], 2, !0);
  }, o.prototype.normalize = function() {
    if (this.zOne)
      return this;
    var c = this.z.redInvm();
    return this.x = this.x.redMul(c), this.y = this.y.redMul(c), this.t && (this.t = this.t.redMul(c)), this.z = this.curve.one, this.zOne = !0, this;
  }, o.prototype.neg = function() {
    return this.curve.point(
      this.x.redNeg(),
      this.y,
      this.z,
      this.t && this.t.redNeg()
    );
  }, o.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, o.prototype.getY = function() {
    return this.normalize(), this.y.fromRed();
  }, o.prototype.eq = function(c) {
    return this === c || this.getX().cmp(c.getX()) === 0 && this.getY().cmp(c.getY()) === 0;
  }, o.prototype.eqXToP = function(c) {
    var h = c.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(h) === 0)
      return !0;
    for (var s = c.clone(), d = this.curve.redN.redMul(this.z); ; ) {
      if (s.iadd(this.curve.n), s.cmp(this.curve.p) >= 0)
        return !1;
      if (h.redIAdd(d), this.x.cmp(h) === 0)
        return !0;
    }
  }, o.prototype.toP = o.prototype.normalize, o.prototype.mixedAdd = o.prototype.add, Qf;
}
var kd;
function z1() {
  return kd || (kd = 1, function(r) {
    var e = r;
    e.base = ko(), e.short = c3(), e.mont = h3(), e.edwards = l3();
  }(zf)), zf;
}
var Gf = {}, Jf = {}, nr = {}, Id;
function dn() {
  if (Id)
    return nr;
  Id = 1;
  var r = Wr(), e = Ft();
  nr.inherits = e;
  function t(A, b) {
    return (A.charCodeAt(b) & 64512) !== 55296 || b < 0 || b + 1 >= A.length ? !1 : (A.charCodeAt(b + 1) & 64512) === 56320;
  }
  function n(A, b) {
    if (Array.isArray(A))
      return A.slice();
    if (!A)
      return [];
    var f = [];
    if (typeof A == "string")
      if (b) {
        if (b === "hex")
          for (A = A.replace(/[^a-z0-9]+/ig, ""), A.length % 2 !== 0 && (A = "0" + A), g = 0; g < A.length; g += 2)
            f.push(parseInt(A[g] + A[g + 1], 16));
      } else
        for (var v = 0, g = 0; g < A.length; g++) {
          var M = A.charCodeAt(g);
          M < 128 ? f[v++] = M : M < 2048 ? (f[v++] = M >> 6 | 192, f[v++] = M & 63 | 128) : t(A, g) ? (M = 65536 + ((M & 1023) << 10) + (A.charCodeAt(++g) & 1023), f[v++] = M >> 18 | 240, f[v++] = M >> 12 & 63 | 128, f[v++] = M >> 6 & 63 | 128, f[v++] = M & 63 | 128) : (f[v++] = M >> 12 | 224, f[v++] = M >> 6 & 63 | 128, f[v++] = M & 63 | 128);
        }
    else
      for (g = 0; g < A.length; g++)
        f[g] = A[g] | 0;
    return f;
  }
  nr.toArray = n;
  function a(A) {
    for (var b = "", f = 0; f < A.length; f++)
      b += u(A[f].toString(16));
    return b;
  }
  nr.toHex = a;
  function i(A) {
    var b = A >>> 24 | A >>> 8 & 65280 | A << 8 & 16711680 | (A & 255) << 24;
    return b >>> 0;
  }
  nr.htonl = i;
  function o(A, b) {
    for (var f = "", v = 0; v < A.length; v++) {
      var g = A[v];
      b === "little" && (g = i(g)), f += c(g.toString(16));
    }
    return f;
  }
  nr.toHex32 = o;
  function u(A) {
    return A.length === 1 ? "0" + A : A;
  }
  nr.zero2 = u;
  function c(A) {
    return A.length === 7 ? "0" + A : A.length === 6 ? "00" + A : A.length === 5 ? "000" + A : A.length === 4 ? "0000" + A : A.length === 3 ? "00000" + A : A.length === 2 ? "000000" + A : A.length === 1 ? "0000000" + A : A;
  }
  nr.zero8 = c;
  function h(A, b, f, v) {
    var g = f - b;
    r(g % 4 === 0);
    for (var M = new Array(g / 4), I = 0, R = b; I < M.length; I++, R += 4) {
      var x;
      v === "big" ? x = A[R] << 24 | A[R + 1] << 16 | A[R + 2] << 8 | A[R + 3] : x = A[R + 3] << 24 | A[R + 2] << 16 | A[R + 1] << 8 | A[R], M[I] = x >>> 0;
    }
    return M;
  }
  nr.join32 = h;
  function s(A, b) {
    for (var f = new Array(A.length * 4), v = 0, g = 0; v < A.length; v++, g += 4) {
      var M = A[v];
      b === "big" ? (f[g] = M >>> 24, f[g + 1] = M >>> 16 & 255, f[g + 2] = M >>> 8 & 255, f[g + 3] = M & 255) : (f[g + 3] = M >>> 24, f[g + 2] = M >>> 16 & 255, f[g + 1] = M >>> 8 & 255, f[g] = M & 255);
    }
    return f;
  }
  nr.split32 = s;
  function d(A, b) {
    return A >>> b | A << 32 - b;
  }
  nr.rotr32 = d;
  function l(A, b) {
    return A << b | A >>> 32 - b;
  }
  nr.rotl32 = l;
  function y(A, b) {
    return A + b >>> 0;
  }
  nr.sum32 = y;
  function m(A, b, f) {
    return A + b + f >>> 0;
  }
  nr.sum32_3 = m;
  function w(A, b, f, v) {
    return A + b + f + v >>> 0;
  }
  nr.sum32_4 = w;
  function E(A, b, f, v, g) {
    return A + b + f + v + g >>> 0;
  }
  nr.sum32_5 = E;
  function S(A, b, f, v) {
    var g = A[b], M = A[b + 1], I = v + M >>> 0, R = (I < v ? 1 : 0) + f + g;
    A[b] = R >>> 0, A[b + 1] = I;
  }
  nr.sum64 = S;
  function P(A, b, f, v) {
    var g = b + v >>> 0, M = (g < b ? 1 : 0) + A + f;
    return M >>> 0;
  }
  nr.sum64_hi = P;
  function L(A, b, f, v) {
    var g = b + v;
    return g >>> 0;
  }
  nr.sum64_lo = L;
  function U(A, b, f, v, g, M, I, R) {
    var x = 0, T = b;
    T = T + v >>> 0, x += T < b ? 1 : 0, T = T + M >>> 0, x += T < M ? 1 : 0, T = T + R >>> 0, x += T < R ? 1 : 0;
    var p = A + f + g + I + x;
    return p >>> 0;
  }
  nr.sum64_4_hi = U;
  function z(A, b, f, v, g, M, I, R) {
    var x = b + v + M + R;
    return x >>> 0;
  }
  nr.sum64_4_lo = z;
  function K(A, b, f, v, g, M, I, R, x, T) {
    var p = 0, B = b;
    B = B + v >>> 0, p += B < b ? 1 : 0, B = B + M >>> 0, p += B < M ? 1 : 0, B = B + R >>> 0, p += B < R ? 1 : 0, B = B + T >>> 0, p += B < T ? 1 : 0;
    var ee = A + f + g + I + x + p;
    return ee >>> 0;
  }
  nr.sum64_5_hi = K;
  function re(A, b, f, v, g, M, I, R, x, T) {
    var p = b + v + M + R + T;
    return p >>> 0;
  }
  nr.sum64_5_lo = re;
  function oe(A, b, f) {
    var v = b << 32 - f | A >>> f;
    return v >>> 0;
  }
  nr.rotr64_hi = oe;
  function se(A, b, f) {
    var v = A << 32 - f | b >>> f;
    return v >>> 0;
  }
  nr.rotr64_lo = se;
  function ve(A, b, f) {
    return A >>> f;
  }
  nr.shr64_hi = ve;
  function Q(A, b, f) {
    var v = A << 32 - f | b >>> f;
    return v >>> 0;
  }
  return nr.shr64_lo = Q, nr;
}
var Yf = {}, Rd;
function wa() {
  if (Rd)
    return Yf;
  Rd = 1;
  var r = dn(), e = Wr();
  function t() {
    this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
  }
  return Yf.BlockHash = t, t.prototype.update = function(a, i) {
    if (a = r.toArray(a, i), this.pending ? this.pending = this.pending.concat(a) : this.pending = a, this.pendingTotal += a.length, this.pending.length >= this._delta8) {
      a = this.pending;
      var o = a.length % this._delta8;
      this.pending = a.slice(a.length - o, a.length), this.pending.length === 0 && (this.pending = null), a = r.join32(a, 0, a.length - o, this.endian);
      for (var u = 0; u < a.length; u += this._delta32)
        this._update(a, u, u + this._delta32);
    }
    return this;
  }, t.prototype.digest = function(a) {
    return this.update(this._pad()), e(this.pending === null), this._digest(a);
  }, t.prototype._pad = function() {
    var a = this.pendingTotal, i = this._delta8, o = i - (a + this.padLength) % i, u = new Array(o + this.padLength);
    u[0] = 128;
    for (var c = 1; c < o; c++)
      u[c] = 0;
    if (a <<= 3, this.endian === "big") {
      for (var h = 8; h < this.padLength; h++)
        u[c++] = 0;
      u[c++] = 0, u[c++] = 0, u[c++] = 0, u[c++] = 0, u[c++] = a >>> 24 & 255, u[c++] = a >>> 16 & 255, u[c++] = a >>> 8 & 255, u[c++] = a & 255;
    } else
      for (u[c++] = a & 255, u[c++] = a >>> 8 & 255, u[c++] = a >>> 16 & 255, u[c++] = a >>> 24 & 255, u[c++] = 0, u[c++] = 0, u[c++] = 0, u[c++] = 0, h = 8; h < this.padLength; h++)
        u[c++] = 0;
    return u;
  }, Yf;
}
var Gn = {}, an = {}, Cd;
function V1() {
  if (Cd)
    return an;
  Cd = 1;
  var r = dn(), e = r.rotr32;
  function t(s, d, l, y) {
    if (s === 0)
      return n(d, l, y);
    if (s === 1 || s === 3)
      return i(d, l, y);
    if (s === 2)
      return a(d, l, y);
  }
  an.ft_1 = t;
  function n(s, d, l) {
    return s & d ^ ~s & l;
  }
  an.ch32 = n;
  function a(s, d, l) {
    return s & d ^ s & l ^ d & l;
  }
  an.maj32 = a;
  function i(s, d, l) {
    return s ^ d ^ l;
  }
  an.p32 = i;
  function o(s) {
    return e(s, 2) ^ e(s, 13) ^ e(s, 22);
  }
  an.s0_256 = o;
  function u(s) {
    return e(s, 6) ^ e(s, 11) ^ e(s, 25);
  }
  an.s1_256 = u;
  function c(s) {
    return e(s, 7) ^ e(s, 18) ^ s >>> 3;
  }
  an.g0_256 = c;
  function h(s) {
    return e(s, 17) ^ e(s, 19) ^ s >>> 10;
  }
  return an.g1_256 = h, an;
}
var Xf, Od;
function d3() {
  if (Od)
    return Xf;
  Od = 1;
  var r = dn(), e = wa(), t = V1(), n = r.rotl32, a = r.sum32, i = r.sum32_5, o = t.ft_1, u = e.BlockHash, c = [
    1518500249,
    1859775393,
    2400959708,
    3395469782
  ];
  function h() {
    if (!(this instanceof h))
      return new h();
    u.call(this), this.h = [
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ], this.W = new Array(80);
  }
  return r.inherits(h, u), Xf = h, h.blockSize = 512, h.outSize = 160, h.hmacStrength = 80, h.padLength = 64, h.prototype._update = function(d, l) {
    for (var y = this.W, m = 0; m < 16; m++)
      y[m] = d[l + m];
    for (; m < y.length; m++)
      y[m] = n(y[m - 3] ^ y[m - 8] ^ y[m - 14] ^ y[m - 16], 1);
    var w = this.h[0], E = this.h[1], S = this.h[2], P = this.h[3], L = this.h[4];
    for (m = 0; m < y.length; m++) {
      var U = ~~(m / 20), z = i(n(w, 5), o(U, E, S, P), L, y[m], c[U]);
      L = P, P = S, S = n(E, 30), E = w, w = z;
    }
    this.h[0] = a(this.h[0], w), this.h[1] = a(this.h[1], E), this.h[2] = a(this.h[2], S), this.h[3] = a(this.h[3], P), this.h[4] = a(this.h[4], L);
  }, h.prototype._digest = function(d) {
    return d === "hex" ? r.toHex32(this.h, "big") : r.split32(this.h, "big");
  }, Xf;
}
var Zf, Bd;
function W1() {
  if (Bd)
    return Zf;
  Bd = 1;
  var r = dn(), e = wa(), t = V1(), n = Wr(), a = r.sum32, i = r.sum32_4, o = r.sum32_5, u = t.ch32, c = t.maj32, h = t.s0_256, s = t.s1_256, d = t.g0_256, l = t.g1_256, y = e.BlockHash, m = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ];
  function w() {
    if (!(this instanceof w))
      return new w();
    y.call(this), this.h = [
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ], this.k = m, this.W = new Array(64);
  }
  return r.inherits(w, y), Zf = w, w.blockSize = 512, w.outSize = 256, w.hmacStrength = 192, w.padLength = 64, w.prototype._update = function(S, P) {
    for (var L = this.W, U = 0; U < 16; U++)
      L[U] = S[P + U];
    for (; U < L.length; U++)
      L[U] = i(l(L[U - 2]), L[U - 7], d(L[U - 15]), L[U - 16]);
    var z = this.h[0], K = this.h[1], re = this.h[2], oe = this.h[3], se = this.h[4], ve = this.h[5], Q = this.h[6], A = this.h[7];
    for (n(this.k.length === L.length), U = 0; U < L.length; U++) {
      var b = o(A, s(se), u(se, ve, Q), this.k[U], L[U]), f = a(h(z), c(z, K, re));
      A = Q, Q = ve, ve = se, se = a(oe, b), oe = re, re = K, K = z, z = a(b, f);
    }
    this.h[0] = a(this.h[0], z), this.h[1] = a(this.h[1], K), this.h[2] = a(this.h[2], re), this.h[3] = a(this.h[3], oe), this.h[4] = a(this.h[4], se), this.h[5] = a(this.h[5], ve), this.h[6] = a(this.h[6], Q), this.h[7] = a(this.h[7], A);
  }, w.prototype._digest = function(S) {
    return S === "hex" ? r.toHex32(this.h, "big") : r.split32(this.h, "big");
  }, Zf;
}
var eu, Pd;
function p3() {
  if (Pd)
    return eu;
  Pd = 1;
  var r = dn(), e = W1();
  function t() {
    if (!(this instanceof t))
      return new t();
    e.call(this), this.h = [
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ];
  }
  return r.inherits(t, e), eu = t, t.blockSize = 512, t.outSize = 224, t.hmacStrength = 192, t.padLength = 64, t.prototype._digest = function(a) {
    return a === "hex" ? r.toHex32(this.h.slice(0, 7), "big") : r.split32(this.h.slice(0, 7), "big");
  }, eu;
}
var tu, Dd;
function K1() {
  if (Dd)
    return tu;
  Dd = 1;
  var r = dn(), e = wa(), t = Wr(), n = r.rotr64_hi, a = r.rotr64_lo, i = r.shr64_hi, o = r.shr64_lo, u = r.sum64, c = r.sum64_hi, h = r.sum64_lo, s = r.sum64_4_hi, d = r.sum64_4_lo, l = r.sum64_5_hi, y = r.sum64_5_lo, m = e.BlockHash, w = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ];
  function E() {
    if (!(this instanceof E))
      return new E();
    m.call(this), this.h = [
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ], this.k = w, this.W = new Array(160);
  }
  r.inherits(E, m), tu = E, E.blockSize = 1024, E.outSize = 512, E.hmacStrength = 192, E.padLength = 128, E.prototype._prepareBlock = function(f, v) {
    for (var g = this.W, M = 0; M < 32; M++)
      g[M] = f[v + M];
    for (; M < g.length; M += 2) {
      var I = Q(g[M - 4], g[M - 3]), R = A(g[M - 4], g[M - 3]), x = g[M - 14], T = g[M - 13], p = se(g[M - 30], g[M - 29]), B = ve(g[M - 30], g[M - 29]), ee = g[M - 32], ae = g[M - 31];
      g[M] = s(
        I,
        R,
        x,
        T,
        p,
        B,
        ee,
        ae
      ), g[M + 1] = d(
        I,
        R,
        x,
        T,
        p,
        B,
        ee,
        ae
      );
    }
  }, E.prototype._update = function(f, v) {
    this._prepareBlock(f, v);
    var g = this.W, M = this.h[0], I = this.h[1], R = this.h[2], x = this.h[3], T = this.h[4], p = this.h[5], B = this.h[6], ee = this.h[7], ae = this.h[8], Z = this.h[9], ne = this.h[10], fe = this.h[11], le = this.h[12], ke = this.h[13], X = this.h[14], G = this.h[15];
    t(this.k.length === g.length);
    for (var we = 0; we < g.length; we += 2) {
      var Ae = X, Oe = G, qe = re(ae, Z), Ue = oe(ae, Z), ze = S(ae, Z, ne, fe, le), ge = P(ae, Z, ne, fe, le, ke), ht = this.k[we], $e = this.k[we + 1], Et = g[we], ot = g[we + 1], Ve = l(
        Ae,
        Oe,
        qe,
        Ue,
        ze,
        ge,
        ht,
        $e,
        Et,
        ot
      ), Mt = y(
        Ae,
        Oe,
        qe,
        Ue,
        ze,
        ge,
        ht,
        $e,
        Et,
        ot
      );
      Ae = z(M, I), Oe = K(M, I), qe = L(M, I, R, x, T), Ue = U(M, I, R, x, T, p);
      var lt = c(Ae, Oe, qe, Ue), Xe = h(Ae, Oe, qe, Ue);
      X = le, G = ke, le = ne, ke = fe, ne = ae, fe = Z, ae = c(B, ee, Ve, Mt), Z = h(ee, ee, Ve, Mt), B = T, ee = p, T = R, p = x, R = M, x = I, M = c(Ve, Mt, lt, Xe), I = h(Ve, Mt, lt, Xe);
    }
    u(this.h, 0, M, I), u(this.h, 2, R, x), u(this.h, 4, T, p), u(this.h, 6, B, ee), u(this.h, 8, ae, Z), u(this.h, 10, ne, fe), u(this.h, 12, le, ke), u(this.h, 14, X, G);
  }, E.prototype._digest = function(f) {
    return f === "hex" ? r.toHex32(this.h, "big") : r.split32(this.h, "big");
  };
  function S(b, f, v, g, M) {
    var I = b & v ^ ~b & M;
    return I < 0 && (I += 4294967296), I;
  }
  function P(b, f, v, g, M, I) {
    var R = f & g ^ ~f & I;
    return R < 0 && (R += 4294967296), R;
  }
  function L(b, f, v, g, M) {
    var I = b & v ^ b & M ^ v & M;
    return I < 0 && (I += 4294967296), I;
  }
  function U(b, f, v, g, M, I) {
    var R = f & g ^ f & I ^ g & I;
    return R < 0 && (R += 4294967296), R;
  }
  function z(b, f) {
    var v = n(b, f, 28), g = n(f, b, 2), M = n(f, b, 7), I = v ^ g ^ M;
    return I < 0 && (I += 4294967296), I;
  }
  function K(b, f) {
    var v = a(b, f, 28), g = a(f, b, 2), M = a(f, b, 7), I = v ^ g ^ M;
    return I < 0 && (I += 4294967296), I;
  }
  function re(b, f) {
    var v = n(b, f, 14), g = n(b, f, 18), M = n(f, b, 9), I = v ^ g ^ M;
    return I < 0 && (I += 4294967296), I;
  }
  function oe(b, f) {
    var v = a(b, f, 14), g = a(b, f, 18), M = a(f, b, 9), I = v ^ g ^ M;
    return I < 0 && (I += 4294967296), I;
  }
  function se(b, f) {
    var v = n(b, f, 1), g = n(b, f, 8), M = i(b, f, 7), I = v ^ g ^ M;
    return I < 0 && (I += 4294967296), I;
  }
  function ve(b, f) {
    var v = a(b, f, 1), g = a(b, f, 8), M = o(b, f, 7), I = v ^ g ^ M;
    return I < 0 && (I += 4294967296), I;
  }
  function Q(b, f) {
    var v = n(b, f, 19), g = n(f, b, 29), M = i(b, f, 6), I = v ^ g ^ M;
    return I < 0 && (I += 4294967296), I;
  }
  function A(b, f) {
    var v = a(b, f, 19), g = a(f, b, 29), M = o(b, f, 6), I = v ^ g ^ M;
    return I < 0 && (I += 4294967296), I;
  }
  return tu;
}
var ru, Nd;
function v3() {
  if (Nd)
    return ru;
  Nd = 1;
  var r = dn(), e = K1();
  function t() {
    if (!(this instanceof t))
      return new t();
    e.call(this), this.h = [
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ];
  }
  return r.inherits(t, e), ru = t, t.blockSize = 1024, t.outSize = 384, t.hmacStrength = 192, t.padLength = 128, t.prototype._digest = function(a) {
    return a === "hex" ? r.toHex32(this.h.slice(0, 12), "big") : r.split32(this.h.slice(0, 12), "big");
  }, ru;
}
var qd;
function y3() {
  return qd || (qd = 1, Gn.sha1 = d3(), Gn.sha224 = p3(), Gn.sha256 = W1(), Gn.sha384 = v3(), Gn.sha512 = K1()), Gn;
}
var nu = {}, Ld;
function b3() {
  if (Ld)
    return nu;
  Ld = 1;
  var r = dn(), e = wa(), t = r.rotl32, n = r.sum32, a = r.sum32_3, i = r.sum32_4, o = e.BlockHash;
  function u() {
    if (!(this instanceof u))
      return new u();
    o.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
  }
  r.inherits(u, o), nu.ripemd160 = u, u.blockSize = 512, u.outSize = 160, u.hmacStrength = 192, u.padLength = 64, u.prototype._update = function(E, S) {
    for (var P = this.h[0], L = this.h[1], U = this.h[2], z = this.h[3], K = this.h[4], re = P, oe = L, se = U, ve = z, Q = K, A = 0; A < 80; A++) {
      var b = n(
        t(
          i(P, c(A, L, U, z), E[d[A] + S], h(A)),
          y[A]
        ),
        K
      );
      P = K, K = z, z = t(U, 10), U = L, L = b, b = n(
        t(
          i(re, c(79 - A, oe, se, ve), E[l[A] + S], s(A)),
          m[A]
        ),
        Q
      ), re = Q, Q = ve, ve = t(se, 10), se = oe, oe = b;
    }
    b = a(this.h[1], U, ve), this.h[1] = a(this.h[2], z, Q), this.h[2] = a(this.h[3], K, re), this.h[3] = a(this.h[4], P, oe), this.h[4] = a(this.h[0], L, se), this.h[0] = b;
  }, u.prototype._digest = function(E) {
    return E === "hex" ? r.toHex32(this.h, "little") : r.split32(this.h, "little");
  };
  function c(w, E, S, P) {
    return w <= 15 ? E ^ S ^ P : w <= 31 ? E & S | ~E & P : w <= 47 ? (E | ~S) ^ P : w <= 63 ? E & P | S & ~P : E ^ (S | ~P);
  }
  function h(w) {
    return w <= 15 ? 0 : w <= 31 ? 1518500249 : w <= 47 ? 1859775393 : w <= 63 ? 2400959708 : 2840853838;
  }
  function s(w) {
    return w <= 15 ? 1352829926 : w <= 31 ? 1548603684 : w <= 47 ? 1836072691 : w <= 63 ? 2053994217 : 0;
  }
  var d = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], l = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], y = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], m = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ];
  return nu;
}
var iu, Fd;
function m3() {
  if (Fd)
    return iu;
  Fd = 1;
  var r = dn(), e = Wr();
  function t(n, a, i) {
    if (!(this instanceof t))
      return new t(n, a, i);
    this.Hash = n, this.blockSize = n.blockSize / 8, this.outSize = n.outSize / 8, this.inner = null, this.outer = null, this._init(r.toArray(a, i));
  }
  return iu = t, t.prototype._init = function(a) {
    a.length > this.blockSize && (a = new this.Hash().update(a).digest()), e(a.length <= this.blockSize);
    for (var i = a.length; i < this.blockSize; i++)
      a.push(0);
    for (i = 0; i < a.length; i++)
      a[i] ^= 54;
    for (this.inner = new this.Hash().update(a), i = 0; i < a.length; i++)
      a[i] ^= 106;
    this.outer = new this.Hash().update(a);
  }, t.prototype.update = function(a, i) {
    return this.inner.update(a, i), this;
  }, t.prototype.digest = function(a) {
    return this.outer.update(this.inner.digest()), this.outer.digest(a);
  }, iu;
}
var Ud;
function oh() {
  return Ud || (Ud = 1, function(r) {
    var e = r;
    e.utils = dn(), e.common = wa(), e.sha = y3(), e.ripemd = b3(), e.hmac = m3(), e.sha1 = e.sha.sha1, e.sha256 = e.sha.sha256, e.sha224 = e.sha.sha224, e.sha384 = e.sha.sha384, e.sha512 = e.sha.sha512, e.ripemd160 = e.ripemd.ripemd160;
  }(Jf)), Jf;
}
var au, $d;
function g3() {
  return $d || ($d = 1, au = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), au;
}
var jd;
function sh() {
  return jd || (jd = 1, function(r) {
    var e = r, t = oh(), n = z1(), a = Kr(), i = a.assert;
    function o(h) {
      h.type === "short" ? this.curve = new n.short(h) : h.type === "edwards" ? this.curve = new n.edwards(h) : this.curve = new n.mont(h), this.g = this.curve.g, this.n = this.curve.n, this.hash = h.hash, i(this.g.validate(), "Invalid curve"), i(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    e.PresetCurve = o;
    function u(h, s) {
      Object.defineProperty(e, h, {
        configurable: !0,
        enumerable: !0,
        get: function() {
          var d = new o(s);
          return Object.defineProperty(e, h, {
            configurable: !0,
            enumerable: !0,
            value: d
          }), d;
        }
      });
    }
    u("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: t.sha256,
      gRed: !1,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    }), u("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: t.sha256,
      gRed: !1,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    }), u("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: t.sha256,
      gRed: !1,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    }), u("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: t.sha384,
      gRed: !1,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    }), u("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: t.sha512,
      gRed: !1,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    }), u("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: t.sha256,
      gRed: !1,
      g: [
        "9"
      ]
    }), u("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: t.sha256,
      gRed: !1,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var c;
    try {
      c = g3();
    } catch (h) {
      c = void 0;
    }
    u("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: t.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: !1,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        c
      ]
    });
  }(Gf)), Gf;
}
var ou, Hd;
function w3() {
  if (Hd)
    return ou;
  Hd = 1;
  var r = oh(), e = H1(), t = Wr();
  function n(a) {
    if (!(this instanceof n))
      return new n(a);
    this.hash = a.hash, this.predResist = !!a.predResist, this.outLen = this.hash.outSize, this.minEntropy = a.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
    var i = e.toArray(a.entropy, a.entropyEnc || "hex"), o = e.toArray(a.nonce, a.nonceEnc || "hex"), u = e.toArray(a.pers, a.persEnc || "hex");
    t(
      i.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    ), this._init(i, o, u);
  }
  return ou = n, n.prototype._init = function(i, o, u) {
    var c = i.concat(o).concat(u);
    this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
    for (var h = 0; h < this.V.length; h++)
      this.K[h] = 0, this.V[h] = 1;
    this._update(c), this._reseed = 1, this.reseedInterval = 281474976710656;
  }, n.prototype._hmac = function() {
    return new r.hmac(this.hash, this.K);
  }, n.prototype._update = function(i) {
    var o = this._hmac().update(this.V).update([0]);
    i && (o = o.update(i)), this.K = o.digest(), this.V = this._hmac().update(this.V).digest(), i && (this.K = this._hmac().update(this.V).update([1]).update(i).digest(), this.V = this._hmac().update(this.V).digest());
  }, n.prototype.reseed = function(i, o, u, c) {
    typeof o != "string" && (c = u, u = o, o = null), i = e.toArray(i, o), u = e.toArray(u, c), t(
      i.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    ), this._update(i.concat(u || [])), this._reseed = 1;
  }, n.prototype.generate = function(i, o, u, c) {
    if (this._reseed > this.reseedInterval)
      throw new Error("Reseed is required");
    typeof o != "string" && (c = u, u = o, o = null), u && (u = e.toArray(u, c || "hex"), this._update(u));
    for (var h = []; h.length < i; )
      this.V = this._hmac().update(this.V).digest(), h = h.concat(this.V);
    var s = h.slice(0, i);
    return this._update(u), this._reseed++, e.encode(s, o);
  }, ou;
}
var su, zd;
function _3() {
  if (zd)
    return su;
  zd = 1;
  var r = Ir(), e = Kr(), t = e.assert;
  function n(a, i) {
    this.ec = a, this.priv = null, this.pub = null, i.priv && this._importPrivate(i.priv, i.privEnc), i.pub && this._importPublic(i.pub, i.pubEnc);
  }
  return su = n, n.fromPublic = function(i, o, u) {
    return o instanceof n ? o : new n(i, {
      pub: o,
      pubEnc: u
    });
  }, n.fromPrivate = function(i, o, u) {
    return o instanceof n ? o : new n(i, {
      priv: o,
      privEnc: u
    });
  }, n.prototype.validate = function() {
    var i = this.getPublic();
    return i.isInfinity() ? { result: !1, reason: "Invalid public key" } : i.validate() ? i.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
  }, n.prototype.getPublic = function(i, o) {
    return typeof i == "string" && (o = i, i = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), o ? this.pub.encode(o, i) : this.pub;
  }, n.prototype.getPrivate = function(i) {
    return i === "hex" ? this.priv.toString(16, 2) : this.priv;
  }, n.prototype._importPrivate = function(i, o) {
    this.priv = new r(i, o || 16), this.priv = this.priv.umod(this.ec.curve.n);
  }, n.prototype._importPublic = function(i, o) {
    if (i.x || i.y) {
      this.ec.curve.type === "mont" ? t(i.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && t(i.x && i.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(i.x, i.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(i, o);
  }, n.prototype.derive = function(i) {
    return i.validate() || t(i.validate(), "public point not validated"), i.mul(this.priv).getX();
  }, n.prototype.sign = function(i, o, u) {
    return this.ec.sign(i, this, o, u);
  }, n.prototype.verify = function(i, o) {
    return this.ec.verify(i, o, this);
  }, n.prototype.inspect = function() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
  }, su;
}
var fu, Vd;
function x3() {
  if (Vd)
    return fu;
  Vd = 1;
  var r = Ir(), e = Kr(), t = e.assert;
  function n(c, h) {
    if (c instanceof n)
      return c;
    this._importDER(c, h) || (t(c.r && c.s, "Signature without r or s"), this.r = new r(c.r, 16), this.s = new r(c.s, 16), c.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = c.recoveryParam);
  }
  fu = n;
  function a() {
    this.place = 0;
  }
  function i(c, h) {
    var s = c[h.place++];
    if (!(s & 128))
      return s;
    var d = s & 15;
    if (d === 0 || d > 4)
      return !1;
    for (var l = 0, y = 0, m = h.place; y < d; y++, m++)
      l <<= 8, l |= c[m], l >>>= 0;
    return l <= 127 ? !1 : (h.place = m, l);
  }
  function o(c) {
    for (var h = 0, s = c.length - 1; !c[h] && !(c[h + 1] & 128) && h < s; )
      h++;
    return h === 0 ? c : c.slice(h);
  }
  n.prototype._importDER = function(h, s) {
    h = e.toArray(h, s);
    var d = new a();
    if (h[d.place++] !== 48)
      return !1;
    var l = i(h, d);
    if (l === !1 || l + d.place !== h.length || h[d.place++] !== 2)
      return !1;
    var y = i(h, d);
    if (y === !1)
      return !1;
    var m = h.slice(d.place, y + d.place);
    if (d.place += y, h[d.place++] !== 2)
      return !1;
    var w = i(h, d);
    if (w === !1 || h.length !== w + d.place)
      return !1;
    var E = h.slice(d.place, w + d.place);
    if (m[0] === 0)
      if (m[1] & 128)
        m = m.slice(1);
      else
        return !1;
    if (E[0] === 0)
      if (E[1] & 128)
        E = E.slice(1);
      else
        return !1;
    return this.r = new r(m), this.s = new r(E), this.recoveryParam = null, !0;
  };
  function u(c, h) {
    if (h < 128) {
      c.push(h);
      return;
    }
    var s = 1 + (Math.log(h) / Math.LN2 >>> 3);
    for (c.push(s | 128); --s; )
      c.push(h >>> (s << 3) & 255);
    c.push(h);
  }
  return n.prototype.toDER = function(h) {
    var s = this.r.toArray(), d = this.s.toArray();
    for (s[0] & 128 && (s = [0].concat(s)), d[0] & 128 && (d = [0].concat(d)), s = o(s), d = o(d); !d[0] && !(d[1] & 128); )
      d = d.slice(1);
    var l = [2];
    u(l, s.length), l = l.concat(s), l.push(2), u(l, d.length);
    var y = l.concat(d), m = [48];
    return u(m, y.length), m = m.concat(y), e.encode(m, h);
  }, fu;
}
var uu, Wd;
function S3() {
  if (Wd)
    return uu;
  Wd = 1;
  var r = Ir(), e = w3(), t = Kr(), n = sh(), a = ih(), i = t.assert, o = _3(), u = x3();
  function c(h) {
    if (!(this instanceof c))
      return new c(h);
    typeof h == "string" && (i(
      Object.prototype.hasOwnProperty.call(n, h),
      "Unknown curve " + h
    ), h = n[h]), h instanceof n.PresetCurve && (h = { curve: h }), this.curve = h.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = h.curve.g, this.g.precompute(h.curve.n.bitLength() + 1), this.hash = h.hash || h.curve.hash;
  }
  return uu = c, c.prototype.keyPair = function(s) {
    return new o(this, s);
  }, c.prototype.keyFromPrivate = function(s, d) {
    return o.fromPrivate(this, s, d);
  }, c.prototype.keyFromPublic = function(s, d) {
    return o.fromPublic(this, s, d);
  }, c.prototype.genKeyPair = function(s) {
    s || (s = {});
    for (var d = new e({
      hash: this.hash,
      pers: s.pers,
      persEnc: s.persEnc || "utf8",
      entropy: s.entropy || a(this.hash.hmacStrength),
      entropyEnc: s.entropy && s.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), l = this.n.byteLength(), y = this.n.sub(new r(2)); ; ) {
      var m = new r(d.generate(l));
      if (!(m.cmp(y) > 0))
        return m.iaddn(1), this.keyFromPrivate(m);
    }
  }, c.prototype._truncateToN = function(s, d) {
    var l = s.byteLength() * 8 - this.n.bitLength();
    return l > 0 && (s = s.ushrn(l)), !d && s.cmp(this.n) >= 0 ? s.sub(this.n) : s;
  }, c.prototype.sign = function(s, d, l, y) {
    typeof l == "object" && (y = l, l = null), y || (y = {}), d = this.keyFromPrivate(d, l), s = this._truncateToN(new r(s, 16));
    for (var m = this.n.byteLength(), w = d.getPrivate().toArray("be", m), E = s.toArray("be", m), S = new e({
      hash: this.hash,
      entropy: w,
      nonce: E,
      pers: y.pers,
      persEnc: y.persEnc || "utf8"
    }), P = this.n.sub(new r(1)), L = 0; ; L++) {
      var U = y.k ? y.k(L) : new r(S.generate(this.n.byteLength()));
      if (U = this._truncateToN(U, !0), !(U.cmpn(1) <= 0 || U.cmp(P) >= 0)) {
        var z = this.g.mul(U);
        if (!z.isInfinity()) {
          var K = z.getX(), re = K.umod(this.n);
          if (re.cmpn(0) !== 0) {
            var oe = U.invm(this.n).mul(re.mul(d.getPrivate()).iadd(s));
            if (oe = oe.umod(this.n), oe.cmpn(0) !== 0) {
              var se = (z.getY().isOdd() ? 1 : 0) | (K.cmp(re) !== 0 ? 2 : 0);
              return y.canonical && oe.cmp(this.nh) > 0 && (oe = this.n.sub(oe), se ^= 1), new u({ r: re, s: oe, recoveryParam: se });
            }
          }
        }
      }
    }
  }, c.prototype.verify = function(s, d, l, y) {
    s = this._truncateToN(new r(s, 16)), l = this.keyFromPublic(l, y), d = new u(d, "hex");
    var m = d.r, w = d.s;
    if (m.cmpn(1) < 0 || m.cmp(this.n) >= 0 || w.cmpn(1) < 0 || w.cmp(this.n) >= 0)
      return !1;
    var E = w.invm(this.n), S = E.mul(s).umod(this.n), P = E.mul(m).umod(this.n), L;
    return this.curve._maxwellTrick ? (L = this.g.jmulAdd(S, l.getPublic(), P), L.isInfinity() ? !1 : L.eqXToP(m)) : (L = this.g.mulAdd(S, l.getPublic(), P), L.isInfinity() ? !1 : L.getX().umod(this.n).cmp(m) === 0);
  }, c.prototype.recoverPubKey = function(h, s, d, l) {
    i((3 & d) === d, "The recovery param is more than two bits"), s = new u(s, l);
    var y = this.n, m = new r(h), w = s.r, E = s.s, S = d & 1, P = d >> 1;
    if (w.cmp(this.curve.p.umod(this.curve.n)) >= 0 && P)
      throw new Error("Unable to find sencond key candinate");
    P ? w = this.curve.pointFromX(w.add(this.curve.n), S) : w = this.curve.pointFromX(w, S);
    var L = s.r.invm(y), U = y.sub(m).mul(L).umod(y), z = E.mul(L).umod(y);
    return this.g.mulAdd(U, w, z);
  }, c.prototype.getKeyRecoveryParam = function(h, s, d, l) {
    if (s = new u(s, l), s.recoveryParam !== null)
      return s.recoveryParam;
    for (var y = 0; y < 4; y++) {
      var m;
      try {
        m = this.recoverPubKey(h, s, y);
      } catch (w) {
        continue;
      }
      if (m.eq(d))
        return y;
    }
    throw new Error("Unable to find valid recovery factor");
  }, uu;
}
var cu, Kd;
function E3() {
  if (Kd)
    return cu;
  Kd = 1;
  var r = Kr(), e = r.assert, t = r.parseBytes, n = r.cachedProperty;
  function a(i, o) {
    this.eddsa = i, this._secret = t(o.secret), i.isPoint(o.pub) ? this._pub = o.pub : this._pubBytes = t(o.pub);
  }
  return a.fromPublic = function(o, u) {
    return u instanceof a ? u : new a(o, { pub: u });
  }, a.fromSecret = function(o, u) {
    return u instanceof a ? u : new a(o, { secret: u });
  }, a.prototype.secret = function() {
    return this._secret;
  }, n(a, "pubBytes", function() {
    return this.eddsa.encodePoint(this.pub());
  }), n(a, "pub", function() {
    return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
  }), n(a, "privBytes", function() {
    var o = this.eddsa, u = this.hash(), c = o.encodingLength - 1, h = u.slice(0, o.encodingLength);
    return h[0] &= 248, h[c] &= 127, h[c] |= 64, h;
  }), n(a, "priv", function() {
    return this.eddsa.decodeInt(this.privBytes());
  }), n(a, "hash", function() {
    return this.eddsa.hash().update(this.secret()).digest();
  }), n(a, "messagePrefix", function() {
    return this.hash().slice(this.eddsa.encodingLength);
  }), a.prototype.sign = function(o) {
    return e(this._secret, "KeyPair can only verify"), this.eddsa.sign(o, this);
  }, a.prototype.verify = function(o, u) {
    return this.eddsa.verify(o, u, this);
  }, a.prototype.getSecret = function(o) {
    return e(this._secret, "KeyPair is public only"), r.encode(this.secret(), o);
  }, a.prototype.getPublic = function(o) {
    return r.encode(this.pubBytes(), o);
  }, cu = a, cu;
}
var hu, Qd;
function M3() {
  if (Qd)
    return hu;
  Qd = 1;
  var r = Ir(), e = Kr(), t = e.assert, n = e.cachedProperty, a = e.parseBytes;
  function i(o, u) {
    this.eddsa = o, typeof u != "object" && (u = a(u)), Array.isArray(u) && (u = {
      R: u.slice(0, o.encodingLength),
      S: u.slice(o.encodingLength)
    }), t(u.R && u.S, "Signature without R or S"), o.isPoint(u.R) && (this._R = u.R), u.S instanceof r && (this._S = u.S), this._Rencoded = Array.isArray(u.R) ? u.R : u.Rencoded, this._Sencoded = Array.isArray(u.S) ? u.S : u.Sencoded;
  }
  return n(i, "S", function() {
    return this.eddsa.decodeInt(this.Sencoded());
  }), n(i, "R", function() {
    return this.eddsa.decodePoint(this.Rencoded());
  }), n(i, "Rencoded", function() {
    return this.eddsa.encodePoint(this.R());
  }), n(i, "Sencoded", function() {
    return this.eddsa.encodeInt(this.S());
  }), i.prototype.toBytes = function() {
    return this.Rencoded().concat(this.Sencoded());
  }, i.prototype.toHex = function() {
    return e.encode(this.toBytes(), "hex").toUpperCase();
  }, hu = i, hu;
}
var lu, Gd;
function A3() {
  if (Gd)
    return lu;
  Gd = 1;
  var r = oh(), e = sh(), t = Kr(), n = t.assert, a = t.parseBytes, i = E3(), o = M3();
  function u(c) {
    if (n(c === "ed25519", "only tested with ed25519 so far"), !(this instanceof u))
      return new u(c);
    c = e[c].curve, this.curve = c, this.g = c.g, this.g.precompute(c.n.bitLength() + 1), this.pointClass = c.point().constructor, this.encodingLength = Math.ceil(c.n.bitLength() / 8), this.hash = r.sha512;
  }
  return lu = u, u.prototype.sign = function(h, s) {
    h = a(h);
    var d = this.keyFromSecret(s), l = this.hashInt(d.messagePrefix(), h), y = this.g.mul(l), m = this.encodePoint(y), w = this.hashInt(m, d.pubBytes(), h).mul(d.priv()), E = l.add(w).umod(this.curve.n);
    return this.makeSignature({ R: y, S: E, Rencoded: m });
  }, u.prototype.verify = function(h, s, d) {
    h = a(h), s = this.makeSignature(s);
    var l = this.keyFromPublic(d), y = this.hashInt(s.Rencoded(), l.pubBytes(), h), m = this.g.mul(s.S()), w = s.R().add(l.pub().mul(y));
    return w.eq(m);
  }, u.prototype.hashInt = function() {
    for (var h = this.hash(), s = 0; s < arguments.length; s++)
      h.update(arguments[s]);
    return t.intFromLE(h.digest()).umod(this.curve.n);
  }, u.prototype.keyFromPublic = function(h) {
    return i.fromPublic(this, h);
  }, u.prototype.keyFromSecret = function(h) {
    return i.fromSecret(this, h);
  }, u.prototype.makeSignature = function(h) {
    return h instanceof o ? h : new o(this, h);
  }, u.prototype.encodePoint = function(h) {
    var s = h.getY().toArray("le", this.encodingLength);
    return s[this.encodingLength - 1] |= h.getX().isOdd() ? 128 : 0, s;
  }, u.prototype.decodePoint = function(h) {
    h = t.parseBytes(h);
    var s = h.length - 1, d = h.slice(0, s).concat(h[s] & -129), l = (h[s] & 128) !== 0, y = t.intFromLE(d);
    return this.curve.pointFromY(y, l);
  }, u.prototype.encodeInt = function(h) {
    return h.toArray("le", this.encodingLength);
  }, u.prototype.decodeInt = function(h) {
    return t.intFromLE(h);
  }, u.prototype.isPoint = function(h) {
    return h instanceof this.pointClass;
  }, lu;
}
var Jd;
function fh() {
  return Jd || (Jd = 1, function(r) {
    var e = r;
    e.version = u3.version, e.utils = Kr(), e.rand = ih(), e.curve = z1(), e.curves = sh(), e.ec = S3(), e.eddsa = A3();
  }($f)), $f;
}
var eo = { exports: {} };
eo.exports;
var Yd;
function Q1() {
  return Yd || (Yd = 1, function(r) {
    (function(e, t) {
      function n(b, f) {
        if (!b)
          throw new Error(f || "Assertion failed");
      }
      function a(b, f) {
        b.super_ = f;
        var v = function() {
        };
        v.prototype = f.prototype, b.prototype = new v(), b.prototype.constructor = b;
      }
      function i(b, f, v) {
        if (i.isBN(b))
          return b;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, b !== null && ((f === "le" || f === "be") && (v = f, f = 10), this._init(b || 0, f || 10, v || "be"));
      }
      typeof e == "object" ? e.exports = i : t.BN = i, i.BN = i, i.wordSize = 26;
      var o;
      try {
        typeof window != "undefined" && typeof window.Buffer != "undefined" ? o = window.Buffer : o = Mn.Buffer;
      } catch (b) {
      }
      i.isBN = function(f) {
        return f instanceof i ? !0 : f !== null && typeof f == "object" && f.constructor.wordSize === i.wordSize && Array.isArray(f.words);
      }, i.max = function(f, v) {
        return f.cmp(v) > 0 ? f : v;
      }, i.min = function(f, v) {
        return f.cmp(v) < 0 ? f : v;
      }, i.prototype._init = function(f, v, g) {
        if (typeof f == "number")
          return this._initNumber(f, v, g);
        if (typeof f == "object")
          return this._initArray(f, v, g);
        v === "hex" && (v = 16), n(v === (v | 0) && v >= 2 && v <= 36), f = f.toString().replace(/\s+/g, "");
        var M = 0;
        f[0] === "-" && (M++, this.negative = 1), M < f.length && (v === 16 ? this._parseHex(f, M, g) : (this._parseBase(f, v, M), g === "le" && this._initArray(this.toArray(), v, g)));
      }, i.prototype._initNumber = function(f, v, g) {
        f < 0 && (this.negative = 1, f = -f), f < 67108864 ? (this.words = [f & 67108863], this.length = 1) : f < 4503599627370496 ? (this.words = [
          f & 67108863,
          f / 67108864 & 67108863
        ], this.length = 2) : (n(f < 9007199254740992), this.words = [
          f & 67108863,
          f / 67108864 & 67108863,
          1
        ], this.length = 3), g === "le" && this._initArray(this.toArray(), v, g);
      }, i.prototype._initArray = function(f, v, g) {
        if (n(typeof f.length == "number"), f.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(f.length / 3), this.words = new Array(this.length);
        for (var M = 0; M < this.length; M++)
          this.words[M] = 0;
        var I, R, x = 0;
        if (g === "be")
          for (M = f.length - 1, I = 0; M >= 0; M -= 3)
            R = f[M] | f[M - 1] << 8 | f[M - 2] << 16, this.words[I] |= R << x & 67108863, this.words[I + 1] = R >>> 26 - x & 67108863, x += 24, x >= 26 && (x -= 26, I++);
        else if (g === "le")
          for (M = 0, I = 0; M < f.length; M += 3)
            R = f[M] | f[M + 1] << 8 | f[M + 2] << 16, this.words[I] |= R << x & 67108863, this.words[I + 1] = R >>> 26 - x & 67108863, x += 24, x >= 26 && (x -= 26, I++);
        return this._strip();
      };
      function u(b, f) {
        var v = b.charCodeAt(f);
        if (v >= 48 && v <= 57)
          return v - 48;
        if (v >= 65 && v <= 70)
          return v - 55;
        if (v >= 97 && v <= 102)
          return v - 87;
        n(!1, "Invalid character in " + b);
      }
      function c(b, f, v) {
        var g = u(b, v);
        return v - 1 >= f && (g |= u(b, v - 1) << 4), g;
      }
      i.prototype._parseHex = function(f, v, g) {
        this.length = Math.ceil((f.length - v) / 6), this.words = new Array(this.length);
        for (var M = 0; M < this.length; M++)
          this.words[M] = 0;
        var I = 0, R = 0, x;
        if (g === "be")
          for (M = f.length - 1; M >= v; M -= 2)
            x = c(f, v, M) << I, this.words[R] |= x & 67108863, I >= 18 ? (I -= 18, R += 1, this.words[R] |= x >>> 26) : I += 8;
        else {
          var T = f.length - v;
          for (M = T % 2 === 0 ? v + 1 : v; M < f.length; M += 2)
            x = c(f, v, M) << I, this.words[R] |= x & 67108863, I >= 18 ? (I -= 18, R += 1, this.words[R] |= x >>> 26) : I += 8;
        }
        this._strip();
      };
      function h(b, f, v, g) {
        for (var M = 0, I = 0, R = Math.min(b.length, v), x = f; x < R; x++) {
          var T = b.charCodeAt(x) - 48;
          M *= g, T >= 49 ? I = T - 49 + 10 : T >= 17 ? I = T - 17 + 10 : I = T, n(T >= 0 && I < g, "Invalid character"), M += I;
        }
        return M;
      }
      i.prototype._parseBase = function(f, v, g) {
        this.words = [0], this.length = 1;
        for (var M = 0, I = 1; I <= 67108863; I *= v)
          M++;
        M--, I = I / v | 0;
        for (var R = f.length - g, x = R % M, T = Math.min(R, R - x) + g, p = 0, B = g; B < T; B += M)
          p = h(f, B, B + M, v), this.imuln(I), this.words[0] + p < 67108864 ? this.words[0] += p : this._iaddn(p);
        if (x !== 0) {
          var ee = 1;
          for (p = h(f, B, f.length, v), B = 0; B < x; B++)
            ee *= v;
          this.imuln(ee), this.words[0] + p < 67108864 ? this.words[0] += p : this._iaddn(p);
        }
        this._strip();
      }, i.prototype.copy = function(f) {
        f.words = new Array(this.length);
        for (var v = 0; v < this.length; v++)
          f.words[v] = this.words[v];
        f.length = this.length, f.negative = this.negative, f.red = this.red;
      };
      function s(b, f) {
        b.words = f.words, b.length = f.length, b.negative = f.negative, b.red = f.red;
      }
      if (i.prototype._move = function(f) {
        s(f, this);
      }, i.prototype.clone = function() {
        var f = new i(null);
        return this.copy(f), f;
      }, i.prototype._expand = function(f) {
        for (; this.length < f; )
          this.words[this.length++] = 0;
        return this;
      }, i.prototype._strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, i.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, typeof Symbol != "undefined" && typeof Symbol.for == "function")
        try {
          i.prototype[Symbol.for("nodejs.util.inspect.custom")] = d;
        } catch (b) {
          i.prototype.inspect = d;
        }
      else
        i.prototype.inspect = d;
      function d() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var l = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], y = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], m = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      i.prototype.toString = function(f, v) {
        f = f || 10, v = v | 0 || 1;
        var g;
        if (f === 16 || f === "hex") {
          g = "";
          for (var M = 0, I = 0, R = 0; R < this.length; R++) {
            var x = this.words[R], T = ((x << M | I) & 16777215).toString(16);
            I = x >>> 24 - M & 16777215, M += 2, M >= 26 && (M -= 26, R--), I !== 0 || R !== this.length - 1 ? g = l[6 - T.length] + T + g : g = T + g;
          }
          for (I !== 0 && (g = I.toString(16) + g); g.length % v !== 0; )
            g = "0" + g;
          return this.negative !== 0 && (g = "-" + g), g;
        }
        if (f === (f | 0) && f >= 2 && f <= 36) {
          var p = y[f], B = m[f];
          g = "";
          var ee = this.clone();
          for (ee.negative = 0; !ee.isZero(); ) {
            var ae = ee.modrn(B).toString(f);
            ee = ee.idivn(B), ee.isZero() ? g = ae + g : g = l[p - ae.length] + ae + g;
          }
          for (this.isZero() && (g = "0" + g); g.length % v !== 0; )
            g = "0" + g;
          return this.negative !== 0 && (g = "-" + g), g;
        }
        n(!1, "Base should be between 2 and 36");
      }, i.prototype.toNumber = function() {
        var f = this.words[0];
        return this.length === 2 ? f += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? f += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -f : f;
      }, i.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, o && (i.prototype.toBuffer = function(f, v) {
        return this.toArrayLike(o, f, v);
      }), i.prototype.toArray = function(f, v) {
        return this.toArrayLike(Array, f, v);
      };
      var w = function(f, v) {
        return f.allocUnsafe ? f.allocUnsafe(v) : new f(v);
      };
      i.prototype.toArrayLike = function(f, v, g) {
        this._strip();
        var M = this.byteLength(), I = g || Math.max(1, M);
        n(M <= I, "byte array longer than desired length"), n(I > 0, "Requested array length <= 0");
        var R = w(f, I), x = v === "le" ? "LE" : "BE";
        return this["_toArrayLike" + x](R, M), R;
      }, i.prototype._toArrayLikeLE = function(f, v) {
        for (var g = 0, M = 0, I = 0, R = 0; I < this.length; I++) {
          var x = this.words[I] << R | M;
          f[g++] = x & 255, g < f.length && (f[g++] = x >> 8 & 255), g < f.length && (f[g++] = x >> 16 & 255), R === 6 ? (g < f.length && (f[g++] = x >> 24 & 255), M = 0, R = 0) : (M = x >>> 24, R += 2);
        }
        if (g < f.length)
          for (f[g++] = M; g < f.length; )
            f[g++] = 0;
      }, i.prototype._toArrayLikeBE = function(f, v) {
        for (var g = f.length - 1, M = 0, I = 0, R = 0; I < this.length; I++) {
          var x = this.words[I] << R | M;
          f[g--] = x & 255, g >= 0 && (f[g--] = x >> 8 & 255), g >= 0 && (f[g--] = x >> 16 & 255), R === 6 ? (g >= 0 && (f[g--] = x >> 24 & 255), M = 0, R = 0) : (M = x >>> 24, R += 2);
        }
        if (g >= 0)
          for (f[g--] = M; g >= 0; )
            f[g--] = 0;
      }, Math.clz32 ? i.prototype._countBits = function(f) {
        return 32 - Math.clz32(f);
      } : i.prototype._countBits = function(f) {
        var v = f, g = 0;
        return v >= 4096 && (g += 13, v >>>= 13), v >= 64 && (g += 7, v >>>= 7), v >= 8 && (g += 4, v >>>= 4), v >= 2 && (g += 2, v >>>= 2), g + v;
      }, i.prototype._zeroBits = function(f) {
        if (f === 0)
          return 26;
        var v = f, g = 0;
        return v & 8191 || (g += 13, v >>>= 13), v & 127 || (g += 7, v >>>= 7), v & 15 || (g += 4, v >>>= 4), v & 3 || (g += 2, v >>>= 2), v & 1 || g++, g;
      }, i.prototype.bitLength = function() {
        var f = this.words[this.length - 1], v = this._countBits(f);
        return (this.length - 1) * 26 + v;
      };
      function E(b) {
        for (var f = new Array(b.bitLength()), v = 0; v < f.length; v++) {
          var g = v / 26 | 0, M = v % 26;
          f[v] = b.words[g] >>> M & 1;
        }
        return f;
      }
      i.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var f = 0, v = 0; v < this.length; v++) {
          var g = this._zeroBits(this.words[v]);
          if (f += g, g !== 26)
            break;
        }
        return f;
      }, i.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, i.prototype.toTwos = function(f) {
        return this.negative !== 0 ? this.abs().inotn(f).iaddn(1) : this.clone();
      }, i.prototype.fromTwos = function(f) {
        return this.testn(f - 1) ? this.notn(f).iaddn(1).ineg() : this.clone();
      }, i.prototype.isNeg = function() {
        return this.negative !== 0;
      }, i.prototype.neg = function() {
        return this.clone().ineg();
      }, i.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, i.prototype.iuor = function(f) {
        for (; this.length < f.length; )
          this.words[this.length++] = 0;
        for (var v = 0; v < f.length; v++)
          this.words[v] = this.words[v] | f.words[v];
        return this._strip();
      }, i.prototype.ior = function(f) {
        return n((this.negative | f.negative) === 0), this.iuor(f);
      }, i.prototype.or = function(f) {
        return this.length > f.length ? this.clone().ior(f) : f.clone().ior(this);
      }, i.prototype.uor = function(f) {
        return this.length > f.length ? this.clone().iuor(f) : f.clone().iuor(this);
      }, i.prototype.iuand = function(f) {
        var v;
        this.length > f.length ? v = f : v = this;
        for (var g = 0; g < v.length; g++)
          this.words[g] = this.words[g] & f.words[g];
        return this.length = v.length, this._strip();
      }, i.prototype.iand = function(f) {
        return n((this.negative | f.negative) === 0), this.iuand(f);
      }, i.prototype.and = function(f) {
        return this.length > f.length ? this.clone().iand(f) : f.clone().iand(this);
      }, i.prototype.uand = function(f) {
        return this.length > f.length ? this.clone().iuand(f) : f.clone().iuand(this);
      }, i.prototype.iuxor = function(f) {
        var v, g;
        this.length > f.length ? (v = this, g = f) : (v = f, g = this);
        for (var M = 0; M < g.length; M++)
          this.words[M] = v.words[M] ^ g.words[M];
        if (this !== v)
          for (; M < v.length; M++)
            this.words[M] = v.words[M];
        return this.length = v.length, this._strip();
      }, i.prototype.ixor = function(f) {
        return n((this.negative | f.negative) === 0), this.iuxor(f);
      }, i.prototype.xor = function(f) {
        return this.length > f.length ? this.clone().ixor(f) : f.clone().ixor(this);
      }, i.prototype.uxor = function(f) {
        return this.length > f.length ? this.clone().iuxor(f) : f.clone().iuxor(this);
      }, i.prototype.inotn = function(f) {
        n(typeof f == "number" && f >= 0);
        var v = Math.ceil(f / 26) | 0, g = f % 26;
        this._expand(v), g > 0 && v--;
        for (var M = 0; M < v; M++)
          this.words[M] = ~this.words[M] & 67108863;
        return g > 0 && (this.words[M] = ~this.words[M] & 67108863 >> 26 - g), this._strip();
      }, i.prototype.notn = function(f) {
        return this.clone().inotn(f);
      }, i.prototype.setn = function(f, v) {
        n(typeof f == "number" && f >= 0);
        var g = f / 26 | 0, M = f % 26;
        return this._expand(g + 1), v ? this.words[g] = this.words[g] | 1 << M : this.words[g] = this.words[g] & ~(1 << M), this._strip();
      }, i.prototype.iadd = function(f) {
        var v;
        if (this.negative !== 0 && f.negative === 0)
          return this.negative = 0, v = this.isub(f), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && f.negative !== 0)
          return f.negative = 0, v = this.isub(f), f.negative = 1, v._normSign();
        var g, M;
        this.length > f.length ? (g = this, M = f) : (g = f, M = this);
        for (var I = 0, R = 0; R < M.length; R++)
          v = (g.words[R] | 0) + (M.words[R] | 0) + I, this.words[R] = v & 67108863, I = v >>> 26;
        for (; I !== 0 && R < g.length; R++)
          v = (g.words[R] | 0) + I, this.words[R] = v & 67108863, I = v >>> 26;
        if (this.length = g.length, I !== 0)
          this.words[this.length] = I, this.length++;
        else if (g !== this)
          for (; R < g.length; R++)
            this.words[R] = g.words[R];
        return this;
      }, i.prototype.add = function(f) {
        var v;
        return f.negative !== 0 && this.negative === 0 ? (f.negative = 0, v = this.sub(f), f.negative ^= 1, v) : f.negative === 0 && this.negative !== 0 ? (this.negative = 0, v = f.sub(this), this.negative = 1, v) : this.length > f.length ? this.clone().iadd(f) : f.clone().iadd(this);
      }, i.prototype.isub = function(f) {
        if (f.negative !== 0) {
          f.negative = 0;
          var v = this.iadd(f);
          return f.negative = 1, v._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(f), this.negative = 1, this._normSign();
        var g = this.cmp(f);
        if (g === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var M, I;
        g > 0 ? (M = this, I = f) : (M = f, I = this);
        for (var R = 0, x = 0; x < I.length; x++)
          v = (M.words[x] | 0) - (I.words[x] | 0) + R, R = v >> 26, this.words[x] = v & 67108863;
        for (; R !== 0 && x < M.length; x++)
          v = (M.words[x] | 0) + R, R = v >> 26, this.words[x] = v & 67108863;
        if (R === 0 && x < M.length && M !== this)
          for (; x < M.length; x++)
            this.words[x] = M.words[x];
        return this.length = Math.max(this.length, x), M !== this && (this.negative = 1), this._strip();
      }, i.prototype.sub = function(f) {
        return this.clone().isub(f);
      };
      function S(b, f, v) {
        v.negative = f.negative ^ b.negative;
        var g = b.length + f.length | 0;
        v.length = g, g = g - 1 | 0;
        var M = b.words[0] | 0, I = f.words[0] | 0, R = M * I, x = R & 67108863, T = R / 67108864 | 0;
        v.words[0] = x;
        for (var p = 1; p < g; p++) {
          for (var B = T >>> 26, ee = T & 67108863, ae = Math.min(p, f.length - 1), Z = Math.max(0, p - b.length + 1); Z <= ae; Z++) {
            var ne = p - Z | 0;
            M = b.words[ne] | 0, I = f.words[Z] | 0, R = M * I + ee, B += R / 67108864 | 0, ee = R & 67108863;
          }
          v.words[p] = ee | 0, T = B | 0;
        }
        return T !== 0 ? v.words[p] = T | 0 : v.length--, v._strip();
      }
      var P = function(f, v, g) {
        var M = f.words, I = v.words, R = g.words, x = 0, T, p, B, ee = M[0] | 0, ae = ee & 8191, Z = ee >>> 13, ne = M[1] | 0, fe = ne & 8191, le = ne >>> 13, ke = M[2] | 0, X = ke & 8191, G = ke >>> 13, we = M[3] | 0, Ae = we & 8191, Oe = we >>> 13, qe = M[4] | 0, Ue = qe & 8191, ze = qe >>> 13, ge = M[5] | 0, ht = ge & 8191, $e = ge >>> 13, Et = M[6] | 0, ot = Et & 8191, Ve = Et >>> 13, Mt = M[7] | 0, lt = Mt & 8191, Xe = Mt >>> 13, st = M[8] | 0, gt = st & 8191, W = st >>> 13, q = M[9] | 0, F = q & 8191, J = q >>> 13, he = I[0] | 0, de = he & 8191, pe = he >>> 13, Je = I[1] | 0, tt = Je & 8191, Ne = Je >>> 13, St = I[2] | 0, rt = St & 8191, dt = St >>> 13, Zt = I[3] | 0, bt = Zt & 8191, at = Zt >>> 13, jt = I[4] | 0, _t = jt & 8191, ft = jt >>> 13, Yt = I[5] | 0, kt = Yt & 8191, Ze = Yt >>> 13, Ht = I[6] | 0, j = Ht & 8191, N = Ht >>> 13, D = I[7] | 0, _ = D & 8191, $ = D >>> 13, Y = I[8] | 0, ie = Y & 8191, ce = Y >>> 13, me = I[9] | 0, Me = me & 8191, Se = me >>> 13;
        g.negative = f.negative ^ v.negative, g.length = 19, T = Math.imul(ae, de), p = Math.imul(ae, pe), p = p + Math.imul(Z, de) | 0, B = Math.imul(Z, pe);
        var Ge = (x + T | 0) + ((p & 8191) << 13) | 0;
        x = (B + (p >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, T = Math.imul(fe, de), p = Math.imul(fe, pe), p = p + Math.imul(le, de) | 0, B = Math.imul(le, pe), T = T + Math.imul(ae, tt) | 0, p = p + Math.imul(ae, Ne) | 0, p = p + Math.imul(Z, tt) | 0, B = B + Math.imul(Z, Ne) | 0;
        var Be = (x + T | 0) + ((p & 8191) << 13) | 0;
        x = (B + (p >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, T = Math.imul(X, de), p = Math.imul(X, pe), p = p + Math.imul(G, de) | 0, B = Math.imul(G, pe), T = T + Math.imul(fe, tt) | 0, p = p + Math.imul(fe, Ne) | 0, p = p + Math.imul(le, tt) | 0, B = B + Math.imul(le, Ne) | 0, T = T + Math.imul(ae, rt) | 0, p = p + Math.imul(ae, dt) | 0, p = p + Math.imul(Z, rt) | 0, B = B + Math.imul(Z, dt) | 0;
        var Ye = (x + T | 0) + ((p & 8191) << 13) | 0;
        x = (B + (p >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, T = Math.imul(Ae, de), p = Math.imul(Ae, pe), p = p + Math.imul(Oe, de) | 0, B = Math.imul(Oe, pe), T = T + Math.imul(X, tt) | 0, p = p + Math.imul(X, Ne) | 0, p = p + Math.imul(G, tt) | 0, B = B + Math.imul(G, Ne) | 0, T = T + Math.imul(fe, rt) | 0, p = p + Math.imul(fe, dt) | 0, p = p + Math.imul(le, rt) | 0, B = B + Math.imul(le, dt) | 0, T = T + Math.imul(ae, bt) | 0, p = p + Math.imul(ae, at) | 0, p = p + Math.imul(Z, bt) | 0, B = B + Math.imul(Z, at) | 0;
        var Pe = (x + T | 0) + ((p & 8191) << 13) | 0;
        x = (B + (p >>> 13) | 0) + (Pe >>> 26) | 0, Pe &= 67108863, T = Math.imul(Ue, de), p = Math.imul(Ue, pe), p = p + Math.imul(ze, de) | 0, B = Math.imul(ze, pe), T = T + Math.imul(Ae, tt) | 0, p = p + Math.imul(Ae, Ne) | 0, p = p + Math.imul(Oe, tt) | 0, B = B + Math.imul(Oe, Ne) | 0, T = T + Math.imul(X, rt) | 0, p = p + Math.imul(X, dt) | 0, p = p + Math.imul(G, rt) | 0, B = B + Math.imul(G, dt) | 0, T = T + Math.imul(fe, bt) | 0, p = p + Math.imul(fe, at) | 0, p = p + Math.imul(le, bt) | 0, B = B + Math.imul(le, at) | 0, T = T + Math.imul(ae, _t) | 0, p = p + Math.imul(ae, ft) | 0, p = p + Math.imul(Z, _t) | 0, B = B + Math.imul(Z, ft) | 0;
        var et = (x + T | 0) + ((p & 8191) << 13) | 0;
        x = (B + (p >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, T = Math.imul(ht, de), p = Math.imul(ht, pe), p = p + Math.imul($e, de) | 0, B = Math.imul($e, pe), T = T + Math.imul(Ue, tt) | 0, p = p + Math.imul(Ue, Ne) | 0, p = p + Math.imul(ze, tt) | 0, B = B + Math.imul(ze, Ne) | 0, T = T + Math.imul(Ae, rt) | 0, p = p + Math.imul(Ae, dt) | 0, p = p + Math.imul(Oe, rt) | 0, B = B + Math.imul(Oe, dt) | 0, T = T + Math.imul(X, bt) | 0, p = p + Math.imul(X, at) | 0, p = p + Math.imul(G, bt) | 0, B = B + Math.imul(G, at) | 0, T = T + Math.imul(fe, _t) | 0, p = p + Math.imul(fe, ft) | 0, p = p + Math.imul(le, _t) | 0, B = B + Math.imul(le, ft) | 0, T = T + Math.imul(ae, kt) | 0, p = p + Math.imul(ae, Ze) | 0, p = p + Math.imul(Z, kt) | 0, B = B + Math.imul(Z, Ze) | 0;
        var nt = (x + T | 0) + ((p & 8191) << 13) | 0;
        x = (B + (p >>> 13) | 0) + (nt >>> 26) | 0, nt &= 67108863, T = Math.imul(ot, de), p = Math.imul(ot, pe), p = p + Math.imul(Ve, de) | 0, B = Math.imul(Ve, pe), T = T + Math.imul(ht, tt) | 0, p = p + Math.imul(ht, Ne) | 0, p = p + Math.imul($e, tt) | 0, B = B + Math.imul($e, Ne) | 0, T = T + Math.imul(Ue, rt) | 0, p = p + Math.imul(Ue, dt) | 0, p = p + Math.imul(ze, rt) | 0, B = B + Math.imul(ze, dt) | 0, T = T + Math.imul(Ae, bt) | 0, p = p + Math.imul(Ae, at) | 0, p = p + Math.imul(Oe, bt) | 0, B = B + Math.imul(Oe, at) | 0, T = T + Math.imul(X, _t) | 0, p = p + Math.imul(X, ft) | 0, p = p + Math.imul(G, _t) | 0, B = B + Math.imul(G, ft) | 0, T = T + Math.imul(fe, kt) | 0, p = p + Math.imul(fe, Ze) | 0, p = p + Math.imul(le, kt) | 0, B = B + Math.imul(le, Ze) | 0, T = T + Math.imul(ae, j) | 0, p = p + Math.imul(ae, N) | 0, p = p + Math.imul(Z, j) | 0, B = B + Math.imul(Z, N) | 0;
        var Qe = (x + T | 0) + ((p & 8191) << 13) | 0;
        x = (B + (p >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, T = Math.imul(lt, de), p = Math.imul(lt, pe), p = p + Math.imul(Xe, de) | 0, B = Math.imul(Xe, pe), T = T + Math.imul(ot, tt) | 0, p = p + Math.imul(ot, Ne) | 0, p = p + Math.imul(Ve, tt) | 0, B = B + Math.imul(Ve, Ne) | 0, T = T + Math.imul(ht, rt) | 0, p = p + Math.imul(ht, dt) | 0, p = p + Math.imul($e, rt) | 0, B = B + Math.imul($e, dt) | 0, T = T + Math.imul(Ue, bt) | 0, p = p + Math.imul(Ue, at) | 0, p = p + Math.imul(ze, bt) | 0, B = B + Math.imul(ze, at) | 0, T = T + Math.imul(Ae, _t) | 0, p = p + Math.imul(Ae, ft) | 0, p = p + Math.imul(Oe, _t) | 0, B = B + Math.imul(Oe, ft) | 0, T = T + Math.imul(X, kt) | 0, p = p + Math.imul(X, Ze) | 0, p = p + Math.imul(G, kt) | 0, B = B + Math.imul(G, Ze) | 0, T = T + Math.imul(fe, j) | 0, p = p + Math.imul(fe, N) | 0, p = p + Math.imul(le, j) | 0, B = B + Math.imul(le, N) | 0, T = T + Math.imul(ae, _) | 0, p = p + Math.imul(ae, $) | 0, p = p + Math.imul(Z, _) | 0, B = B + Math.imul(Z, $) | 0;
        var pt = (x + T | 0) + ((p & 8191) << 13) | 0;
        x = (B + (p >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, T = Math.imul(gt, de), p = Math.imul(gt, pe), p = p + Math.imul(W, de) | 0, B = Math.imul(W, pe), T = T + Math.imul(lt, tt) | 0, p = p + Math.imul(lt, Ne) | 0, p = p + Math.imul(Xe, tt) | 0, B = B + Math.imul(Xe, Ne) | 0, T = T + Math.imul(ot, rt) | 0, p = p + Math.imul(ot, dt) | 0, p = p + Math.imul(Ve, rt) | 0, B = B + Math.imul(Ve, dt) | 0, T = T + Math.imul(ht, bt) | 0, p = p + Math.imul(ht, at) | 0, p = p + Math.imul($e, bt) | 0, B = B + Math.imul($e, at) | 0, T = T + Math.imul(Ue, _t) | 0, p = p + Math.imul(Ue, ft) | 0, p = p + Math.imul(ze, _t) | 0, B = B + Math.imul(ze, ft) | 0, T = T + Math.imul(Ae, kt) | 0, p = p + Math.imul(Ae, Ze) | 0, p = p + Math.imul(Oe, kt) | 0, B = B + Math.imul(Oe, Ze) | 0, T = T + Math.imul(X, j) | 0, p = p + Math.imul(X, N) | 0, p = p + Math.imul(G, j) | 0, B = B + Math.imul(G, N) | 0, T = T + Math.imul(fe, _) | 0, p = p + Math.imul(fe, $) | 0, p = p + Math.imul(le, _) | 0, B = B + Math.imul(le, $) | 0, T = T + Math.imul(ae, ie) | 0, p = p + Math.imul(ae, ce) | 0, p = p + Math.imul(Z, ie) | 0, B = B + Math.imul(Z, ce) | 0;
        var ut = (x + T | 0) + ((p & 8191) << 13) | 0;
        x = (B + (p >>> 13) | 0) + (ut >>> 26) | 0, ut &= 67108863, T = Math.imul(F, de), p = Math.imul(F, pe), p = p + Math.imul(J, de) | 0, B = Math.imul(J, pe), T = T + Math.imul(gt, tt) | 0, p = p + Math.imul(gt, Ne) | 0, p = p + Math.imul(W, tt) | 0, B = B + Math.imul(W, Ne) | 0, T = T + Math.imul(lt, rt) | 0, p = p + Math.imul(lt, dt) | 0, p = p + Math.imul(Xe, rt) | 0, B = B + Math.imul(Xe, dt) | 0, T = T + Math.imul(ot, bt) | 0, p = p + Math.imul(ot, at) | 0, p = p + Math.imul(Ve, bt) | 0, B = B + Math.imul(Ve, at) | 0, T = T + Math.imul(ht, _t) | 0, p = p + Math.imul(ht, ft) | 0, p = p + Math.imul($e, _t) | 0, B = B + Math.imul($e, ft) | 0, T = T + Math.imul(Ue, kt) | 0, p = p + Math.imul(Ue, Ze) | 0, p = p + Math.imul(ze, kt) | 0, B = B + Math.imul(ze, Ze) | 0, T = T + Math.imul(Ae, j) | 0, p = p + Math.imul(Ae, N) | 0, p = p + Math.imul(Oe, j) | 0, B = B + Math.imul(Oe, N) | 0, T = T + Math.imul(X, _) | 0, p = p + Math.imul(X, $) | 0, p = p + Math.imul(G, _) | 0, B = B + Math.imul(G, $) | 0, T = T + Math.imul(fe, ie) | 0, p = p + Math.imul(fe, ce) | 0, p = p + Math.imul(le, ie) | 0, B = B + Math.imul(le, ce) | 0, T = T + Math.imul(ae, Me) | 0, p = p + Math.imul(ae, Se) | 0, p = p + Math.imul(Z, Me) | 0, B = B + Math.imul(Z, Se) | 0;
        var Le = (x + T | 0) + ((p & 8191) << 13) | 0;
        x = (B + (p >>> 13) | 0) + (Le >>> 26) | 0, Le &= 67108863, T = Math.imul(F, tt), p = Math.imul(F, Ne), p = p + Math.imul(J, tt) | 0, B = Math.imul(J, Ne), T = T + Math.imul(gt, rt) | 0, p = p + Math.imul(gt, dt) | 0, p = p + Math.imul(W, rt) | 0, B = B + Math.imul(W, dt) | 0, T = T + Math.imul(lt, bt) | 0, p = p + Math.imul(lt, at) | 0, p = p + Math.imul(Xe, bt) | 0, B = B + Math.imul(Xe, at) | 0, T = T + Math.imul(ot, _t) | 0, p = p + Math.imul(ot, ft) | 0, p = p + Math.imul(Ve, _t) | 0, B = B + Math.imul(Ve, ft) | 0, T = T + Math.imul(ht, kt) | 0, p = p + Math.imul(ht, Ze) | 0, p = p + Math.imul($e, kt) | 0, B = B + Math.imul($e, Ze) | 0, T = T + Math.imul(Ue, j) | 0, p = p + Math.imul(Ue, N) | 0, p = p + Math.imul(ze, j) | 0, B = B + Math.imul(ze, N) | 0, T = T + Math.imul(Ae, _) | 0, p = p + Math.imul(Ae, $) | 0, p = p + Math.imul(Oe, _) | 0, B = B + Math.imul(Oe, $) | 0, T = T + Math.imul(X, ie) | 0, p = p + Math.imul(X, ce) | 0, p = p + Math.imul(G, ie) | 0, B = B + Math.imul(G, ce) | 0, T = T + Math.imul(fe, Me) | 0, p = p + Math.imul(fe, Se) | 0, p = p + Math.imul(le, Me) | 0, B = B + Math.imul(le, Se) | 0;
        var it = (x + T | 0) + ((p & 8191) << 13) | 0;
        x = (B + (p >>> 13) | 0) + (it >>> 26) | 0, it &= 67108863, T = Math.imul(F, rt), p = Math.imul(F, dt), p = p + Math.imul(J, rt) | 0, B = Math.imul(J, dt), T = T + Math.imul(gt, bt) | 0, p = p + Math.imul(gt, at) | 0, p = p + Math.imul(W, bt) | 0, B = B + Math.imul(W, at) | 0, T = T + Math.imul(lt, _t) | 0, p = p + Math.imul(lt, ft) | 0, p = p + Math.imul(Xe, _t) | 0, B = B + Math.imul(Xe, ft) | 0, T = T + Math.imul(ot, kt) | 0, p = p + Math.imul(ot, Ze) | 0, p = p + Math.imul(Ve, kt) | 0, B = B + Math.imul(Ve, Ze) | 0, T = T + Math.imul(ht, j) | 0, p = p + Math.imul(ht, N) | 0, p = p + Math.imul($e, j) | 0, B = B + Math.imul($e, N) | 0, T = T + Math.imul(Ue, _) | 0, p = p + Math.imul(Ue, $) | 0, p = p + Math.imul(ze, _) | 0, B = B + Math.imul(ze, $) | 0, T = T + Math.imul(Ae, ie) | 0, p = p + Math.imul(Ae, ce) | 0, p = p + Math.imul(Oe, ie) | 0, B = B + Math.imul(Oe, ce) | 0, T = T + Math.imul(X, Me) | 0, p = p + Math.imul(X, Se) | 0, p = p + Math.imul(G, Me) | 0, B = B + Math.imul(G, Se) | 0;
        var je = (x + T | 0) + ((p & 8191) << 13) | 0;
        x = (B + (p >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, T = Math.imul(F, bt), p = Math.imul(F, at), p = p + Math.imul(J, bt) | 0, B = Math.imul(J, at), T = T + Math.imul(gt, _t) | 0, p = p + Math.imul(gt, ft) | 0, p = p + Math.imul(W, _t) | 0, B = B + Math.imul(W, ft) | 0, T = T + Math.imul(lt, kt) | 0, p = p + Math.imul(lt, Ze) | 0, p = p + Math.imul(Xe, kt) | 0, B = B + Math.imul(Xe, Ze) | 0, T = T + Math.imul(ot, j) | 0, p = p + Math.imul(ot, N) | 0, p = p + Math.imul(Ve, j) | 0, B = B + Math.imul(Ve, N) | 0, T = T + Math.imul(ht, _) | 0, p = p + Math.imul(ht, $) | 0, p = p + Math.imul($e, _) | 0, B = B + Math.imul($e, $) | 0, T = T + Math.imul(Ue, ie) | 0, p = p + Math.imul(Ue, ce) | 0, p = p + Math.imul(ze, ie) | 0, B = B + Math.imul(ze, ce) | 0, T = T + Math.imul(Ae, Me) | 0, p = p + Math.imul(Ae, Se) | 0, p = p + Math.imul(Oe, Me) | 0, B = B + Math.imul(Oe, Se) | 0;
        var He = (x + T | 0) + ((p & 8191) << 13) | 0;
        x = (B + (p >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, T = Math.imul(F, _t), p = Math.imul(F, ft), p = p + Math.imul(J, _t) | 0, B = Math.imul(J, ft), T = T + Math.imul(gt, kt) | 0, p = p + Math.imul(gt, Ze) | 0, p = p + Math.imul(W, kt) | 0, B = B + Math.imul(W, Ze) | 0, T = T + Math.imul(lt, j) | 0, p = p + Math.imul(lt, N) | 0, p = p + Math.imul(Xe, j) | 0, B = B + Math.imul(Xe, N) | 0, T = T + Math.imul(ot, _) | 0, p = p + Math.imul(ot, $) | 0, p = p + Math.imul(Ve, _) | 0, B = B + Math.imul(Ve, $) | 0, T = T + Math.imul(ht, ie) | 0, p = p + Math.imul(ht, ce) | 0, p = p + Math.imul($e, ie) | 0, B = B + Math.imul($e, ce) | 0, T = T + Math.imul(Ue, Me) | 0, p = p + Math.imul(Ue, Se) | 0, p = p + Math.imul(ze, Me) | 0, B = B + Math.imul(ze, Se) | 0;
        var We = (x + T | 0) + ((p & 8191) << 13) | 0;
        x = (B + (p >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, T = Math.imul(F, kt), p = Math.imul(F, Ze), p = p + Math.imul(J, kt) | 0, B = Math.imul(J, Ze), T = T + Math.imul(gt, j) | 0, p = p + Math.imul(gt, N) | 0, p = p + Math.imul(W, j) | 0, B = B + Math.imul(W, N) | 0, T = T + Math.imul(lt, _) | 0, p = p + Math.imul(lt, $) | 0, p = p + Math.imul(Xe, _) | 0, B = B + Math.imul(Xe, $) | 0, T = T + Math.imul(ot, ie) | 0, p = p + Math.imul(ot, ce) | 0, p = p + Math.imul(Ve, ie) | 0, B = B + Math.imul(Ve, ce) | 0, T = T + Math.imul(ht, Me) | 0, p = p + Math.imul(ht, Se) | 0, p = p + Math.imul($e, Me) | 0, B = B + Math.imul($e, Se) | 0;
        var Fe = (x + T | 0) + ((p & 8191) << 13) | 0;
        x = (B + (p >>> 13) | 0) + (Fe >>> 26) | 0, Fe &= 67108863, T = Math.imul(F, j), p = Math.imul(F, N), p = p + Math.imul(J, j) | 0, B = Math.imul(J, N), T = T + Math.imul(gt, _) | 0, p = p + Math.imul(gt, $) | 0, p = p + Math.imul(W, _) | 0, B = B + Math.imul(W, $) | 0, T = T + Math.imul(lt, ie) | 0, p = p + Math.imul(lt, ce) | 0, p = p + Math.imul(Xe, ie) | 0, B = B + Math.imul(Xe, ce) | 0, T = T + Math.imul(ot, Me) | 0, p = p + Math.imul(ot, Se) | 0, p = p + Math.imul(Ve, Me) | 0, B = B + Math.imul(Ve, Se) | 0;
        var ye = (x + T | 0) + ((p & 8191) << 13) | 0;
        x = (B + (p >>> 13) | 0) + (ye >>> 26) | 0, ye &= 67108863, T = Math.imul(F, _), p = Math.imul(F, $), p = p + Math.imul(J, _) | 0, B = Math.imul(J, $), T = T + Math.imul(gt, ie) | 0, p = p + Math.imul(gt, ce) | 0, p = p + Math.imul(W, ie) | 0, B = B + Math.imul(W, ce) | 0, T = T + Math.imul(lt, Me) | 0, p = p + Math.imul(lt, Se) | 0, p = p + Math.imul(Xe, Me) | 0, B = B + Math.imul(Xe, Se) | 0;
        var be = (x + T | 0) + ((p & 8191) << 13) | 0;
        x = (B + (p >>> 13) | 0) + (be >>> 26) | 0, be &= 67108863, T = Math.imul(F, ie), p = Math.imul(F, ce), p = p + Math.imul(J, ie) | 0, B = Math.imul(J, ce), T = T + Math.imul(gt, Me) | 0, p = p + Math.imul(gt, Se) | 0, p = p + Math.imul(W, Me) | 0, B = B + Math.imul(W, Se) | 0;
        var Re = (x + T | 0) + ((p & 8191) << 13) | 0;
        x = (B + (p >>> 13) | 0) + (Re >>> 26) | 0, Re &= 67108863, T = Math.imul(F, Me), p = Math.imul(F, Se), p = p + Math.imul(J, Me) | 0, B = Math.imul(J, Se);
        var Te = (x + T | 0) + ((p & 8191) << 13) | 0;
        return x = (B + (p >>> 13) | 0) + (Te >>> 26) | 0, Te &= 67108863, R[0] = Ge, R[1] = Be, R[2] = Ye, R[3] = Pe, R[4] = et, R[5] = nt, R[6] = Qe, R[7] = pt, R[8] = ut, R[9] = Le, R[10] = it, R[11] = je, R[12] = He, R[13] = We, R[14] = Fe, R[15] = ye, R[16] = be, R[17] = Re, R[18] = Te, x !== 0 && (R[19] = x, g.length++), g;
      };
      Math.imul || (P = S);
      function L(b, f, v) {
        v.negative = f.negative ^ b.negative, v.length = b.length + f.length;
        for (var g = 0, M = 0, I = 0; I < v.length - 1; I++) {
          var R = M;
          M = 0;
          for (var x = g & 67108863, T = Math.min(I, f.length - 1), p = Math.max(0, I - b.length + 1); p <= T; p++) {
            var B = I - p, ee = b.words[B] | 0, ae = f.words[p] | 0, Z = ee * ae, ne = Z & 67108863;
            R = R + (Z / 67108864 | 0) | 0, ne = ne + x | 0, x = ne & 67108863, R = R + (ne >>> 26) | 0, M += R >>> 26, R &= 67108863;
          }
          v.words[I] = x, g = R, R = M;
        }
        return g !== 0 ? v.words[I] = g : v.length--, v._strip();
      }
      function U(b, f, v) {
        return L(b, f, v);
      }
      i.prototype.mulTo = function(f, v) {
        var g, M = this.length + f.length;
        return this.length === 10 && f.length === 10 ? g = P(this, f, v) : M < 63 ? g = S(this, f, v) : M < 1024 ? g = L(this, f, v) : g = U(this, f, v), g;
      }, i.prototype.mul = function(f) {
        var v = new i(null);
        return v.words = new Array(this.length + f.length), this.mulTo(f, v);
      }, i.prototype.mulf = function(f) {
        var v = new i(null);
        return v.words = new Array(this.length + f.length), U(this, f, v);
      }, i.prototype.imul = function(f) {
        return this.clone().mulTo(f, this);
      }, i.prototype.imuln = function(f) {
        var v = f < 0;
        v && (f = -f), n(typeof f == "number"), n(f < 67108864);
        for (var g = 0, M = 0; M < this.length; M++) {
          var I = (this.words[M] | 0) * f, R = (I & 67108863) + (g & 67108863);
          g >>= 26, g += I / 67108864 | 0, g += R >>> 26, this.words[M] = R & 67108863;
        }
        return g !== 0 && (this.words[M] = g, this.length++), v ? this.ineg() : this;
      }, i.prototype.muln = function(f) {
        return this.clone().imuln(f);
      }, i.prototype.sqr = function() {
        return this.mul(this);
      }, i.prototype.isqr = function() {
        return this.imul(this.clone());
      }, i.prototype.pow = function(f) {
        var v = E(f);
        if (v.length === 0)
          return new i(1);
        for (var g = this, M = 0; M < v.length && v[M] === 0; M++, g = g.sqr())
          ;
        if (++M < v.length)
          for (var I = g.sqr(); M < v.length; M++, I = I.sqr())
            v[M] !== 0 && (g = g.mul(I));
        return g;
      }, i.prototype.iushln = function(f) {
        n(typeof f == "number" && f >= 0);
        var v = f % 26, g = (f - v) / 26, M = 67108863 >>> 26 - v << 26 - v, I;
        if (v !== 0) {
          var R = 0;
          for (I = 0; I < this.length; I++) {
            var x = this.words[I] & M, T = (this.words[I] | 0) - x << v;
            this.words[I] = T | R, R = x >>> 26 - v;
          }
          R && (this.words[I] = R, this.length++);
        }
        if (g !== 0) {
          for (I = this.length - 1; I >= 0; I--)
            this.words[I + g] = this.words[I];
          for (I = 0; I < g; I++)
            this.words[I] = 0;
          this.length += g;
        }
        return this._strip();
      }, i.prototype.ishln = function(f) {
        return n(this.negative === 0), this.iushln(f);
      }, i.prototype.iushrn = function(f, v, g) {
        n(typeof f == "number" && f >= 0);
        var M;
        v ? M = (v - v % 26) / 26 : M = 0;
        var I = f % 26, R = Math.min((f - I) / 26, this.length), x = 67108863 ^ 67108863 >>> I << I, T = g;
        if (M -= R, M = Math.max(0, M), T) {
          for (var p = 0; p < R; p++)
            T.words[p] = this.words[p];
          T.length = R;
        }
        if (R !== 0)
          if (this.length > R)
            for (this.length -= R, p = 0; p < this.length; p++)
              this.words[p] = this.words[p + R];
          else
            this.words[0] = 0, this.length = 1;
        var B = 0;
        for (p = this.length - 1; p >= 0 && (B !== 0 || p >= M); p--) {
          var ee = this.words[p] | 0;
          this.words[p] = B << 26 - I | ee >>> I, B = ee & x;
        }
        return T && B !== 0 && (T.words[T.length++] = B), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
      }, i.prototype.ishrn = function(f, v, g) {
        return n(this.negative === 0), this.iushrn(f, v, g);
      }, i.prototype.shln = function(f) {
        return this.clone().ishln(f);
      }, i.prototype.ushln = function(f) {
        return this.clone().iushln(f);
      }, i.prototype.shrn = function(f) {
        return this.clone().ishrn(f);
      }, i.prototype.ushrn = function(f) {
        return this.clone().iushrn(f);
      }, i.prototype.testn = function(f) {
        n(typeof f == "number" && f >= 0);
        var v = f % 26, g = (f - v) / 26, M = 1 << v;
        if (this.length <= g)
          return !1;
        var I = this.words[g];
        return !!(I & M);
      }, i.prototype.imaskn = function(f) {
        n(typeof f == "number" && f >= 0);
        var v = f % 26, g = (f - v) / 26;
        if (n(this.negative === 0, "imaskn works only with positive numbers"), this.length <= g)
          return this;
        if (v !== 0 && g++, this.length = Math.min(g, this.length), v !== 0) {
          var M = 67108863 ^ 67108863 >>> v << v;
          this.words[this.length - 1] &= M;
        }
        return this._strip();
      }, i.prototype.maskn = function(f) {
        return this.clone().imaskn(f);
      }, i.prototype.iaddn = function(f) {
        return n(typeof f == "number"), n(f < 67108864), f < 0 ? this.isubn(-f) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= f ? (this.words[0] = f - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(f), this.negative = 1, this) : this._iaddn(f);
      }, i.prototype._iaddn = function(f) {
        this.words[0] += f;
        for (var v = 0; v < this.length && this.words[v] >= 67108864; v++)
          this.words[v] -= 67108864, v === this.length - 1 ? this.words[v + 1] = 1 : this.words[v + 1]++;
        return this.length = Math.max(this.length, v + 1), this;
      }, i.prototype.isubn = function(f) {
        if (n(typeof f == "number"), n(f < 67108864), f < 0)
          return this.iaddn(-f);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(f), this.negative = 1, this;
        if (this.words[0] -= f, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var v = 0; v < this.length && this.words[v] < 0; v++)
            this.words[v] += 67108864, this.words[v + 1] -= 1;
        return this._strip();
      }, i.prototype.addn = function(f) {
        return this.clone().iaddn(f);
      }, i.prototype.subn = function(f) {
        return this.clone().isubn(f);
      }, i.prototype.iabs = function() {
        return this.negative = 0, this;
      }, i.prototype.abs = function() {
        return this.clone().iabs();
      }, i.prototype._ishlnsubmul = function(f, v, g) {
        var M = f.length + g, I;
        this._expand(M);
        var R, x = 0;
        for (I = 0; I < f.length; I++) {
          R = (this.words[I + g] | 0) + x;
          var T = (f.words[I] | 0) * v;
          R -= T & 67108863, x = (R >> 26) - (T / 67108864 | 0), this.words[I + g] = R & 67108863;
        }
        for (; I < this.length - g; I++)
          R = (this.words[I + g] | 0) + x, x = R >> 26, this.words[I + g] = R & 67108863;
        if (x === 0)
          return this._strip();
        for (n(x === -1), x = 0, I = 0; I < this.length; I++)
          R = -(this.words[I] | 0) + x, x = R >> 26, this.words[I] = R & 67108863;
        return this.negative = 1, this._strip();
      }, i.prototype._wordDiv = function(f, v) {
        var g = this.length - f.length, M = this.clone(), I = f, R = I.words[I.length - 1] | 0, x = this._countBits(R);
        g = 26 - x, g !== 0 && (I = I.ushln(g), M.iushln(g), R = I.words[I.length - 1] | 0);
        var T = M.length - I.length, p;
        if (v !== "mod") {
          p = new i(null), p.length = T + 1, p.words = new Array(p.length);
          for (var B = 0; B < p.length; B++)
            p.words[B] = 0;
        }
        var ee = M.clone()._ishlnsubmul(I, 1, T);
        ee.negative === 0 && (M = ee, p && (p.words[T] = 1));
        for (var ae = T - 1; ae >= 0; ae--) {
          var Z = (M.words[I.length + ae] | 0) * 67108864 + (M.words[I.length + ae - 1] | 0);
          for (Z = Math.min(Z / R | 0, 67108863), M._ishlnsubmul(I, Z, ae); M.negative !== 0; )
            Z--, M.negative = 0, M._ishlnsubmul(I, 1, ae), M.isZero() || (M.negative ^= 1);
          p && (p.words[ae] = Z);
        }
        return p && p._strip(), M._strip(), v !== "div" && g !== 0 && M.iushrn(g), {
          div: p || null,
          mod: M
        };
      }, i.prototype.divmod = function(f, v, g) {
        if (n(!f.isZero()), this.isZero())
          return {
            div: new i(0),
            mod: new i(0)
          };
        var M, I, R;
        return this.negative !== 0 && f.negative === 0 ? (R = this.neg().divmod(f, v), v !== "mod" && (M = R.div.neg()), v !== "div" && (I = R.mod.neg(), g && I.negative !== 0 && I.iadd(f)), {
          div: M,
          mod: I
        }) : this.negative === 0 && f.negative !== 0 ? (R = this.divmod(f.neg(), v), v !== "mod" && (M = R.div.neg()), {
          div: M,
          mod: R.mod
        }) : this.negative & f.negative ? (R = this.neg().divmod(f.neg(), v), v !== "div" && (I = R.mod.neg(), g && I.negative !== 0 && I.isub(f)), {
          div: R.div,
          mod: I
        }) : f.length > this.length || this.cmp(f) < 0 ? {
          div: new i(0),
          mod: this
        } : f.length === 1 ? v === "div" ? {
          div: this.divn(f.words[0]),
          mod: null
        } : v === "mod" ? {
          div: null,
          mod: new i(this.modrn(f.words[0]))
        } : {
          div: this.divn(f.words[0]),
          mod: new i(this.modrn(f.words[0]))
        } : this._wordDiv(f, v);
      }, i.prototype.div = function(f) {
        return this.divmod(f, "div", !1).div;
      }, i.prototype.mod = function(f) {
        return this.divmod(f, "mod", !1).mod;
      }, i.prototype.umod = function(f) {
        return this.divmod(f, "mod", !0).mod;
      }, i.prototype.divRound = function(f) {
        var v = this.divmod(f);
        if (v.mod.isZero())
          return v.div;
        var g = v.div.negative !== 0 ? v.mod.isub(f) : v.mod, M = f.ushrn(1), I = f.andln(1), R = g.cmp(M);
        return R < 0 || I === 1 && R === 0 ? v.div : v.div.negative !== 0 ? v.div.isubn(1) : v.div.iaddn(1);
      }, i.prototype.modrn = function(f) {
        var v = f < 0;
        v && (f = -f), n(f <= 67108863);
        for (var g = (1 << 26) % f, M = 0, I = this.length - 1; I >= 0; I--)
          M = (g * M + (this.words[I] | 0)) % f;
        return v ? -M : M;
      }, i.prototype.modn = function(f) {
        return this.modrn(f);
      }, i.prototype.idivn = function(f) {
        var v = f < 0;
        v && (f = -f), n(f <= 67108863);
        for (var g = 0, M = this.length - 1; M >= 0; M--) {
          var I = (this.words[M] | 0) + g * 67108864;
          this.words[M] = I / f | 0, g = I % f;
        }
        return this._strip(), v ? this.ineg() : this;
      }, i.prototype.divn = function(f) {
        return this.clone().idivn(f);
      }, i.prototype.egcd = function(f) {
        n(f.negative === 0), n(!f.isZero());
        var v = this, g = f.clone();
        v.negative !== 0 ? v = v.umod(f) : v = v.clone();
        for (var M = new i(1), I = new i(0), R = new i(0), x = new i(1), T = 0; v.isEven() && g.isEven(); )
          v.iushrn(1), g.iushrn(1), ++T;
        for (var p = g.clone(), B = v.clone(); !v.isZero(); ) {
          for (var ee = 0, ae = 1; !(v.words[0] & ae) && ee < 26; ++ee, ae <<= 1)
            ;
          if (ee > 0)
            for (v.iushrn(ee); ee-- > 0; )
              (M.isOdd() || I.isOdd()) && (M.iadd(p), I.isub(B)), M.iushrn(1), I.iushrn(1);
          for (var Z = 0, ne = 1; !(g.words[0] & ne) && Z < 26; ++Z, ne <<= 1)
            ;
          if (Z > 0)
            for (g.iushrn(Z); Z-- > 0; )
              (R.isOdd() || x.isOdd()) && (R.iadd(p), x.isub(B)), R.iushrn(1), x.iushrn(1);
          v.cmp(g) >= 0 ? (v.isub(g), M.isub(R), I.isub(x)) : (g.isub(v), R.isub(M), x.isub(I));
        }
        return {
          a: R,
          b: x,
          gcd: g.iushln(T)
        };
      }, i.prototype._invmp = function(f) {
        n(f.negative === 0), n(!f.isZero());
        var v = this, g = f.clone();
        v.negative !== 0 ? v = v.umod(f) : v = v.clone();
        for (var M = new i(1), I = new i(0), R = g.clone(); v.cmpn(1) > 0 && g.cmpn(1) > 0; ) {
          for (var x = 0, T = 1; !(v.words[0] & T) && x < 26; ++x, T <<= 1)
            ;
          if (x > 0)
            for (v.iushrn(x); x-- > 0; )
              M.isOdd() && M.iadd(R), M.iushrn(1);
          for (var p = 0, B = 1; !(g.words[0] & B) && p < 26; ++p, B <<= 1)
            ;
          if (p > 0)
            for (g.iushrn(p); p-- > 0; )
              I.isOdd() && I.iadd(R), I.iushrn(1);
          v.cmp(g) >= 0 ? (v.isub(g), M.isub(I)) : (g.isub(v), I.isub(M));
        }
        var ee;
        return v.cmpn(1) === 0 ? ee = M : ee = I, ee.cmpn(0) < 0 && ee.iadd(f), ee;
      }, i.prototype.gcd = function(f) {
        if (this.isZero())
          return f.abs();
        if (f.isZero())
          return this.abs();
        var v = this.clone(), g = f.clone();
        v.negative = 0, g.negative = 0;
        for (var M = 0; v.isEven() && g.isEven(); M++)
          v.iushrn(1), g.iushrn(1);
        do {
          for (; v.isEven(); )
            v.iushrn(1);
          for (; g.isEven(); )
            g.iushrn(1);
          var I = v.cmp(g);
          if (I < 0) {
            var R = v;
            v = g, g = R;
          } else if (I === 0 || g.cmpn(1) === 0)
            break;
          v.isub(g);
        } while (!0);
        return g.iushln(M);
      }, i.prototype.invm = function(f) {
        return this.egcd(f).a.umod(f);
      }, i.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, i.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, i.prototype.andln = function(f) {
        return this.words[0] & f;
      }, i.prototype.bincn = function(f) {
        n(typeof f == "number");
        var v = f % 26, g = (f - v) / 26, M = 1 << v;
        if (this.length <= g)
          return this._expand(g + 1), this.words[g] |= M, this;
        for (var I = M, R = g; I !== 0 && R < this.length; R++) {
          var x = this.words[R] | 0;
          x += I, I = x >>> 26, x &= 67108863, this.words[R] = x;
        }
        return I !== 0 && (this.words[R] = I, this.length++), this;
      }, i.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, i.prototype.cmpn = function(f) {
        var v = f < 0;
        if (this.negative !== 0 && !v)
          return -1;
        if (this.negative === 0 && v)
          return 1;
        this._strip();
        var g;
        if (this.length > 1)
          g = 1;
        else {
          v && (f = -f), n(f <= 67108863, "Number is too big");
          var M = this.words[0] | 0;
          g = M === f ? 0 : M < f ? -1 : 1;
        }
        return this.negative !== 0 ? -g | 0 : g;
      }, i.prototype.cmp = function(f) {
        if (this.negative !== 0 && f.negative === 0)
          return -1;
        if (this.negative === 0 && f.negative !== 0)
          return 1;
        var v = this.ucmp(f);
        return this.negative !== 0 ? -v | 0 : v;
      }, i.prototype.ucmp = function(f) {
        if (this.length > f.length)
          return 1;
        if (this.length < f.length)
          return -1;
        for (var v = 0, g = this.length - 1; g >= 0; g--) {
          var M = this.words[g] | 0, I = f.words[g] | 0;
          if (M !== I) {
            M < I ? v = -1 : M > I && (v = 1);
            break;
          }
        }
        return v;
      }, i.prototype.gtn = function(f) {
        return this.cmpn(f) === 1;
      }, i.prototype.gt = function(f) {
        return this.cmp(f) === 1;
      }, i.prototype.gten = function(f) {
        return this.cmpn(f) >= 0;
      }, i.prototype.gte = function(f) {
        return this.cmp(f) >= 0;
      }, i.prototype.ltn = function(f) {
        return this.cmpn(f) === -1;
      }, i.prototype.lt = function(f) {
        return this.cmp(f) === -1;
      }, i.prototype.lten = function(f) {
        return this.cmpn(f) <= 0;
      }, i.prototype.lte = function(f) {
        return this.cmp(f) <= 0;
      }, i.prototype.eqn = function(f) {
        return this.cmpn(f) === 0;
      }, i.prototype.eq = function(f) {
        return this.cmp(f) === 0;
      }, i.red = function(f) {
        return new Q(f);
      }, i.prototype.toRed = function(f) {
        return n(!this.red, "Already a number in reduction context"), n(this.negative === 0, "red works only with positives"), f.convertTo(this)._forceRed(f);
      }, i.prototype.fromRed = function() {
        return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, i.prototype._forceRed = function(f) {
        return this.red = f, this;
      }, i.prototype.forceRed = function(f) {
        return n(!this.red, "Already a number in reduction context"), this._forceRed(f);
      }, i.prototype.redAdd = function(f) {
        return n(this.red, "redAdd works only with red numbers"), this.red.add(this, f);
      }, i.prototype.redIAdd = function(f) {
        return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, f);
      }, i.prototype.redSub = function(f) {
        return n(this.red, "redSub works only with red numbers"), this.red.sub(this, f);
      }, i.prototype.redISub = function(f) {
        return n(this.red, "redISub works only with red numbers"), this.red.isub(this, f);
      }, i.prototype.redShl = function(f) {
        return n(this.red, "redShl works only with red numbers"), this.red.shl(this, f);
      }, i.prototype.redMul = function(f) {
        return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, f), this.red.mul(this, f);
      }, i.prototype.redIMul = function(f) {
        return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, f), this.red.imul(this, f);
      }, i.prototype.redSqr = function() {
        return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, i.prototype.redISqr = function() {
        return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, i.prototype.redSqrt = function() {
        return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, i.prototype.redInvm = function() {
        return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, i.prototype.redNeg = function() {
        return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, i.prototype.redPow = function(f) {
        return n(this.red && !f.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, f);
      };
      var z = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function K(b, f) {
        this.name = b, this.p = new i(f, 16), this.n = this.p.bitLength(), this.k = new i(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      K.prototype._tmp = function() {
        var f = new i(null);
        return f.words = new Array(Math.ceil(this.n / 13)), f;
      }, K.prototype.ireduce = function(f) {
        var v = f, g;
        do
          this.split(v, this.tmp), v = this.imulK(v), v = v.iadd(this.tmp), g = v.bitLength();
        while (g > this.n);
        var M = g < this.n ? -1 : v.ucmp(this.p);
        return M === 0 ? (v.words[0] = 0, v.length = 1) : M > 0 ? v.isub(this.p) : v.strip !== void 0 ? v.strip() : v._strip(), v;
      }, K.prototype.split = function(f, v) {
        f.iushrn(this.n, 0, v);
      }, K.prototype.imulK = function(f) {
        return f.imul(this.k);
      };
      function re() {
        K.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      a(re, K), re.prototype.split = function(f, v) {
        for (var g = 4194303, M = Math.min(f.length, 9), I = 0; I < M; I++)
          v.words[I] = f.words[I];
        if (v.length = M, f.length <= 9) {
          f.words[0] = 0, f.length = 1;
          return;
        }
        var R = f.words[9];
        for (v.words[v.length++] = R & g, I = 10; I < f.length; I++) {
          var x = f.words[I] | 0;
          f.words[I - 10] = (x & g) << 4 | R >>> 22, R = x;
        }
        R >>>= 22, f.words[I - 10] = R, R === 0 && f.length > 10 ? f.length -= 10 : f.length -= 9;
      }, re.prototype.imulK = function(f) {
        f.words[f.length] = 0, f.words[f.length + 1] = 0, f.length += 2;
        for (var v = 0, g = 0; g < f.length; g++) {
          var M = f.words[g] | 0;
          v += M * 977, f.words[g] = v & 67108863, v = M * 64 + (v / 67108864 | 0);
        }
        return f.words[f.length - 1] === 0 && (f.length--, f.words[f.length - 1] === 0 && f.length--), f;
      };
      function oe() {
        K.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      a(oe, K);
      function se() {
        K.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      a(se, K);
      function ve() {
        K.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      a(ve, K), ve.prototype.imulK = function(f) {
        for (var v = 0, g = 0; g < f.length; g++) {
          var M = (f.words[g] | 0) * 19 + v, I = M & 67108863;
          M >>>= 26, f.words[g] = I, v = M;
        }
        return v !== 0 && (f.words[f.length++] = v), f;
      }, i._prime = function(f) {
        if (z[f])
          return z[f];
        var v;
        if (f === "k256")
          v = new re();
        else if (f === "p224")
          v = new oe();
        else if (f === "p192")
          v = new se();
        else if (f === "p25519")
          v = new ve();
        else
          throw new Error("Unknown prime " + f);
        return z[f] = v, v;
      };
      function Q(b) {
        if (typeof b == "string") {
          var f = i._prime(b);
          this.m = f.p, this.prime = f;
        } else
          n(b.gtn(1), "modulus must be greater than 1"), this.m = b, this.prime = null;
      }
      Q.prototype._verify1 = function(f) {
        n(f.negative === 0, "red works only with positives"), n(f.red, "red works only with red numbers");
      }, Q.prototype._verify2 = function(f, v) {
        n((f.negative | v.negative) === 0, "red works only with positives"), n(
          f.red && f.red === v.red,
          "red works only with red numbers"
        );
      }, Q.prototype.imod = function(f) {
        return this.prime ? this.prime.ireduce(f)._forceRed(this) : (s(f, f.umod(this.m)._forceRed(this)), f);
      }, Q.prototype.neg = function(f) {
        return f.isZero() ? f.clone() : this.m.sub(f)._forceRed(this);
      }, Q.prototype.add = function(f, v) {
        this._verify2(f, v);
        var g = f.add(v);
        return g.cmp(this.m) >= 0 && g.isub(this.m), g._forceRed(this);
      }, Q.prototype.iadd = function(f, v) {
        this._verify2(f, v);
        var g = f.iadd(v);
        return g.cmp(this.m) >= 0 && g.isub(this.m), g;
      }, Q.prototype.sub = function(f, v) {
        this._verify2(f, v);
        var g = f.sub(v);
        return g.cmpn(0) < 0 && g.iadd(this.m), g._forceRed(this);
      }, Q.prototype.isub = function(f, v) {
        this._verify2(f, v);
        var g = f.isub(v);
        return g.cmpn(0) < 0 && g.iadd(this.m), g;
      }, Q.prototype.shl = function(f, v) {
        return this._verify1(f), this.imod(f.ushln(v));
      }, Q.prototype.imul = function(f, v) {
        return this._verify2(f, v), this.imod(f.imul(v));
      }, Q.prototype.mul = function(f, v) {
        return this._verify2(f, v), this.imod(f.mul(v));
      }, Q.prototype.isqr = function(f) {
        return this.imul(f, f.clone());
      }, Q.prototype.sqr = function(f) {
        return this.mul(f, f);
      }, Q.prototype.sqrt = function(f) {
        if (f.isZero())
          return f.clone();
        var v = this.m.andln(3);
        if (n(v % 2 === 1), v === 3) {
          var g = this.m.add(new i(1)).iushrn(2);
          return this.pow(f, g);
        }
        for (var M = this.m.subn(1), I = 0; !M.isZero() && M.andln(1) === 0; )
          I++, M.iushrn(1);
        n(!M.isZero());
        var R = new i(1).toRed(this), x = R.redNeg(), T = this.m.subn(1).iushrn(1), p = this.m.bitLength();
        for (p = new i(2 * p * p).toRed(this); this.pow(p, T).cmp(x) !== 0; )
          p.redIAdd(x);
        for (var B = this.pow(p, M), ee = this.pow(f, M.addn(1).iushrn(1)), ae = this.pow(f, M), Z = I; ae.cmp(R) !== 0; ) {
          for (var ne = ae, fe = 0; ne.cmp(R) !== 0; fe++)
            ne = ne.redSqr();
          n(fe < Z);
          var le = this.pow(B, new i(1).iushln(Z - fe - 1));
          ee = ee.redMul(le), B = le.redSqr(), ae = ae.redMul(B), Z = fe;
        }
        return ee;
      }, Q.prototype.invm = function(f) {
        var v = f._invmp(this.m);
        return v.negative !== 0 ? (v.negative = 0, this.imod(v).redNeg()) : this.imod(v);
      }, Q.prototype.pow = function(f, v) {
        if (v.isZero())
          return new i(1).toRed(this);
        if (v.cmpn(1) === 0)
          return f.clone();
        var g = 4, M = new Array(1 << g);
        M[0] = new i(1).toRed(this), M[1] = f;
        for (var I = 2; I < M.length; I++)
          M[I] = this.mul(M[I - 1], f);
        var R = M[0], x = 0, T = 0, p = v.bitLength() % 26;
        for (p === 0 && (p = 26), I = v.length - 1; I >= 0; I--) {
          for (var B = v.words[I], ee = p - 1; ee >= 0; ee--) {
            var ae = B >> ee & 1;
            if (R !== M[0] && (R = this.sqr(R)), ae === 0 && x === 0) {
              T = 0;
              continue;
            }
            x <<= 1, x |= ae, T++, !(T !== g && (I !== 0 || ee !== 0)) && (R = this.mul(R, M[x]), T = 0, x = 0);
          }
          p = 26;
        }
        return R;
      }, Q.prototype.convertTo = function(f) {
        var v = f.umod(this.m);
        return v === f ? v.clone() : v;
      }, Q.prototype.convertFrom = function(f) {
        var v = f.clone();
        return v.red = null, v;
      }, i.mont = function(f) {
        return new A(f);
      };
      function A(b) {
        Q.call(this, b), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new i(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      a(A, Q), A.prototype.convertTo = function(f) {
        return this.imod(f.ushln(this.shift));
      }, A.prototype.convertFrom = function(f) {
        var v = this.imod(f.mul(this.rinv));
        return v.red = null, v;
      }, A.prototype.imul = function(f, v) {
        if (f.isZero() || v.isZero())
          return f.words[0] = 0, f.length = 1, f;
        var g = f.imul(v), M = g.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), I = g.isub(M).iushrn(this.shift), R = I;
        return I.cmp(this.m) >= 0 ? R = I.isub(this.m) : I.cmpn(0) < 0 && (R = I.iadd(this.m)), R._forceRed(this);
      }, A.prototype.mul = function(f, v) {
        if (f.isZero() || v.isZero())
          return new i(0)._forceRed(this);
        var g = f.mul(v), M = g.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), I = g.isub(M).iushrn(this.shift), R = I;
        return I.cmp(this.m) >= 0 ? R = I.isub(this.m) : I.cmpn(0) < 0 && (R = I.iadd(this.m)), R._forceRed(this);
      }, A.prototype.invm = function(f) {
        var v = this.imod(f._invmp(this.m).mul(this.r2));
        return v._forceRed(this);
      };
    })(r, Jt);
  }(eo)), eo.exports;
}
var zr = {}, du = {}, pu = {}, vu = {}, yu, Xd;
function uh() {
  if (Xd)
    return yu;
  Xd = 1;
  var r = Mn, e = r.Buffer, t = {}, n;
  for (n in r)
    r.hasOwnProperty(n) && (n === "SlowBuffer" || n === "Buffer" || (t[n] = r[n]));
  var a = t.Buffer = {};
  for (n in e)
    e.hasOwnProperty(n) && (n === "allocUnsafe" || n === "allocUnsafeSlow" || (a[n] = e[n]));
  if (t.Buffer.prototype = e.prototype, (!a.from || a.from === Uint8Array.from) && (a.from = function(i, o, u) {
    if (typeof i == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof i);
    if (i && typeof i.length == "undefined")
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof i);
    return e(i, o, u);
  }), a.alloc || (a.alloc = function(i, o, u) {
    if (typeof i != "number")
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof i);
    if (i < 0 || i >= 2 * (1 << 30))
      throw new RangeError('The value "' + i + '" is invalid for option "size"');
    var c = e(i);
    return !o || o.length === 0 ? c.fill(0) : typeof u == "string" ? c.fill(o, u) : c.fill(o), c;
  }), !t.kStringMaxLength)
    try {
      t.kStringMaxLength = Bt.binding("buffer").kStringMaxLength;
    } catch (i) {
    }
  return t.constants || (t.constants = {
    MAX_LENGTH: t.kMaxLength
  }, t.kStringMaxLength && (t.constants.MAX_STRING_LENGTH = t.kStringMaxLength)), yu = t, yu;
}
var bu = {}, Zd;
function ch() {
  if (Zd)
    return bu;
  Zd = 1;
  const r = Ft();
  function e(n) {
    this._reporterState = {
      obj: null,
      path: [],
      options: n || {},
      errors: []
    };
  }
  bu.Reporter = e, e.prototype.isError = function(a) {
    return a instanceof t;
  }, e.prototype.save = function() {
    const a = this._reporterState;
    return { obj: a.obj, pathLen: a.path.length };
  }, e.prototype.restore = function(a) {
    const i = this._reporterState;
    i.obj = a.obj, i.path = i.path.slice(0, a.pathLen);
  }, e.prototype.enterKey = function(a) {
    return this._reporterState.path.push(a);
  }, e.prototype.exitKey = function(a) {
    const i = this._reporterState;
    i.path = i.path.slice(0, a - 1);
  }, e.prototype.leaveKey = function(a, i, o) {
    const u = this._reporterState;
    this.exitKey(a), u.obj !== null && (u.obj[i] = o);
  }, e.prototype.path = function() {
    return this._reporterState.path.join("/");
  }, e.prototype.enterObject = function() {
    const a = this._reporterState, i = a.obj;
    return a.obj = {}, i;
  }, e.prototype.leaveObject = function(a) {
    const i = this._reporterState, o = i.obj;
    return i.obj = a, o;
  }, e.prototype.error = function(a) {
    let i;
    const o = this._reporterState, u = a instanceof t;
    if (u ? i = a : i = new t(o.path.map(function(c) {
      return "[" + JSON.stringify(c) + "]";
    }).join(""), a.message || a, a.stack), !o.options.partial)
      throw i;
    return u || o.errors.push(i), i;
  }, e.prototype.wrapResult = function(a) {
    const i = this._reporterState;
    return i.options.partial ? {
      result: this.isError(a) ? null : a,
      errors: i.errors
    } : a;
  };
  function t(n, a) {
    this.path = n, this.rethrow(a);
  }
  return r(t, Error), t.prototype.rethrow = function(a) {
    if (this.message = a + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, t), !this.stack)
      try {
        throw new Error(this.message);
      } catch (i) {
        this.stack = i.stack;
      }
    return this;
  }, bu;
}
var $a = {}, ep;
function ia() {
  if (ep)
    return $a;
  ep = 1;
  const r = Ft(), e = ch().Reporter, t = uh().Buffer;
  function n(i, o) {
    if (e.call(this, o), !t.isBuffer(i)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = i, this.offset = 0, this.length = i.length;
  }
  r(n, e), $a.DecoderBuffer = n, n.isDecoderBuffer = function(o) {
    return o instanceof n ? !0 : typeof o == "object" && t.isBuffer(o.base) && o.constructor.name === "DecoderBuffer" && typeof o.offset == "number" && typeof o.length == "number" && typeof o.save == "function" && typeof o.restore == "function" && typeof o.isEmpty == "function" && typeof o.readUInt8 == "function" && typeof o.skip == "function" && typeof o.raw == "function";
  }, n.prototype.save = function() {
    return { offset: this.offset, reporter: e.prototype.save.call(this) };
  }, n.prototype.restore = function(o) {
    const u = new n(this.base);
    return u.offset = o.offset, u.length = this.offset, this.offset = o.offset, e.prototype.restore.call(this, o.reporter), u;
  }, n.prototype.isEmpty = function() {
    return this.offset === this.length;
  }, n.prototype.readUInt8 = function(o) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(o || "DecoderBuffer overrun");
  }, n.prototype.skip = function(o, u) {
    if (!(this.offset + o <= this.length))
      return this.error(u || "DecoderBuffer overrun");
    const c = new n(this.base);
    return c._reporterState = this._reporterState, c.offset = this.offset, c.length = this.offset + o, this.offset += o, c;
  }, n.prototype.raw = function(o) {
    return this.base.slice(o ? o.offset : this.offset, this.length);
  };
  function a(i, o) {
    if (Array.isArray(i))
      this.length = 0, this.value = i.map(function(u) {
        return a.isEncoderBuffer(u) || (u = new a(u, o)), this.length += u.length, u;
      }, this);
    else if (typeof i == "number") {
      if (!(0 <= i && i <= 255))
        return o.error("non-byte EncoderBuffer value");
      this.value = i, this.length = 1;
    } else if (typeof i == "string")
      this.value = i, this.length = t.byteLength(i);
    else if (t.isBuffer(i))
      this.value = i, this.length = i.length;
    else
      return o.error("Unsupported type: " + typeof i);
  }
  return $a.EncoderBuffer = a, a.isEncoderBuffer = function(o) {
    return o instanceof a ? !0 : typeof o == "object" && o.constructor.name === "EncoderBuffer" && typeof o.length == "number" && typeof o.join == "function";
  }, a.prototype.join = function(o, u) {
    return o || (o = t.alloc(this.length)), u || (u = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(c) {
      c.join(o, u), u += c.length;
    }) : (typeof this.value == "number" ? o[u] = this.value : typeof this.value == "string" ? o.write(this.value, u) : t.isBuffer(this.value) && this.value.copy(o, u), u += this.length)), o;
  }, $a;
}
var mu, tp;
function hh() {
  if (tp)
    return mu;
  tp = 1;
  const r = ch().Reporter, e = ia().EncoderBuffer, t = ia().DecoderBuffer, n = Wr(), a = [
    "seq",
    "seqof",
    "set",
    "setof",
    "objid",
    "bool",
    "gentime",
    "utctime",
    "null_",
    "enum",
    "int",
    "objDesc",
    "bitstr",
    "bmpstr",
    "charstr",
    "genstr",
    "graphstr",
    "ia5str",
    "iso646str",
    "numstr",
    "octstr",
    "printstr",
    "t61str",
    "unistr",
    "utf8str",
    "videostr"
  ], i = [
    "key",
    "obj",
    "use",
    "optional",
    "explicit",
    "implicit",
    "def",
    "choice",
    "any",
    "contains"
  ].concat(a), o = [
    "_peekTag",
    "_decodeTag",
    "_use",
    "_decodeStr",
    "_decodeObjid",
    "_decodeTime",
    "_decodeNull",
    "_decodeInt",
    "_decodeBool",
    "_decodeList",
    "_encodeComposite",
    "_encodeStr",
    "_encodeObjid",
    "_encodeTime",
    "_encodeNull",
    "_encodeInt",
    "_encodeBool"
  ];
  function u(h, s, d) {
    const l = {};
    this._baseState = l, l.name = d, l.enc = h, l.parent = s || null, l.children = null, l.tag = null, l.args = null, l.reverseArgs = null, l.choice = null, l.optional = !1, l.any = !1, l.obj = !1, l.use = null, l.useDecoder = null, l.key = null, l.default = null, l.explicit = null, l.implicit = null, l.contains = null, l.parent || (l.children = [], this._wrap());
  }
  mu = u;
  const c = [
    "enc",
    "parent",
    "children",
    "tag",
    "args",
    "reverseArgs",
    "choice",
    "optional",
    "any",
    "obj",
    "use",
    "alteredUse",
    "key",
    "default",
    "explicit",
    "implicit",
    "contains"
  ];
  return u.prototype.clone = function() {
    const s = this._baseState, d = {};
    c.forEach(function(y) {
      d[y] = s[y];
    });
    const l = new this.constructor(d.parent);
    return l._baseState = d, l;
  }, u.prototype._wrap = function() {
    const s = this._baseState;
    i.forEach(function(d) {
      this[d] = function() {
        const y = new this.constructor(this);
        return s.children.push(y), y[d].apply(y, arguments);
      };
    }, this);
  }, u.prototype._init = function(s) {
    const d = this._baseState;
    n(d.parent === null), s.call(this), d.children = d.children.filter(function(l) {
      return l._baseState.parent === this;
    }, this), n.equal(d.children.length, 1, "Root node can have only one child");
  }, u.prototype._useArgs = function(s) {
    const d = this._baseState, l = s.filter(function(y) {
      return y instanceof this.constructor;
    }, this);
    s = s.filter(function(y) {
      return !(y instanceof this.constructor);
    }, this), l.length !== 0 && (n(d.children === null), d.children = l, l.forEach(function(y) {
      y._baseState.parent = this;
    }, this)), s.length !== 0 && (n(d.args === null), d.args = s, d.reverseArgs = s.map(function(y) {
      if (typeof y != "object" || y.constructor !== Object)
        return y;
      const m = {};
      return Object.keys(y).forEach(function(w) {
        w == (w | 0) && (w |= 0);
        const E = y[w];
        m[E] = w;
      }), m;
    }));
  }, o.forEach(function(h) {
    u.prototype[h] = function() {
      const d = this._baseState;
      throw new Error(h + " not implemented for encoding: " + d.enc);
    };
  }), a.forEach(function(h) {
    u.prototype[h] = function() {
      const d = this._baseState, l = Array.prototype.slice.call(arguments);
      return n(d.tag === null), d.tag = h, this._useArgs(l), this;
    };
  }), u.prototype.use = function(s) {
    n(s);
    const d = this._baseState;
    return n(d.use === null), d.use = s, this;
  }, u.prototype.optional = function() {
    const s = this._baseState;
    return s.optional = !0, this;
  }, u.prototype.def = function(s) {
    const d = this._baseState;
    return n(d.default === null), d.default = s, d.optional = !0, this;
  }, u.prototype.explicit = function(s) {
    const d = this._baseState;
    return n(d.explicit === null && d.implicit === null), d.explicit = s, this;
  }, u.prototype.implicit = function(s) {
    const d = this._baseState;
    return n(d.explicit === null && d.implicit === null), d.implicit = s, this;
  }, u.prototype.obj = function() {
    const s = this._baseState, d = Array.prototype.slice.call(arguments);
    return s.obj = !0, d.length !== 0 && this._useArgs(d), this;
  }, u.prototype.key = function(s) {
    const d = this._baseState;
    return n(d.key === null), d.key = s, this;
  }, u.prototype.any = function() {
    const s = this._baseState;
    return s.any = !0, this;
  }, u.prototype.choice = function(s) {
    const d = this._baseState;
    return n(d.choice === null), d.choice = s, this._useArgs(Object.keys(s).map(function(l) {
      return s[l];
    })), this;
  }, u.prototype.contains = function(s) {
    const d = this._baseState;
    return n(d.use === null), d.contains = s, this;
  }, u.prototype._decode = function(s, d) {
    const l = this._baseState;
    if (l.parent === null)
      return s.wrapResult(l.children[0]._decode(s, d));
    let y = l.default, m = !0, w = null;
    if (l.key !== null && (w = s.enterKey(l.key)), l.optional) {
      let S = null;
      if (l.explicit !== null ? S = l.explicit : l.implicit !== null ? S = l.implicit : l.tag !== null && (S = l.tag), S === null && !l.any) {
        const P = s.save();
        try {
          l.choice === null ? this._decodeGeneric(l.tag, s, d) : this._decodeChoice(s, d), m = !0;
        } catch (L) {
          m = !1;
        }
        s.restore(P);
      } else if (m = this._peekTag(s, S, l.any), s.isError(m))
        return m;
    }
    let E;
    if (l.obj && m && (E = s.enterObject()), m) {
      if (l.explicit !== null) {
        const P = this._decodeTag(s, l.explicit);
        if (s.isError(P))
          return P;
        s = P;
      }
      const S = s.offset;
      if (l.use === null && l.choice === null) {
        let P;
        l.any && (P = s.save());
        const L = this._decodeTag(
          s,
          l.implicit !== null ? l.implicit : l.tag,
          l.any
        );
        if (s.isError(L))
          return L;
        l.any ? y = s.raw(P) : s = L;
      }
      if (d && d.track && l.tag !== null && d.track(s.path(), S, s.length, "tagged"), d && d.track && l.tag !== null && d.track(s.path(), s.offset, s.length, "content"), l.any || (l.choice === null ? y = this._decodeGeneric(l.tag, s, d) : y = this._decodeChoice(s, d)), s.isError(y))
        return y;
      if (!l.any && l.choice === null && l.children !== null && l.children.forEach(function(L) {
        L._decode(s, d);
      }), l.contains && (l.tag === "octstr" || l.tag === "bitstr")) {
        const P = new t(y);
        y = this._getUse(l.contains, s._reporterState.obj)._decode(P, d);
      }
    }
    return l.obj && m && (y = s.leaveObject(E)), l.key !== null && (y !== null || m === !0) ? s.leaveKey(w, l.key, y) : w !== null && s.exitKey(w), y;
  }, u.prototype._decodeGeneric = function(s, d, l) {
    const y = this._baseState;
    return s === "seq" || s === "set" ? null : s === "seqof" || s === "setof" ? this._decodeList(d, s, y.args[0], l) : /str$/.test(s) ? this._decodeStr(d, s, l) : s === "objid" && y.args ? this._decodeObjid(d, y.args[0], y.args[1], l) : s === "objid" ? this._decodeObjid(d, null, null, l) : s === "gentime" || s === "utctime" ? this._decodeTime(d, s, l) : s === "null_" ? this._decodeNull(d, l) : s === "bool" ? this._decodeBool(d, l) : s === "objDesc" ? this._decodeStr(d, s, l) : s === "int" || s === "enum" ? this._decodeInt(d, y.args && y.args[0], l) : y.use !== null ? this._getUse(y.use, d._reporterState.obj)._decode(d, l) : d.error("unknown tag: " + s);
  }, u.prototype._getUse = function(s, d) {
    const l = this._baseState;
    return l.useDecoder = this._use(s, d), n(l.useDecoder._baseState.parent === null), l.useDecoder = l.useDecoder._baseState.children[0], l.implicit !== l.useDecoder._baseState.implicit && (l.useDecoder = l.useDecoder.clone(), l.useDecoder._baseState.implicit = l.implicit), l.useDecoder;
  }, u.prototype._decodeChoice = function(s, d) {
    const l = this._baseState;
    let y = null, m = !1;
    return Object.keys(l.choice).some(function(w) {
      const E = s.save(), S = l.choice[w];
      try {
        const P = S._decode(s, d);
        if (s.isError(P))
          return !1;
        y = { type: w, value: P }, m = !0;
      } catch (P) {
        return s.restore(E), !1;
      }
      return !0;
    }, this), m ? y : s.error("Choice not matched");
  }, u.prototype._createEncoderBuffer = function(s) {
    return new e(s, this.reporter);
  }, u.prototype._encode = function(s, d, l) {
    const y = this._baseState;
    if (y.default !== null && y.default === s)
      return;
    const m = this._encodeValue(s, d, l);
    if (m !== void 0 && !this._skipDefault(m, d, l))
      return m;
  }, u.prototype._encodeValue = function(s, d, l) {
    const y = this._baseState;
    if (y.parent === null)
      return y.children[0]._encode(s, d || new r());
    let m = null;
    if (this.reporter = d, y.optional && s === void 0)
      if (y.default !== null)
        s = y.default;
      else
        return;
    let w = null, E = !1;
    if (y.any)
      m = this._createEncoderBuffer(s);
    else if (y.choice)
      m = this._encodeChoice(s, d);
    else if (y.contains)
      w = this._getUse(y.contains, l)._encode(s, d), E = !0;
    else if (y.children)
      w = y.children.map(function(S) {
        if (S._baseState.tag === "null_")
          return S._encode(null, d, s);
        if (S._baseState.key === null)
          return d.error("Child should have a key");
        const P = d.enterKey(S._baseState.key);
        if (typeof s != "object")
          return d.error("Child expected, but input is not object");
        const L = S._encode(s[S._baseState.key], d, s);
        return d.leaveKey(P), L;
      }, this).filter(function(S) {
        return S;
      }), w = this._createEncoderBuffer(w);
    else if (y.tag === "seqof" || y.tag === "setof") {
      if (!(y.args && y.args.length === 1))
        return d.error("Too many args for : " + y.tag);
      if (!Array.isArray(s))
        return d.error("seqof/setof, but data is not Array");
      const S = this.clone();
      S._baseState.implicit = null, w = this._createEncoderBuffer(s.map(function(P) {
        const L = this._baseState;
        return this._getUse(L.args[0], s)._encode(P, d);
      }, S));
    } else
      y.use !== null ? m = this._getUse(y.use, l)._encode(s, d) : (w = this._encodePrimitive(y.tag, s), E = !0);
    if (!y.any && y.choice === null) {
      const S = y.implicit !== null ? y.implicit : y.tag, P = y.implicit === null ? "universal" : "context";
      S === null ? y.use === null && d.error("Tag could be omitted only for .use()") : y.use === null && (m = this._encodeComposite(S, E, P, w));
    }
    return y.explicit !== null && (m = this._encodeComposite(y.explicit, !1, "context", m)), m;
  }, u.prototype._encodeChoice = function(s, d) {
    const l = this._baseState, y = l.choice[s.type];
    return y || n(
      !1,
      s.type + " not found in " + JSON.stringify(Object.keys(l.choice))
    ), y._encode(s.value, d);
  }, u.prototype._encodePrimitive = function(s, d) {
    const l = this._baseState;
    if (/str$/.test(s))
      return this._encodeStr(d, s);
    if (s === "objid" && l.args)
      return this._encodeObjid(d, l.reverseArgs[0], l.args[1]);
    if (s === "objid")
      return this._encodeObjid(d, null, null);
    if (s === "gentime" || s === "utctime")
      return this._encodeTime(d, s);
    if (s === "null_")
      return this._encodeNull();
    if (s === "int" || s === "enum")
      return this._encodeInt(d, l.args && l.reverseArgs[0]);
    if (s === "bool")
      return this._encodeBool(d);
    if (s === "objDesc")
      return this._encodeStr(d, s);
    throw new Error("Unsupported tag: " + s);
  }, u.prototype._isNumstr = function(s) {
    return /^[0-9 ]*$/.test(s);
  }, u.prototype._isPrintstr = function(s) {
    return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(s);
  }, mu;
}
var gu = {}, rp;
function lh() {
  return rp || (rp = 1, function(r) {
    function e(t) {
      const n = {};
      return Object.keys(t).forEach(function(a) {
        (a | 0) == a && (a = a | 0);
        const i = t[a];
        n[i] = a;
      }), n;
    }
    r.tagClass = {
      0: "universal",
      1: "application",
      2: "context",
      3: "private"
    }, r.tagClassByName = e(r.tagClass), r.tag = {
      0: "end",
      1: "bool",
      2: "int",
      3: "bitstr",
      4: "octstr",
      5: "null_",
      6: "objid",
      7: "objDesc",
      8: "external",
      9: "real",
      10: "enum",
      11: "embed",
      12: "utf8str",
      13: "relativeOid",
      16: "seq",
      17: "set",
      18: "numstr",
      19: "printstr",
      20: "t61str",
      21: "videostr",
      22: "ia5str",
      23: "utctime",
      24: "gentime",
      25: "graphstr",
      26: "iso646str",
      27: "genstr",
      28: "unistr",
      29: "charstr",
      30: "bmpstr"
    }, r.tagByName = e(r.tag);
  }(gu)), gu;
}
var wu, np;
function G1() {
  if (np)
    return wu;
  np = 1;
  const r = Ft(), e = uh().Buffer, t = hh(), n = lh();
  function a(c) {
    this.enc = "der", this.name = c.name, this.entity = c, this.tree = new i(), this.tree._init(c.body);
  }
  wu = a, a.prototype.encode = function(h, s) {
    return this.tree._encode(h, s).join();
  };
  function i(c) {
    t.call(this, "der", c);
  }
  r(i, t), i.prototype._encodeComposite = function(h, s, d, l) {
    const y = u(h, s, d, this.reporter);
    if (l.length < 128) {
      const E = e.alloc(2);
      return E[0] = y, E[1] = l.length, this._createEncoderBuffer([E, l]);
    }
    let m = 1;
    for (let E = l.length; E >= 256; E >>= 8)
      m++;
    const w = e.alloc(2 + m);
    w[0] = y, w[1] = 128 | m;
    for (let E = 1 + m, S = l.length; S > 0; E--, S >>= 8)
      w[E] = S & 255;
    return this._createEncoderBuffer([w, l]);
  }, i.prototype._encodeStr = function(h, s) {
    if (s === "bitstr")
      return this._createEncoderBuffer([h.unused | 0, h.data]);
    if (s === "bmpstr") {
      const d = e.alloc(h.length * 2);
      for (let l = 0; l < h.length; l++)
        d.writeUInt16BE(h.charCodeAt(l), l * 2);
      return this._createEncoderBuffer(d);
    } else
      return s === "numstr" ? this._isNumstr(h) ? this._createEncoderBuffer(h) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : s === "printstr" ? this._isPrintstr(h) ? this._createEncoderBuffer(h) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(s) ? this._createEncoderBuffer(h) : s === "objDesc" ? this._createEncoderBuffer(h) : this.reporter.error("Encoding of string type: " + s + " unsupported");
  }, i.prototype._encodeObjid = function(h, s, d) {
    if (typeof h == "string") {
      if (!s)
        return this.reporter.error("string objid given, but no values map found");
      if (!s.hasOwnProperty(h))
        return this.reporter.error("objid not found in values map");
      h = s[h].split(/[\s.]+/g);
      for (let w = 0; w < h.length; w++)
        h[w] |= 0;
    } else if (Array.isArray(h)) {
      h = h.slice();
      for (let w = 0; w < h.length; w++)
        h[w] |= 0;
    }
    if (!Array.isArray(h))
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(h));
    if (!d) {
      if (h[1] >= 40)
        return this.reporter.error("Second objid identifier OOB");
      h.splice(0, 2, h[0] * 40 + h[1]);
    }
    let l = 0;
    for (let w = 0; w < h.length; w++) {
      let E = h[w];
      for (l++; E >= 128; E >>= 7)
        l++;
    }
    const y = e.alloc(l);
    let m = y.length - 1;
    for (let w = h.length - 1; w >= 0; w--) {
      let E = h[w];
      for (y[m--] = E & 127; (E >>= 7) > 0; )
        y[m--] = 128 | E & 127;
    }
    return this._createEncoderBuffer(y);
  };
  function o(c) {
    return c < 10 ? "0" + c : c;
  }
  i.prototype._encodeTime = function(h, s) {
    let d;
    const l = new Date(h);
    return s === "gentime" ? d = [
      o(l.getUTCFullYear()),
      o(l.getUTCMonth() + 1),
      o(l.getUTCDate()),
      o(l.getUTCHours()),
      o(l.getUTCMinutes()),
      o(l.getUTCSeconds()),
      "Z"
    ].join("") : s === "utctime" ? d = [
      o(l.getUTCFullYear() % 100),
      o(l.getUTCMonth() + 1),
      o(l.getUTCDate()),
      o(l.getUTCHours()),
      o(l.getUTCMinutes()),
      o(l.getUTCSeconds()),
      "Z"
    ].join("") : this.reporter.error("Encoding " + s + " time is not supported yet"), this._encodeStr(d, "octstr");
  }, i.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  }, i.prototype._encodeInt = function(h, s) {
    if (typeof h == "string") {
      if (!s)
        return this.reporter.error("String int or enum given, but no values map");
      if (!s.hasOwnProperty(h))
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(h));
      h = s[h];
    }
    if (typeof h != "number" && !e.isBuffer(h)) {
      const y = h.toArray();
      !h.sign && y[0] & 128 && y.unshift(0), h = e.from(y);
    }
    if (e.isBuffer(h)) {
      let y = h.length;
      h.length === 0 && y++;
      const m = e.alloc(y);
      return h.copy(m), h.length === 0 && (m[0] = 0), this._createEncoderBuffer(m);
    }
    if (h < 128)
      return this._createEncoderBuffer(h);
    if (h < 256)
      return this._createEncoderBuffer([0, h]);
    let d = 1;
    for (let y = h; y >= 256; y >>= 8)
      d++;
    const l = new Array(d);
    for (let y = l.length - 1; y >= 0; y--)
      l[y] = h & 255, h >>= 8;
    return l[0] & 128 && l.unshift(0), this._createEncoderBuffer(e.from(l));
  }, i.prototype._encodeBool = function(h) {
    return this._createEncoderBuffer(h ? 255 : 0);
  }, i.prototype._use = function(h, s) {
    return typeof h == "function" && (h = h(s)), h._getEncoder("der").tree;
  }, i.prototype._skipDefault = function(h, s, d) {
    const l = this._baseState;
    let y;
    if (l.default === null)
      return !1;
    const m = h.join();
    if (l.defaultBuffer === void 0 && (l.defaultBuffer = this._encodeValue(l.default, s, d).join()), m.length !== l.defaultBuffer.length)
      return !1;
    for (y = 0; y < m.length; y++)
      if (m[y] !== l.defaultBuffer[y])
        return !1;
    return !0;
  };
  function u(c, h, s, d) {
    let l;
    if (c === "seqof" ? c = "seq" : c === "setof" && (c = "set"), n.tagByName.hasOwnProperty(c))
      l = n.tagByName[c];
    else if (typeof c == "number" && (c | 0) === c)
      l = c;
    else
      return d.error("Unknown tag: " + c);
    return l >= 31 ? d.error("Multi-octet tag encoding unsupported") : (h || (l |= 32), l |= n.tagClassByName[s || "universal"] << 6, l);
  }
  return wu;
}
var _u, ip;
function T3() {
  if (ip)
    return _u;
  ip = 1;
  const r = Ft(), e = G1();
  function t(n) {
    e.call(this, n), this.enc = "pem";
  }
  return r(t, e), _u = t, t.prototype.encode = function(a, i) {
    const u = e.prototype.encode.call(this, a).toString("base64"), c = ["-----BEGIN " + i.label + "-----"];
    for (let h = 0; h < u.length; h += 64)
      c.push(u.slice(h, h + 64));
    return c.push("-----END " + i.label + "-----"), c.join(`
`);
  }, _u;
}
var ap;
function J1() {
  return ap || (ap = 1, function(r) {
    const e = r;
    e.der = G1(), e.pem = T3();
  }(vu)), vu;
}
var xu = {}, Su, op;
function Y1() {
  if (op)
    return Su;
  op = 1;
  const r = Ft(), e = Ir(), t = ia().DecoderBuffer, n = hh(), a = lh();
  function i(h) {
    this.enc = "der", this.name = h.name, this.entity = h, this.tree = new o(), this.tree._init(h.body);
  }
  Su = i, i.prototype.decode = function(s, d) {
    return t.isDecoderBuffer(s) || (s = new t(s, d)), this.tree._decode(s, d);
  };
  function o(h) {
    n.call(this, "der", h);
  }
  r(o, n), o.prototype._peekTag = function(s, d, l) {
    if (s.isEmpty())
      return !1;
    const y = s.save(), m = u(s, 'Failed to peek tag: "' + d + '"');
    return s.isError(m) ? m : (s.restore(y), m.tag === d || m.tagStr === d || m.tagStr + "of" === d || l);
  }, o.prototype._decodeTag = function(s, d, l) {
    const y = u(
      s,
      'Failed to decode tag of "' + d + '"'
    );
    if (s.isError(y))
      return y;
    let m = c(
      s,
      y.primitive,
      'Failed to get length of "' + d + '"'
    );
    if (s.isError(m))
      return m;
    if (!l && y.tag !== d && y.tagStr !== d && y.tagStr + "of" !== d)
      return s.error('Failed to match tag: "' + d + '"');
    if (y.primitive || m !== null)
      return s.skip(m, 'Failed to match body of: "' + d + '"');
    const w = s.save(), E = this._skipUntilEnd(
      s,
      'Failed to skip indefinite length body: "' + this.tag + '"'
    );
    return s.isError(E) ? E : (m = s.offset - w.offset, s.restore(w), s.skip(m, 'Failed to match body of: "' + d + '"'));
  }, o.prototype._skipUntilEnd = function(s, d) {
    for (; ; ) {
      const l = u(s, d);
      if (s.isError(l))
        return l;
      const y = c(s, l.primitive, d);
      if (s.isError(y))
        return y;
      let m;
      if (l.primitive || y !== null ? m = s.skip(y) : m = this._skipUntilEnd(s, d), s.isError(m))
        return m;
      if (l.tagStr === "end")
        break;
    }
  }, o.prototype._decodeList = function(s, d, l, y) {
    const m = [];
    for (; !s.isEmpty(); ) {
      const w = this._peekTag(s, "end");
      if (s.isError(w))
        return w;
      const E = l.decode(s, "der", y);
      if (s.isError(E) && w)
        break;
      m.push(E);
    }
    return m;
  }, o.prototype._decodeStr = function(s, d) {
    if (d === "bitstr") {
      const l = s.readUInt8();
      return s.isError(l) ? l : { unused: l, data: s.raw() };
    } else if (d === "bmpstr") {
      const l = s.raw();
      if (l.length % 2 === 1)
        return s.error("Decoding of string type: bmpstr length mismatch");
      let y = "";
      for (let m = 0; m < l.length / 2; m++)
        y += String.fromCharCode(l.readUInt16BE(m * 2));
      return y;
    } else if (d === "numstr") {
      const l = s.raw().toString("ascii");
      return this._isNumstr(l) ? l : s.error("Decoding of string type: numstr unsupported characters");
    } else {
      if (d === "octstr")
        return s.raw();
      if (d === "objDesc")
        return s.raw();
      if (d === "printstr") {
        const l = s.raw().toString("ascii");
        return this._isPrintstr(l) ? l : s.error("Decoding of string type: printstr unsupported characters");
      } else
        return /str$/.test(d) ? s.raw().toString() : s.error("Decoding of string type: " + d + " unsupported");
    }
  }, o.prototype._decodeObjid = function(s, d, l) {
    let y;
    const m = [];
    let w = 0, E = 0;
    for (; !s.isEmpty(); )
      E = s.readUInt8(), w <<= 7, w |= E & 127, E & 128 || (m.push(w), w = 0);
    E & 128 && m.push(w);
    const S = m[0] / 40 | 0, P = m[0] % 40;
    if (l ? y = m : y = [S, P].concat(m.slice(1)), d) {
      let L = d[y.join(" ")];
      L === void 0 && (L = d[y.join(".")]), L !== void 0 && (y = L);
    }
    return y;
  }, o.prototype._decodeTime = function(s, d) {
    const l = s.raw().toString();
    let y, m, w, E, S, P;
    if (d === "gentime")
      y = l.slice(0, 4) | 0, m = l.slice(4, 6) | 0, w = l.slice(6, 8) | 0, E = l.slice(8, 10) | 0, S = l.slice(10, 12) | 0, P = l.slice(12, 14) | 0;
    else if (d === "utctime")
      y = l.slice(0, 2) | 0, m = l.slice(2, 4) | 0, w = l.slice(4, 6) | 0, E = l.slice(6, 8) | 0, S = l.slice(8, 10) | 0, P = l.slice(10, 12) | 0, y < 70 ? y = 2e3 + y : y = 1900 + y;
    else
      return s.error("Decoding " + d + " time is not supported yet");
    return Date.UTC(y, m - 1, w, E, S, P, 0);
  }, o.prototype._decodeNull = function() {
    return null;
  }, o.prototype._decodeBool = function(s) {
    const d = s.readUInt8();
    return s.isError(d) ? d : d !== 0;
  }, o.prototype._decodeInt = function(s, d) {
    const l = s.raw();
    let y = new e(l);
    return d && (y = d[y.toString(10)] || y), y;
  }, o.prototype._use = function(s, d) {
    return typeof s == "function" && (s = s(d)), s._getDecoder("der").tree;
  };
  function u(h, s) {
    let d = h.readUInt8(s);
    if (h.isError(d))
      return d;
    const l = a.tagClass[d >> 6], y = (d & 32) === 0;
    if ((d & 31) === 31) {
      let w = d;
      for (d = 0; (w & 128) === 128; ) {
        if (w = h.readUInt8(s), h.isError(w))
          return w;
        d <<= 7, d |= w & 127;
      }
    } else
      d &= 31;
    const m = a.tag[d];
    return {
      cls: l,
      primitive: y,
      tag: d,
      tagStr: m
    };
  }
  function c(h, s, d) {
    let l = h.readUInt8(d);
    if (h.isError(l))
      return l;
    if (!s && l === 128)
      return null;
    if (!(l & 128))
      return l;
    const y = l & 127;
    if (y > 4)
      return h.error("length octect is too long");
    l = 0;
    for (let m = 0; m < y; m++) {
      l <<= 8;
      const w = h.readUInt8(d);
      if (h.isError(w))
        return w;
      l |= w;
    }
    return l;
  }
  return Su;
}
var Eu, sp;
function k3() {
  if (sp)
    return Eu;
  sp = 1;
  const r = Ft(), e = uh().Buffer, t = Y1();
  function n(a) {
    t.call(this, a), this.enc = "pem";
  }
  return r(n, t), Eu = n, n.prototype.decode = function(i, o) {
    const u = i.toString().split(/[\r\n]+/g), c = o.label.toUpperCase(), h = /^-----(BEGIN|END) ([^-]+)-----$/;
    let s = -1, d = -1;
    for (let m = 0; m < u.length; m++) {
      const w = u[m].match(h);
      if (w !== null && w[2] === c)
        if (s === -1) {
          if (w[1] !== "BEGIN")
            break;
          s = m;
        } else {
          if (w[1] !== "END")
            break;
          d = m;
          break;
        }
    }
    if (s === -1 || d === -1)
      throw new Error("PEM section not found for: " + c);
    const l = u.slice(s + 1, d).join("");
    l.replace(/[^a-z0-9+/=]+/gi, "");
    const y = e.from(l, "base64");
    return t.prototype.decode.call(this, y, o);
  }, Eu;
}
var fp;
function X1() {
  return fp || (fp = 1, function(r) {
    const e = r;
    e.der = Y1(), e.pem = k3();
  }(xu)), xu;
}
var up;
function I3() {
  return up || (up = 1, function(r) {
    const e = J1(), t = X1(), n = Ft(), a = r;
    a.define = function(u, c) {
      return new i(u, c);
    };
    function i(o, u) {
      this.name = o, this.body = u, this.decoders = {}, this.encoders = {};
    }
    i.prototype._createNamed = function(u) {
      const c = this.name;
      function h(s) {
        this._initNamed(s, c);
      }
      return n(h, u), h.prototype._initNamed = function(d, l) {
        u.call(this, d, l);
      }, new h(this);
    }, i.prototype._getDecoder = function(u) {
      return u = u || "der", this.decoders.hasOwnProperty(u) || (this.decoders[u] = this._createNamed(t[u])), this.decoders[u];
    }, i.prototype.decode = function(u, c, h) {
      return this._getDecoder(c).decode(u, h);
    }, i.prototype._getEncoder = function(u) {
      return u = u || "der", this.encoders.hasOwnProperty(u) || (this.encoders[u] = this._createNamed(e[u])), this.encoders[u];
    }, i.prototype.encode = function(u, c, h) {
      return this._getEncoder(c).encode(u, h);
    };
  }(pu)), pu;
}
var Mu = {}, cp;
function R3() {
  return cp || (cp = 1, function(r) {
    const e = r;
    e.Reporter = ch().Reporter, e.DecoderBuffer = ia().DecoderBuffer, e.EncoderBuffer = ia().EncoderBuffer, e.Node = hh();
  }(Mu)), Mu;
}
var Au = {}, hp;
function C3() {
  return hp || (hp = 1, function(r) {
    const e = r;
    e._reverse = function(n) {
      const a = {};
      return Object.keys(n).forEach(function(i) {
        (i | 0) == i && (i = i | 0);
        const o = n[i];
        a[o] = i;
      }), a;
    }, e.der = lh();
  }(Au)), Au;
}
var lp;
function Z1() {
  return lp || (lp = 1, function(r) {
    const e = r;
    e.bignum = Ir(), e.define = I3().define, e.base = R3(), e.constants = C3(), e.decoders = X1(), e.encoders = J1();
  }(du)), du;
}
var Tu, dp;
function O3() {
  if (dp)
    return Tu;
  dp = 1;
  var r = Z1(), e = r.define("Time", function() {
    this.choice({
      utcTime: this.utctime(),
      generalTime: this.gentime()
    });
  }), t = r.define("AttributeTypeValue", function() {
    this.seq().obj(
      this.key("type").objid(),
      this.key("value").any()
    );
  }), n = r.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("parameters").optional(),
      this.key("curve").objid().optional()
    );
  }), a = r.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(n),
      this.key("subjectPublicKey").bitstr()
    );
  }), i = r.define("RelativeDistinguishedName", function() {
    this.setof(t);
  }), o = r.define("RDNSequence", function() {
    this.seqof(i);
  }), u = r.define("Name", function() {
    this.choice({
      rdnSequence: this.use(o)
    });
  }), c = r.define("Validity", function() {
    this.seq().obj(
      this.key("notBefore").use(e),
      this.key("notAfter").use(e)
    );
  }), h = r.define("Extension", function() {
    this.seq().obj(
      this.key("extnID").objid(),
      this.key("critical").bool().def(!1),
      this.key("extnValue").octstr()
    );
  }), s = r.define("TBSCertificate", function() {
    this.seq().obj(
      this.key("version").explicit(0).int().optional(),
      this.key("serialNumber").int(),
      this.key("signature").use(n),
      this.key("issuer").use(u),
      this.key("validity").use(c),
      this.key("subject").use(u),
      this.key("subjectPublicKeyInfo").use(a),
      this.key("issuerUniqueID").implicit(1).bitstr().optional(),
      this.key("subjectUniqueID").implicit(2).bitstr().optional(),
      this.key("extensions").explicit(3).seqof(h).optional()
    );
  }), d = r.define("X509Certificate", function() {
    this.seq().obj(
      this.key("tbsCertificate").use(s),
      this.key("signatureAlgorithm").use(n),
      this.key("signatureValue").bitstr()
    );
  });
  return Tu = d, Tu;
}
var pp;
function B3() {
  if (pp)
    return zr;
  pp = 1;
  var r = Z1();
  zr.certificate = O3();
  var e = r.define("RSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("modulus").int(),
      this.key("publicExponent").int(),
      this.key("privateExponent").int(),
      this.key("prime1").int(),
      this.key("prime2").int(),
      this.key("exponent1").int(),
      this.key("exponent2").int(),
      this.key("coefficient").int()
    );
  });
  zr.RSAPrivateKey = e;
  var t = r.define("RSAPublicKey", function() {
    this.seq().obj(
      this.key("modulus").int(),
      this.key("publicExponent").int()
    );
  });
  zr.RSAPublicKey = t;
  var n = r.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(a),
      this.key("subjectPublicKey").bitstr()
    );
  });
  zr.PublicKey = n;
  var a = r.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("none").null_().optional(),
      this.key("curve").objid().optional(),
      this.key("params").seq().obj(
        this.key("p").int(),
        this.key("q").int(),
        this.key("g").int()
      ).optional()
    );
  }), i = r.define("PrivateKeyInfo", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("algorithm").use(a),
      this.key("subjectPrivateKey").octstr()
    );
  });
  zr.PrivateKey = i;
  var o = r.define("EncryptedPrivateKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").seq().obj(
        this.key("id").objid(),
        this.key("decrypt").seq().obj(
          this.key("kde").seq().obj(
            this.key("id").objid(),
            this.key("kdeparams").seq().obj(
              this.key("salt").octstr(),
              this.key("iters").int()
            )
          ),
          this.key("cipher").seq().obj(
            this.key("algo").objid(),
            this.key("iv").octstr()
          )
        )
      ),
      this.key("subjectPrivateKey").octstr()
    );
  });
  zr.EncryptedPrivateKey = o;
  var u = r.define("DSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("p").int(),
      this.key("q").int(),
      this.key("g").int(),
      this.key("pub_key").int(),
      this.key("priv_key").int()
    );
  });
  zr.DSAPrivateKey = u, zr.DSAparam = r.define("DSAparam", function() {
    this.int();
  });
  var c = r.define("ECPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("privateKey").octstr(),
      this.key("parameters").optional().explicit(0).use(h),
      this.key("publicKey").optional().explicit(1).bitstr()
    );
  });
  zr.ECPrivateKey = c;
  var h = r.define("ECParameters", function() {
    this.choice({
      namedCurve: this.objid()
    });
  });
  return zr.signature = r.define("signature", function() {
    this.seq().obj(
      this.key("r").int(),
      this.key("s").int()
    );
  }), zr;
}
const P3 = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var ku, vp;
function D3() {
  if (vp)
    return ku;
  vp = 1;
  var r = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, e = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, t = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, n = To(), a = nh(), i = $t().Buffer;
  return ku = function(o, u) {
    var c = o.toString(), h = c.match(r), s;
    if (h) {
      var l = "aes" + h[1], y = i.from(h[2], "hex"), m = i.from(h[3].replace(/[\r\n]/g, ""), "base64"), w = n(u, y.slice(0, 8), parseInt(h[1], 10)).key, E = [], S = a.createDecipheriv(l, w, y);
      E.push(S.update(m)), E.push(S.final()), s = i.concat(E);
    } else {
      var d = c.match(t);
      s = i.from(d[2].replace(/[\r\n]/g, ""), "base64");
    }
    var P = c.match(e)[1];
    return {
      tag: P,
      data: s
    };
  }, ku;
}
var Iu, yp;
function Io() {
  if (yp)
    return Iu;
  yp = 1;
  var r = B3(), e = P3, t = D3(), n = nh(), a = P1(), i = $t().Buffer;
  Iu = o;
  function o(c) {
    var h;
    typeof c == "object" && !i.isBuffer(c) && (h = c.passphrase, c = c.key), typeof c == "string" && (c = i.from(c));
    var s = t(c, h), d = s.tag, l = s.data, y, m;
    switch (d) {
      case "CERTIFICATE":
        m = r.certificate.decode(l, "der").tbsCertificate.subjectPublicKeyInfo;
      case "PUBLIC KEY":
        switch (m || (m = r.PublicKey.decode(l, "der")), y = m.algorithm.algorithm.join("."), y) {
          case "1.2.840.113549.1.1.1":
            return r.RSAPublicKey.decode(m.subjectPublicKey.data, "der");
          case "1.2.840.10045.2.1":
            return m.subjectPrivateKey = m.subjectPublicKey, {
              type: "ec",
              data: m
            };
          case "1.2.840.10040.4.1":
            return m.algorithm.params.pub_key = r.DSAparam.decode(m.subjectPublicKey.data, "der"), {
              type: "dsa",
              data: m.algorithm.params
            };
          default:
            throw new Error("unknown key id " + y);
        }
      case "ENCRYPTED PRIVATE KEY":
        l = r.EncryptedPrivateKey.decode(l, "der"), l = u(l, h);
      case "PRIVATE KEY":
        switch (m = r.PrivateKey.decode(l, "der"), y = m.algorithm.algorithm.join("."), y) {
          case "1.2.840.113549.1.1.1":
            return r.RSAPrivateKey.decode(m.subjectPrivateKey, "der");
          case "1.2.840.10045.2.1":
            return {
              curve: m.algorithm.curve,
              privateKey: r.ECPrivateKey.decode(m.subjectPrivateKey, "der").privateKey
            };
          case "1.2.840.10040.4.1":
            return m.algorithm.params.priv_key = r.DSAparam.decode(m.subjectPrivateKey, "der"), {
              type: "dsa",
              params: m.algorithm.params
            };
          default:
            throw new Error("unknown key id " + y);
        }
      case "RSA PUBLIC KEY":
        return r.RSAPublicKey.decode(l, "der");
      case "RSA PRIVATE KEY":
        return r.RSAPrivateKey.decode(l, "der");
      case "DSA PRIVATE KEY":
        return {
          type: "dsa",
          params: r.DSAPrivateKey.decode(l, "der")
        };
      case "EC PRIVATE KEY":
        return l = r.ECPrivateKey.decode(l, "der"), {
          curve: l.parameters.value,
          privateKey: l.privateKey
        };
      default:
        throw new Error("unknown key type " + d);
    }
  }
  o.signature = r.signature;
  function u(c, h) {
    var s = c.algorithm.decrypt.kde.kdeparams.salt, d = parseInt(c.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), l = e[c.algorithm.decrypt.cipher.algo.join(".")], y = c.algorithm.decrypt.cipher.iv, m = c.subjectPrivateKey, w = parseInt(l.split("-")[1], 10) / 8, E = a.pbkdf2Sync(h, s, d, w, "sha1"), S = n.createDecipheriv(l, E, y), P = [];
    return P.push(S.update(m)), P.push(S.final()), i.concat(P);
  }
  return Iu;
}
const ey = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
};
var bp;
function N3() {
  if (bp)
    return Fi.exports;
  bp = 1;
  var r = $t().Buffer, e = k1(), t = ah(), n = fh().ec, a = Q1(), i = Io(), o = ey, u = 1;
  function c(S, P, L, U, z) {
    var K = i(P);
    if (K.curve) {
      if (U !== "ecdsa" && U !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return h(S, K);
    } else if (K.type === "dsa") {
      if (U !== "dsa")
        throw new Error("wrong private key type");
      return s(S, K, L);
    }
    if (U !== "rsa" && U !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    if (P.padding !== void 0 && P.padding !== u)
      throw new Error("illegal or unsupported padding mode");
    S = r.concat([z, S]);
    for (var re = K.modulus.byteLength(), oe = [0, 1]; S.length + oe.length + 1 < re; )
      oe.push(255);
    oe.push(0);
    for (var se = -1; ++se < S.length; )
      oe.push(S[se]);
    var ve = t(oe, K);
    return ve;
  }
  function h(S, P) {
    var L = o[P.curve.join(".")];
    if (!L)
      throw new Error("unknown curve " + P.curve.join("."));
    var U = new n(L), z = U.keyFromPrivate(P.privateKey), K = z.sign(S);
    return r.from(K.toDER());
  }
  function s(S, P, L) {
    for (var U = P.params.priv_key, z = P.params.p, K = P.params.q, re = P.params.g, oe = new a(0), se, ve = y(S, K).mod(K), Q = !1, A = l(U, K, S, L); Q === !1; )
      se = w(K, A, L), oe = E(re, se, z, K), Q = se.invm(K).imul(ve.add(U.mul(oe))).mod(K), Q.cmpn(0) === 0 && (Q = !1, oe = new a(0));
    return d(oe, Q);
  }
  function d(S, P) {
    S = S.toArray(), P = P.toArray(), S[0] & 128 && (S = [0].concat(S)), P[0] & 128 && (P = [0].concat(P));
    var L = S.length + P.length + 4, U = [
      48,
      L,
      2,
      S.length
    ];
    return U = U.concat(S, [2, P.length], P), r.from(U);
  }
  function l(S, P, L, U) {
    if (S = r.from(S.toArray()), S.length < P.byteLength()) {
      var z = r.alloc(P.byteLength() - S.length);
      S = r.concat([z, S]);
    }
    var K = L.length, re = m(L, P), oe = r.alloc(K);
    oe.fill(1);
    var se = r.alloc(K);
    return se = e(U, se).update(oe).update(r.from([0])).update(S).update(re).digest(), oe = e(U, se).update(oe).digest(), se = e(U, se).update(oe).update(r.from([1])).update(S).update(re).digest(), oe = e(U, se).update(oe).digest(), { k: se, v: oe };
  }
  function y(S, P) {
    var L = new a(S), U = (S.length << 3) - P.bitLength();
    return U > 0 && L.ishrn(U), L;
  }
  function m(S, P) {
    S = y(S, P), S = S.mod(P);
    var L = r.from(S.toArray());
    if (L.length < P.byteLength()) {
      var U = r.alloc(P.byteLength() - L.length);
      L = r.concat([U, L]);
    }
    return L;
  }
  function w(S, P, L) {
    var U, z;
    do {
      for (U = r.alloc(0); U.length * 8 < S.bitLength(); )
        P.v = e(L, P.k).update(P.v).digest(), U = r.concat([U, P.v]);
      z = y(U, S), P.k = e(L, P.k).update(P.v).update(r.from([0])).digest(), P.v = e(L, P.k).update(P.v).digest();
    } while (z.cmp(S) !== -1);
    return z;
  }
  function E(S, P, L, U) {
    return S.toRed(a.mont(L)).redPow(P).fromRed().mod(U);
  }
  return Fi.exports = c, Fi.exports.getKey = l, Fi.exports.makeKey = w, Fi.exports;
}
var Ru, mp;
function q3() {
  if (mp)
    return Ru;
  mp = 1;
  var r = $t().Buffer, e = Q1(), t = fh().ec, n = Io(), a = ey;
  function i(h, s, d, l, y) {
    var m = n(d);
    if (m.type === "ec") {
      if (l !== "ecdsa" && l !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return o(h, s, m);
    } else if (m.type === "dsa") {
      if (l !== "dsa")
        throw new Error("wrong public key type");
      return u(h, s, m);
    }
    if (l !== "rsa" && l !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    s = r.concat([y, s]);
    for (var w = m.modulus.byteLength(), E = [1], S = 0; s.length + E.length + 2 < w; )
      E.push(255), S += 1;
    E.push(0);
    for (var P = -1; ++P < s.length; )
      E.push(s[P]);
    E = r.from(E);
    var L = e.mont(m.modulus);
    h = new e(h).toRed(L), h = h.redPow(new e(m.publicExponent)), h = r.from(h.fromRed().toArray());
    var U = S < 8 ? 1 : 0;
    for (w = Math.min(h.length, E.length), h.length !== E.length && (U = 1), P = -1; ++P < w; )
      U |= h[P] ^ E[P];
    return U === 0;
  }
  function o(h, s, d) {
    var l = a[d.data.algorithm.curve.join(".")];
    if (!l)
      throw new Error("unknown curve " + d.data.algorithm.curve.join("."));
    var y = new t(l), m = d.data.subjectPrivateKey.data;
    return y.verify(s, h, m);
  }
  function u(h, s, d) {
    var l = d.data.p, y = d.data.q, m = d.data.g, w = d.data.pub_key, E = n.signature.decode(h, "der"), S = E.s, P = E.r;
    c(S, y), c(P, y);
    var L = e.mont(l), U = S.invm(y), z = m.toRed(L).redPow(new e(s).mul(U).mod(y)).fromRed().mul(w.toRed(L).redPow(P.mul(U).mod(y)).fromRed()).mod(l).mod(y);
    return z.cmp(P) === 0;
  }
  function c(h, s) {
    if (h.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (h.cmp(s) >= 0)
      throw new Error("invalid sig");
  }
  return Ru = i, Ru;
}
var Cu, gp;
function L3() {
  if (gp)
    return Cu;
  gp = 1;
  var r = $t().Buffer, e = ma(), t = S1(), n = Ft(), a = N3(), i = q3(), o = I1;
  Object.keys(o).forEach(function(d) {
    o[d].id = r.from(o[d].id, "hex"), o[d.toLowerCase()] = o[d];
  });
  function u(d) {
    t.Writable.call(this);
    var l = o[d];
    if (!l)
      throw new Error("Unknown message digest");
    this._hashType = l.hash, this._hash = e(l.hash), this._tag = l.id, this._signType = l.sign;
  }
  n(u, t.Writable), u.prototype._write = function(l, y, m) {
    this._hash.update(l), m();
  }, u.prototype.update = function(l, y) {
    return this._hash.update(typeof l == "string" ? r.from(l, y) : l), this;
  }, u.prototype.sign = function(l, y) {
    this.end();
    var m = this._hash.digest(), w = a(m, l, this._hashType, this._signType, this._tag);
    return y ? w.toString(y) : w;
  };
  function c(d) {
    t.Writable.call(this);
    var l = o[d];
    if (!l)
      throw new Error("Unknown message digest");
    this._hash = e(l.hash), this._tag = l.id, this._signType = l.sign;
  }
  n(c, t.Writable), c.prototype._write = function(l, y, m) {
    this._hash.update(l), m();
  }, c.prototype.update = function(l, y) {
    return this._hash.update(typeof l == "string" ? r.from(l, y) : l), this;
  }, c.prototype.verify = function(l, y, m) {
    var w = typeof y == "string" ? r.from(y, m) : y;
    this.end();
    var E = this._hash.digest();
    return i(w, E, l, this._signType, this._tag);
  };
  function h(d) {
    return new u(d);
  }
  function s(d) {
    return new c(d);
  }
  return Cu = {
    Sign: h,
    Verify: s,
    createSign: h,
    createVerify: s
  }, Cu;
}
var Ou, wp;
function F3() {
  if (wp)
    return Ou;
  wp = 1;
  var r = fh(), e = Ir();
  Ou = function(o) {
    return new n(o);
  };
  var t = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  t.p224 = t.secp224r1, t.p256 = t.secp256r1 = t.prime256v1, t.p192 = t.secp192r1 = t.prime192v1, t.p384 = t.secp384r1, t.p521 = t.secp521r1;
  function n(i) {
    this.curveType = t[i], this.curveType || (this.curveType = {
      name: i
    }), this.curve = new r.ec(this.curveType.name), this.keys = void 0;
  }
  n.prototype.generateKeys = function(i, o) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(i, o);
  }, n.prototype.computeSecret = function(i, o, u) {
    o = o || "utf8", Xt.isBuffer(i) || (i = new Xt(i, o));
    var c = this.curve.keyFromPublic(i).getPublic(), h = c.mul(this.keys.getPrivate()).getX();
    return a(h, u, this.curveType.byteLength);
  }, n.prototype.getPublicKey = function(i, o) {
    var u = this.keys.getPublic(o === "compressed", !0);
    return o === "hybrid" && (u[u.length - 1] % 2 ? u[0] = 7 : u[0] = 6), a(u, i);
  }, n.prototype.getPrivateKey = function(i) {
    return a(this.keys.getPrivate(), i);
  }, n.prototype.setPublicKey = function(i, o) {
    return o = o || "utf8", Xt.isBuffer(i) || (i = new Xt(i, o)), this.keys._importPublic(i), this;
  }, n.prototype.setPrivateKey = function(i, o) {
    o = o || "utf8", Xt.isBuffer(i) || (i = new Xt(i, o));
    var u = new e(i);
    return u = u.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(u), this;
  };
  function a(i, o, u) {
    Array.isArray(i) || (i = i.toArray());
    var c = new Xt(i);
    if (u && c.length < u) {
      var h = new Xt(u - c.length);
      h.fill(0), c = Xt.concat([h, c]);
    }
    return o ? c.toString(o) : c;
  }
  return Ou;
}
var Bu = {}, Pu, _p;
function ty() {
  if (_p)
    return Pu;
  _p = 1;
  var r = ma(), e = $t().Buffer;
  Pu = function(n, a) {
    for (var i = e.alloc(0), o = 0, u; i.length < a; )
      u = t(o++), i = e.concat([i, r("sha1").update(n).update(u).digest()]);
    return i.slice(0, a);
  };
  function t(n) {
    var a = e.allocUnsafe(4);
    return a.writeUInt32BE(n, 0), a;
  }
  return Pu;
}
var Du, xp;
function ry() {
  return xp || (xp = 1, Du = function(e, t) {
    for (var n = e.length, a = -1; ++a < n; )
      e[a] ^= t[a];
    return e;
  }), Du;
}
var Nu, Sp;
function ny() {
  if (Sp)
    return Nu;
  Sp = 1;
  var r = Ir(), e = $t().Buffer;
  function t(n, a) {
    return e.from(n.toRed(r.mont(a.modulus)).redPow(new r(a.publicExponent)).fromRed().toArray());
  }
  return Nu = t, Nu;
}
var qu, Ep;
function U3() {
  if (Ep)
    return qu;
  Ep = 1;
  var r = Io(), e = Ii(), t = ma(), n = ty(), a = ry(), i = Ir(), o = ny(), u = ah(), c = $t().Buffer;
  qu = function(y, m, w) {
    var E;
    y.padding ? E = y.padding : w ? E = 1 : E = 4;
    var S = r(y), P;
    if (E === 4)
      P = h(S, m);
    else if (E === 1)
      P = s(S, m, w);
    else if (E === 3) {
      if (P = new i(m), P.cmp(S.modulus) >= 0)
        throw new Error("data too long for modulus");
    } else
      throw new Error("unknown padding");
    return w ? u(P, S) : o(P, S);
  };
  function h(l, y) {
    var m = l.modulus.byteLength(), w = y.length, E = t("sha1").update(c.alloc(0)).digest(), S = E.length, P = 2 * S;
    if (w > m - P - 2)
      throw new Error("message too long");
    var L = c.alloc(m - w - P - 2), U = m - S - 1, z = e(S), K = a(c.concat([E, L, c.alloc(1, 1), y], U), n(z, U)), re = a(z, n(K, S));
    return new i(c.concat([c.alloc(1), re, K], m));
  }
  function s(l, y, m) {
    var w = y.length, E = l.modulus.byteLength();
    if (w > E - 11)
      throw new Error("message too long");
    var S;
    return m ? S = c.alloc(E - w - 3, 255) : S = d(E - w - 3), new i(c.concat([c.from([0, m ? 1 : 2]), S, c.alloc(1), y], E));
  }
  function d(l) {
    for (var y = c.allocUnsafe(l), m = 0, w = e(l * 2), E = 0, S; m < l; )
      E === w.length && (w = e(l * 2), E = 0), S = w[E++], S && (y[m++] = S);
    return y;
  }
  return qu;
}
var Lu, Mp;
function $3() {
  if (Mp)
    return Lu;
  Mp = 1;
  var r = Io(), e = ty(), t = ry(), n = Ir(), a = ah(), i = ma(), o = ny(), u = $t().Buffer;
  Lu = function(l, y, m) {
    var w;
    l.padding ? w = l.padding : m ? w = 1 : w = 4;
    var E = r(l), S = E.modulus.byteLength();
    if (y.length > S || new n(y).cmp(E.modulus) >= 0)
      throw new Error("decryption error");
    var P;
    m ? P = o(new n(y), E) : P = a(y, E);
    var L = u.alloc(S - P.length);
    if (P = u.concat([L, P], S), w === 4)
      return c(E, P);
    if (w === 1)
      return h(E, P, m);
    if (w === 3)
      return P;
    throw new Error("unknown padding");
  };
  function c(d, l) {
    var y = d.modulus.byteLength(), m = i("sha1").update(u.alloc(0)).digest(), w = m.length;
    if (l[0] !== 0)
      throw new Error("decryption error");
    var E = l.slice(1, w + 1), S = l.slice(w + 1), P = t(E, e(S, w)), L = t(S, e(P, y - w - 1));
    if (s(m, L.slice(0, w)))
      throw new Error("decryption error");
    for (var U = w; L[U] === 0; )
      U++;
    if (L[U++] !== 1)
      throw new Error("decryption error");
    return L.slice(U);
  }
  function h(d, l, y) {
    for (var m = l.slice(0, 2), w = 2, E = 0; l[w++] !== 0; )
      if (w >= l.length) {
        E++;
        break;
      }
    var S = l.slice(2, w - 1);
    if ((m.toString("hex") !== "0002" && !y || m.toString("hex") !== "0001" && y) && E++, S.length < 8 && E++, E)
      throw new Error("decryption error");
    return l.slice(w);
  }
  function s(d, l) {
    d = u.from(d), l = u.from(l);
    var y = 0, m = d.length;
    d.length !== l.length && (y++, m = Math.min(d.length, l.length));
    for (var w = -1; ++w < m; )
      y += d[w] ^ l[w];
    return y;
  }
  return Lu;
}
var Ap;
function j3() {
  return Ap || (Ap = 1, function(r) {
    r.publicEncrypt = U3(), r.privateDecrypt = $3(), r.privateEncrypt = function(t, n) {
      return r.publicEncrypt(t, n, !0);
    }, r.publicDecrypt = function(t, n) {
      return r.privateDecrypt(t, n, !0);
    };
  }(Bu)), Bu;
}
var ui = {}, Tp;
function H3() {
  if (Tp)
    return ui;
  Tp = 1;
  function r() {
    throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
  }
  var e = $t(), t = Ii(), n = e.Buffer, a = e.kMaxLength, i = Jt.crypto || Jt.msCrypto, o = Math.pow(2, 32) - 1;
  function u(l, y) {
    if (typeof l != "number" || l !== l)
      throw new TypeError("offset must be a number");
    if (l > o || l < 0)
      throw new TypeError("offset must be a uint32");
    if (l > a || l > y)
      throw new RangeError("offset out of range");
  }
  function c(l, y, m) {
    if (typeof l != "number" || l !== l)
      throw new TypeError("size must be a number");
    if (l > o || l < 0)
      throw new TypeError("size must be a uint32");
    if (l + y > m || l > a)
      throw new RangeError("buffer too small");
  }
  i && i.getRandomValues || !Bt.browser ? (ui.randomFill = h, ui.randomFillSync = d) : (ui.randomFill = r, ui.randomFillSync = r);
  function h(l, y, m, w) {
    if (!n.isBuffer(l) && !(l instanceof Jt.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    if (typeof y == "function")
      w = y, y = 0, m = l.length;
    else if (typeof m == "function")
      w = m, m = l.length - y;
    else if (typeof w != "function")
      throw new TypeError('"cb" argument must be a function');
    return u(y, l.length), c(m, y, l.length), s(l, y, m, w);
  }
  function s(l, y, m, w) {
    if (Bt.browser) {
      var E = l.buffer, S = new Uint8Array(E, y, m);
      if (i.getRandomValues(S), w) {
        Bt.nextTick(function() {
          w(null, l);
        });
        return;
      }
      return l;
    }
    if (w) {
      t(m, function(L, U) {
        if (L)
          return w(L);
        U.copy(l, y), w(null, l);
      });
      return;
    }
    var P = t(m);
    return P.copy(l, y), l;
  }
  function d(l, y, m) {
    if (typeof y == "undefined" && (y = 0), !n.isBuffer(l) && !(l instanceof Jt.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    return u(y, l.length), m === void 0 && (m = l.length - y), c(m, y, l.length), s(l, y, m);
  }
  return ui;
}
var kp;
function iy() {
  if (kp)
    return Lt;
  kp = 1, Lt.randomBytes = Lt.rng = Lt.pseudoRandomBytes = Lt.prng = Ii(), Lt.createHash = Lt.Hash = ma(), Lt.createHmac = Lt.Hmac = k1();
  var r = b6(), e = Object.keys(r), t = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(e);
  Lt.getHashes = function() {
    return t;
  };
  var n = P1();
  Lt.pbkdf2 = n.pbkdf2, Lt.pbkdf2Sync = n.pbkdf2Sync;
  var a = N6();
  Lt.Cipher = a.Cipher, Lt.createCipher = a.createCipher, Lt.Cipheriv = a.Cipheriv, Lt.createCipheriv = a.createCipheriv, Lt.Decipher = a.Decipher, Lt.createDecipher = a.createDecipher, Lt.Decipheriv = a.Decipheriv, Lt.createDecipheriv = a.createDecipheriv, Lt.getCiphers = a.getCiphers, Lt.listCiphers = a.listCiphers;
  var i = K6();
  Lt.DiffieHellmanGroup = i.DiffieHellmanGroup, Lt.createDiffieHellmanGroup = i.createDiffieHellmanGroup, Lt.getDiffieHellman = i.getDiffieHellman, Lt.createDiffieHellman = i.createDiffieHellman, Lt.DiffieHellman = i.DiffieHellman;
  var o = L3();
  Lt.createSign = o.createSign, Lt.Sign = o.Sign, Lt.createVerify = o.createVerify, Lt.Verify = o.Verify, Lt.createECDH = F3();
  var u = j3();
  Lt.publicEncrypt = u.publicEncrypt, Lt.privateEncrypt = u.privateEncrypt, Lt.publicDecrypt = u.publicDecrypt, Lt.privateDecrypt = u.privateDecrypt;
  var c = H3();
  return Lt.randomFill = c.randomFill, Lt.randomFillSync = c.randomFillSync, Lt.createCredentials = function() {
    throw new Error([
      "sorry, createCredentials is not implemented yet",
      "we accept pull requests",
      "https://github.com/crypto-browserify/crypto-browserify"
    ].join(`
`));
  }, Lt.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  }, Lt;
}
(function(r) {
  (function(e) {
    var t = function(j) {
      var N, D = new Float64Array(16);
      if (j)
        for (N = 0; N < j.length; N++)
          D[N] = j[N];
      return D;
    }, n = function() {
      throw new Error("no PRNG");
    }, a = new Uint8Array(16), i = new Uint8Array(32);
    i[0] = 9;
    var o = t(), u = t([1]), c = t([56129, 1]), h = t([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), s = t([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), d = t([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), l = t([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), y = t([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function m(j, N, D, _) {
      j[N] = D >> 24 & 255, j[N + 1] = D >> 16 & 255, j[N + 2] = D >> 8 & 255, j[N + 3] = D & 255, j[N + 4] = _ >> 24 & 255, j[N + 5] = _ >> 16 & 255, j[N + 6] = _ >> 8 & 255, j[N + 7] = _ & 255;
    }
    function w(j, N, D, _, $) {
      var Y, ie = 0;
      for (Y = 0; Y < $; Y++)
        ie |= j[N + Y] ^ D[_ + Y];
      return (1 & ie - 1 >>> 8) - 1;
    }
    function E(j, N, D, _) {
      return w(j, N, D, _, 16);
    }
    function S(j, N, D, _) {
      return w(j, N, D, _, 32);
    }
    function P(j, N, D, _) {
      for (var $ = _[0] & 255 | (_[1] & 255) << 8 | (_[2] & 255) << 16 | (_[3] & 255) << 24, Y = D[0] & 255 | (D[1] & 255) << 8 | (D[2] & 255) << 16 | (D[3] & 255) << 24, ie = D[4] & 255 | (D[5] & 255) << 8 | (D[6] & 255) << 16 | (D[7] & 255) << 24, ce = D[8] & 255 | (D[9] & 255) << 8 | (D[10] & 255) << 16 | (D[11] & 255) << 24, me = D[12] & 255 | (D[13] & 255) << 8 | (D[14] & 255) << 16 | (D[15] & 255) << 24, Me = _[4] & 255 | (_[5] & 255) << 8 | (_[6] & 255) << 16 | (_[7] & 255) << 24, Se = N[0] & 255 | (N[1] & 255) << 8 | (N[2] & 255) << 16 | (N[3] & 255) << 24, Ge = N[4] & 255 | (N[5] & 255) << 8 | (N[6] & 255) << 16 | (N[7] & 255) << 24, Be = N[8] & 255 | (N[9] & 255) << 8 | (N[10] & 255) << 16 | (N[11] & 255) << 24, Ye = N[12] & 255 | (N[13] & 255) << 8 | (N[14] & 255) << 16 | (N[15] & 255) << 24, Pe = _[8] & 255 | (_[9] & 255) << 8 | (_[10] & 255) << 16 | (_[11] & 255) << 24, et = D[16] & 255 | (D[17] & 255) << 8 | (D[18] & 255) << 16 | (D[19] & 255) << 24, nt = D[20] & 255 | (D[21] & 255) << 8 | (D[22] & 255) << 16 | (D[23] & 255) << 24, Qe = D[24] & 255 | (D[25] & 255) << 8 | (D[26] & 255) << 16 | (D[27] & 255) << 24, pt = D[28] & 255 | (D[29] & 255) << 8 | (D[30] & 255) << 16 | (D[31] & 255) << 24, ut = _[12] & 255 | (_[13] & 255) << 8 | (_[14] & 255) << 16 | (_[15] & 255) << 24, Le = $, it = Y, je = ie, He = ce, We = me, Fe = Me, ye = Se, be = Ge, Re = Be, Te = Ye, Ie = Pe, De = et, xt = nt, Rt = Qe, Ot = pt, It = ut, ue, qt = 0; qt < 20; qt += 2)
        ue = Le + xt | 0, We ^= ue << 7 | ue >>> 25, ue = We + Le | 0, Re ^= ue << 9 | ue >>> 23, ue = Re + We | 0, xt ^= ue << 13 | ue >>> 19, ue = xt + Re | 0, Le ^= ue << 18 | ue >>> 14, ue = Fe + it | 0, Te ^= ue << 7 | ue >>> 25, ue = Te + Fe | 0, Rt ^= ue << 9 | ue >>> 23, ue = Rt + Te | 0, it ^= ue << 13 | ue >>> 19, ue = it + Rt | 0, Fe ^= ue << 18 | ue >>> 14, ue = Ie + ye | 0, Ot ^= ue << 7 | ue >>> 25, ue = Ot + Ie | 0, je ^= ue << 9 | ue >>> 23, ue = je + Ot | 0, ye ^= ue << 13 | ue >>> 19, ue = ye + je | 0, Ie ^= ue << 18 | ue >>> 14, ue = It + De | 0, He ^= ue << 7 | ue >>> 25, ue = He + It | 0, be ^= ue << 9 | ue >>> 23, ue = be + He | 0, De ^= ue << 13 | ue >>> 19, ue = De + be | 0, It ^= ue << 18 | ue >>> 14, ue = Le + He | 0, it ^= ue << 7 | ue >>> 25, ue = it + Le | 0, je ^= ue << 9 | ue >>> 23, ue = je + it | 0, He ^= ue << 13 | ue >>> 19, ue = He + je | 0, Le ^= ue << 18 | ue >>> 14, ue = Fe + We | 0, ye ^= ue << 7 | ue >>> 25, ue = ye + Fe | 0, be ^= ue << 9 | ue >>> 23, ue = be + ye | 0, We ^= ue << 13 | ue >>> 19, ue = We + be | 0, Fe ^= ue << 18 | ue >>> 14, ue = Ie + Te | 0, De ^= ue << 7 | ue >>> 25, ue = De + Ie | 0, Re ^= ue << 9 | ue >>> 23, ue = Re + De | 0, Te ^= ue << 13 | ue >>> 19, ue = Te + Re | 0, Ie ^= ue << 18 | ue >>> 14, ue = It + Ot | 0, xt ^= ue << 7 | ue >>> 25, ue = xt + It | 0, Rt ^= ue << 9 | ue >>> 23, ue = Rt + xt | 0, Ot ^= ue << 13 | ue >>> 19, ue = Ot + Rt | 0, It ^= ue << 18 | ue >>> 14;
      Le = Le + $ | 0, it = it + Y | 0, je = je + ie | 0, He = He + ce | 0, We = We + me | 0, Fe = Fe + Me | 0, ye = ye + Se | 0, be = be + Ge | 0, Re = Re + Be | 0, Te = Te + Ye | 0, Ie = Ie + Pe | 0, De = De + et | 0, xt = xt + nt | 0, Rt = Rt + Qe | 0, Ot = Ot + pt | 0, It = It + ut | 0, j[0] = Le >>> 0 & 255, j[1] = Le >>> 8 & 255, j[2] = Le >>> 16 & 255, j[3] = Le >>> 24 & 255, j[4] = it >>> 0 & 255, j[5] = it >>> 8 & 255, j[6] = it >>> 16 & 255, j[7] = it >>> 24 & 255, j[8] = je >>> 0 & 255, j[9] = je >>> 8 & 255, j[10] = je >>> 16 & 255, j[11] = je >>> 24 & 255, j[12] = He >>> 0 & 255, j[13] = He >>> 8 & 255, j[14] = He >>> 16 & 255, j[15] = He >>> 24 & 255, j[16] = We >>> 0 & 255, j[17] = We >>> 8 & 255, j[18] = We >>> 16 & 255, j[19] = We >>> 24 & 255, j[20] = Fe >>> 0 & 255, j[21] = Fe >>> 8 & 255, j[22] = Fe >>> 16 & 255, j[23] = Fe >>> 24 & 255, j[24] = ye >>> 0 & 255, j[25] = ye >>> 8 & 255, j[26] = ye >>> 16 & 255, j[27] = ye >>> 24 & 255, j[28] = be >>> 0 & 255, j[29] = be >>> 8 & 255, j[30] = be >>> 16 & 255, j[31] = be >>> 24 & 255, j[32] = Re >>> 0 & 255, j[33] = Re >>> 8 & 255, j[34] = Re >>> 16 & 255, j[35] = Re >>> 24 & 255, j[36] = Te >>> 0 & 255, j[37] = Te >>> 8 & 255, j[38] = Te >>> 16 & 255, j[39] = Te >>> 24 & 255, j[40] = Ie >>> 0 & 255, j[41] = Ie >>> 8 & 255, j[42] = Ie >>> 16 & 255, j[43] = Ie >>> 24 & 255, j[44] = De >>> 0 & 255, j[45] = De >>> 8 & 255, j[46] = De >>> 16 & 255, j[47] = De >>> 24 & 255, j[48] = xt >>> 0 & 255, j[49] = xt >>> 8 & 255, j[50] = xt >>> 16 & 255, j[51] = xt >>> 24 & 255, j[52] = Rt >>> 0 & 255, j[53] = Rt >>> 8 & 255, j[54] = Rt >>> 16 & 255, j[55] = Rt >>> 24 & 255, j[56] = Ot >>> 0 & 255, j[57] = Ot >>> 8 & 255, j[58] = Ot >>> 16 & 255, j[59] = Ot >>> 24 & 255, j[60] = It >>> 0 & 255, j[61] = It >>> 8 & 255, j[62] = It >>> 16 & 255, j[63] = It >>> 24 & 255;
    }
    function L(j, N, D, _) {
      for (var $ = _[0] & 255 | (_[1] & 255) << 8 | (_[2] & 255) << 16 | (_[3] & 255) << 24, Y = D[0] & 255 | (D[1] & 255) << 8 | (D[2] & 255) << 16 | (D[3] & 255) << 24, ie = D[4] & 255 | (D[5] & 255) << 8 | (D[6] & 255) << 16 | (D[7] & 255) << 24, ce = D[8] & 255 | (D[9] & 255) << 8 | (D[10] & 255) << 16 | (D[11] & 255) << 24, me = D[12] & 255 | (D[13] & 255) << 8 | (D[14] & 255) << 16 | (D[15] & 255) << 24, Me = _[4] & 255 | (_[5] & 255) << 8 | (_[6] & 255) << 16 | (_[7] & 255) << 24, Se = N[0] & 255 | (N[1] & 255) << 8 | (N[2] & 255) << 16 | (N[3] & 255) << 24, Ge = N[4] & 255 | (N[5] & 255) << 8 | (N[6] & 255) << 16 | (N[7] & 255) << 24, Be = N[8] & 255 | (N[9] & 255) << 8 | (N[10] & 255) << 16 | (N[11] & 255) << 24, Ye = N[12] & 255 | (N[13] & 255) << 8 | (N[14] & 255) << 16 | (N[15] & 255) << 24, Pe = _[8] & 255 | (_[9] & 255) << 8 | (_[10] & 255) << 16 | (_[11] & 255) << 24, et = D[16] & 255 | (D[17] & 255) << 8 | (D[18] & 255) << 16 | (D[19] & 255) << 24, nt = D[20] & 255 | (D[21] & 255) << 8 | (D[22] & 255) << 16 | (D[23] & 255) << 24, Qe = D[24] & 255 | (D[25] & 255) << 8 | (D[26] & 255) << 16 | (D[27] & 255) << 24, pt = D[28] & 255 | (D[29] & 255) << 8 | (D[30] & 255) << 16 | (D[31] & 255) << 24, ut = _[12] & 255 | (_[13] & 255) << 8 | (_[14] & 255) << 16 | (_[15] & 255) << 24, Le = $, it = Y, je = ie, He = ce, We = me, Fe = Me, ye = Se, be = Ge, Re = Be, Te = Ye, Ie = Pe, De = et, xt = nt, Rt = Qe, Ot = pt, It = ut, ue, qt = 0; qt < 20; qt += 2)
        ue = Le + xt | 0, We ^= ue << 7 | ue >>> 25, ue = We + Le | 0, Re ^= ue << 9 | ue >>> 23, ue = Re + We | 0, xt ^= ue << 13 | ue >>> 19, ue = xt + Re | 0, Le ^= ue << 18 | ue >>> 14, ue = Fe + it | 0, Te ^= ue << 7 | ue >>> 25, ue = Te + Fe | 0, Rt ^= ue << 9 | ue >>> 23, ue = Rt + Te | 0, it ^= ue << 13 | ue >>> 19, ue = it + Rt | 0, Fe ^= ue << 18 | ue >>> 14, ue = Ie + ye | 0, Ot ^= ue << 7 | ue >>> 25, ue = Ot + Ie | 0, je ^= ue << 9 | ue >>> 23, ue = je + Ot | 0, ye ^= ue << 13 | ue >>> 19, ue = ye + je | 0, Ie ^= ue << 18 | ue >>> 14, ue = It + De | 0, He ^= ue << 7 | ue >>> 25, ue = He + It | 0, be ^= ue << 9 | ue >>> 23, ue = be + He | 0, De ^= ue << 13 | ue >>> 19, ue = De + be | 0, It ^= ue << 18 | ue >>> 14, ue = Le + He | 0, it ^= ue << 7 | ue >>> 25, ue = it + Le | 0, je ^= ue << 9 | ue >>> 23, ue = je + it | 0, He ^= ue << 13 | ue >>> 19, ue = He + je | 0, Le ^= ue << 18 | ue >>> 14, ue = Fe + We | 0, ye ^= ue << 7 | ue >>> 25, ue = ye + Fe | 0, be ^= ue << 9 | ue >>> 23, ue = be + ye | 0, We ^= ue << 13 | ue >>> 19, ue = We + be | 0, Fe ^= ue << 18 | ue >>> 14, ue = Ie + Te | 0, De ^= ue << 7 | ue >>> 25, ue = De + Ie | 0, Re ^= ue << 9 | ue >>> 23, ue = Re + De | 0, Te ^= ue << 13 | ue >>> 19, ue = Te + Re | 0, Ie ^= ue << 18 | ue >>> 14, ue = It + Ot | 0, xt ^= ue << 7 | ue >>> 25, ue = xt + It | 0, Rt ^= ue << 9 | ue >>> 23, ue = Rt + xt | 0, Ot ^= ue << 13 | ue >>> 19, ue = Ot + Rt | 0, It ^= ue << 18 | ue >>> 14;
      j[0] = Le >>> 0 & 255, j[1] = Le >>> 8 & 255, j[2] = Le >>> 16 & 255, j[3] = Le >>> 24 & 255, j[4] = Fe >>> 0 & 255, j[5] = Fe >>> 8 & 255, j[6] = Fe >>> 16 & 255, j[7] = Fe >>> 24 & 255, j[8] = Ie >>> 0 & 255, j[9] = Ie >>> 8 & 255, j[10] = Ie >>> 16 & 255, j[11] = Ie >>> 24 & 255, j[12] = It >>> 0 & 255, j[13] = It >>> 8 & 255, j[14] = It >>> 16 & 255, j[15] = It >>> 24 & 255, j[16] = ye >>> 0 & 255, j[17] = ye >>> 8 & 255, j[18] = ye >>> 16 & 255, j[19] = ye >>> 24 & 255, j[20] = be >>> 0 & 255, j[21] = be >>> 8 & 255, j[22] = be >>> 16 & 255, j[23] = be >>> 24 & 255, j[24] = Re >>> 0 & 255, j[25] = Re >>> 8 & 255, j[26] = Re >>> 16 & 255, j[27] = Re >>> 24 & 255, j[28] = Te >>> 0 & 255, j[29] = Te >>> 8 & 255, j[30] = Te >>> 16 & 255, j[31] = Te >>> 24 & 255;
    }
    function U(j, N, D, _) {
      P(j, N, D, _);
    }
    function z(j, N, D, _) {
      L(j, N, D, _);
    }
    var K = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function re(j, N, D, _, $, Y, ie) {
      var ce = new Uint8Array(16), me = new Uint8Array(64), Me, Se;
      for (Se = 0; Se < 16; Se++)
        ce[Se] = 0;
      for (Se = 0; Se < 8; Se++)
        ce[Se] = Y[Se];
      for (; $ >= 64; ) {
        for (U(me, ce, ie, K), Se = 0; Se < 64; Se++)
          j[N + Se] = D[_ + Se] ^ me[Se];
        for (Me = 1, Se = 8; Se < 16; Se++)
          Me = Me + (ce[Se] & 255) | 0, ce[Se] = Me & 255, Me >>>= 8;
        $ -= 64, N += 64, _ += 64;
      }
      if ($ > 0)
        for (U(me, ce, ie, K), Se = 0; Se < $; Se++)
          j[N + Se] = D[_ + Se] ^ me[Se];
      return 0;
    }
    function oe(j, N, D, _, $) {
      var Y = new Uint8Array(16), ie = new Uint8Array(64), ce, me;
      for (me = 0; me < 16; me++)
        Y[me] = 0;
      for (me = 0; me < 8; me++)
        Y[me] = _[me];
      for (; D >= 64; ) {
        for (U(ie, Y, $, K), me = 0; me < 64; me++)
          j[N + me] = ie[me];
        for (ce = 1, me = 8; me < 16; me++)
          ce = ce + (Y[me] & 255) | 0, Y[me] = ce & 255, ce >>>= 8;
        D -= 64, N += 64;
      }
      if (D > 0)
        for (U(ie, Y, $, K), me = 0; me < D; me++)
          j[N + me] = ie[me];
      return 0;
    }
    function se(j, N, D, _, $) {
      var Y = new Uint8Array(32);
      z(Y, _, $, K);
      for (var ie = new Uint8Array(8), ce = 0; ce < 8; ce++)
        ie[ce] = _[ce + 16];
      return oe(j, N, D, ie, Y);
    }
    function ve(j, N, D, _, $, Y, ie) {
      var ce = new Uint8Array(32);
      z(ce, Y, ie, K);
      for (var me = new Uint8Array(8), Me = 0; Me < 8; Me++)
        me[Me] = Y[Me + 16];
      return re(j, N, D, _, $, me, ce);
    }
    var Q = function(j) {
      this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.leftover = 0, this.fin = 0;
      var N, D, _, $, Y, ie, ce, me;
      N = j[0] & 255 | (j[1] & 255) << 8, this.r[0] = N & 8191, D = j[2] & 255 | (j[3] & 255) << 8, this.r[1] = (N >>> 13 | D << 3) & 8191, _ = j[4] & 255 | (j[5] & 255) << 8, this.r[2] = (D >>> 10 | _ << 6) & 7939, $ = j[6] & 255 | (j[7] & 255) << 8, this.r[3] = (_ >>> 7 | $ << 9) & 8191, Y = j[8] & 255 | (j[9] & 255) << 8, this.r[4] = ($ >>> 4 | Y << 12) & 255, this.r[5] = Y >>> 1 & 8190, ie = j[10] & 255 | (j[11] & 255) << 8, this.r[6] = (Y >>> 14 | ie << 2) & 8191, ce = j[12] & 255 | (j[13] & 255) << 8, this.r[7] = (ie >>> 11 | ce << 5) & 8065, me = j[14] & 255 | (j[15] & 255) << 8, this.r[8] = (ce >>> 8 | me << 8) & 8191, this.r[9] = me >>> 5 & 127, this.pad[0] = j[16] & 255 | (j[17] & 255) << 8, this.pad[1] = j[18] & 255 | (j[19] & 255) << 8, this.pad[2] = j[20] & 255 | (j[21] & 255) << 8, this.pad[3] = j[22] & 255 | (j[23] & 255) << 8, this.pad[4] = j[24] & 255 | (j[25] & 255) << 8, this.pad[5] = j[26] & 255 | (j[27] & 255) << 8, this.pad[6] = j[28] & 255 | (j[29] & 255) << 8, this.pad[7] = j[30] & 255 | (j[31] & 255) << 8;
    };
    Q.prototype.blocks = function(j, N, D) {
      for (var _ = this.fin ? 0 : 2048, $, Y, ie, ce, me, Me, Se, Ge, Be, Ye, Pe, et, nt, Qe, pt, ut, Le, it, je, He = this.h[0], We = this.h[1], Fe = this.h[2], ye = this.h[3], be = this.h[4], Re = this.h[5], Te = this.h[6], Ie = this.h[7], De = this.h[8], xt = this.h[9], Rt = this.r[0], Ot = this.r[1], It = this.r[2], ue = this.r[3], qt = this.r[4], Qt = this.r[5], Gt = this.r[6], Pt = this.r[7], Wt = this.r[8], zt = this.r[9]; D >= 16; )
        $ = j[N + 0] & 255 | (j[N + 1] & 255) << 8, He += $ & 8191, Y = j[N + 2] & 255 | (j[N + 3] & 255) << 8, We += ($ >>> 13 | Y << 3) & 8191, ie = j[N + 4] & 255 | (j[N + 5] & 255) << 8, Fe += (Y >>> 10 | ie << 6) & 8191, ce = j[N + 6] & 255 | (j[N + 7] & 255) << 8, ye += (ie >>> 7 | ce << 9) & 8191, me = j[N + 8] & 255 | (j[N + 9] & 255) << 8, be += (ce >>> 4 | me << 12) & 8191, Re += me >>> 1 & 8191, Me = j[N + 10] & 255 | (j[N + 11] & 255) << 8, Te += (me >>> 14 | Me << 2) & 8191, Se = j[N + 12] & 255 | (j[N + 13] & 255) << 8, Ie += (Me >>> 11 | Se << 5) & 8191, Ge = j[N + 14] & 255 | (j[N + 15] & 255) << 8, De += (Se >>> 8 | Ge << 8) & 8191, xt += Ge >>> 5 | _, Be = 0, Ye = Be, Ye += He * Rt, Ye += We * (5 * zt), Ye += Fe * (5 * Wt), Ye += ye * (5 * Pt), Ye += be * (5 * Gt), Be = Ye >>> 13, Ye &= 8191, Ye += Re * (5 * Qt), Ye += Te * (5 * qt), Ye += Ie * (5 * ue), Ye += De * (5 * It), Ye += xt * (5 * Ot), Be += Ye >>> 13, Ye &= 8191, Pe = Be, Pe += He * Ot, Pe += We * Rt, Pe += Fe * (5 * zt), Pe += ye * (5 * Wt), Pe += be * (5 * Pt), Be = Pe >>> 13, Pe &= 8191, Pe += Re * (5 * Gt), Pe += Te * (5 * Qt), Pe += Ie * (5 * qt), Pe += De * (5 * ue), Pe += xt * (5 * It), Be += Pe >>> 13, Pe &= 8191, et = Be, et += He * It, et += We * Ot, et += Fe * Rt, et += ye * (5 * zt), et += be * (5 * Wt), Be = et >>> 13, et &= 8191, et += Re * (5 * Pt), et += Te * (5 * Gt), et += Ie * (5 * Qt), et += De * (5 * qt), et += xt * (5 * ue), Be += et >>> 13, et &= 8191, nt = Be, nt += He * ue, nt += We * It, nt += Fe * Ot, nt += ye * Rt, nt += be * (5 * zt), Be = nt >>> 13, nt &= 8191, nt += Re * (5 * Wt), nt += Te * (5 * Pt), nt += Ie * (5 * Gt), nt += De * (5 * Qt), nt += xt * (5 * qt), Be += nt >>> 13, nt &= 8191, Qe = Be, Qe += He * qt, Qe += We * ue, Qe += Fe * It, Qe += ye * Ot, Qe += be * Rt, Be = Qe >>> 13, Qe &= 8191, Qe += Re * (5 * zt), Qe += Te * (5 * Wt), Qe += Ie * (5 * Pt), Qe += De * (5 * Gt), Qe += xt * (5 * Qt), Be += Qe >>> 13, Qe &= 8191, pt = Be, pt += He * Qt, pt += We * qt, pt += Fe * ue, pt += ye * It, pt += be * Ot, Be = pt >>> 13, pt &= 8191, pt += Re * Rt, pt += Te * (5 * zt), pt += Ie * (5 * Wt), pt += De * (5 * Pt), pt += xt * (5 * Gt), Be += pt >>> 13, pt &= 8191, ut = Be, ut += He * Gt, ut += We * Qt, ut += Fe * qt, ut += ye * ue, ut += be * It, Be = ut >>> 13, ut &= 8191, ut += Re * Ot, ut += Te * Rt, ut += Ie * (5 * zt), ut += De * (5 * Wt), ut += xt * (5 * Pt), Be += ut >>> 13, ut &= 8191, Le = Be, Le += He * Pt, Le += We * Gt, Le += Fe * Qt, Le += ye * qt, Le += be * ue, Be = Le >>> 13, Le &= 8191, Le += Re * It, Le += Te * Ot, Le += Ie * Rt, Le += De * (5 * zt), Le += xt * (5 * Wt), Be += Le >>> 13, Le &= 8191, it = Be, it += He * Wt, it += We * Pt, it += Fe * Gt, it += ye * Qt, it += be * qt, Be = it >>> 13, it &= 8191, it += Re * ue, it += Te * It, it += Ie * Ot, it += De * Rt, it += xt * (5 * zt), Be += it >>> 13, it &= 8191, je = Be, je += He * zt, je += We * Wt, je += Fe * Pt, je += ye * Gt, je += be * Qt, Be = je >>> 13, je &= 8191, je += Re * qt, je += Te * ue, je += Ie * It, je += De * Ot, je += xt * Rt, Be += je >>> 13, je &= 8191, Be = (Be << 2) + Be | 0, Be = Be + Ye | 0, Ye = Be & 8191, Be = Be >>> 13, Pe += Be, He = Ye, We = Pe, Fe = et, ye = nt, be = Qe, Re = pt, Te = ut, Ie = Le, De = it, xt = je, N += 16, D -= 16;
      this.h[0] = He, this.h[1] = We, this.h[2] = Fe, this.h[3] = ye, this.h[4] = be, this.h[5] = Re, this.h[6] = Te, this.h[7] = Ie, this.h[8] = De, this.h[9] = xt;
    }, Q.prototype.finish = function(j, N) {
      var D = new Uint16Array(10), _, $, Y, ie;
      if (this.leftover) {
        for (ie = this.leftover, this.buffer[ie++] = 1; ie < 16; ie++)
          this.buffer[ie] = 0;
        this.fin = 1, this.blocks(this.buffer, 0, 16);
      }
      for (_ = this.h[1] >>> 13, this.h[1] &= 8191, ie = 2; ie < 10; ie++)
        this.h[ie] += _, _ = this.h[ie] >>> 13, this.h[ie] &= 8191;
      for (this.h[0] += _ * 5, _ = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += _, _ = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += _, D[0] = this.h[0] + 5, _ = D[0] >>> 13, D[0] &= 8191, ie = 1; ie < 10; ie++)
        D[ie] = this.h[ie] + _, _ = D[ie] >>> 13, D[ie] &= 8191;
      for (D[9] -= 8192, $ = (_ ^ 1) - 1, ie = 0; ie < 10; ie++)
        D[ie] &= $;
      for ($ = ~$, ie = 0; ie < 10; ie++)
        this.h[ie] = this.h[ie] & $ | D[ie];
      for (this.h[0] = (this.h[0] | this.h[1] << 13) & 65535, this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535, this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535, this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535, this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535, this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535, this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535, this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535, Y = this.h[0] + this.pad[0], this.h[0] = Y & 65535, ie = 1; ie < 8; ie++)
        Y = (this.h[ie] + this.pad[ie] | 0) + (Y >>> 16) | 0, this.h[ie] = Y & 65535;
      j[N + 0] = this.h[0] >>> 0 & 255, j[N + 1] = this.h[0] >>> 8 & 255, j[N + 2] = this.h[1] >>> 0 & 255, j[N + 3] = this.h[1] >>> 8 & 255, j[N + 4] = this.h[2] >>> 0 & 255, j[N + 5] = this.h[2] >>> 8 & 255, j[N + 6] = this.h[3] >>> 0 & 255, j[N + 7] = this.h[3] >>> 8 & 255, j[N + 8] = this.h[4] >>> 0 & 255, j[N + 9] = this.h[4] >>> 8 & 255, j[N + 10] = this.h[5] >>> 0 & 255, j[N + 11] = this.h[5] >>> 8 & 255, j[N + 12] = this.h[6] >>> 0 & 255, j[N + 13] = this.h[6] >>> 8 & 255, j[N + 14] = this.h[7] >>> 0 & 255, j[N + 15] = this.h[7] >>> 8 & 255;
    }, Q.prototype.update = function(j, N, D) {
      var _, $;
      if (this.leftover) {
        for ($ = 16 - this.leftover, $ > D && ($ = D), _ = 0; _ < $; _++)
          this.buffer[this.leftover + _] = j[N + _];
        if (D -= $, N += $, this.leftover += $, this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16), this.leftover = 0;
      }
      if (D >= 16 && ($ = D - D % 16, this.blocks(j, N, $), N += $, D -= $), D) {
        for (_ = 0; _ < D; _++)
          this.buffer[this.leftover + _] = j[N + _];
        this.leftover += D;
      }
    };
    function A(j, N, D, _, $, Y) {
      var ie = new Q(Y);
      return ie.update(D, _, $), ie.finish(j, N), 0;
    }
    function b(j, N, D, _, $, Y) {
      var ie = new Uint8Array(16);
      return A(ie, 0, D, _, $, Y), E(j, N, ie, 0);
    }
    function f(j, N, D, _, $) {
      var Y;
      if (D < 32)
        return -1;
      for (ve(j, 0, N, 0, D, _, $), A(j, 16, j, 32, D - 32, j), Y = 0; Y < 16; Y++)
        j[Y] = 0;
      return 0;
    }
    function v(j, N, D, _, $) {
      var Y, ie = new Uint8Array(32);
      if (D < 32 || (se(ie, 0, 32, _, $), b(N, 16, N, 32, D - 32, ie) !== 0))
        return -1;
      for (ve(j, 0, N, 0, D, _, $), Y = 0; Y < 32; Y++)
        j[Y] = 0;
      return 0;
    }
    function g(j, N) {
      var D;
      for (D = 0; D < 16; D++)
        j[D] = N[D] | 0;
    }
    function M(j) {
      var N, D, _ = 1;
      for (N = 0; N < 16; N++)
        D = j[N] + _ + 65535, _ = Math.floor(D / 65536), j[N] = D - _ * 65536;
      j[0] += _ - 1 + 37 * (_ - 1);
    }
    function I(j, N, D) {
      for (var _, $ = ~(D - 1), Y = 0; Y < 16; Y++)
        _ = $ & (j[Y] ^ N[Y]), j[Y] ^= _, N[Y] ^= _;
    }
    function R(j, N) {
      var D, _, $, Y = t(), ie = t();
      for (D = 0; D < 16; D++)
        ie[D] = N[D];
      for (M(ie), M(ie), M(ie), _ = 0; _ < 2; _++) {
        for (Y[0] = ie[0] - 65517, D = 1; D < 15; D++)
          Y[D] = ie[D] - 65535 - (Y[D - 1] >> 16 & 1), Y[D - 1] &= 65535;
        Y[15] = ie[15] - 32767 - (Y[14] >> 16 & 1), $ = Y[15] >> 16 & 1, Y[14] &= 65535, I(ie, Y, 1 - $);
      }
      for (D = 0; D < 16; D++)
        j[2 * D] = ie[D] & 255, j[2 * D + 1] = ie[D] >> 8;
    }
    function x(j, N) {
      var D = new Uint8Array(32), _ = new Uint8Array(32);
      return R(D, j), R(_, N), S(D, 0, _, 0);
    }
    function T(j) {
      var N = new Uint8Array(32);
      return R(N, j), N[0] & 1;
    }
    function p(j, N) {
      var D;
      for (D = 0; D < 16; D++)
        j[D] = N[2 * D] + (N[2 * D + 1] << 8);
      j[15] &= 32767;
    }
    function B(j, N, D) {
      for (var _ = 0; _ < 16; _++)
        j[_] = N[_] + D[_];
    }
    function ee(j, N, D) {
      for (var _ = 0; _ < 16; _++)
        j[_] = N[_] - D[_];
    }
    function ae(j, N, D) {
      var _, $, Y = 0, ie = 0, ce = 0, me = 0, Me = 0, Se = 0, Ge = 0, Be = 0, Ye = 0, Pe = 0, et = 0, nt = 0, Qe = 0, pt = 0, ut = 0, Le = 0, it = 0, je = 0, He = 0, We = 0, Fe = 0, ye = 0, be = 0, Re = 0, Te = 0, Ie = 0, De = 0, xt = 0, Rt = 0, Ot = 0, It = 0, ue = D[0], qt = D[1], Qt = D[2], Gt = D[3], Pt = D[4], Wt = D[5], zt = D[6], pr = D[7], er = D[8], cr = D[9], hr = D[10], lr = D[11], br = D[12], Sr = D[13], Er = D[14], Mr = D[15];
      _ = N[0], Y += _ * ue, ie += _ * qt, ce += _ * Qt, me += _ * Gt, Me += _ * Pt, Se += _ * Wt, Ge += _ * zt, Be += _ * pr, Ye += _ * er, Pe += _ * cr, et += _ * hr, nt += _ * lr, Qe += _ * br, pt += _ * Sr, ut += _ * Er, Le += _ * Mr, _ = N[1], ie += _ * ue, ce += _ * qt, me += _ * Qt, Me += _ * Gt, Se += _ * Pt, Ge += _ * Wt, Be += _ * zt, Ye += _ * pr, Pe += _ * er, et += _ * cr, nt += _ * hr, Qe += _ * lr, pt += _ * br, ut += _ * Sr, Le += _ * Er, it += _ * Mr, _ = N[2], ce += _ * ue, me += _ * qt, Me += _ * Qt, Se += _ * Gt, Ge += _ * Pt, Be += _ * Wt, Ye += _ * zt, Pe += _ * pr, et += _ * er, nt += _ * cr, Qe += _ * hr, pt += _ * lr, ut += _ * br, Le += _ * Sr, it += _ * Er, je += _ * Mr, _ = N[3], me += _ * ue, Me += _ * qt, Se += _ * Qt, Ge += _ * Gt, Be += _ * Pt, Ye += _ * Wt, Pe += _ * zt, et += _ * pr, nt += _ * er, Qe += _ * cr, pt += _ * hr, ut += _ * lr, Le += _ * br, it += _ * Sr, je += _ * Er, He += _ * Mr, _ = N[4], Me += _ * ue, Se += _ * qt, Ge += _ * Qt, Be += _ * Gt, Ye += _ * Pt, Pe += _ * Wt, et += _ * zt, nt += _ * pr, Qe += _ * er, pt += _ * cr, ut += _ * hr, Le += _ * lr, it += _ * br, je += _ * Sr, He += _ * Er, We += _ * Mr, _ = N[5], Se += _ * ue, Ge += _ * qt, Be += _ * Qt, Ye += _ * Gt, Pe += _ * Pt, et += _ * Wt, nt += _ * zt, Qe += _ * pr, pt += _ * er, ut += _ * cr, Le += _ * hr, it += _ * lr, je += _ * br, He += _ * Sr, We += _ * Er, Fe += _ * Mr, _ = N[6], Ge += _ * ue, Be += _ * qt, Ye += _ * Qt, Pe += _ * Gt, et += _ * Pt, nt += _ * Wt, Qe += _ * zt, pt += _ * pr, ut += _ * er, Le += _ * cr, it += _ * hr, je += _ * lr, He += _ * br, We += _ * Sr, Fe += _ * Er, ye += _ * Mr, _ = N[7], Be += _ * ue, Ye += _ * qt, Pe += _ * Qt, et += _ * Gt, nt += _ * Pt, Qe += _ * Wt, pt += _ * zt, ut += _ * pr, Le += _ * er, it += _ * cr, je += _ * hr, He += _ * lr, We += _ * br, Fe += _ * Sr, ye += _ * Er, be += _ * Mr, _ = N[8], Ye += _ * ue, Pe += _ * qt, et += _ * Qt, nt += _ * Gt, Qe += _ * Pt, pt += _ * Wt, ut += _ * zt, Le += _ * pr, it += _ * er, je += _ * cr, He += _ * hr, We += _ * lr, Fe += _ * br, ye += _ * Sr, be += _ * Er, Re += _ * Mr, _ = N[9], Pe += _ * ue, et += _ * qt, nt += _ * Qt, Qe += _ * Gt, pt += _ * Pt, ut += _ * Wt, Le += _ * zt, it += _ * pr, je += _ * er, He += _ * cr, We += _ * hr, Fe += _ * lr, ye += _ * br, be += _ * Sr, Re += _ * Er, Te += _ * Mr, _ = N[10], et += _ * ue, nt += _ * qt, Qe += _ * Qt, pt += _ * Gt, ut += _ * Pt, Le += _ * Wt, it += _ * zt, je += _ * pr, He += _ * er, We += _ * cr, Fe += _ * hr, ye += _ * lr, be += _ * br, Re += _ * Sr, Te += _ * Er, Ie += _ * Mr, _ = N[11], nt += _ * ue, Qe += _ * qt, pt += _ * Qt, ut += _ * Gt, Le += _ * Pt, it += _ * Wt, je += _ * zt, He += _ * pr, We += _ * er, Fe += _ * cr, ye += _ * hr, be += _ * lr, Re += _ * br, Te += _ * Sr, Ie += _ * Er, De += _ * Mr, _ = N[12], Qe += _ * ue, pt += _ * qt, ut += _ * Qt, Le += _ * Gt, it += _ * Pt, je += _ * Wt, He += _ * zt, We += _ * pr, Fe += _ * er, ye += _ * cr, be += _ * hr, Re += _ * lr, Te += _ * br, Ie += _ * Sr, De += _ * Er, xt += _ * Mr, _ = N[13], pt += _ * ue, ut += _ * qt, Le += _ * Qt, it += _ * Gt, je += _ * Pt, He += _ * Wt, We += _ * zt, Fe += _ * pr, ye += _ * er, be += _ * cr, Re += _ * hr, Te += _ * lr, Ie += _ * br, De += _ * Sr, xt += _ * Er, Rt += _ * Mr, _ = N[14], ut += _ * ue, Le += _ * qt, it += _ * Qt, je += _ * Gt, He += _ * Pt, We += _ * Wt, Fe += _ * zt, ye += _ * pr, be += _ * er, Re += _ * cr, Te += _ * hr, Ie += _ * lr, De += _ * br, xt += _ * Sr, Rt += _ * Er, Ot += _ * Mr, _ = N[15], Le += _ * ue, it += _ * qt, je += _ * Qt, He += _ * Gt, We += _ * Pt, Fe += _ * Wt, ye += _ * zt, be += _ * pr, Re += _ * er, Te += _ * cr, Ie += _ * hr, De += _ * lr, xt += _ * br, Rt += _ * Sr, Ot += _ * Er, It += _ * Mr, Y += 38 * it, ie += 38 * je, ce += 38 * He, me += 38 * We, Me += 38 * Fe, Se += 38 * ye, Ge += 38 * be, Be += 38 * Re, Ye += 38 * Te, Pe += 38 * Ie, et += 38 * De, nt += 38 * xt, Qe += 38 * Rt, pt += 38 * Ot, ut += 38 * It, $ = 1, _ = Y + $ + 65535, $ = Math.floor(_ / 65536), Y = _ - $ * 65536, _ = ie + $ + 65535, $ = Math.floor(_ / 65536), ie = _ - $ * 65536, _ = ce + $ + 65535, $ = Math.floor(_ / 65536), ce = _ - $ * 65536, _ = me + $ + 65535, $ = Math.floor(_ / 65536), me = _ - $ * 65536, _ = Me + $ + 65535, $ = Math.floor(_ / 65536), Me = _ - $ * 65536, _ = Se + $ + 65535, $ = Math.floor(_ / 65536), Se = _ - $ * 65536, _ = Ge + $ + 65535, $ = Math.floor(_ / 65536), Ge = _ - $ * 65536, _ = Be + $ + 65535, $ = Math.floor(_ / 65536), Be = _ - $ * 65536, _ = Ye + $ + 65535, $ = Math.floor(_ / 65536), Ye = _ - $ * 65536, _ = Pe + $ + 65535, $ = Math.floor(_ / 65536), Pe = _ - $ * 65536, _ = et + $ + 65535, $ = Math.floor(_ / 65536), et = _ - $ * 65536, _ = nt + $ + 65535, $ = Math.floor(_ / 65536), nt = _ - $ * 65536, _ = Qe + $ + 65535, $ = Math.floor(_ / 65536), Qe = _ - $ * 65536, _ = pt + $ + 65535, $ = Math.floor(_ / 65536), pt = _ - $ * 65536, _ = ut + $ + 65535, $ = Math.floor(_ / 65536), ut = _ - $ * 65536, _ = Le + $ + 65535, $ = Math.floor(_ / 65536), Le = _ - $ * 65536, Y += $ - 1 + 37 * ($ - 1), $ = 1, _ = Y + $ + 65535, $ = Math.floor(_ / 65536), Y = _ - $ * 65536, _ = ie + $ + 65535, $ = Math.floor(_ / 65536), ie = _ - $ * 65536, _ = ce + $ + 65535, $ = Math.floor(_ / 65536), ce = _ - $ * 65536, _ = me + $ + 65535, $ = Math.floor(_ / 65536), me = _ - $ * 65536, _ = Me + $ + 65535, $ = Math.floor(_ / 65536), Me = _ - $ * 65536, _ = Se + $ + 65535, $ = Math.floor(_ / 65536), Se = _ - $ * 65536, _ = Ge + $ + 65535, $ = Math.floor(_ / 65536), Ge = _ - $ * 65536, _ = Be + $ + 65535, $ = Math.floor(_ / 65536), Be = _ - $ * 65536, _ = Ye + $ + 65535, $ = Math.floor(_ / 65536), Ye = _ - $ * 65536, _ = Pe + $ + 65535, $ = Math.floor(_ / 65536), Pe = _ - $ * 65536, _ = et + $ + 65535, $ = Math.floor(_ / 65536), et = _ - $ * 65536, _ = nt + $ + 65535, $ = Math.floor(_ / 65536), nt = _ - $ * 65536, _ = Qe + $ + 65535, $ = Math.floor(_ / 65536), Qe = _ - $ * 65536, _ = pt + $ + 65535, $ = Math.floor(_ / 65536), pt = _ - $ * 65536, _ = ut + $ + 65535, $ = Math.floor(_ / 65536), ut = _ - $ * 65536, _ = Le + $ + 65535, $ = Math.floor(_ / 65536), Le = _ - $ * 65536, Y += $ - 1 + 37 * ($ - 1), j[0] = Y, j[1] = ie, j[2] = ce, j[3] = me, j[4] = Me, j[5] = Se, j[6] = Ge, j[7] = Be, j[8] = Ye, j[9] = Pe, j[10] = et, j[11] = nt, j[12] = Qe, j[13] = pt, j[14] = ut, j[15] = Le;
    }
    function Z(j, N) {
      ae(j, N, N);
    }
    function ne(j, N) {
      var D = t(), _;
      for (_ = 0; _ < 16; _++)
        D[_] = N[_];
      for (_ = 253; _ >= 0; _--)
        Z(D, D), _ !== 2 && _ !== 4 && ae(D, D, N);
      for (_ = 0; _ < 16; _++)
        j[_] = D[_];
    }
    function fe(j, N) {
      var D = t(), _;
      for (_ = 0; _ < 16; _++)
        D[_] = N[_];
      for (_ = 250; _ >= 0; _--)
        Z(D, D), _ !== 1 && ae(D, D, N);
      for (_ = 0; _ < 16; _++)
        j[_] = D[_];
    }
    function le(j, N, D) {
      var _ = new Uint8Array(32), $ = new Float64Array(80), Y, ie, ce = t(), me = t(), Me = t(), Se = t(), Ge = t(), Be = t();
      for (ie = 0; ie < 31; ie++)
        _[ie] = N[ie];
      for (_[31] = N[31] & 127 | 64, _[0] &= 248, p($, D), ie = 0; ie < 16; ie++)
        me[ie] = $[ie], Se[ie] = ce[ie] = Me[ie] = 0;
      for (ce[0] = Se[0] = 1, ie = 254; ie >= 0; --ie)
        Y = _[ie >>> 3] >>> (ie & 7) & 1, I(ce, me, Y), I(Me, Se, Y), B(Ge, ce, Me), ee(ce, ce, Me), B(Me, me, Se), ee(me, me, Se), Z(Se, Ge), Z(Be, ce), ae(ce, Me, ce), ae(Me, me, Ge), B(Ge, ce, Me), ee(ce, ce, Me), Z(me, ce), ee(Me, Se, Be), ae(ce, Me, c), B(ce, ce, Se), ae(Me, Me, ce), ae(ce, Se, Be), ae(Se, me, $), Z(me, Ge), I(ce, me, Y), I(Me, Se, Y);
      for (ie = 0; ie < 16; ie++)
        $[ie + 16] = ce[ie], $[ie + 32] = Me[ie], $[ie + 48] = me[ie], $[ie + 64] = Se[ie];
      var Ye = $.subarray(32), Pe = $.subarray(16);
      return ne(Ye, Ye), ae(Pe, Pe, Ye), R(j, Pe), 0;
    }
    function ke(j, N) {
      return le(j, N, i);
    }
    function X(j, N) {
      return n(N, 32), ke(j, N);
    }
    function G(j, N, D) {
      var _ = new Uint8Array(32);
      return le(_, D, N), z(j, a, _, K);
    }
    var we = f, Ae = v;
    function Oe(j, N, D, _, $, Y) {
      var ie = new Uint8Array(32);
      return G(ie, $, Y), we(j, N, D, _, ie);
    }
    function qe(j, N, D, _, $, Y) {
      var ie = new Uint8Array(32);
      return G(ie, $, Y), Ae(j, N, D, _, ie);
    }
    var Ue = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function ze(j, N, D, _) {
      for (var $ = new Int32Array(16), Y = new Int32Array(16), ie, ce, me, Me, Se, Ge, Be, Ye, Pe, et, nt, Qe, pt, ut, Le, it, je, He, We, Fe, ye, be, Re, Te, Ie, De, xt = j[0], Rt = j[1], Ot = j[2], It = j[3], ue = j[4], qt = j[5], Qt = j[6], Gt = j[7], Pt = N[0], Wt = N[1], zt = N[2], pr = N[3], er = N[4], cr = N[5], hr = N[6], lr = N[7], br = 0; _ >= 128; ) {
        for (We = 0; We < 16; We++)
          Fe = 8 * We + br, $[We] = D[Fe + 0] << 24 | D[Fe + 1] << 16 | D[Fe + 2] << 8 | D[Fe + 3], Y[We] = D[Fe + 4] << 24 | D[Fe + 5] << 16 | D[Fe + 6] << 8 | D[Fe + 7];
        for (We = 0; We < 80; We++)
          if (ie = xt, ce = Rt, me = Ot, Me = It, Se = ue, Ge = qt, Be = Qt, Ye = Gt, Pe = Pt, et = Wt, nt = zt, Qe = pr, pt = er, ut = cr, Le = hr, it = lr, ye = Gt, be = lr, Re = be & 65535, Te = be >>> 16, Ie = ye & 65535, De = ye >>> 16, ye = (ue >>> 14 | er << 18) ^ (ue >>> 18 | er << 14) ^ (er >>> 9 | ue << 23), be = (er >>> 14 | ue << 18) ^ (er >>> 18 | ue << 14) ^ (ue >>> 9 | er << 23), Re += be & 65535, Te += be >>> 16, Ie += ye & 65535, De += ye >>> 16, ye = ue & qt ^ ~ue & Qt, be = er & cr ^ ~er & hr, Re += be & 65535, Te += be >>> 16, Ie += ye & 65535, De += ye >>> 16, ye = Ue[We * 2], be = Ue[We * 2 + 1], Re += be & 65535, Te += be >>> 16, Ie += ye & 65535, De += ye >>> 16, ye = $[We % 16], be = Y[We % 16], Re += be & 65535, Te += be >>> 16, Ie += ye & 65535, De += ye >>> 16, Te += Re >>> 16, Ie += Te >>> 16, De += Ie >>> 16, je = Ie & 65535 | De << 16, He = Re & 65535 | Te << 16, ye = je, be = He, Re = be & 65535, Te = be >>> 16, Ie = ye & 65535, De = ye >>> 16, ye = (xt >>> 28 | Pt << 4) ^ (Pt >>> 2 | xt << 30) ^ (Pt >>> 7 | xt << 25), be = (Pt >>> 28 | xt << 4) ^ (xt >>> 2 | Pt << 30) ^ (xt >>> 7 | Pt << 25), Re += be & 65535, Te += be >>> 16, Ie += ye & 65535, De += ye >>> 16, ye = xt & Rt ^ xt & Ot ^ Rt & Ot, be = Pt & Wt ^ Pt & zt ^ Wt & zt, Re += be & 65535, Te += be >>> 16, Ie += ye & 65535, De += ye >>> 16, Te += Re >>> 16, Ie += Te >>> 16, De += Ie >>> 16, Ye = Ie & 65535 | De << 16, it = Re & 65535 | Te << 16, ye = Me, be = Qe, Re = be & 65535, Te = be >>> 16, Ie = ye & 65535, De = ye >>> 16, ye = je, be = He, Re += be & 65535, Te += be >>> 16, Ie += ye & 65535, De += ye >>> 16, Te += Re >>> 16, Ie += Te >>> 16, De += Ie >>> 16, Me = Ie & 65535 | De << 16, Qe = Re & 65535 | Te << 16, Rt = ie, Ot = ce, It = me, ue = Me, qt = Se, Qt = Ge, Gt = Be, xt = Ye, Wt = Pe, zt = et, pr = nt, er = Qe, cr = pt, hr = ut, lr = Le, Pt = it, We % 16 === 15)
            for (Fe = 0; Fe < 16; Fe++)
              ye = $[Fe], be = Y[Fe], Re = be & 65535, Te = be >>> 16, Ie = ye & 65535, De = ye >>> 16, ye = $[(Fe + 9) % 16], be = Y[(Fe + 9) % 16], Re += be & 65535, Te += be >>> 16, Ie += ye & 65535, De += ye >>> 16, je = $[(Fe + 1) % 16], He = Y[(Fe + 1) % 16], ye = (je >>> 1 | He << 31) ^ (je >>> 8 | He << 24) ^ je >>> 7, be = (He >>> 1 | je << 31) ^ (He >>> 8 | je << 24) ^ (He >>> 7 | je << 25), Re += be & 65535, Te += be >>> 16, Ie += ye & 65535, De += ye >>> 16, je = $[(Fe + 14) % 16], He = Y[(Fe + 14) % 16], ye = (je >>> 19 | He << 13) ^ (He >>> 29 | je << 3) ^ je >>> 6, be = (He >>> 19 | je << 13) ^ (je >>> 29 | He << 3) ^ (He >>> 6 | je << 26), Re += be & 65535, Te += be >>> 16, Ie += ye & 65535, De += ye >>> 16, Te += Re >>> 16, Ie += Te >>> 16, De += Ie >>> 16, $[Fe] = Ie & 65535 | De << 16, Y[Fe] = Re & 65535 | Te << 16;
        ye = xt, be = Pt, Re = be & 65535, Te = be >>> 16, Ie = ye & 65535, De = ye >>> 16, ye = j[0], be = N[0], Re += be & 65535, Te += be >>> 16, Ie += ye & 65535, De += ye >>> 16, Te += Re >>> 16, Ie += Te >>> 16, De += Ie >>> 16, j[0] = xt = Ie & 65535 | De << 16, N[0] = Pt = Re & 65535 | Te << 16, ye = Rt, be = Wt, Re = be & 65535, Te = be >>> 16, Ie = ye & 65535, De = ye >>> 16, ye = j[1], be = N[1], Re += be & 65535, Te += be >>> 16, Ie += ye & 65535, De += ye >>> 16, Te += Re >>> 16, Ie += Te >>> 16, De += Ie >>> 16, j[1] = Rt = Ie & 65535 | De << 16, N[1] = Wt = Re & 65535 | Te << 16, ye = Ot, be = zt, Re = be & 65535, Te = be >>> 16, Ie = ye & 65535, De = ye >>> 16, ye = j[2], be = N[2], Re += be & 65535, Te += be >>> 16, Ie += ye & 65535, De += ye >>> 16, Te += Re >>> 16, Ie += Te >>> 16, De += Ie >>> 16, j[2] = Ot = Ie & 65535 | De << 16, N[2] = zt = Re & 65535 | Te << 16, ye = It, be = pr, Re = be & 65535, Te = be >>> 16, Ie = ye & 65535, De = ye >>> 16, ye = j[3], be = N[3], Re += be & 65535, Te += be >>> 16, Ie += ye & 65535, De += ye >>> 16, Te += Re >>> 16, Ie += Te >>> 16, De += Ie >>> 16, j[3] = It = Ie & 65535 | De << 16, N[3] = pr = Re & 65535 | Te << 16, ye = ue, be = er, Re = be & 65535, Te = be >>> 16, Ie = ye & 65535, De = ye >>> 16, ye = j[4], be = N[4], Re += be & 65535, Te += be >>> 16, Ie += ye & 65535, De += ye >>> 16, Te += Re >>> 16, Ie += Te >>> 16, De += Ie >>> 16, j[4] = ue = Ie & 65535 | De << 16, N[4] = er = Re & 65535 | Te << 16, ye = qt, be = cr, Re = be & 65535, Te = be >>> 16, Ie = ye & 65535, De = ye >>> 16, ye = j[5], be = N[5], Re += be & 65535, Te += be >>> 16, Ie += ye & 65535, De += ye >>> 16, Te += Re >>> 16, Ie += Te >>> 16, De += Ie >>> 16, j[5] = qt = Ie & 65535 | De << 16, N[5] = cr = Re & 65535 | Te << 16, ye = Qt, be = hr, Re = be & 65535, Te = be >>> 16, Ie = ye & 65535, De = ye >>> 16, ye = j[6], be = N[6], Re += be & 65535, Te += be >>> 16, Ie += ye & 65535, De += ye >>> 16, Te += Re >>> 16, Ie += Te >>> 16, De += Ie >>> 16, j[6] = Qt = Ie & 65535 | De << 16, N[6] = hr = Re & 65535 | Te << 16, ye = Gt, be = lr, Re = be & 65535, Te = be >>> 16, Ie = ye & 65535, De = ye >>> 16, ye = j[7], be = N[7], Re += be & 65535, Te += be >>> 16, Ie += ye & 65535, De += ye >>> 16, Te += Re >>> 16, Ie += Te >>> 16, De += Ie >>> 16, j[7] = Gt = Ie & 65535 | De << 16, N[7] = lr = Re & 65535 | Te << 16, br += 128, _ -= 128;
      }
      return _;
    }
    function ge(j, N, D) {
      var _ = new Int32Array(8), $ = new Int32Array(8), Y = new Uint8Array(256), ie, ce = D;
      for (_[0] = 1779033703, _[1] = 3144134277, _[2] = 1013904242, _[3] = 2773480762, _[4] = 1359893119, _[5] = 2600822924, _[6] = 528734635, _[7] = 1541459225, $[0] = 4089235720, $[1] = 2227873595, $[2] = 4271175723, $[3] = 1595750129, $[4] = 2917565137, $[5] = 725511199, $[6] = 4215389547, $[7] = 327033209, ze(_, $, N, D), D %= 128, ie = 0; ie < D; ie++)
        Y[ie] = N[ce - D + ie];
      for (Y[D] = 128, D = 256 - 128 * (D < 112 ? 1 : 0), Y[D - 9] = 0, m(Y, D - 8, ce / 536870912 | 0, ce << 3), ze(_, $, Y, D), ie = 0; ie < 8; ie++)
        m(j, 8 * ie, _[ie], $[ie]);
      return 0;
    }
    function ht(j, N) {
      var D = t(), _ = t(), $ = t(), Y = t(), ie = t(), ce = t(), me = t(), Me = t(), Se = t();
      ee(D, j[1], j[0]), ee(Se, N[1], N[0]), ae(D, D, Se), B(_, j[0], j[1]), B(Se, N[0], N[1]), ae(_, _, Se), ae($, j[3], N[3]), ae($, $, s), ae(Y, j[2], N[2]), B(Y, Y, Y), ee(ie, _, D), ee(ce, Y, $), B(me, Y, $), B(Me, _, D), ae(j[0], ie, ce), ae(j[1], Me, me), ae(j[2], me, ce), ae(j[3], ie, Me);
    }
    function $e(j, N, D) {
      var _;
      for (_ = 0; _ < 4; _++)
        I(j[_], N[_], D);
    }
    function Et(j, N) {
      var D = t(), _ = t(), $ = t();
      ne($, N[2]), ae(D, N[0], $), ae(_, N[1], $), R(j, _), j[31] ^= T(D) << 7;
    }
    function ot(j, N, D) {
      var _, $;
      for (g(j[0], o), g(j[1], u), g(j[2], u), g(j[3], o), $ = 255; $ >= 0; --$)
        _ = D[$ / 8 | 0] >> ($ & 7) & 1, $e(j, N, _), ht(N, j), ht(j, j), $e(j, N, _);
    }
    function Ve(j, N) {
      var D = [t(), t(), t(), t()];
      g(D[0], d), g(D[1], l), g(D[2], u), ae(D[3], d, l), ot(j, D, N);
    }
    function Mt(j, N, D) {
      var _ = new Uint8Array(64), $ = [t(), t(), t(), t()], Y;
      for (D || n(N, 32), ge(_, N, 32), _[0] &= 248, _[31] &= 127, _[31] |= 64, Ve($, _), Et(j, $), Y = 0; Y < 32; Y++)
        N[Y + 32] = j[Y];
      return 0;
    }
    var lt = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function Xe(j, N) {
      var D, _, $, Y;
      for (_ = 63; _ >= 32; --_) {
        for (D = 0, $ = _ - 32, Y = _ - 12; $ < Y; ++$)
          N[$] += D - 16 * N[_] * lt[$ - (_ - 32)], D = Math.floor((N[$] + 128) / 256), N[$] -= D * 256;
        N[$] += D, N[_] = 0;
      }
      for (D = 0, $ = 0; $ < 32; $++)
        N[$] += D - (N[31] >> 4) * lt[$], D = N[$] >> 8, N[$] &= 255;
      for ($ = 0; $ < 32; $++)
        N[$] -= D * lt[$];
      for (_ = 0; _ < 32; _++)
        N[_ + 1] += N[_] >> 8, j[_] = N[_] & 255;
    }
    function st(j) {
      var N = new Float64Array(64), D;
      for (D = 0; D < 64; D++)
        N[D] = j[D];
      for (D = 0; D < 64; D++)
        j[D] = 0;
      Xe(j, N);
    }
    function gt(j, N, D, _) {
      var $ = new Uint8Array(64), Y = new Uint8Array(64), ie = new Uint8Array(64), ce, me, Me = new Float64Array(64), Se = [t(), t(), t(), t()];
      ge($, _, 32), $[0] &= 248, $[31] &= 127, $[31] |= 64;
      var Ge = D + 64;
      for (ce = 0; ce < D; ce++)
        j[64 + ce] = N[ce];
      for (ce = 0; ce < 32; ce++)
        j[32 + ce] = $[32 + ce];
      for (ge(ie, j.subarray(32), D + 32), st(ie), Ve(Se, ie), Et(j, Se), ce = 32; ce < 64; ce++)
        j[ce] = _[ce];
      for (ge(Y, j, D + 64), st(Y), ce = 0; ce < 64; ce++)
        Me[ce] = 0;
      for (ce = 0; ce < 32; ce++)
        Me[ce] = ie[ce];
      for (ce = 0; ce < 32; ce++)
        for (me = 0; me < 32; me++)
          Me[ce + me] += Y[ce] * $[me];
      return Xe(j.subarray(32), Me), Ge;
    }
    function W(j, N) {
      var D = t(), _ = t(), $ = t(), Y = t(), ie = t(), ce = t(), me = t();
      return g(j[2], u), p(j[1], N), Z($, j[1]), ae(Y, $, h), ee($, $, j[2]), B(Y, j[2], Y), Z(ie, Y), Z(ce, ie), ae(me, ce, ie), ae(D, me, $), ae(D, D, Y), fe(D, D), ae(D, D, $), ae(D, D, Y), ae(D, D, Y), ae(j[0], D, Y), Z(_, j[0]), ae(_, _, Y), x(_, $) && ae(j[0], j[0], y), Z(_, j[0]), ae(_, _, Y), x(_, $) ? -1 : (T(j[0]) === N[31] >> 7 && ee(j[0], o, j[0]), ae(j[3], j[0], j[1]), 0);
    }
    function q(j, N, D, _) {
      var $, Y = new Uint8Array(32), ie = new Uint8Array(64), ce = [t(), t(), t(), t()], me = [t(), t(), t(), t()];
      if (D < 64 || W(me, _))
        return -1;
      for ($ = 0; $ < D; $++)
        j[$] = N[$];
      for ($ = 0; $ < 32; $++)
        j[$ + 32] = _[$];
      if (ge(ie, j, D), st(ie), ot(ce, me, ie), Ve(me, N.subarray(32)), ht(ce, me), Et(Y, ce), D -= 64, S(N, 0, Y, 0)) {
        for ($ = 0; $ < D; $++)
          j[$] = 0;
        return -1;
      }
      for ($ = 0; $ < D; $++)
        j[$] = N[$ + 64];
      return D;
    }
    var F = 32, J = 24, he = 32, de = 16, pe = 32, Je = 32, tt = 32, Ne = 32, St = 32, rt = J, dt = he, Zt = de, bt = 64, at = 32, jt = 64, _t = 32, ft = 64;
    e.lowlevel = {
      crypto_core_hsalsa20: z,
      crypto_stream_xor: ve,
      crypto_stream: se,
      crypto_stream_salsa20_xor: re,
      crypto_stream_salsa20: oe,
      crypto_onetimeauth: A,
      crypto_onetimeauth_verify: b,
      crypto_verify_16: E,
      crypto_verify_32: S,
      crypto_secretbox: f,
      crypto_secretbox_open: v,
      crypto_scalarmult: le,
      crypto_scalarmult_base: ke,
      crypto_box_beforenm: G,
      crypto_box_afternm: we,
      crypto_box: Oe,
      crypto_box_open: qe,
      crypto_box_keypair: X,
      crypto_hash: ge,
      crypto_sign: gt,
      crypto_sign_keypair: Mt,
      crypto_sign_open: q,
      crypto_secretbox_KEYBYTES: F,
      crypto_secretbox_NONCEBYTES: J,
      crypto_secretbox_ZEROBYTES: he,
      crypto_secretbox_BOXZEROBYTES: de,
      crypto_scalarmult_BYTES: pe,
      crypto_scalarmult_SCALARBYTES: Je,
      crypto_box_PUBLICKEYBYTES: tt,
      crypto_box_SECRETKEYBYTES: Ne,
      crypto_box_BEFORENMBYTES: St,
      crypto_box_NONCEBYTES: rt,
      crypto_box_ZEROBYTES: dt,
      crypto_box_BOXZEROBYTES: Zt,
      crypto_sign_BYTES: bt,
      crypto_sign_PUBLICKEYBYTES: at,
      crypto_sign_SECRETKEYBYTES: jt,
      crypto_sign_SEEDBYTES: _t,
      crypto_hash_BYTES: ft,
      gf: t,
      D: h,
      L: lt,
      pack25519: R,
      unpack25519: p,
      M: ae,
      A: B,
      S: Z,
      Z: ee,
      pow2523: fe,
      add: ht,
      set25519: g,
      modL: Xe,
      scalarmult: ot,
      scalarbase: Ve
    };
    function Yt(j, N) {
      if (j.length !== F)
        throw new Error("bad key size");
      if (N.length !== J)
        throw new Error("bad nonce size");
    }
    function kt(j, N) {
      if (j.length !== tt)
        throw new Error("bad public key size");
      if (N.length !== Ne)
        throw new Error("bad secret key size");
    }
    function Ze() {
      for (var j = 0; j < arguments.length; j++)
        if (!(arguments[j] instanceof Uint8Array))
          throw new TypeError("unexpected type, use Uint8Array");
    }
    function Ht(j) {
      for (var N = 0; N < j.length; N++)
        j[N] = 0;
    }
    e.randomBytes = function(j) {
      var N = new Uint8Array(j);
      return n(N, j), N;
    }, e.secretbox = function(j, N, D) {
      Ze(j, N, D), Yt(D, N);
      for (var _ = new Uint8Array(he + j.length), $ = new Uint8Array(_.length), Y = 0; Y < j.length; Y++)
        _[Y + he] = j[Y];
      return f($, _, _.length, N, D), $.subarray(de);
    }, e.secretbox.open = function(j, N, D) {
      Ze(j, N, D), Yt(D, N);
      for (var _ = new Uint8Array(de + j.length), $ = new Uint8Array(_.length), Y = 0; Y < j.length; Y++)
        _[Y + de] = j[Y];
      return _.length < 32 || v($, _, _.length, N, D) !== 0 ? null : $.subarray(he);
    }, e.secretbox.keyLength = F, e.secretbox.nonceLength = J, e.secretbox.overheadLength = de, e.scalarMult = function(j, N) {
      if (Ze(j, N), j.length !== Je)
        throw new Error("bad n size");
      if (N.length !== pe)
        throw new Error("bad p size");
      var D = new Uint8Array(pe);
      return le(D, j, N), D;
    }, e.scalarMult.base = function(j) {
      if (Ze(j), j.length !== Je)
        throw new Error("bad n size");
      var N = new Uint8Array(pe);
      return ke(N, j), N;
    }, e.scalarMult.scalarLength = Je, e.scalarMult.groupElementLength = pe, e.box = function(j, N, D, _) {
      var $ = e.box.before(D, _);
      return e.secretbox(j, N, $);
    }, e.box.before = function(j, N) {
      Ze(j, N), kt(j, N);
      var D = new Uint8Array(St);
      return G(D, j, N), D;
    }, e.box.after = e.secretbox, e.box.open = function(j, N, D, _) {
      var $ = e.box.before(D, _);
      return e.secretbox.open(j, N, $);
    }, e.box.open.after = e.secretbox.open, e.box.keyPair = function() {
      var j = new Uint8Array(tt), N = new Uint8Array(Ne);
      return X(j, N), { publicKey: j, secretKey: N };
    }, e.box.keyPair.fromSecretKey = function(j) {
      if (Ze(j), j.length !== Ne)
        throw new Error("bad secret key size");
      var N = new Uint8Array(tt);
      return ke(N, j), { publicKey: N, secretKey: new Uint8Array(j) };
    }, e.box.publicKeyLength = tt, e.box.secretKeyLength = Ne, e.box.sharedKeyLength = St, e.box.nonceLength = rt, e.box.overheadLength = e.secretbox.overheadLength, e.sign = function(j, N) {
      if (Ze(j, N), N.length !== jt)
        throw new Error("bad secret key size");
      var D = new Uint8Array(bt + j.length);
      return gt(D, j, j.length, N), D;
    }, e.sign.open = function(j, N) {
      if (Ze(j, N), N.length !== at)
        throw new Error("bad public key size");
      var D = new Uint8Array(j.length), _ = q(D, j, j.length, N);
      if (_ < 0)
        return null;
      for (var $ = new Uint8Array(_), Y = 0; Y < $.length; Y++)
        $[Y] = D[Y];
      return $;
    }, e.sign.detached = function(j, N) {
      for (var D = e.sign(j, N), _ = new Uint8Array(bt), $ = 0; $ < _.length; $++)
        _[$] = D[$];
      return _;
    }, e.sign.detached.verify = function(j, N, D) {
      if (Ze(j, N, D), N.length !== bt)
        throw new Error("bad signature size");
      if (D.length !== at)
        throw new Error("bad public key size");
      var _ = new Uint8Array(bt + j.length), $ = new Uint8Array(bt + j.length), Y;
      for (Y = 0; Y < bt; Y++)
        _[Y] = N[Y];
      for (Y = 0; Y < j.length; Y++)
        _[Y + bt] = j[Y];
      return q($, _, _.length, D) >= 0;
    }, e.sign.keyPair = function() {
      var j = new Uint8Array(at), N = new Uint8Array(jt);
      return Mt(j, N), { publicKey: j, secretKey: N };
    }, e.sign.keyPair.fromSecretKey = function(j) {
      if (Ze(j), j.length !== jt)
        throw new Error("bad secret key size");
      for (var N = new Uint8Array(at), D = 0; D < N.length; D++)
        N[D] = j[32 + D];
      return { publicKey: N, secretKey: new Uint8Array(j) };
    }, e.sign.keyPair.fromSeed = function(j) {
      if (Ze(j), j.length !== _t)
        throw new Error("bad seed size");
      for (var N = new Uint8Array(at), D = new Uint8Array(jt), _ = 0; _ < 32; _++)
        D[_] = j[_];
      return Mt(N, D, !0), { publicKey: N, secretKey: D };
    }, e.sign.publicKeyLength = at, e.sign.secretKeyLength = jt, e.sign.seedLength = _t, e.sign.signatureLength = bt, e.hash = function(j) {
      Ze(j);
      var N = new Uint8Array(ft);
      return ge(N, j, j.length), N;
    }, e.hash.hashLength = ft, e.verify = function(j, N) {
      return Ze(j, N), j.length === 0 || N.length === 0 || j.length !== N.length ? !1 : w(j, 0, N, 0, j.length) === 0;
    }, e.setPRNG = function(j) {
      n = j;
    }, function() {
      var j = typeof self != "undefined" ? self.crypto || self.msCrypto : null;
      if (j && j.getRandomValues) {
        var N = 65536;
        e.setPRNG(function(D, _) {
          var $, Y = new Uint8Array(_);
          for ($ = 0; $ < _; $ += N)
            j.getRandomValues(Y.subarray($, $ + Math.min(_ - $, N)));
          for ($ = 0; $ < _; $++)
            D[$] = Y[$];
          Ht(Y);
        });
      } else
        typeof E2 != "undefined" && (j = iy(), j && j.randomBytes && e.setPRNG(function(D, _) {
          var $, Y = j.randomBytes(_);
          for ($ = 0; $ < _; $++)
            D[$] = Y[$];
          Ht(Y);
        }));
    }();
  })(r.exports ? r.exports : self.nacl = self.nacl || {});
})(s1);
var cc = s1.exports;
const Pn = /* @__PURE__ */ ki(cc), z3 = Pn.box.publicKeyLength + Pn.box.overheadLength, V3 = "Input must be an string, Buffer or Uint8Array";
function W3(r) {
  let e;
  if (r instanceof Uint8Array)
    e = r;
  else if (typeof r == "string")
    e = new TextEncoder().encode(r);
  else
    throw new Error(V3);
  return e;
}
function K3(r) {
  return Array.prototype.map.call(r, function(e) {
    return (e < 16 ? "0" : "") + e.toString(16);
  }).join("");
}
function ja(r) {
  return (4294967296 + r).toString(16).substring(1);
}
function Q3(r, e, t) {
  let n = `
` + r + " = ";
  for (let a = 0; a < e.length; a += 2) {
    if (t === 32)
      n += ja(e[a]).toUpperCase(), n += " ", n += ja(e[a + 1]).toUpperCase();
    else if (t === 64)
      n += ja(e[a + 1]).toUpperCase(), n += ja(e[a]).toUpperCase();
    else
      throw new Error("Invalid size " + t);
    a % 6 === 4 ? n += `
` + new Array(r.length + 4).join(" ") : a < e.length - 2 && (n += " ");
  }
  console.log(n);
}
function G3(r, e, t) {
  let n = (/* @__PURE__ */ new Date()).getTime();
  const a = new Uint8Array(e);
  for (let o = 0; o < e; o++)
    a[o] = o % 256;
  const i = (/* @__PURE__ */ new Date()).getTime();
  console.log("Generated random input in " + (i - n) + "ms"), n = i;
  for (let o = 0; o < t; o++) {
    const u = r(a), c = (/* @__PURE__ */ new Date()).getTime(), h = c - n;
    n = c, console.log("Hashed in " + h + "ms: " + u.substring(0, 20) + "..."), console.log(
      Math.round(e / (1 << 20) / (h / 1e3) * 100) / 100 + " MB PER SECOND"
    );
  }
}
var ay = {
  normalizeInput: W3,
  toHex: K3,
  debugPrint: Q3,
  testSpeed: G3
};
const J3 = /* @__PURE__ */ ki(ay), Y3 = /* @__PURE__ */ _g({
  __proto__: null,
  default: J3
}, [ay]), X3 = /* @__PURE__ */ a1(Y3), to = X3;
function Ha(r, e, t) {
  const n = r[e] + r[t];
  let a = r[e + 1] + r[t + 1];
  n >= 4294967296 && a++, r[e] = n, r[e + 1] = a;
}
function Ip(r, e, t, n) {
  let a = r[e] + t;
  t < 0 && (a += 4294967296);
  let i = r[e + 1] + n;
  a >= 4294967296 && i++, r[e] = a, r[e + 1] = i;
}
function oy(r, e) {
  return r[e] ^ r[e + 1] << 8 ^ r[e + 2] << 16 ^ r[e + 3] << 24;
}
function An(r, e, t, n, a, i) {
  const o = Gi[a], u = Gi[a + 1], c = Gi[i], h = Gi[i + 1];
  Ha(Nt, r, e), Ip(Nt, r, o, u);
  let s = Nt[n] ^ Nt[r], d = Nt[n + 1] ^ Nt[r + 1];
  Nt[n] = d, Nt[n + 1] = s, Ha(Nt, t, n), s = Nt[e] ^ Nt[t], d = Nt[e + 1] ^ Nt[t + 1], Nt[e] = s >>> 24 ^ d << 8, Nt[e + 1] = d >>> 24 ^ s << 8, Ha(Nt, r, e), Ip(Nt, r, c, h), s = Nt[n] ^ Nt[r], d = Nt[n + 1] ^ Nt[r + 1], Nt[n] = s >>> 16 ^ d << 16, Nt[n + 1] = d >>> 16 ^ s << 16, Ha(Nt, t, n), s = Nt[e] ^ Nt[t], d = Nt[e + 1] ^ Nt[t + 1], Nt[e] = d >>> 31 ^ s << 1, Nt[e + 1] = s >>> 31 ^ d << 1;
}
const sy = new Uint32Array([
  4089235720,
  1779033703,
  2227873595,
  3144134277,
  4271175723,
  1013904242,
  1595750129,
  2773480762,
  2917565137,
  1359893119,
  725511199,
  2600822924,
  4215389547,
  528734635,
  327033209,
  1541459225
]), Z3 = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9,
  12,
  5,
  1,
  15,
  14,
  13,
  4,
  10,
  0,
  7,
  6,
  3,
  9,
  2,
  8,
  11,
  13,
  11,
  7,
  14,
  12,
  1,
  3,
  9,
  5,
  0,
  15,
  4,
  8,
  6,
  2,
  10,
  6,
  15,
  14,
  9,
  11,
  3,
  0,
  8,
  12,
  2,
  13,
  7,
  1,
  4,
  10,
  5,
  10,
  2,
  8,
  4,
  7,
  6,
  1,
  5,
  15,
  11,
  9,
  14,
  3,
  12,
  13,
  0,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3
], Or = new Uint8Array(
  Z3.map(function(r) {
    return r * 2;
  })
), Nt = new Uint32Array(32), Gi = new Uint32Array(32);
function fy(r, e) {
  let t = 0;
  for (t = 0; t < 16; t++)
    Nt[t] = r.h[t], Nt[t + 16] = sy[t];
  for (Nt[24] = Nt[24] ^ r.t, Nt[25] = Nt[25] ^ r.t / 4294967296, e && (Nt[28] = ~Nt[28], Nt[29] = ~Nt[29]), t = 0; t < 32; t++)
    Gi[t] = oy(r.b, 4 * t);
  for (t = 0; t < 12; t++)
    An(0, 8, 16, 24, Or[t * 16 + 0], Or[t * 16 + 1]), An(2, 10, 18, 26, Or[t * 16 + 2], Or[t * 16 + 3]), An(4, 12, 20, 28, Or[t * 16 + 4], Or[t * 16 + 5]), An(6, 14, 22, 30, Or[t * 16 + 6], Or[t * 16 + 7]), An(0, 10, 20, 30, Or[t * 16 + 8], Or[t * 16 + 9]), An(2, 12, 22, 24, Or[t * 16 + 10], Or[t * 16 + 11]), An(4, 14, 16, 26, Or[t * 16 + 12], Or[t * 16 + 13]), An(6, 8, 18, 28, Or[t * 16 + 14], Or[t * 16 + 15]);
  for (t = 0; t < 16; t++)
    r.h[t] = r.h[t] ^ Nt[t] ^ Nt[t + 16];
}
const Tn = new Uint8Array([
  0,
  0,
  0,
  0,
  //  0: outlen, keylen, fanout, depth
  0,
  0,
  0,
  0,
  //  4: leaf length, sequential mode
  0,
  0,
  0,
  0,
  //  8: node offset
  0,
  0,
  0,
  0,
  // 12: node offset
  0,
  0,
  0,
  0,
  // 16: node depth, inner length, rfu
  0,
  0,
  0,
  0,
  // 20: rfu
  0,
  0,
  0,
  0,
  // 24: rfu
  0,
  0,
  0,
  0,
  // 28: rfu
  0,
  0,
  0,
  0,
  // 32: salt
  0,
  0,
  0,
  0,
  // 36: salt
  0,
  0,
  0,
  0,
  // 40: salt
  0,
  0,
  0,
  0,
  // 44: salt
  0,
  0,
  0,
  0,
  // 48: personal
  0,
  0,
  0,
  0,
  // 52: personal
  0,
  0,
  0,
  0,
  // 56: personal
  0,
  0,
  0,
  0
  // 60: personal
]);
function uy(r, e, t, n) {
  if (r === 0 || r > 64)
    throw new Error("Illegal output length, expected 0 < length <= 64");
  if (e && e.length > 64)
    throw new Error("Illegal key, expected Uint8Array with 0 < length <= 64");
  if (t && t.length !== 16)
    throw new Error("Illegal salt, expected Uint8Array with length is 16");
  if (n && n.length !== 16)
    throw new Error("Illegal personal, expected Uint8Array with length is 16");
  const a = {
    b: new Uint8Array(128),
    h: new Uint32Array(16),
    t: 0,
    // input count
    c: 0,
    // pointer within buffer
    outlen: r
    // output length in bytes
  };
  Tn.fill(0), Tn[0] = r, e && (Tn[1] = e.length), Tn[2] = 1, Tn[3] = 1, t && Tn.set(t, 32), n && Tn.set(n, 48);
  for (let i = 0; i < 16; i++)
    a.h[i] = sy[i] ^ oy(Tn, i * 4);
  return e && (dh(a, e), a.c = 128), a;
}
function dh(r, e) {
  for (let t = 0; t < e.length; t++)
    r.c === 128 && (r.t += r.c, fy(r, !1), r.c = 0), r.b[r.c++] = e[t];
}
function cy(r) {
  for (r.t += r.c; r.c < 128; )
    r.b[r.c++] = 0;
  fy(r, !0);
  const e = new Uint8Array(r.outlen);
  for (let t = 0; t < r.outlen; t++)
    e[t] = r.h[t >> 2] >> 8 * (t & 3);
  return e;
}
function hy(r, e, t, n, a) {
  t = t || 64, r = to.normalizeInput(r), n && (n = to.normalizeInput(n)), a && (a = to.normalizeInput(a));
  const i = uy(t, e, n, a);
  return dh(i, r), cy(i);
}
function ew(r, e, t, n, a) {
  const i = hy(r, e, t, n, a);
  return to.toHex(i);
}
var tw = {
  blake2b: hy,
  blake2bHex: ew,
  blake2bInit: uy,
  blake2bUpdate: dh,
  blake2bFinal: cy
};
const za = /* @__PURE__ */ ki(tw);
function ly(r, e) {
  var t = za.blake2bInit(Pn.box.nonceLength, null);
  return za.blake2bUpdate(t, r), za.blake2bUpdate(t, e), za.blake2bFinal(t);
}
function rw(r) {
  for (var e = 0; e < r.length; e++)
    r[e] = 0;
}
function nw(r, e) {
  var t = new Uint8Array(z3 + r.length), n = Pn.box.keyPair();
  t.set(n.publicKey);
  var a = ly(n.publicKey, e), i = Pn.box(r, a, e, n.secretKey);
  return t.set(i, n.publicKey.length), rw(n.secretKey), t;
}
function iw(r, e, t) {
  var n = r.subarray(0, Pn.box.publicKeyLength), a = ly(n, e), i = r.subarray(Pn.box.publicKeyLength);
  return Pn.box.open(i, a, n, t);
}
class aw {
  /**
   * @param {string|null} characters
   */
  constructor(e = null) {
    this.base = new oc({ characters: e || "BASE64" });
  }
  /**
   * @param {array|object} message
   * @param {string} key
   * @return {string}
   */
  encrypt(e, t) {
    const n = JSON.stringify(e), i = new TextEncoder().encode(n), o = nw(i, this.decode(t));
    return this.encode(o);
  }
  /**
   * @param {string} decrypted
   * @param {string} privateKey
   * @param {string} publicKey
   * @return {null|any}
   */
  decrypt(e, t, n) {
    try {
      const a = iw(this.decode(e), this.decode(n), this.decode(t)), o = new TextDecoder().decode(a);
      return JSON.parse(o);
    } catch (a) {
      return null;
    }
  }
  /**
   *
   * @param {string} key
   * @return {string}
   */
  generatePrivateKey(e) {
    const t = new Lr("SHAKE256", "TEXT");
    t.update(e);
    const n = t.getHash("HEX", { outputLen: cc.box.secretKeyLength * 8 }), a = new Uint8Array(n.length / 2);
    for (let i = 0; i < n.length; i += 2)
      a[i / 2] = parseInt(n.substr(i, 2), 16);
    return this.base.encode(a);
  }
  /**
   * @param {string} key
   * @return {string}
   */
  generatePublicKey(e) {
    const t = cc.box.keyPair.fromSecretKey(this.decode(e));
    return this.encode(t.publicKey);
  }
  /**
   * @param {string} key
   * @return {string}
   */
  shortHash(e) {
    const t = new Lr("SHAKE256", "TEXT");
    t.update(e);
    const n = t.getHash("HEX", { outputLen: 64 }), a = new Uint8Array(n.length / 2);
    for (let i = 0; i < n.length; i += 2)
      a[i / 2] = parseInt(n.substr(i, 2), 16);
    return this.base.encode(a);
  }
  /**
   * @param {string} data
   * @return {string|Buffer}
   */
  decode(e) {
    return this.base.decode(e);
  }
  /**
   * @param {string|Buffer|Uint8Array} data
   * @return {string}
   */
  encode(e) {
    return this.base.encode(e);
  }
}
class ow extends sr {
  /**
   * Class constructor
   *
   * @param {string} message
   * @param {string|null} fileName
   * @param {number|null} lineNumber
   */
  constructor(e = "Attempting to create a wallet with no credentials (secret or bundle hash)", t = null, n = null) {
    super(e, t, n), this.name = "WalletCredentialException";
  }
}
class tr {
  /**
   * Class constructor
   *
   * @param {string|null} secret - typically a 2048-character biometric hash
   * @param {string|null} bundle - 64-character hexadecimal user identifier
   * @param {string} token - slug for the token this wallet is intended for
   * @param {string|null} address - hexadecimal public key for the signature of this wallet
   * @param {string|null} position - hexadecimal string used to salt the secret and produce one-time signatures
   * @param {string|null} batchId
   * @param {string|null} characters
   */
  constructor({
    secret: e = null,
    bundle: t = null,
    token: n = "USER",
    address: a = null,
    position: i = null,
    batchId: o = null,
    characters: u = null
  }) {
    this.token = n, this.balance = 0, this.molecules = {}, this.key = null, this.privkey = null, this.pubkey = null, this.tokenUnits = [], this.tradeRates = {}, this.address = a, this.position = i, this.bundle = t, this.batchId = o, this.characters = u, e && (this.bundle = this.bundle || Nn(e, "Wallet::constructor"), this.position = this.position || tr.generatePosition(), this.key = tr.generateKey({
      secret: e,
      token: this.token,
      position: this.position
    }), this.address = this.address || tr.generateAddress(this.key), this.soda = new aw(u), this.privkey = this.soda.generatePrivateKey(this.key), this.pubkey = this.soda.generatePublicKey(this.privkey), this.characters = this.characters || "BASE64");
  }
  /**
   * Creates a new Wallet instance
   *
   * @param {string|null} secret
   * @param {string|null} bundle
   * @param {string} token
   * @param {string|null} batchId
   * @param {string|null} characters
   * @return {Wallet}
   */
  static create({
    secret: e = null,
    bundle: t = null,
    token: n,
    batchId: a = null,
    characters: i = null
  }) {
    let o = null;
    if (!e && !t)
      throw new ow();
    return e && !t && (o = tr.generatePosition(), t = Nn(e, "Wallet::create")), new tr({
      secret: e,
      bundle: t,
      token: n,
      position: o,
      batchId: a,
      characters: i
    });
  }
  /**
   * Determines if the provided string is a bundle hash
   *
   * @param {string} maybeBundleHash
   * @return {boolean}
   */
  static isBundleHash(e) {
    return typeof e != "string" ? !1 : e.length === 64 && m2(e);
  }
  /**
   * Get formatted token units from the raw data
   *
   * @param unitsData
   * @return {[]}
   */
  static getTokenUnits(e) {
    const t = [];
    return e.forEach((n) => {
      t.push(xi.createFromDB(n));
    }), t;
  }
  /**
   * Generates a private key for the given parameters
   *
   * @param {string} secret
   * @param {string} token
   * @param {string} position
   * @return {string}
   */
  static generateKey({
    secret: e,
    token: t,
    position: n
  }) {
    const i = BigInt(`0x${e}`) + BigInt(`0x${n}`), o = new Lr("SHAKE256", "TEXT");
    o.update(i.toString(16)), t && o.update(t);
    const u = new Lr("SHAKE256", "TEXT");
    return u.update(o.getHash("HEX", { outputLen: 8192 })), u.getHash("HEX", { outputLen: 8192 });
  }
  /**
   * Generates a wallet address
   *
   * @param {string} key
   * @return {string}
   */
  static generateAddress(e) {
    const t = ho(e, 128), n = new Lr("SHAKE256", "TEXT");
    for (const i in t) {
      let o = t[i];
      for (let u = 1; u <= 16; u++) {
        const c = new Lr("SHAKE256", "TEXT");
        c.update(o), o = c.getHash("HEX", { outputLen: 512 });
      }
      n.update(o);
    }
    const a = new Lr("SHAKE256", "TEXT");
    return a.update(n.getHash("HEX", { outputLen: 8192 })), a.getHash("HEX", { outputLen: 256 });
  }
  /**
   *
   * @param saltLength
   * @returns {string}
   */
  static generatePosition(e = 64) {
    return jc(e, "abcdef0123456789");
  }
  /**
   *
   * @returns {*[]}
   */
  getTokenUnitsData() {
    const e = [];
    return this.tokenUnits.forEach((t) => {
      e.push(t.toData());
    }), e;
  }
  /**
   * Split token units
   *
   * @param {array} units
   * @param remainderWallet
   * @param recipientWallet
   */
  splitUnits(e, t, n = null) {
    if (e.length === 0)
      return;
    const a = [], i = [];
    this.tokenUnits.forEach((o) => {
      e.includes(o.id) ? a.push(o) : i.push(o);
    }), this.tokenUnits = a, n !== null && (n.tokenUnits = a), t.tokenUnits = i;
  }
  /**
   * Create a remainder wallet from the source one
   *
   * @param secret
   */
  createRemainder(e) {
    const t = tr.create({
      secret: e,
      token: this.token,
      characters: this.characters
    });
    return t.initBatchId({
      sourceWallet: this,
      isRemainder: !0
    }), t;
  }
  /**
   * @return boolean
   */
  isShadow() {
    return (typeof this.position == "undefined" || this.position === null) && (typeof this.address == "undefined" || this.address === null);
  }
  /**
   * Sets up a batch ID - either using the sender's, or a new one
   *
   * @param {Wallet} sourceWallet
   * @param {boolean} isRemainder
   */
  initBatchId({
    sourceWallet: e,
    isRemainder: t = !1
  }) {
    e.batchId && (this.batchId = t ? e.batchId : po({}));
  }
  /**
   * Encrypts a message for this wallet instance
   *
   * @param {object|array} message
   * @return {object}
   */
  encryptMessage(e) {
    const t = {};
    for (let n = 1, a = arguments.length; n < a; n++)
      t[this.soda.shortHash(arguments[n])] = this.soda.encrypt(e, arguments[n]);
    return t;
  }
  /**
   * Uses the current wallet's private key to decrypt the given message
   *
   * @param {string|object} message
   * @return {null|any}
   */
  decryptMessage(e) {
    const t = this.pubkey;
    let n = e;
    return e !== null && typeof e == "object" && Object.prototype.toString.call(e) === "[object Object]" && (n = e[this.soda.shortHash(t)] || ""), this.soda.decrypt(n, this.privkey, t);
  }
  /**
   * @param {string|object} message
   *
   * @returns {Buffer|ArrayBuffer|Uint8Array}
   */
  decryptBinary(e) {
    const t = this.decryptMessage(e);
    return new oc({ characters: "BASE64" }).decode(t);
  }
  /**
   * @param {Buffer|ArrayBuffer|Uint8Array} message
   * @returns {{string}}
   */
  encryptBinary(e) {
    const t = Array.from(arguments).slice(1), n = new oc({ characters: "BASE64" }).encode(e);
    return this.encryptMessage(n, ...t);
  }
  /**
   * Encrypts a string for the given public keys
   *
   * @param {string} data
   * @param {string|array} publicKeys
   * @return {string}
   */
  encryptString({
    data: e,
    publicKeys: t
  }) {
    if (e) {
      const n = this.pubkey;
      typeof t == "string" && (t = [t]);
      const a = this.encryptMessage(e, n, ...t);
      return btoa(JSON.stringify(a));
    }
  }
  /**
   * Attempts to decrypt the given string
   *
   * @param {string} data
   * @param {string|null} fallbackValue
   * @return {array|object}
   */
  decryptString({
    data: e,
    fallbackValue: t = null
  }) {
    if (e)
      try {
        const n = JSON.parse(atob(e));
        return this.decryptMessage(n) || t;
      } catch (n) {
        return console.error(n), t || e;
      }
  }
}
class Ui extends sr {
  /**
   * Class constructor
   *
   * @param {string} message
   * @param {string|null} fileName
   * @param {number|null} lineNumber
   */
  constructor(e = "There is an atom without an index", t = null, n = null) {
    super(e, t, n), this.name = "AtomIndexException";
  }
}
class sw extends sr {
  /**
   * Class constructor
   *
   * @param {string} message
   * @param {string|null} fileName
   * @param {number|null} lineNumber
   */
  constructor(e = "The molecular hash does not match", t = null, n = null) {
    super(e, t, n), this.name = "MolecularHashMismatchException";
  }
}
class fw extends sr {
  /**
   * Class constructor
   *
   * @param {string} message
   * @param {string|null} fileName
   * @param {number|null} lineNumber
   */
  constructor(e = "The molecular hash is missing", t = null, n = null) {
    super(e, t, n), this.name = "MolecularHashMissingException";
  }
}
class Rp extends sr {
  /**
   * Class constructor
   *
   * @param {string} message
   * @param {string|null} fileName
   * @param {number|null} lineNumber
   */
  constructor(e = "", t = null, n = null) {
    super(e, t, n), this.name = "PolicyInvalidException";
  }
}
class dy extends sr {
  /**
   * Class constructor
   *
   * @param {string} message
   * @param {string|null} fileName
   * @param {number|null} lineNumber
   */
  constructor(e = "OTS malformed", t = null, n = null) {
    super(e, t, n), this.name = "SignatureMalformedException";
  }
}
class uw extends sr {
  /**
   * Class constructor
   *
   * @param {string} message
   * @param {string|null} fileName
   * @param {number|null} lineNumber
   */
  constructor(e = "One-time signature (OTS) does not match!", t = null, n = null) {
    super(e, t, n), this.name = "SignatureMismatchException";
  }
}
class bn extends sr {
  /**
   * Class constructor
   *
   * @param {string} message
   * @param {string|null} fileName
   * @param {number|null} lineNumber
   */
  constructor(e = "Insufficient balance to make transfer", t = null, n = null) {
    super(e, t, n), this.name = "TransferBalanceException";
  }
}
class Cp extends sr {
  /**
   * Class constructor
   *
   * @param {string} message
   * @param {string|null} fileName
   * @param {number|null} lineNumber
   */
  constructor(e = "Token transfer atoms are malformed", t = null, n = null) {
    super(e, t, n), this.name = "TransferMalformedException";
  }
}
class Op extends sr {
  /**
   * @param {string} message
   * @param {string|null} fileName
   * @param {number|null} lineNumber
   */
  constructor(e = "Token slugs for wallets in transfer do not match!", t = null, n = null) {
    super(e, t, n), this.name = "TransferMismatchedException";
  }
}
class Bp extends sr {
  /**
   * Class constructor
   *
   * @param {string} message
   * @param {string|null} fileName
   * @param {number|null} lineNumber
   */
  constructor(e = "Invalid remainder provided", t = null, n = null) {
    super(e, t, n), this.name = "TransferRemainderException";
  }
}
class cw extends sr {
  /**
   * Class constructor
   *
   * @param {string} message
   * @param {string|null} fileName
   * @param {number|null} lineNumber
   */
  constructor(e = "Sender and recipient(s) cannot be the same", t = null, n = null) {
    super(e, t, n), this.name = "TransferToSelfException";
  }
}
class hw extends sr {
  /**
   * Class constructor
   *
   * @param {string} message
   * @param {string|null} fileName
   * @param {number|null} lineNumber
   */
  constructor(e = "Token transfer atoms are unbalanced", t = null, n = null) {
    super(e, t, n), this.name = "TransferUnbalancedException";
  }
}
class In extends sr {
  /**
   * Class constructor
   *
   * @param {string} message
   * @param {string|null} fileName
   * @param {number|null} lineNumber
   */
  constructor(e = "Empty meta data.", t = null, n = null) {
    super(e, t, n), this.name = "MetaMissingException";
  }
}
class $i extends sr {
  /**
   * Class constructor
   *
   * @param {string} message
   * @param {string|null} fileName
   * @param {number|null} lineNumber
   */
  constructor(e = "Wrong type of token for this isotope", t = null, n = null) {
    super(e, t, n), this.name = "WrongTokenTypeException";
  }
}
class ro extends sr {
  /**
   * @param {string|null} message
   * @param {string|null} fileName
   * @param {number|null} lineNumber
   */
  constructor(e = "Incorrect BatchId", t = null, n = null) {
    super(e, t, n), this.name = "BatchIdException";
  }
}
class Pp {
  constructor({}) {
    const e = arguments[0];
    for (const t in e)
      this[`__${t}`] = e[t];
  }
  static toObject(e) {
    return new this(e);
  }
  /**
   *
   * @returns {{}}
   */
  toJSON() {
    const e = {};
    for (const t of Object.keys(this))
      t.substring(0, 2) === "__" && (e[t.substring(2, t.length)] = this[t]);
    return e;
  }
}
class yo extends sr {
  /**
   * Class constructor
   *
   * @param {string} message
   * @param {string|null} fileName
   * @param {number|null} lineNumber
   */
  constructor(e = "An incorrect argument!", t = null, n = null) {
    super(e, t, n), this.name = "RuleArgumentException";
  }
}
class $r extends sr {
  /**
   * @param {string|null} message
   * @param {string|null} fileName
   * @param {number|null} lineNumber
   */
  constructor(e = "Code exception", t = null, n = null) {
    super(e, t, n), this.name = "CodeException";
  }
}
class Xi {
  /**
   *
   * @param {string} action
   * @param {string|null} metaType
   * @param {string|null} metaId
   * @param {Meta|null} meta
   * @param {string|null} address
   * @param {string|null} token
   * @param {string|null} amount
   * @param {string|null} comparison
   */
  constructor({
    action: e,
    metaType: t = null,
    metaId: n = null,
    meta: a = null,
    address: i = null,
    token: o = null,
    amount: u = null,
    comparison: c = null
  }) {
    if (a && (this.meta = a), !e)
      throw new yo('Callback structure violated, missing mandatory "action" parameter.');
    this.__metaId = n, this.__metaType = t, this.__action = e, this.__address = i, this.__token = o, this.__amount = u, this.__comparison = c;
  }
  /**
   *
   * @param {string} comparison
   */
  set comparison(e) {
    this.__comparison = e;
  }
  /**
   *
   * @param {string} amount
   */
  set amount(e) {
    if (!g2(e))
      throw new $r("Parameter amount should be a string containing numbers");
    this.__amount = e;
  }
  /**
   *
   * @param {string} token
   */
  set token(e) {
    this.__token = e;
  }
  /**
   *
   * @param {string} address
   */
  set address(e) {
    this.__address = e;
  }
  /**
   *
   * @param {Meta|object} meta
   */
  set meta(e) {
    this.__meta = e instanceof Pp ? e : Pp.toObject(e);
  }
  /**
   *
   * @param {string} metaType
   */
  set metaType(e) {
    this.__metaType = e;
  }
  /**
   *
   * @param {string} metaId
   */
  set metaId(e) {
    this.__metaId = e;
  }
  /**
   *
   * @param {object} object
   *
   * @return Callback
   */
  static toObject(e) {
    const t = new Xi({
      action: e.action
    });
    return e.metaType && (t.metaType = e.metaType), e.metaId && (t.metaId = e.metaId), e.meta && (t.meta = e.meta), e.address && (t.address = e.address), e.token && (t.token = e.token), e.amount && (t.amount = e.amount), e.comparison && (t.comparison = e.comparison), t;
  }
  /**
   *
   * @return {{action: string}}
   */
  toJSON() {
    const e = {
      action: this.__action
    };
    return this.__metaType && (e.metaType = this.__metaType), this.__metaId && (e.metaId = this.__metaId), this.__meta && (e.meta = this.__meta), this.__address && (e.address = this.__address), this.__token && (e.token = this.__token), this.__amount && (e.amount = this.__amount), this.__comparison && (e.comparison = this.__comparison), e;
  }
  /**
   * @return {boolean}
   */
  isReject() {
    return this._is("reject");
  }
  /**
   * @return {boolean}
   */
  isMeta() {
    return Li(Object.keys(this.toJSON()), ["action", "metaId", "metaType", "meta"]).length === 4 && this._is("meta");
  }
  /**
   * @return {boolean}
   */
  isCollect() {
    return Li(Object.keys(this.toJSON()), ["action", "address", "token", "amount", "comparison"]).length === 5 && this._is("collect");
  }
  /**
   * @return {boolean}
   */
  isBuffer() {
    return Li(Object.keys(this.toJSON()), ["action", "address", "token", "amount", "comparison"]).length === 5 && this._is("buffer");
  }
  /**
   * @return {boolean}
   */
  isRemit() {
    return Li(Object.keys(this.toJSON()), ["action", "token", "amount"]).length === 3 && this._is("remit");
  }
  /**
   * @return {boolean}
   */
  isBurn() {
    return Li(Object.keys(this.toJSON()), ["action", "token", "amount", "comparison"]).length === 4 && this._is("burn");
  }
  /**
   * @param {string} type
   *
   * @return {boolean}
   * @private
   */
  _is(e) {
    return this.__action.toLowerCase() === e.toLowerCase();
  }
}
class Fu {
  /**
   *
   * @param key
   * @param value
   * @param comparison
   */
  constructor({
    key: e,
    value: t,
    comparison: n
  }) {
    if ([e, t, n].some((a) => !a))
      throw new yo("Condition::constructor( { key, value, comparison } ) - not all class parameters are initialised!");
    this.__key = e, this.__value = t, this.__comparison = n;
  }
  /**
   * @param object
   * @return {Condition}
   */
  static toObject(e) {
    return new this({
      key: e.key,
      value: e.value,
      comparison: e.comparison
    });
  }
  /**
   * @return {{comparison, value, key}}
   */
  toJSON() {
    return {
      key: this.__key,
      value: this.__value,
      comparison: this.__comparison
    };
  }
}
class aa {
  /**
   *
   * @param {Condition[]} condition
   * @param  {Callback[]} callback
   */
  constructor({
    condition: e = [],
    callback: t = []
  }) {
    for (const n of e)
      if (!(n instanceof Fu))
        throw new yo();
    for (const n of t)
      if (!(n instanceof Xi))
        throw new yo();
    this.__condition = e, this.__callback = t;
  }
  /**
   *
   * @param {Condition[]|{}} condition
   */
  set comparison(e) {
    this.__condition.push(e instanceof Fu ? e : Fu.toObject(e));
  }
  /**
   * @param {Callback[]|{}} callback
   */
  set callback(e) {
    this.__callback.push(e instanceof Xi ? e : Xi.toObject(e));
  }
  /**
   *
   * @param {object} object
   *
   * @return {Rule}
   */
  static toObject(e) {
    if (!e.condition)
      throw new In("Rule::toObject() - Incorrect rule format! There is no condition field.");
    if (!e.callback)
      throw new In("Rule::toObject() - Incorrect rule format! There is no callback field.");
    const t = new aa({});
    for (const n of e.condition)
      t.comparison = n;
    for (const n of e.callback)
      t.callback = n;
    return t;
  }
  /**
   * @returns {{condition: *, callback: Callback[]}}
   */
  toJSON() {
    return {
      condition: this.__condition,
      callback: this.__callback
    };
  }
}
class dr {
  /**
   * @param {object|array} obj
   * @param {string} keys
   * @private
   */
  static __init(e, t) {
    this.arr = String(t).split("."), this.key = this.arr.shift();
    const n = Number(this.key);
    Number.isInteger(n) && (this.key = n), this.__nextKey = this.arr.length, this.__next = this.__tic(e);
  }
  /**
   * @param {object|array} obj
   * @return {boolean}
   * @private
   */
  static __tic(e) {
    return !Array.isArray(e) && !(e instanceof Object) ? !1 : typeof e[this.key] != "undefined";
  }
  /**
   * @param {object|array} obj
   * @param {string} keys
   * @return {boolean}
   */
  static has(e, t) {
    return this.__init(e, t), this.__next ? this.__nextKey === 0 ? !0 : this.has(e[this.key], this.arr.join(".")) : !1;
  }
  /**
   * @param {object|array} obj
   * @param {string} keys
   * @param {*} def
   * @return {*}
   */
  static get(e, t, n = null) {
    return this.__init(e, t), this.__next ? this.__nextKey === 0 ? e[this.key] : this.get(e[this.key], this.arr.join("."), n) : n;
  }
}
class lw {
  /**
   *
   * @param molecule
   */
  constructor(e) {
    if (e.molecularHash === null)
      throw new fw();
    if (!e.atoms.length)
      throw new ri();
    for (const t of e.atoms)
      if (t.index === null)
        throw new Ui();
    this.molecule = e;
  }
  /**
   *
   * @param senderWallet
   * @returns {false|*|boolean}
   */
  verify(e) {
    return this.molecularHash() && this.ots() && this.batchId() && this.continuId() && this.isotopeM() && this.isotopeT() && this.isotopeC() && this.isotopeU() && this.isotopeI() && this.isotopeR() && this.isotopeV(e);
  }
  /**
   *
   * @returns {boolean}
   */
  continuId() {
    if (this.molecule.atoms[0].token === "USER" && this.molecule.getIsotopes("I").length < 1)
      throw new ri("Check::continuId() - Molecule is missing required ContinuID Atom!");
    return !0;
  }
  /**
   *
   * @returns {boolean}
   */
  batchId() {
    if (this.molecule.atoms.length > 0) {
      const e = this.molecule.atoms[0];
      if (e.isotope === "V" && e.batchId !== null) {
        const t = this.molecule.getIsotopes("V"), n = t[t.length - 1];
        if (e.batchId !== n.batchId)
          throw new ro();
        for (const a of t)
          if (a.batchId === null)
            throw new ro();
      }
      return !0;
    }
    throw new ro();
  }
  /**
   *
   * @returns {boolean}
   */
  isotopeI() {
    for (const e of this.molecule.getIsotopes("I")) {
      if (e.token !== "USER")
        throw new $i(`Check::isotopeI() - "${e.token}" is not a valid Token slug for "${e.isotope}" isotope Atoms!`);
      if (e.index === 0)
        throw new Ui(`Check::isotopeI() - Isotope "${e.isotope}" Atoms must have a non-zero index!`);
    }
    return !0;
  }
  /**
   *
   * @returns {boolean}
   */
  isotopeU() {
    for (const e of this.molecule.getIsotopes("U")) {
      if (e.token !== "AUTH")
        throw new $i(`Check::isotopeU() - "${e.token}" is not a valid Token slug for "${e.isotope}" isotope Atoms!`);
      if (e.index !== 0)
        throw new Ui(`Check::isotopeU() - Isotope "${e.isotope}" Atoms must have an index equal to 0!`);
    }
    return !0;
  }
  /**
   *
   * @returns {boolean}
   */
  isotopeM() {
    const e = ["readPolicy", "writePolicy"];
    for (const t of this.molecule.getIsotopes("M")) {
      if (t.meta.length < 1)
        throw new In();
      if (t.token !== "USER")
        throw new $i(`Check::isotopeM() - "${t.token}" is not a valid Token slug for "${t.isotope}" isotope Atoms!`);
      const n = lo.aggregateMeta(t.meta);
      for (const a of e) {
        let i = n[a];
        if (i) {
          i = JSON.parse(i);
          for (const [o, u] of Object.entries(i))
            if (!e.includes(o)) {
              if (!Object.keys(n).includes(o))
                throw new Rp(`${o} is missing from the meta.`);
              for (const c of u)
                if (!tr.isBundleHash(c) && !["all", "self"].includes(c))
                  throw new Rp(`${c} does not correspond to the format of the policy.`);
            }
        }
      }
    }
    return !0;
  }
  /**
   *
   * @returns {boolean}
   */
  isotopeC() {
    for (const e of this.molecule.getIsotopes("C")) {
      if (e.token !== "USER")
        throw new $i(`Check::isotopeC() - "${e.token}" is not a valid Token slug for "${e.isotope}" isotope Atoms!`);
      if (e.index !== 0)
        throw new Ui(`Check::isotopeC() - Isotope "${e.isotope}" Atoms must have an index equal to 0!`);
    }
    return !0;
  }
  /**
   *
   * @returns {boolean}
   */
  isotopeT() {
    for (const e of this.molecule.getIsotopes("T")) {
      const t = e.aggregatedMeta();
      if (String(e.metaType).toLowerCase() === "wallet") {
        for (const a of ["position", "bundle"])
          if (!t.hasOwnProperty(a) || !t[a])
            throw new In(`Check::isotopeT() - Required meta field "${a}" is missing!`);
      }
      for (const a of ["token"])
        if (!t.hasOwnProperty(a) || !t[a])
          throw new In(`Check::isotopeT() - Required meta field "${a}" is missing!`);
      if (e.token !== "USER")
        throw new $i(`Check::isotopeT() - "${e.token}" is not a valid Token slug for "${e.isotope}" isotope Atoms!`);
      if (e.index !== 0)
        throw new Ui(`Check::isotopeT() - Isotope "${e.isotope}" Atoms must have an index equal to 0!`);
    }
    return !0;
  }
  /**
   *
   * @returns {boolean}
   */
  isotopeR() {
    for (const e of this.molecule.getIsotopes("R")) {
      const t = e.aggregatedMeta();
      if (t.policy) {
        const n = JSON.parse(t.policy);
        if (!Object.keys(n).every((a) => ["read", "write"].includes(a)))
          throw new In("Check::isotopeR() - Mixing rules with politics!");
      }
      if (t.rule) {
        const n = JSON.parse(t.rule);
        if (!Array.isArray(n))
          throw new In("Check::isotopeR() - Incorrect rule format!");
        for (const a of n)
          aa.toObject(a);
        if (n.length < 1)
          throw new In("Check::isotopeR() - No rules!");
      }
    }
    return !0;
  }
  /**
   *
   * @param senderWallet
   * @returns {boolean}
   */
  isotopeV(e = null) {
    const t = this.molecule.getIsotopes("V");
    if (t.length === 0)
      return !0;
    const n = this.molecule.atoms[0];
    if (n.isotope === "V" && t.length === 2) {
      const o = t[t.length - 1];
      if (n.token !== o.token)
        throw new Op();
      if (o.value < 0)
        throw new Cp();
      return !0;
    }
    let a = 0, i = 0;
    for (const o in this.molecule.atoms)
      if (this.molecule.atoms.hasOwnProperty(o)) {
        const u = this.molecule.atoms[o];
        if (u.isotope !== "V")
          continue;
        if (i = u.value * 1, Number.isNaN(i))
          throw new TypeError('Invalid isotope "V" values');
        if (u.token !== n.token)
          throw new Op();
        if (o > 0) {
          if (i < 0)
            throw new Cp();
          if (u.walletAddress === n.walletAddress)
            throw new cw();
        }
        a += i;
      }
    if (a !== i)
      throw new hw();
    if (e) {
      if (i = n.value * 1, Number.isNaN(i))
        throw new TypeError('Invalid isotope "V" values');
      const o = e.balance + i;
      if (o < 0)
        throw new bn();
      if (o !== a)
        throw new Bp();
    } else if (i !== 0)
      throw new Bp();
    return !0;
  }
  /**
   * Verifies if the hash of all the atoms matches the molecular hash to ensure content has not been messed with
   *
   * @returns {boolean}
   */
  molecularHash() {
    if (this.molecule.molecularHash !== Ut.hashAtoms({
      atoms: this.molecule.atoms
    }))
      throw new sw();
    return !0;
  }
  /**
   * Checks if the provided molecule was signed properly by transforming a collection of signature
   * fragments from its atoms and its molecular hash into a single-use wallet address to be matched
   * against the senders address. If it matches, the molecule was correctly signed.
   *
   * @returns {boolean}
   */
  ots() {
    const e = this.molecule.normalizedHash();
    let t = this.molecule.atoms.map(
      (l) => l.otsFragment
    ).reduce(
      (l, y) => l + y
    );
    if (t.length !== 2048 && (t = b2(t), t.length !== 2048))
      throw new dy();
    const n = ho(t, 128);
    let a = "";
    for (const l in n) {
      let y = n[l];
      for (let m = 0, w = 8 + e[l]; m < w; m++)
        y = new Lr("SHAKE256", "TEXT").update(y).getHash("HEX", { outputLen: 512 });
      a += y;
    }
    const i = new Lr("SHAKE256", "TEXT");
    i.update(a);
    const o = i.getHash("HEX", { outputLen: 8192 }), u = new Lr("SHAKE256", "TEXT");
    u.update(o);
    const c = u.getHash("HEX", { outputLen: 256 }), h = this.molecule.atoms[0];
    let s = h.walletAddress;
    const d = dr.get(h.aggregatedMeta(), "signingWallet");
    if (d && (s = dr.get(JSON.parse(d), "address")), c !== s)
      throw new uw();
    return !0;
  }
}
class ji extends sr {
  /**
   * Class constructor
   *
   * @param {string} message
   * @param {string|null} fileName
   * @param {number|null} lineNumber
   */
  constructor(e = "Insufficient balance for requested transfer", t = null, n = null) {
    super(e, t, n), this.name = "BalanceInsufficientException";
  }
}
class Dp extends sr {
  /**
   * Class constructor
   *
   * @param {string} message
   * @param {string|null} fileName
   * @param {number|null} lineNumber
   */
  constructor(e = "Amount cannot be negative!", t = null, n = null) {
    super(e, t, n), this.name = "NegativeAmountException";
  }
}
class mn {
  /**
   * Class constructor
   *
   * @param {string|null} secret
   * @param {string|null} bundle
   * @param {Wallet|null} sourceWallet
   * @param {Wallet|null} remainderWallet
   * @param {string|null} cellSlug
   * @param {string|null} version
   */
  constructor({
    secret: e = null,
    bundle: t = null,
    sourceWallet: n = null,
    remainderWallet: a = null,
    cellSlug: i = null,
    version: o = null
  }) {
    this.cellSlugOrigin = this.cellSlug = i, this.secret = e, this.bundle = t, this.sourceWallet = n, this.atoms = [], o !== null && Ja.hasOwnProperty(o) && (this.version = String(o)), (a || n) && (this.remainderWallet = a || tr.create({
      secret: e,
      bundle: t,
      token: n.token,
      batchId: n.batchId,
      characters: n.characters
    })), this.clear();
  }
  /**
   * Returns the cell slug delimiter
   *
   * @return {string}
   */
  get cellSlugDelimiter() {
    return ".";
  }
  /**
   * Filters the atoms array by the supplied isotope list
   *
   * @param {string|array} isotopes
   * @param {array} atoms
   * @returns {*[]}
   */
  static isotopeFilter(e, t) {
    return Array.isArray(e) || (e = [e]), t.filter((n) => e.includes(n.isotope));
  }
  /**
   * Generates the next atomic index
   *
   * @param {array} atoms
   * @return {number}
   */
  static generateNextAtomIndex(e) {
    return e.length;
  }
  /**
   * Converts a JSON object into a Molecule Structure instance
   *
   * @param {string} json
   * @return {object}
   * @throws {AtomsMissingException}
   */
  static jsonToObject(e) {
    const t = Object.assign(new mn({}), JSON.parse(e)), n = Object.keys(new mn({}));
    if (!Array.isArray(t.atoms))
      throw new ri();
    for (const a in Object.keys(t.atoms)) {
      t.atoms[a] = Ut.jsonToObject(JSON.stringify(t.atoms[a]));
      for (const i of ["position", "walletAddress", "isotope"])
        if (t.atoms[a].isotope.toLowerCase() !== "r" && (typeof t.atoms[a][i] == "undefined" || t.atoms[a][i] === null))
          throw new ri("MolecularStructure::jsonToObject() - Required Atom properties are missing!");
    }
    for (const a in t)
      t.hasOwnProperty(a) && !n.includes(a) && delete t[a];
    return t.atoms = Ut.sortAtoms(t.atoms), t;
  }
  /**
   * Accept a string of letters and numbers, and outputs a collection of decimals representing each
   * character according to a pre-defined dictionary. Input string would typically be 64-character
   * hexadecimal string featuring numbers from 0 to 9 and characters from a to f - a total of 15
   * unique symbols. To ensure that string has an even number of symbols, convert it to Base 17
   * (adding G as a possible symbol). Map each symbol to integer values as follows:
   *  0   1   2   3   4   5   6   7  8  9  a   b   c   d   e   f   g
   * -8  -7  -6  -5  -4  -3  -2  -1  0  1  2   3   4   5   6   7   8
   *
   * @param {string} hash
   * @return {array}
   */
  static enumerate(e) {
    const t = {
      0: -8,
      1: -7,
      2: -6,
      3: -5,
      4: -4,
      5: -3,
      6: -2,
      7: -1,
      8: 0,
      9: 1,
      a: 2,
      b: 3,
      c: 4,
      d: 5,
      e: 6,
      f: 7,
      g: 8
    }, n = [], a = e.toLowerCase().split("");
    for (let i = 0, o = a.length; i < o; ++i) {
      const u = a[i];
      typeof t[u] != "undefined" && (n[i] = t[u]);
    }
    return n;
  }
  /**
   * Normalize enumerated string to ensure that the total sum of all symbols is exactly zero. This
   * ensures that exactly 50% of the WOTS+ key is leaked with each usage, ensuring predictable key
   * safety:
   * The sum of each symbol within Hm shall be presented by m
   *  While m0 iterate across that sets integers as Im:
   *    If m0 and Im>-8 , let Im=Im-1
   *    If m<0 and Im<8 , let Im=Im+1
   *    If m=0, stop the iteration
   *
   * @param {array} mappedHashArray
   * @return {array}
   */
  static normalize(e) {
    let t = e.reduce((a, i) => a + i);
    const n = t < 0;
    for (; t < 0 || t > 0; )
      for (const a of Object.keys(e))
        if ((n ? e[a] < 8 : e[a] > -8) && (n ? (++e[a], ++t) : (--e[a], --t), t === 0))
          break;
    return e;
  }
  /**
   *
   * @param isotopes
   * @returns {*[]}
   */
  getIsotopes(e) {
    return mn.isotopeFilter(e, this.atoms);
  }
  /**
   * Generates the next atomic index
   *
   * @return {number}
   */
  generateIndex() {
    return mn.generateNextAtomIndex(this.atoms);
  }
  /**
   * Fills a Molecule's properties with the provided object
   *
   * @param {Molecule} molecule
   */
  fill(e) {
    for (const t in Object.keys(e))
      this[t] = e[t];
  }
  /**
   *
   * @param {Atom} atom
   * @returns {Molecule}
   */
  addAtom(e) {
    return this.molecularHash = null, e.index = this.generateIndex(), e.version = this.version, this.atoms.push(e), this.atoms = Ut.sortAtoms(this.atoms), this;
  }
  /**
   * Add user remainder atom for ContinuID
   *
   * @return {Molecule}
   */
  addContinuIdAtom() {
    return this.addAtom(Ut.create({
      isotope: "I",
      wallet: this.remainderWallet,
      metaType: "walletBundle",
      metaId: this.remainderWallet.bundle
    })), this;
  }
  /**
   *
   * @param {string} metaType
   * @param {string} metaId
   * @param {object} meta
   * @param {object} policy
   *
   * @return {Molecule}
   */
  addPolicyAtom({
    metaType: e,
    metaId: t,
    meta: n = {},
    policy: a = {}
  }) {
    const i = new Yr(n);
    i.addPolicy(a);
    const o = tr.create({
      secret: this.secret,
      bundle: this.sourceWallet.bundle,
      token: "USER"
    });
    return this.addAtom(Ut.create({
      wallet: o,
      isotope: "R",
      metaType: e,
      metaId: t,
      meta: i
    })), this;
  }
  /**
   *
   * @param tokenUnits
   * @param recipientWallet
   * @returns {Molecule}
   */
  fuseToken(e, t) {
    const n = e.length;
    if (this.sourceWallet.balance - n < 0)
      throw new ji();
    return this.addAtom(Ut.create({
      isotope: "V",
      wallet: this.sourceWallet,
      value: -n
    })), this.addAtom(Ut.create({
      isotope: "F",
      wallet: t,
      value: 1,
      metaType: "walletBundle",
      metaId: t.bundle
    })), this.addAtom(Ut.create({
      isotope: "V",
      wallet: this.remainderWallet,
      value: this.sourceWallet.balance - n,
      metaType: "walletBundle",
      metaId: this.remainderWallet.bundle
    })), this;
  }
  /**
   * Burns some amount of tokens from a wallet
   *
   * @param {number} amount
   * @param {string|null} walletBundle
   * @return {Molecule}
   */
  burnToken({
    amount: e,
    walletBundle: t = null
  }) {
    if (e < 0)
      throw new Dp("Molecule::burnToken() - Amount to burn must be positive!");
    if (this.sourceWallet.balance - e < 0)
      throw new ji();
    return this.addAtom(Ut.create({
      isotope: "V",
      wallet: this.sourceWallet,
      value: -e
    })), this.addAtom(Ut.create({
      isotope: "V",
      wallet: this.remainderWallet,
      value: this.sourceWallet.balance - e,
      metaType: "walletBundle",
      metaId: this.remainderWallet.bundle
    })), this;
  }
  /*
   * Replenishes non-finite token supplies
   *
   * @param {number} amount
   * @param {string} token
   * @param {array|object} metas
   * @return {Molecule}
   */
  replenishToken({
    amount: e,
    units: t = []
  }) {
    if (e < 0)
      throw new Dp("Molecule::replenishToken() - Amount to replenish must be positive!");
    if (t.length) {
      t = tr.getTokenUnits(t), this.remainderWallet.tokenUnits = this.sourceWallet.tokenUnits;
      for (const n of t)
        this.remainderWallet.tokenUnits.push(n);
      this.remainderWallet.balance = this.remainderWallet.tokenUnits.length, this.sourceWallet.tokenUnits = t, this.sourceWallet.balance = this.sourceWallet.tokenUnits.length;
    } else
      this.remainderWallet.balance = this.sourceWallet.balance + e, this.sourceWallet.balance = e;
    return this.addAtom(Ut.create({
      isotope: "V",
      wallet: this.sourceWallet,
      value: this.sourceWallet.balance
    })), this.addAtom(Ut.create({
      isotope: "V",
      wallet: this.remainderWallet,
      value: this.remainderWallet.balance,
      metaType: "walletBundle",
      metaId: this.remainderWallet.bundle
    })), this;
  }
  /**
   * Initialize a V-type molecule to transfer value from one wallet to another, with a third,
   * regenerated wallet receiving the remainder
   *
   * @param {Wallet} recipientWallet
   * @param {number} amount
   * @return {Molecule}
   */
  initValue({
    recipientWallet: e,
    amount: t
  }) {
    if (this.sourceWallet.balance - t < 0)
      throw new ji();
    return this.addAtom(Ut.create({
      isotope: "V",
      wallet: this.sourceWallet,
      value: -t
    })), this.addAtom(Ut.create({
      isotope: "V",
      wallet: e,
      value: t,
      metaType: "walletBundle",
      metaId: e.bundle
    })), this.addAtom(Ut.create({
      isotope: "V",
      wallet: this.remainderWallet,
      value: this.sourceWallet.balance - t,
      metaType: "walletBundle",
      metaId: this.remainderWallet.bundle
    })), this;
  }
  /**
   *
   * @param amount
   * @param tradeRates
   */
  initDepositBuffer({
    amount: e,
    tradeRates: t
  }) {
    if (this.sourceWallet.balance - e < 0)
      throw new ji();
    const n = tr.create({
      secret: this.secret,
      bundle: this.bundle,
      token: this.sourceWallet.token,
      batchId: this.sourceWallet.batchId
    });
    return n.tradeRates = t, this.addAtom(Ut.create({
      isotope: "V",
      wallet: this.sourceWallet,
      value: -e
    })), this.addAtom(Ut.create({
      isotope: "B",
      wallet: n,
      value: e,
      metaType: "walletBundle",
      metaId: this.sourceWallet.bundle
    })), this.addAtom(Ut.create({
      isotope: "V",
      wallet: this.remainderWallet,
      value: this.sourceWallet.balance - e,
      metaType: "walletBundle",
      metaId: this.sourceWallet.bundle
    })), this;
  }
  /**
   *
   * @param {{}} recipients
   * @param {Wallet|{}} signingWallet
   * @returns {Molecule}
   */
  initWithdrawBuffer({
    recipients: e,
    signingWallet: t = null
  }) {
    let n = 0;
    for (const [i, o] of Object.entries(e || {}))
      n += o;
    if (this.sourceWallet.balance - n < 0)
      throw new ji();
    const a = new Yr();
    t && a.setSigningWallet(t), this.addAtom(Ut.create({
      isotope: "B",
      wallet: this.sourceWallet,
      value: -n,
      meta: a,
      metaType: "walletBundle",
      metaId: this.sourceWallet.bundle
    }));
    for (const [i, o] of Object.entries(e || {}))
      this.addAtom(new Ut({
        isotope: "V",
        token: this.sourceWallet.token,
        value: o,
        batchId: this.sourceWallet.batchId ? po({}) : null,
        metaType: "walletBundle",
        metaId: i
      }));
    return this.addAtom(Ut.create({
      isotope: "B",
      wallet: this.remainderWallet,
      value: this.sourceWallet.balance - n,
      metaType: "walletBundle",
      metaId: this.remainderWallet.bundle
    })), this;
  }
  /**
   * Initialize a C-type molecule to issue a new type of token
   *
   * @param {Wallet} recipientWallet - wallet receiving the tokens. Needs to be initialized for the new token beforehand.
   * @param {number} amount - how many of the token we are initially issuing (for fungible tokens only)
   * @param {array|object} meta - additional fields to configure the token
   * @return {Molecule}
   */
  initTokenCreation({
    recipientWallet: e,
    amount: t,
    meta: n
  }) {
    const a = new Yr(n);
    return a.setMetaWallet(e), this.addAtom(Ut.create({
      isotope: "C",
      wallet: this.sourceWallet,
      value: t,
      metaType: "token",
      metaId: e.token,
      meta: a,
      batchId: e.batchId
    })), this.addContinuIdAtom(), this;
  }
  /**
   *
   * @param {string} metaType
   * @param {string} metaId
   * @param {object[]} rule,
   * @param {object} policy
   * @return {Molecule}
   */
  createRule({
    metaType: e,
    metaId: t,
    rule: n,
    policy: a = {}
  }) {
    const i = [];
    for (const u of n)
      i.push(u instanceof aa ? u : aa.toObject(u));
    const o = new Yr({
      rule: JSON.stringify(i)
    });
    return o.addPolicy(a), this.addAtom(Ut.create({
      isotope: "R",
      wallet: this.sourceWallet,
      metaType: e,
      metaId: t,
      meta: o
    })), this.addContinuIdAtom(), this;
  }
  /**
   * Builds Atoms to define a new wallet on the ledger
   *
   * @param {Wallet} wallet
   * @param {AtomMeta|null} atomMeta
   * @return {Molecule}
   */
  initWalletCreation(e, t = null) {
    return t || (t = new Yr()), t.setMetaWallet(e), this.addAtom(Ut.create({
      isotope: "C",
      wallet: this.sourceWallet,
      metaType: "wallet",
      metaId: e.address,
      meta: t,
      batchId: e.batchId
    })), this.addContinuIdAtom(), this;
  }
  /**
   * Init shadow wallet claim
   *
   * @param wallet
   */
  initShadowWalletClaim(e) {
    const t = new Yr().setShadowWalletClaim(!0);
    return this.initWalletCreation(e, t);
  }
  /**
   * Builds Atoms to define a new identifier on the ledger
   *
   * @param {string} type - phone or email
   * @param {string} contact - phone number or email string
   * @param {string} code -
   *
   * @return {Molecule}
   */
  initIdentifierCreation({
    type: e,
    contact: t,
    code: n
  }) {
    const a = {
      code: n,
      hash: Nn(t.trim(), "Molecule::initIdentifierCreation")
    };
    return this.addAtom(Ut.create({
      isotope: "C",
      wallet: this.sourceWallet,
      metaType: "identifier",
      metaId: e,
      meta: new Yr(a)
    })), this.addContinuIdAtom(), this;
  }
  /**
   * Initialize an M-type molecule with the given data
   *
   * @param {array|object} meta
   * @param {string} metaType
   * @param {string} metaId
   * @param {object} policy
   * @return {Molecule}
   */
  initMeta({
    meta: e,
    metaType: t,
    metaId: n,
    policy: a
  }) {
    return this.addAtom(Ut.create({
      isotope: "M",
      wallet: this.sourceWallet,
      metaType: t,
      metaId: n,
      meta: new Yr(e)
    })), this.addPolicyAtom({
      metaType: t,
      metaId: n,
      meta: e,
      policy: a
    }), this.addContinuIdAtom(), this;
  }
  /**
   * Arranges atoms to request tokens from the node itself
   *
   * @param {string} token
   * @param {Number} amount
   * @param {string} metaType
   * @param {string} metaId
   * @param {array|object} meta
   * @param {string|null} batchId
   *
   * @return {Molecule}
   */
  initTokenRequest({
    token: e,
    amount: t,
    metaType: n,
    metaId: a,
    meta: i = {},
    batchId: o = null
  }) {
    return i.token = e, this.local = 1, this.addAtom(Ut.create({
      isotope: "T",
      wallet: this.sourceWallet,
      value: t,
      metaType: n,
      metaId: a,
      meta: new Yr(i),
      batchId: o
    })), this.addContinuIdAtom(), this;
  }
  /**
   * Arranges atoms to request an authorization token from the node
   *
   * @param {object} meta
   *
   * @return {Molecule}
   */
  initAuthorization({ meta: e }) {
    return this.addAtom(Ut.create({
      isotope: "U",
      wallet: this.sourceWallet,
      meta: new Yr(e)
    })), this.addContinuIdAtom(), this;
  }
  /**
   * Clears the instance of the data, leads the instance to a state equivalent to that after new Molecule()
   *
   * @return {Molecule}
   */
  clear() {
    return this.molecularHash = null, this.bundle = null, this.status = null, this.createdAt = String(+/* @__PURE__ */ new Date()), this.atoms = [], this;
  }
  /**
   * Creates a one-time signature for a molecule and breaks it up across multiple atoms within that
   * molecule. Resulting 4096 byte (2048 character) string is the one-time signature, which is then compressed.
   *
   * @param {string|null} bundle
   * @param {boolean} anonymous
   * @param {boolean} compressed
   * @return {string|null}
   * @throws {AtomsMissingException}
   */
  sign({
    bundle: e = null,
    anonymous: t = !1,
    compressed: n = !0
  }) {
    if (this.atoms.length === 0 || this.atoms.filter((y) => !(y instanceof Ut)).length !== 0)
      throw new ri();
    !t && !this.bundle && (this.bundle = e || Nn(this.secret, "Molecule::sign")), this.molecularHash = Ut.hashAtoms({
      atoms: this.atoms
    });
    const a = this.atoms[0];
    let i = a.position;
    const o = dr.get(a.aggregatedMeta(), "signingWallet");
    if (o && (i = dr.get(JSON.parse(o), "position")), !i)
      throw new dy("Signing wallet must have a position!");
    const u = tr.generateKey({
      secret: this.secret,
      token: a.token,
      position: a.position
    }), c = ho(u, 128), h = this.normalizedHash();
    let s = "";
    for (const y in c) {
      let m = c[y];
      for (let w = 0, E = 8 - h[y]; w < E; w++)
        m = new Lr("SHAKE256", "TEXT").update(m).getHash("HEX", { outputLen: 512 });
      s += m;
    }
    n && (s = y2(s));
    const d = ho(s, Math.ceil(s.length / this.atoms.length));
    let l = null;
    for (let y = 0, m = d.length; y < m; y++)
      this.atoms[y].otsFragment = d[y], l = this.atoms[y].position;
    return l;
  }
  /**
   * Returns the base cell slug portion
   *
   * @return {string}
   */
  cellSlugBase() {
    return (this.cellSlug || "").split(this.cellSlugDelimiter)[0];
  }
  /**
   * Returns JSON-ready clone minus protected properties
   *
   * @return {object}
   */
  toJSON() {
    const e = i1(this);
    for (const t of ["remainderWallet", "secret", "sourceWallet", "cellSlugOrigin", "version"])
      e.hasOwnProperty(t) && delete e[t];
    return e;
  }
  /**
   * Validates the current molecular structure
   *
   * @param senderWallet
   */
  check(e = null) {
    new lw(this).verify(e);
  }
  /**
   * Convert Hm to numeric notation via EnumerateMolecule(Hm)
   *
   * @returns {Array}
   */
  normalizedHash() {
    return mn.normalize(mn.enumerate(this.molecularHash));
  }
}
const Uu = ar(10, 18);
class mi {
  /**
   * @param {number} value
   * @return {number}
   */
  static val(e) {
    return Math.abs(e * Uu) < 1 ? 0 : e;
  }
  /**
   * @param {number} value1
   * @param {number} value2
   * @param {boolean} debug
   * @return {number}
   */
  static cmp(e, t, n = !1) {
    const a = mi.val(e) * Uu, i = mi.val(t) * Uu;
    return Math.abs(a - i) < 1 ? 0 : a > i ? 1 : -1;
  }
  /**
   * @param {number} value1
   * @param {number} value2
   * @return {boolean}
   */
  static equal(e, t) {
    return mi.cmp(e, t) === 0;
  }
}
class oa {
  /**
   *
   * @param {string} token
   * @param {number} expiresAt
   * @param {boolean} encrypt
   * @param {string} pubkey
   */
  constructor({
    token: e,
    expiresAt: t,
    encrypt: n,
    pubkey: a
  }) {
    this.$__token = e, this.$__expiresAt = t, this.$__pubkey = a, this.$__encrypt = n;
  }
  /**
   *
   * @param data
   * @param wallet
   * @returns {AuthToken}
   */
  static create(e, t) {
    const n = new oa(e);
    return n.setWallet(t), n;
  }
  /**
   *
   * @param {object} snapshot
   * @param {string} secret
   * @return {AuthToken}
   */
  static restore(e, t) {
    const n = new tr({
      secret: t,
      token: "AUTH",
      position: e.wallet.position,
      characters: e.wallet.characters
    });
    return oa.create({
      token: e.token,
      expiresAt: e.expiresAt,
      pubkey: e.pubkey,
      encrypt: e.encrypt
    }, n);
  }
  /**
   *
   * @param {Wallet} wallet
   */
  setWallet(e) {
    this.$__wallet = e;
  }
  /**
   * Get a wallet
   * @return {Wallet}
   */
  getWallet() {
    return this.$__wallet;
  }
  /**
   *
   * @return {{wallet: {characters, position}, encrypt, expiresAt, token, pubkey}}
   */
  getSnapshot() {
    return {
      token: this.$__token,
      expiresAt: this.$__expiresAt,
      pubkey: this.$__pubkey,
      encrypt: this.$__encrypt,
      wallet: {
        position: this.$__wallet.position,
        characters: this.$__wallet.characters
      }
    };
  }
  /**
   *
   * @return {string}
   */
  getToken() {
    return this.$__token;
  }
  /**
   *
   * @return {string}
   */
  getPubkey() {
    return this.$__pubkey;
  }
  /**
   *
   * @return {number}
   */
  getExpireInterval() {
    return this.$__expiresAt * 1e3 - Date.now();
  }
  /**
   *
   * @return {boolean}
   */
  isExpired() {
    return !this.$__expiresAt || this.getExpireInterval() < 0;
  }
  /**
   * Get auth data for the final client (apollo)
   * @return {{wallet: Wallet, token: string, pubkey: string}}
   */
  getAuthData() {
    return {
      token: this.getToken(),
      pubkey: this.getPubkey(),
      wallet: this.getWallet()
    };
  }
}
class Zi extends sr {
  /**
   * Class constructor
   *
   * @param {string} message
   * @param {string|null} fileName
   * @param {number|null} lineNumber
   */
  constructor(e = "GraphQL did not provide a valid response.", t = null, n = null) {
    super(e, t, n), this.name = "InvalidResponseException";
  }
}
class hc extends sr {
  /**
   * Class constructor
   *
   * @param {string} message
   * @param {string|null} fileName
   * @param {number|null} lineNumber
   */
  constructor(e = "Authorization token missing or invalid.", t = null, n = null) {
    super(e, t, n), this.name = "UnauthenticatedException";
  }
}
let Cr = class {
  /**
   * Class constructor
   *
   * @param {Query} query
   * @param {object} json
   * @param {string|null} dataKey
   */
  constructor({
    query: e,
    json: t,
    dataKey: n = null
  }) {
    if (this.dataKey = n, this.errorKey = "exception", this.$__payload = null, this.$__query = e, this.$__originResponse = t, this.$__response = t, typeof this.$__response == "undefined" || this.$__response === null)
      throw new Zi();
    if (dr.has(this.$__response, this.errorKey)) {
      const a = dr.get(this.$__response, this.errorKey);
      throw String(a).includes("Unauthenticated") ? new hc() : new Zi();
    }
    this.init();
  }
  /**
   *
   */
  init() {
  }
  /**
   * @return {*}
   */
  data() {
    if (!this.dataKey)
      return this.response();
    if (!dr.has(this.response(), this.dataKey))
      throw new Zi();
    return dr.get(this.response(), this.dataKey);
  }
  /**
   * @return {object}
   */
  response() {
    return this.$__response;
  }
  /**
   * @return {*}
   */
  payload() {
    return null;
  }
  /**
   * @return {Query}
   */
  query() {
    return this.$__query;
  }
  /**
   * @return {*}
   */
  status() {
    return null;
  }
};
class Fr {
  /**
   *
   * @param {ApolloClient} apolloClient
   */
  constructor(e) {
    this.client = e, this.$__variables = null, this.$__query = null;
  }
  /**
   * Return a response object
   * Used at KnishIOClient::createMolecule => sets the source wallet from the remainder one stored in response object
   * @return {Response}
   */
  response() {
    return this.$__response;
  }
  /**
   * Builds a Response based on JSON input
   *
   * @param response
   * @return {Promise<Response>}
   */
  createResponseRaw(e) {
    return wt(this, null, function* () {
      return this.createResponse(e);
    });
  }
  /**
   * Returns a Response object
   *
   * @param {object} json
   * @return {Response}
   */
  createResponse(e) {
    return new Cr({
      query: this,
      json: e
    });
  }
  /**
   * Creates a new Request for the given parameters
   *
   * @param {{}} variables
   * @returns {{variables: (Object|null), query: null}}
   */
  createQuery({ variables: e = null }) {
    if (this.$__variables = this.compiledVariables(e), !this.uri())
      throw new $r("Query::createQuery() - Node URI was not initialized for this client instance!");
    if (this.$__query === null)
      throw new $r("Query::createQuery() - GraphQL subscription was not initialized!");
    return {
      query: this.$__query,
      variables: this.variables()
    };
  }
  /**
   * Sends the Query to a Knish.IO node and returns the Response
   *
   * @param {object} variables
   * @return {Promise<Response>}
   */
  execute(t) {
    return wt(this, arguments, function* ({ variables: e = null }) {
      this.$__request = this.createQuery({
        variables: e
      });
      const n = yield this.client.query(this.$__request);
      return this.$__response = yield this.createResponseRaw(n), this.$__response;
    });
  }
  /**
   * Returns a variables object for the Query
   *
   * @param {object} variables
   * @return {object}
   */
  compiledVariables(e = null) {
    return e || {};
  }
  /**
   * Returns the Knish.IO endpoint URI
   *
   * @return {string}
   */
  uri() {
    return this.client.getUri();
  }
  /**
   * Returns the query variables object
   *
   * @return {object|null}
   */
  variables() {
    return this.$__variables;
  }
}
class dw extends Cr {
  /**
   * Class constructor
   *
   * @param {Query} query
   * @param {object} json
   */
  constructor({
    query: e,
    json: t
  }) {
    super({
      query: e,
      json: t,
      dataKey: "data.ContinuId"
    });
  }
  /**
   * Returns the ContinuID wallet
   *
   * @return {Wallet|null}
   */
  payload() {
    let e = null;
    const t = this.data();
    return t && (e = new tr({
      secret: null,
      token: t.tokenSlug
    }), e.address = t.address, e.position = t.position, e.bundle = t.bundleHash, e.batchId = t.batchId, e.characters = t.characters, e.pubkey = t.pubkey, e.balance = t.amount * 1), e;
  }
}
var lc = function(r, e) {
  return lc = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, n) {
    t.__proto__ = n;
  } || function(t, n) {
    for (var a in n)
      Object.prototype.hasOwnProperty.call(n, a) && (t[a] = n[a]);
  }, lc(r, e);
};
function tn(r, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  lc(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
var _e = function() {
  return _e = Object.assign || function(e) {
    for (var t, n = 1, a = arguments.length; n < a; n++) {
      t = arguments[n];
      for (var i in t)
        Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
    }
    return e;
  }, _e.apply(this, arguments);
};
function qn(r, e) {
  var t = {};
  for (var n in r)
    Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]);
  if (r != null && typeof Object.getOwnPropertySymbols == "function")
    for (var a = 0, n = Object.getOwnPropertySymbols(r); a < n.length; a++)
      e.indexOf(n[a]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[a]) && (t[n[a]] = r[n[a]]);
  return t;
}
function Rn(r, e, t, n) {
  function a(i) {
    return i instanceof t ? i : new t(function(o) {
      o(i);
    });
  }
  return new (t || (t = Promise))(function(i, o) {
    function u(s) {
      try {
        h(n.next(s));
      } catch (d) {
        o(d);
      }
    }
    function c(s) {
      try {
        h(n.throw(s));
      } catch (d) {
        o(d);
      }
    }
    function h(s) {
      s.done ? i(s.value) : a(s.value).then(u, c);
    }
    h((n = n.apply(r, e || [])).next());
  });
}
function Cn(r, e) {
  var t = { label: 0, sent: function() {
    if (i[0] & 1)
      throw i[1];
    return i[1];
  }, trys: [], ops: [] }, n, a, i, o;
  return o = { next: u(0), throw: u(1), return: u(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function u(h) {
    return function(s) {
      return c([h, s]);
    };
  }
  function c(h) {
    if (n)
      throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, h[0] && (t = 0)), t; )
      try {
        if (n = 1, a && (i = h[0] & 2 ? a.return : h[0] ? a.throw || ((i = a.return) && i.call(a), 0) : a.next) && !(i = i.call(a, h[1])).done)
          return i;
        switch (a = 0, i && (h = [h[0] & 2, i.value]), h[0]) {
          case 0:
          case 1:
            i = h;
            break;
          case 4:
            return t.label++, { value: h[1], done: !1 };
          case 5:
            t.label++, a = h[1], h = [0];
            continue;
          case 7:
            h = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (h[0] === 6 || h[0] === 2)) {
              t = 0;
              continue;
            }
            if (h[0] === 3 && (!i || h[1] > i[0] && h[1] < i[3])) {
              t.label = h[1];
              break;
            }
            if (h[0] === 6 && t.label < i[1]) {
              t.label = i[1], i = h;
              break;
            }
            if (i && t.label < i[2]) {
              t.label = i[2], t.ops.push(h);
              break;
            }
            i[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        h = e.call(r, t);
      } catch (s) {
        h = [6, s], a = 0;
      } finally {
        n = i = 0;
      }
    if (h[0] & 5)
      throw h[1];
    return { value: h[0] ? h[1] : void 0, done: !0 };
  }
}
function en(r, e, t) {
  if (t || arguments.length === 2)
    for (var n = 0, a = e.length, i; n < a; n++)
      (i || !(n in e)) && (i || (i = Array.prototype.slice.call(e, 0, n)), i[n] = e[n]);
  return r.concat(i || Array.prototype.slice.call(e));
}
var $u = "Invariant Violation", Np = Object.setPrototypeOf, pw = Np === void 0 ? function(r, e) {
  return r.__proto__ = e, r;
} : Np, py = (
  /** @class */
  function(r) {
    tn(e, r);
    function e(t) {
      t === void 0 && (t = $u);
      var n = r.call(this, typeof t == "number" ? $u + ": " + t + " (see https://github.com/apollographql/invariant-packages)" : t) || this;
      return n.framesToPop = 1, n.name = $u, pw(n, e.prototype), n;
    }
    return e;
  }(Error)
);
function Zn(r, e) {
  if (!r)
    throw new py(e);
}
var vy = ["debug", "log", "warn", "error", "silent"], vw = vy.indexOf("log");
function Va(r) {
  return function() {
    if (vy.indexOf(r) >= vw) {
      var e = console[r] || console.log;
      return e.apply(console, arguments);
    }
  };
}
(function(r) {
  r.debug = Va("debug"), r.log = Va("log"), r.warn = Va("warn"), r.error = Va("error");
})(Zn || (Zn = {}));
var ph = "3.9.7";
const sa = globalThis || void 0 || self;
function Xr(r) {
  try {
    return r();
  } catch (e) {
  }
}
const dc = Xr(function() {
  return globalThis;
}) || Xr(function() {
  return window;
}) || Xr(function() {
  return self;
}) || Xr(function() {
  return sa;
}) || // We don't expect the Function constructor ever to be invoked at runtime, as
// long as at least one of globalThis, window, self, or global is defined, so
// we are under no obligation to make it easy for static analysis tools to
// detect syntactic usage of the Function constructor. If you think you can
// improve your static analysis to detect this obfuscation, think again. This
// is an arms race you cannot win, at least not in JavaScript.
Xr(function() {
  return Xr.constructor("return this")();
});
var qp = /* @__PURE__ */ new Map();
function pc(r) {
  var e = qp.get(r) || 1;
  return qp.set(r, e + 1), "".concat(r, ":").concat(e, ":").concat(Math.random().toString(36).slice(2));
}
function yy(r, e) {
  e === void 0 && (e = 0);
  var t = pc("stringifyForDisplay");
  return JSON.stringify(r, function(n, a) {
    return a === void 0 ? t : a;
  }, e).split(JSON.stringify(t)).join("<undefined>");
}
function Wa(r) {
  return function(e) {
    for (var t = [], n = 1; n < arguments.length; n++)
      t[n - 1] = arguments[n];
    if (typeof e == "number") {
      var a = e;
      e = vh(a), e || (e = yh(a, t), t = []);
    }
    r.apply(void 0, [e].concat(t));
  };
}
var Ct = Object.assign(function(e, t) {
  for (var n = [], a = 2; a < arguments.length; a++)
    n[a - 2] = arguments[a];
  e || Zn(e, vh(t, n) || yh(t, n));
}, {
  debug: Wa(Zn.debug),
  log: Wa(Zn.log),
  warn: Wa(Zn.warn),
  error: Wa(Zn.error)
});
function Nr(r) {
  for (var e = [], t = 1; t < arguments.length; t++)
    e[t - 1] = arguments[t];
  return new py(vh(r, e) || yh(r, e));
}
var Lp = Symbol.for("ApolloErrorMessageHandler_" + ph);
function by(r) {
  return typeof r == "string" ? r : yy(r, 2).slice(0, 1e3);
}
function vh(r, e) {
  if (e === void 0 && (e = []), !!r)
    return dc[Lp] && dc[Lp](r, e.map(by));
}
function yh(r, e) {
  if (e === void 0 && (e = []), !!r)
    return "An error occurred! For more details, see the full error text at https://go.apollo.dev/c/err#".concat(encodeURIComponent(JSON.stringify({
      version: ph,
      message: r,
      args: e.map(by)
    })));
}
function no(r, e) {
  if (!!!r)
    throw new Error(e);
}
function yw(r) {
  return typeof r == "object" && r !== null;
}
function bw(r, e) {
  if (!!!r)
    throw new Error(
      e != null ? e : "Unexpected invariant triggered."
    );
}
const mw = /\r\n|[\n\r]/g;
function vc(r, e) {
  let t = 0, n = 1;
  for (const a of r.body.matchAll(mw)) {
    if (typeof a.index == "number" || bw(!1), a.index >= e)
      break;
    t = a.index + a[0].length, n += 1;
  }
  return {
    line: n,
    column: e + 1 - t
  };
}
function gw(r) {
  return my(
    r.source,
    vc(r.source, r.start)
  );
}
function my(r, e) {
  const t = r.locationOffset.column - 1, n = "".padStart(t) + r.body, a = e.line - 1, i = r.locationOffset.line - 1, o = e.line + i, u = e.line === 1 ? t : 0, c = e.column + u, h = `${r.name}:${o}:${c}
`, s = n.split(/\r\n|[\n\r]/g), d = s[a];
  if (d.length > 120) {
    const l = Math.floor(c / 80), y = c % 80, m = [];
    for (let w = 0; w < d.length; w += 80)
      m.push(d.slice(w, w + 80));
    return h + Fp([
      [`${o} |`, m[0]],
      ...m.slice(1, l + 1).map((w) => ["|", w]),
      ["|", "^".padStart(y)],
      ["|", m[l + 1]]
    ]);
  }
  return h + Fp([
    // Lines specified like this: ["prefix", "string"],
    [`${o - 1} |`, s[a - 1]],
    [`${o} |`, d],
    ["|", "^".padStart(c)],
    [`${o + 1} |`, s[a + 1]]
  ]);
}
function Fp(r) {
  const e = r.filter(([n, a]) => a !== void 0), t = Math.max(...e.map(([n]) => n.length));
  return e.map(([n, a]) => n.padStart(t) + (a ? " " + a : "")).join(`
`);
}
function ww(r) {
  const e = r[0];
  return e == null || "kind" in e || "length" in e ? {
    nodes: e,
    source: r[1],
    positions: r[2],
    path: r[3],
    originalError: r[4],
    extensions: r[5]
  } : e;
}
class bh extends Error {
  /**
   * An array of `{ line, column }` locations within the source GraphQL document
   * which correspond to this error.
   *
   * Errors during validation often contain multiple locations, for example to
   * point out two things with the same name. Errors during execution include a
   * single location, the field which produced the error.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array describing the JSON-path into the execution response which
   * corresponds to this error. Only included for errors during execution.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array of GraphQL AST Nodes corresponding to this error.
   */
  /**
   * The source GraphQL document for the first location of this error.
   *
   * Note that if this Error represents more than one node, the source may not
   * represent nodes after the first node.
   */
  /**
   * An array of character offsets within the source GraphQL document
   * which correspond to this error.
   */
  /**
   * The original error thrown from a field resolver during execution.
   */
  /**
   * Extension fields to add to the formatted error.
   */
  /**
   * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
   */
  constructor(e, ...t) {
    var n, a, i;
    const { nodes: o, source: u, positions: c, path: h, originalError: s, extensions: d } = ww(t);
    super(e), this.name = "GraphQLError", this.path = h != null ? h : void 0, this.originalError = s != null ? s : void 0, this.nodes = Up(
      Array.isArray(o) ? o : o ? [o] : void 0
    );
    const l = Up(
      (n = this.nodes) === null || n === void 0 ? void 0 : n.map((m) => m.loc).filter((m) => m != null)
    );
    this.source = u != null ? u : l == null || (a = l[0]) === null || a === void 0 ? void 0 : a.source, this.positions = c != null ? c : l == null ? void 0 : l.map((m) => m.start), this.locations = c && u ? c.map((m) => vc(u, m)) : l == null ? void 0 : l.map((m) => vc(m.source, m.start));
    const y = yw(
      s == null ? void 0 : s.extensions
    ) ? s == null ? void 0 : s.extensions : void 0;
    this.extensions = (i = d != null ? d : y) !== null && i !== void 0 ? i : /* @__PURE__ */ Object.create(null), Object.defineProperties(this, {
      message: {
        writable: !0,
        enumerable: !0
      },
      name: {
        enumerable: !1
      },
      nodes: {
        enumerable: !1
      },
      source: {
        enumerable: !1
      },
      positions: {
        enumerable: !1
      },
      originalError: {
        enumerable: !1
      }
    }), s != null && s.stack ? Object.defineProperty(this, "stack", {
      value: s.stack,
      writable: !0,
      configurable: !0
    }) : Error.captureStackTrace ? Error.captureStackTrace(this, bh) : Object.defineProperty(this, "stack", {
      value: Error().stack,
      writable: !0,
      configurable: !0
    });
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    let e = this.message;
    if (this.nodes)
      for (const t of this.nodes)
        t.loc && (e += `

` + gw(t.loc));
    else if (this.source && this.locations)
      for (const t of this.locations)
        e += `

` + my(this.source, t);
    return e;
  }
  toJSON() {
    const e = {
      message: this.message
    };
    return this.locations != null && (e.locations = this.locations), this.path != null && (e.path = this.path), this.extensions != null && Object.keys(this.extensions).length > 0 && (e.extensions = this.extensions), e;
  }
}
function Up(r) {
  return r === void 0 || r.length === 0 ? void 0 : r;
}
function Tr(r, e, t) {
  return new bh(`Syntax Error: ${t}`, {
    source: r,
    positions: [e]
  });
}
class _w {
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The Token at which this Node begins.
   */
  /**
   * The Token at which this Node ends.
   */
  /**
   * The Source document the AST represents.
   */
  constructor(e, t, n) {
    this.start = e.start, this.end = t.end, this.startToken = e, this.endToken = t, this.source = n;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
}
class gy {
  /**
   * The kind of Token.
   */
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The 1-indexed line number on which this Token appears.
   */
  /**
   * The 1-indexed column number at which this Token begins.
   */
  /**
   * For non-punctuation tokens, represents the interpreted value of the token.
   *
   * Note: is undefined for punctuation tokens, but typed as string for
   * convenience in the parser.
   */
  /**
   * Tokens exist as nodes in a double-linked-list amongst all tokens
   * including ignored tokens. <SOF> is always the first node and <EOF>
   * the last.
   */
  constructor(e, t, n, a, i, o) {
    this.kind = e, this.start = t, this.end = n, this.line = a, this.column = i, this.value = o, this.prev = null, this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
}
const wy = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    // Note: fragment variable definitions are deprecated and will removed in v17.0.0
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
}, xw = new Set(Object.keys(wy));
function $p(r) {
  const e = r == null ? void 0 : r.kind;
  return typeof e == "string" && xw.has(e);
}
var di;
(function(r) {
  r.QUERY = "query", r.MUTATION = "mutation", r.SUBSCRIPTION = "subscription";
})(di || (di = {}));
var yc;
(function(r) {
  r.QUERY = "QUERY", r.MUTATION = "MUTATION", r.SUBSCRIPTION = "SUBSCRIPTION", r.FIELD = "FIELD", r.FRAGMENT_DEFINITION = "FRAGMENT_DEFINITION", r.FRAGMENT_SPREAD = "FRAGMENT_SPREAD", r.INLINE_FRAGMENT = "INLINE_FRAGMENT", r.VARIABLE_DEFINITION = "VARIABLE_DEFINITION", r.SCHEMA = "SCHEMA", r.SCALAR = "SCALAR", r.OBJECT = "OBJECT", r.FIELD_DEFINITION = "FIELD_DEFINITION", r.ARGUMENT_DEFINITION = "ARGUMENT_DEFINITION", r.INTERFACE = "INTERFACE", r.UNION = "UNION", r.ENUM = "ENUM", r.ENUM_VALUE = "ENUM_VALUE", r.INPUT_OBJECT = "INPUT_OBJECT", r.INPUT_FIELD_DEFINITION = "INPUT_FIELD_DEFINITION";
})(yc || (yc = {}));
var yt;
(function(r) {
  r.NAME = "Name", r.DOCUMENT = "Document", r.OPERATION_DEFINITION = "OperationDefinition", r.VARIABLE_DEFINITION = "VariableDefinition", r.SELECTION_SET = "SelectionSet", r.FIELD = "Field", r.ARGUMENT = "Argument", r.FRAGMENT_SPREAD = "FragmentSpread", r.INLINE_FRAGMENT = "InlineFragment", r.FRAGMENT_DEFINITION = "FragmentDefinition", r.VARIABLE = "Variable", r.INT = "IntValue", r.FLOAT = "FloatValue", r.STRING = "StringValue", r.BOOLEAN = "BooleanValue", r.NULL = "NullValue", r.ENUM = "EnumValue", r.LIST = "ListValue", r.OBJECT = "ObjectValue", r.OBJECT_FIELD = "ObjectField", r.DIRECTIVE = "Directive", r.NAMED_TYPE = "NamedType", r.LIST_TYPE = "ListType", r.NON_NULL_TYPE = "NonNullType", r.SCHEMA_DEFINITION = "SchemaDefinition", r.OPERATION_TYPE_DEFINITION = "OperationTypeDefinition", r.SCALAR_TYPE_DEFINITION = "ScalarTypeDefinition", r.OBJECT_TYPE_DEFINITION = "ObjectTypeDefinition", r.FIELD_DEFINITION = "FieldDefinition", r.INPUT_VALUE_DEFINITION = "InputValueDefinition", r.INTERFACE_TYPE_DEFINITION = "InterfaceTypeDefinition", r.UNION_TYPE_DEFINITION = "UnionTypeDefinition", r.ENUM_TYPE_DEFINITION = "EnumTypeDefinition", r.ENUM_VALUE_DEFINITION = "EnumValueDefinition", r.INPUT_OBJECT_TYPE_DEFINITION = "InputObjectTypeDefinition", r.DIRECTIVE_DEFINITION = "DirectiveDefinition", r.SCHEMA_EXTENSION = "SchemaExtension", r.SCALAR_TYPE_EXTENSION = "ScalarTypeExtension", r.OBJECT_TYPE_EXTENSION = "ObjectTypeExtension", r.INTERFACE_TYPE_EXTENSION = "InterfaceTypeExtension", r.UNION_TYPE_EXTENSION = "UnionTypeExtension", r.ENUM_TYPE_EXTENSION = "EnumTypeExtension", r.INPUT_OBJECT_TYPE_EXTENSION = "InputObjectTypeExtension";
})(yt || (yt = {}));
function bc(r) {
  return r === 9 || r === 32;
}
function fa(r) {
  return r >= 48 && r <= 57;
}
function _y(r) {
  return r >= 97 && r <= 122 || // A-Z
  r >= 65 && r <= 90;
}
function xy(r) {
  return _y(r) || r === 95;
}
function Sw(r) {
  return _y(r) || fa(r) || r === 95;
}
function Ew(r) {
  var e;
  let t = Number.MAX_SAFE_INTEGER, n = null, a = -1;
  for (let o = 0; o < r.length; ++o) {
    var i;
    const u = r[o], c = Mw(u);
    c !== u.length && (n = (i = n) !== null && i !== void 0 ? i : o, a = o, o !== 0 && c < t && (t = c));
  }
  return r.map((o, u) => u === 0 ? o : o.slice(t)).slice(
    (e = n) !== null && e !== void 0 ? e : 0,
    a + 1
  );
}
function Mw(r) {
  let e = 0;
  for (; e < r.length && bc(r.charCodeAt(e)); )
    ++e;
  return e;
}
function Aw(r, e) {
  const t = r.replace(/"""/g, '\\"""'), n = t.split(/\r\n|[\n\r]/g), a = n.length === 1, i = n.length > 1 && n.slice(1).every((y) => y.length === 0 || bc(y.charCodeAt(0))), o = t.endsWith('\\"""'), u = r.endsWith('"') && !o, c = r.endsWith("\\"), h = u || c, s = !(e != null && e.minimize) && // add leading and trailing new lines only if it improves readability
  (!a || r.length > 70 || h || i || o);
  let d = "";
  const l = a && bc(r.charCodeAt(0));
  return (s && !l || i) && (d += `
`), d += t, (s || h) && (d += `
`), '"""' + d + '"""';
}
var Ce;
(function(r) {
  r.SOF = "<SOF>", r.EOF = "<EOF>", r.BANG = "!", r.DOLLAR = "$", r.AMP = "&", r.PAREN_L = "(", r.PAREN_R = ")", r.SPREAD = "...", r.COLON = ":", r.EQUALS = "=", r.AT = "@", r.BRACKET_L = "[", r.BRACKET_R = "]", r.BRACE_L = "{", r.PIPE = "|", r.BRACE_R = "}", r.NAME = "Name", r.INT = "Int", r.FLOAT = "Float", r.STRING = "String", r.BLOCK_STRING = "BlockString", r.COMMENT = "Comment";
})(Ce || (Ce = {}));
class Tw {
  /**
   * The previously focused non-ignored token.
   */
  /**
   * The currently focused non-ignored token.
   */
  /**
   * The (1-indexed) line containing the current token.
   */
  /**
   * The character offset at which the current line begins.
   */
  constructor(e) {
    const t = new gy(Ce.SOF, 0, 0, 0, 0);
    this.source = e, this.lastToken = t, this.token = t, this.line = 1, this.lineStart = 0;
  }
  get [Symbol.toStringTag]() {
    return "Lexer";
  }
  /**
   * Advances the token stream to the next non-ignored token.
   */
  advance() {
    return this.lastToken = this.token, this.token = this.lookahead();
  }
  /**
   * Looks ahead and returns the next non-ignored token, but does not change
   * the state of Lexer.
   */
  lookahead() {
    let e = this.token;
    if (e.kind !== Ce.EOF)
      do
        if (e.next)
          e = e.next;
        else {
          const t = Iw(this, e.end);
          e.next = t, t.prev = e, e = t;
        }
      while (e.kind === Ce.COMMENT);
    return e;
  }
}
function kw(r) {
  return r === Ce.BANG || r === Ce.DOLLAR || r === Ce.AMP || r === Ce.PAREN_L || r === Ce.PAREN_R || r === Ce.SPREAD || r === Ce.COLON || r === Ce.EQUALS || r === Ce.AT || r === Ce.BRACKET_L || r === Ce.BRACKET_R || r === Ce.BRACE_L || r === Ce.PIPE || r === Ce.BRACE_R;
}
function Oi(r) {
  return r >= 0 && r <= 55295 || r >= 57344 && r <= 1114111;
}
function Ro(r, e) {
  return Sy(r.charCodeAt(e)) && Ey(r.charCodeAt(e + 1));
}
function Sy(r) {
  return r >= 55296 && r <= 56319;
}
function Ey(r) {
  return r >= 56320 && r <= 57343;
}
function ii(r, e) {
  const t = r.source.body.codePointAt(e);
  if (t === void 0)
    return Ce.EOF;
  if (t >= 32 && t <= 126) {
    const n = String.fromCodePoint(t);
    return n === '"' ? `'"'` : `"${n}"`;
  }
  return "U+" + t.toString(16).toUpperCase().padStart(4, "0");
}
function wr(r, e, t, n, a) {
  const i = r.line, o = 1 + t - r.lineStart;
  return new gy(e, t, n, i, o, a);
}
function Iw(r, e) {
  const t = r.source.body, n = t.length;
  let a = e;
  for (; a < n; ) {
    const i = t.charCodeAt(a);
    switch (i) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++a;
        continue;
      case 10:
        ++a, ++r.line, r.lineStart = a;
        continue;
      case 13:
        t.charCodeAt(a + 1) === 10 ? a += 2 : ++a, ++r.line, r.lineStart = a;
        continue;
      case 35:
        return Rw(r, a);
      case 33:
        return wr(r, Ce.BANG, a, a + 1);
      case 36:
        return wr(r, Ce.DOLLAR, a, a + 1);
      case 38:
        return wr(r, Ce.AMP, a, a + 1);
      case 40:
        return wr(r, Ce.PAREN_L, a, a + 1);
      case 41:
        return wr(r, Ce.PAREN_R, a, a + 1);
      case 46:
        if (t.charCodeAt(a + 1) === 46 && t.charCodeAt(a + 2) === 46)
          return wr(r, Ce.SPREAD, a, a + 3);
        break;
      case 58:
        return wr(r, Ce.COLON, a, a + 1);
      case 61:
        return wr(r, Ce.EQUALS, a, a + 1);
      case 64:
        return wr(r, Ce.AT, a, a + 1);
      case 91:
        return wr(r, Ce.BRACKET_L, a, a + 1);
      case 93:
        return wr(r, Ce.BRACKET_R, a, a + 1);
      case 123:
        return wr(r, Ce.BRACE_L, a, a + 1);
      case 124:
        return wr(r, Ce.PIPE, a, a + 1);
      case 125:
        return wr(r, Ce.BRACE_R, a, a + 1);
      case 34:
        return t.charCodeAt(a + 1) === 34 && t.charCodeAt(a + 2) === 34 ? Nw(r, a) : Ow(r, a);
    }
    if (fa(i) || i === 45)
      return Cw(r, a, i);
    if (xy(i))
      return qw(r, a);
    throw Tr(
      r.source,
      a,
      i === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : Oi(i) || Ro(t, a) ? `Unexpected character: ${ii(r, a)}.` : `Invalid character: ${ii(r, a)}.`
    );
  }
  return wr(r, Ce.EOF, n, n);
}
function Rw(r, e) {
  const t = r.source.body, n = t.length;
  let a = e + 1;
  for (; a < n; ) {
    const i = t.charCodeAt(a);
    if (i === 10 || i === 13)
      break;
    if (Oi(i))
      ++a;
    else if (Ro(t, a))
      a += 2;
    else
      break;
  }
  return wr(
    r,
    Ce.COMMENT,
    e,
    a,
    t.slice(e + 1, a)
  );
}
function Cw(r, e, t) {
  const n = r.source.body;
  let a = e, i = t, o = !1;
  if (i === 45 && (i = n.charCodeAt(++a)), i === 48) {
    if (i = n.charCodeAt(++a), fa(i))
      throw Tr(
        r.source,
        a,
        `Invalid number, unexpected digit after 0: ${ii(
          r,
          a
        )}.`
      );
  } else
    a = ju(r, a, i), i = n.charCodeAt(a);
  if (i === 46 && (o = !0, i = n.charCodeAt(++a), a = ju(r, a, i), i = n.charCodeAt(a)), (i === 69 || i === 101) && (o = !0, i = n.charCodeAt(++a), (i === 43 || i === 45) && (i = n.charCodeAt(++a)), a = ju(r, a, i), i = n.charCodeAt(a)), i === 46 || xy(i))
    throw Tr(
      r.source,
      a,
      `Invalid number, expected digit but got: ${ii(
        r,
        a
      )}.`
    );
  return wr(
    r,
    o ? Ce.FLOAT : Ce.INT,
    e,
    a,
    n.slice(e, a)
  );
}
function ju(r, e, t) {
  if (!fa(t))
    throw Tr(
      r.source,
      e,
      `Invalid number, expected digit but got: ${ii(
        r,
        e
      )}.`
    );
  const n = r.source.body;
  let a = e + 1;
  for (; fa(n.charCodeAt(a)); )
    ++a;
  return a;
}
function Ow(r, e) {
  const t = r.source.body, n = t.length;
  let a = e + 1, i = a, o = "";
  for (; a < n; ) {
    const u = t.charCodeAt(a);
    if (u === 34)
      return o += t.slice(i, a), wr(r, Ce.STRING, e, a + 1, o);
    if (u === 92) {
      o += t.slice(i, a);
      const c = t.charCodeAt(a + 1) === 117 ? t.charCodeAt(a + 2) === 123 ? Bw(r, a) : Pw(r, a) : Dw(r, a);
      o += c.value, a += c.size, i = a;
      continue;
    }
    if (u === 10 || u === 13)
      break;
    if (Oi(u))
      ++a;
    else if (Ro(t, a))
      a += 2;
    else
      throw Tr(
        r.source,
        a,
        `Invalid character within String: ${ii(
          r,
          a
        )}.`
      );
  }
  throw Tr(r.source, a, "Unterminated string.");
}
function Bw(r, e) {
  const t = r.source.body;
  let n = 0, a = 3;
  for (; a < 12; ) {
    const i = t.charCodeAt(e + a++);
    if (i === 125) {
      if (a < 5 || !Oi(n))
        break;
      return {
        value: String.fromCodePoint(n),
        size: a
      };
    }
    if (n = n << 4 | Ji(i), n < 0)
      break;
  }
  throw Tr(
    r.source,
    e,
    `Invalid Unicode escape sequence: "${t.slice(
      e,
      e + a
    )}".`
  );
}
function Pw(r, e) {
  const t = r.source.body, n = jp(t, e + 2);
  if (Oi(n))
    return {
      value: String.fromCodePoint(n),
      size: 6
    };
  if (Sy(n) && t.charCodeAt(e + 6) === 92 && t.charCodeAt(e + 7) === 117) {
    const a = jp(t, e + 8);
    if (Ey(a))
      return {
        value: String.fromCodePoint(n, a),
        size: 12
      };
  }
  throw Tr(
    r.source,
    e,
    `Invalid Unicode escape sequence: "${t.slice(e, e + 6)}".`
  );
}
function jp(r, e) {
  return Ji(r.charCodeAt(e)) << 12 | Ji(r.charCodeAt(e + 1)) << 8 | Ji(r.charCodeAt(e + 2)) << 4 | Ji(r.charCodeAt(e + 3));
}
function Ji(r) {
  return r >= 48 && r <= 57 ? r - 48 : r >= 65 && r <= 70 ? r - 55 : r >= 97 && r <= 102 ? r - 87 : -1;
}
function Dw(r, e) {
  const t = r.source.body;
  switch (t.charCodeAt(e + 1)) {
    case 34:
      return {
        value: '"',
        size: 2
      };
    case 92:
      return {
        value: "\\",
        size: 2
      };
    case 47:
      return {
        value: "/",
        size: 2
      };
    case 98:
      return {
        value: "\b",
        size: 2
      };
    case 102:
      return {
        value: "\f",
        size: 2
      };
    case 110:
      return {
        value: `
`,
        size: 2
      };
    case 114:
      return {
        value: "\r",
        size: 2
      };
    case 116:
      return {
        value: "	",
        size: 2
      };
  }
  throw Tr(
    r.source,
    e,
    `Invalid character escape sequence: "${t.slice(
      e,
      e + 2
    )}".`
  );
}
function Nw(r, e) {
  const t = r.source.body, n = t.length;
  let a = r.lineStart, i = e + 3, o = i, u = "";
  const c = [];
  for (; i < n; ) {
    const h = t.charCodeAt(i);
    if (h === 34 && t.charCodeAt(i + 1) === 34 && t.charCodeAt(i + 2) === 34) {
      u += t.slice(o, i), c.push(u);
      const s = wr(
        r,
        Ce.BLOCK_STRING,
        e,
        i + 3,
        // Return a string of the lines joined with U+000A.
        Ew(c).join(`
`)
      );
      return r.line += c.length - 1, r.lineStart = a, s;
    }
    if (h === 92 && t.charCodeAt(i + 1) === 34 && t.charCodeAt(i + 2) === 34 && t.charCodeAt(i + 3) === 34) {
      u += t.slice(o, i), o = i + 1, i += 4;
      continue;
    }
    if (h === 10 || h === 13) {
      u += t.slice(o, i), c.push(u), h === 13 && t.charCodeAt(i + 1) === 10 ? i += 2 : ++i, u = "", o = i, a = i;
      continue;
    }
    if (Oi(h))
      ++i;
    else if (Ro(t, i))
      i += 2;
    else
      throw Tr(
        r.source,
        i,
        `Invalid character within String: ${ii(
          r,
          i
        )}.`
      );
  }
  throw Tr(r.source, i, "Unterminated string.");
}
function qw(r, e) {
  const t = r.source.body, n = t.length;
  let a = e + 1;
  for (; a < n; ) {
    const i = t.charCodeAt(a);
    if (Sw(i))
      ++a;
    else
      break;
  }
  return wr(
    r,
    Ce.NAME,
    e,
    a,
    t.slice(e, a)
  );
}
const Lw = 10, My = 2;
function mh(r) {
  return Co(r, []);
}
function Co(r, e) {
  switch (typeof r) {
    case "string":
      return JSON.stringify(r);
    case "function":
      return r.name ? `[function ${r.name}]` : "[function]";
    case "object":
      return Fw(r, e);
    default:
      return String(r);
  }
}
function Fw(r, e) {
  if (r === null)
    return "null";
  if (e.includes(r))
    return "[Circular]";
  const t = [...e, r];
  if (Uw(r)) {
    const n = r.toJSON();
    if (n !== r)
      return typeof n == "string" ? n : Co(n, t);
  } else if (Array.isArray(r))
    return jw(r, t);
  return $w(r, t);
}
function Uw(r) {
  return typeof r.toJSON == "function";
}
function $w(r, e) {
  const t = Object.entries(r);
  return t.length === 0 ? "{}" : e.length > My ? "[" + Hw(r) + "]" : "{ " + t.map(
    ([a, i]) => a + ": " + Co(i, e)
  ).join(", ") + " }";
}
function jw(r, e) {
  if (r.length === 0)
    return "[]";
  if (e.length > My)
    return "[Array]";
  const t = Math.min(Lw, r.length), n = r.length - t, a = [];
  for (let i = 0; i < t; ++i)
    a.push(Co(r[i], e));
  return n === 1 ? a.push("... 1 more item") : n > 1 && a.push(`... ${n} more items`), "[" + a.join(", ") + "]";
}
function Hw(r) {
  const e = Object.prototype.toString.call(r).replace(/^\[object /, "").replace(/]$/, "");
  if (e === "Object" && typeof r.constructor == "function") {
    const t = r.constructor.name;
    if (typeof t == "string" && t !== "")
      return t;
  }
  return e;
}
const zw = (
  /* c8 ignore next 6 */
  // FIXME: https://github.com/graphql/graphql-js/issues/2317
  globalThis.process && globalThis.process.env.NODE_ENV === "production" ? function(e, t) {
    return e instanceof t;
  } : function(e, t) {
    if (e instanceof t)
      return !0;
    if (typeof e == "object" && e !== null) {
      var n;
      const a = t.prototype[Symbol.toStringTag], i = (
        // We still need to support constructor's name to detect conflicts with older versions of this library.
        Symbol.toStringTag in e ? e[Symbol.toStringTag] : (n = e.constructor) === null || n === void 0 ? void 0 : n.name
      );
      if (a === i) {
        const o = mh(e);
        throw new Error(`Cannot use ${a} "${o}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
      }
    }
    return !1;
  }
);
class Ay {
  constructor(e, t = "GraphQL request", n = {
    line: 1,
    column: 1
  }) {
    typeof e == "string" || no(!1, `Body must be a string. Received: ${mh(e)}.`), this.body = e, this.name = t, this.locationOffset = n, this.locationOffset.line > 0 || no(
      !1,
      "line in locationOffset is 1-indexed and must be positive."
    ), this.locationOffset.column > 0 || no(
      !1,
      "column in locationOffset is 1-indexed and must be positive."
    );
  }
  get [Symbol.toStringTag]() {
    return "Source";
  }
}
function Vw(r) {
  return zw(r, Ay);
}
function Ww(r, e) {
  return new Kw(r, e).parseDocument();
}
class Kw {
  constructor(e, t = {}) {
    const n = Vw(e) ? e : new Ay(e);
    this._lexer = new Tw(n), this._options = t, this._tokenCounter = 0;
  }
  /**
   * Converts a name lex token into a name parse node.
   */
  parseName() {
    const e = this.expectToken(Ce.NAME);
    return this.node(e, {
      kind: yt.NAME,
      value: e.value
    });
  }
  // Implements the parsing rules in the Document section.
  /**
   * Document : Definition+
   */
  parseDocument() {
    return this.node(this._lexer.token, {
      kind: yt.DOCUMENT,
      definitions: this.many(
        Ce.SOF,
        this.parseDefinition,
        Ce.EOF
      )
    });
  }
  /**
   * Definition :
   *   - ExecutableDefinition
   *   - TypeSystemDefinition
   *   - TypeSystemExtension
   *
   * ExecutableDefinition :
   *   - OperationDefinition
   *   - FragmentDefinition
   *
   * TypeSystemDefinition :
   *   - SchemaDefinition
   *   - TypeDefinition
   *   - DirectiveDefinition
   *
   * TypeDefinition :
   *   - ScalarTypeDefinition
   *   - ObjectTypeDefinition
   *   - InterfaceTypeDefinition
   *   - UnionTypeDefinition
   *   - EnumTypeDefinition
   *   - InputObjectTypeDefinition
   */
  parseDefinition() {
    if (this.peek(Ce.BRACE_L))
      return this.parseOperationDefinition();
    const e = this.peekDescription(), t = e ? this._lexer.lookahead() : this._lexer.token;
    if (t.kind === Ce.NAME) {
      switch (t.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition();
      }
      if (e)
        throw Tr(
          this._lexer.source,
          this._lexer.token.start,
          "Unexpected description, descriptions are supported only on type definitions."
        );
      switch (t.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
        case "extend":
          return this.parseTypeSystemExtension();
      }
    }
    throw this.unexpected(t);
  }
  // Implements the parsing rules in the Operations section.
  /**
   * OperationDefinition :
   *  - SelectionSet
   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
   */
  parseOperationDefinition() {
    const e = this._lexer.token;
    if (this.peek(Ce.BRACE_L))
      return this.node(e, {
        kind: yt.OPERATION_DEFINITION,
        operation: di.QUERY,
        name: void 0,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet()
      });
    const t = this.parseOperationType();
    let n;
    return this.peek(Ce.NAME) && (n = this.parseName()), this.node(e, {
      kind: yt.OPERATION_DEFINITION,
      operation: t,
      name: n,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * OperationType : one of query mutation subscription
   */
  parseOperationType() {
    const e = this.expectToken(Ce.NAME);
    switch (e.value) {
      case "query":
        return di.QUERY;
      case "mutation":
        return di.MUTATION;
      case "subscription":
        return di.SUBSCRIPTION;
    }
    throw this.unexpected(e);
  }
  /**
   * VariableDefinitions : ( VariableDefinition+ )
   */
  parseVariableDefinitions() {
    return this.optionalMany(
      Ce.PAREN_L,
      this.parseVariableDefinition,
      Ce.PAREN_R
    );
  }
  /**
   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
   */
  parseVariableDefinition() {
    return this.node(this._lexer.token, {
      kind: yt.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(Ce.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(Ce.EQUALS) ? this.parseConstValueLiteral() : void 0,
      directives: this.parseConstDirectives()
    });
  }
  /**
   * Variable : $ Name
   */
  parseVariable() {
    const e = this._lexer.token;
    return this.expectToken(Ce.DOLLAR), this.node(e, {
      kind: yt.VARIABLE,
      name: this.parseName()
    });
  }
  /**
   * ```
   * SelectionSet : { Selection+ }
   * ```
   */
  parseSelectionSet() {
    return this.node(this._lexer.token, {
      kind: yt.SELECTION_SET,
      selections: this.many(
        Ce.BRACE_L,
        this.parseSelection,
        Ce.BRACE_R
      )
    });
  }
  /**
   * Selection :
   *   - Field
   *   - FragmentSpread
   *   - InlineFragment
   */
  parseSelection() {
    return this.peek(Ce.SPREAD) ? this.parseFragment() : this.parseField();
  }
  /**
   * Field : Alias? Name Arguments? Directives? SelectionSet?
   *
   * Alias : Name :
   */
  parseField() {
    const e = this._lexer.token, t = this.parseName();
    let n, a;
    return this.expectOptionalToken(Ce.COLON) ? (n = t, a = this.parseName()) : a = t, this.node(e, {
      kind: yt.FIELD,
      alias: n,
      name: a,
      arguments: this.parseArguments(!1),
      directives: this.parseDirectives(!1),
      selectionSet: this.peek(Ce.BRACE_L) ? this.parseSelectionSet() : void 0
    });
  }
  /**
   * Arguments[Const] : ( Argument[?Const]+ )
   */
  parseArguments(e) {
    const t = e ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(Ce.PAREN_L, t, Ce.PAREN_R);
  }
  /**
   * Argument[Const] : Name : Value[?Const]
   */
  parseArgument(e = !1) {
    const t = this._lexer.token, n = this.parseName();
    return this.expectToken(Ce.COLON), this.node(t, {
      kind: yt.ARGUMENT,
      name: n,
      value: this.parseValueLiteral(e)
    });
  }
  parseConstArgument() {
    return this.parseArgument(!0);
  }
  // Implements the parsing rules in the Fragments section.
  /**
   * Corresponds to both FragmentSpread and InlineFragment in the spec.
   *
   * FragmentSpread : ... FragmentName Directives?
   *
   * InlineFragment : ... TypeCondition? Directives? SelectionSet
   */
  parseFragment() {
    const e = this._lexer.token;
    this.expectToken(Ce.SPREAD);
    const t = this.expectOptionalKeyword("on");
    return !t && this.peek(Ce.NAME) ? this.node(e, {
      kind: yt.FRAGMENT_SPREAD,
      name: this.parseFragmentName(),
      directives: this.parseDirectives(!1)
    }) : this.node(e, {
      kind: yt.INLINE_FRAGMENT,
      typeCondition: t ? this.parseNamedType() : void 0,
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentDefinition :
   *   - fragment FragmentName on TypeCondition Directives? SelectionSet
   *
   * TypeCondition : NamedType
   */
  parseFragmentDefinition() {
    const e = this._lexer.token;
    return this.expectKeyword("fragment"), this._options.allowLegacyFragmentVariables === !0 ? this.node(e, {
      kind: yt.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      variableDefinitions: this.parseVariableDefinitions(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    }) : this.node(e, {
      kind: yt.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentName : Name but not `on`
   */
  parseFragmentName() {
    if (this._lexer.token.value === "on")
      throw this.unexpected();
    return this.parseName();
  }
  // Implements the parsing rules in the Values section.
  /**
   * Value[Const] :
   *   - [~Const] Variable
   *   - IntValue
   *   - FloatValue
   *   - StringValue
   *   - BooleanValue
   *   - NullValue
   *   - EnumValue
   *   - ListValue[?Const]
   *   - ObjectValue[?Const]
   *
   * BooleanValue : one of `true` `false`
   *
   * NullValue : `null`
   *
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseValueLiteral(e) {
    const t = this._lexer.token;
    switch (t.kind) {
      case Ce.BRACKET_L:
        return this.parseList(e);
      case Ce.BRACE_L:
        return this.parseObject(e);
      case Ce.INT:
        return this.advanceLexer(), this.node(t, {
          kind: yt.INT,
          value: t.value
        });
      case Ce.FLOAT:
        return this.advanceLexer(), this.node(t, {
          kind: yt.FLOAT,
          value: t.value
        });
      case Ce.STRING:
      case Ce.BLOCK_STRING:
        return this.parseStringLiteral();
      case Ce.NAME:
        switch (this.advanceLexer(), t.value) {
          case "true":
            return this.node(t, {
              kind: yt.BOOLEAN,
              value: !0
            });
          case "false":
            return this.node(t, {
              kind: yt.BOOLEAN,
              value: !1
            });
          case "null":
            return this.node(t, {
              kind: yt.NULL
            });
          default:
            return this.node(t, {
              kind: yt.ENUM,
              value: t.value
            });
        }
      case Ce.DOLLAR:
        if (e)
          if (this.expectToken(Ce.DOLLAR), this._lexer.token.kind === Ce.NAME) {
            const n = this._lexer.token.value;
            throw Tr(
              this._lexer.source,
              t.start,
              `Unexpected variable "$${n}" in constant value.`
            );
          } else
            throw this.unexpected(t);
        return this.parseVariable();
      default:
        throw this.unexpected();
    }
  }
  parseConstValueLiteral() {
    return this.parseValueLiteral(!0);
  }
  parseStringLiteral() {
    const e = this._lexer.token;
    return this.advanceLexer(), this.node(e, {
      kind: yt.STRING,
      value: e.value,
      block: e.kind === Ce.BLOCK_STRING
    });
  }
  /**
   * ListValue[Const] :
   *   - [ ]
   *   - [ Value[?Const]+ ]
   */
  parseList(e) {
    const t = () => this.parseValueLiteral(e);
    return this.node(this._lexer.token, {
      kind: yt.LIST,
      values: this.any(Ce.BRACKET_L, t, Ce.BRACKET_R)
    });
  }
  /**
   * ```
   * ObjectValue[Const] :
   *   - { }
   *   - { ObjectField[?Const]+ }
   * ```
   */
  parseObject(e) {
    const t = () => this.parseObjectField(e);
    return this.node(this._lexer.token, {
      kind: yt.OBJECT,
      fields: this.any(Ce.BRACE_L, t, Ce.BRACE_R)
    });
  }
  /**
   * ObjectField[Const] : Name : Value[?Const]
   */
  parseObjectField(e) {
    const t = this._lexer.token, n = this.parseName();
    return this.expectToken(Ce.COLON), this.node(t, {
      kind: yt.OBJECT_FIELD,
      name: n,
      value: this.parseValueLiteral(e)
    });
  }
  // Implements the parsing rules in the Directives section.
  /**
   * Directives[Const] : Directive[?Const]+
   */
  parseDirectives(e) {
    const t = [];
    for (; this.peek(Ce.AT); )
      t.push(this.parseDirective(e));
    return t;
  }
  parseConstDirectives() {
    return this.parseDirectives(!0);
  }
  /**
   * ```
   * Directive[Const] : @ Name Arguments[?Const]?
   * ```
   */
  parseDirective(e) {
    const t = this._lexer.token;
    return this.expectToken(Ce.AT), this.node(t, {
      kind: yt.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(e)
    });
  }
  // Implements the parsing rules in the Types section.
  /**
   * Type :
   *   - NamedType
   *   - ListType
   *   - NonNullType
   */
  parseTypeReference() {
    const e = this._lexer.token;
    let t;
    if (this.expectOptionalToken(Ce.BRACKET_L)) {
      const n = this.parseTypeReference();
      this.expectToken(Ce.BRACKET_R), t = this.node(e, {
        kind: yt.LIST_TYPE,
        type: n
      });
    } else
      t = this.parseNamedType();
    return this.expectOptionalToken(Ce.BANG) ? this.node(e, {
      kind: yt.NON_NULL_TYPE,
      type: t
    }) : t;
  }
  /**
   * NamedType : Name
   */
  parseNamedType() {
    return this.node(this._lexer.token, {
      kind: yt.NAMED_TYPE,
      name: this.parseName()
    });
  }
  // Implements the parsing rules in the Type Definition section.
  peekDescription() {
    return this.peek(Ce.STRING) || this.peek(Ce.BLOCK_STRING);
  }
  /**
   * Description : StringValue
   */
  parseDescription() {
    if (this.peekDescription())
      return this.parseStringLiteral();
  }
  /**
   * ```
   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
   * ```
   */
  parseSchemaDefinition() {
    const e = this._lexer.token, t = this.parseDescription();
    this.expectKeyword("schema");
    const n = this.parseConstDirectives(), a = this.many(
      Ce.BRACE_L,
      this.parseOperationTypeDefinition,
      Ce.BRACE_R
    );
    return this.node(e, {
      kind: yt.SCHEMA_DEFINITION,
      description: t,
      directives: n,
      operationTypes: a
    });
  }
  /**
   * OperationTypeDefinition : OperationType : NamedType
   */
  parseOperationTypeDefinition() {
    const e = this._lexer.token, t = this.parseOperationType();
    this.expectToken(Ce.COLON);
    const n = this.parseNamedType();
    return this.node(e, {
      kind: yt.OPERATION_TYPE_DEFINITION,
      operation: t,
      type: n
    });
  }
  /**
   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
   */
  parseScalarTypeDefinition() {
    const e = this._lexer.token, t = this.parseDescription();
    this.expectKeyword("scalar");
    const n = this.parseName(), a = this.parseConstDirectives();
    return this.node(e, {
      kind: yt.SCALAR_TYPE_DEFINITION,
      description: t,
      name: n,
      directives: a
    });
  }
  /**
   * ObjectTypeDefinition :
   *   Description?
   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
   */
  parseObjectTypeDefinition() {
    const e = this._lexer.token, t = this.parseDescription();
    this.expectKeyword("type");
    const n = this.parseName(), a = this.parseImplementsInterfaces(), i = this.parseConstDirectives(), o = this.parseFieldsDefinition();
    return this.node(e, {
      kind: yt.OBJECT_TYPE_DEFINITION,
      description: t,
      name: n,
      interfaces: a,
      directives: i,
      fields: o
    });
  }
  /**
   * ImplementsInterfaces :
   *   - implements `&`? NamedType
   *   - ImplementsInterfaces & NamedType
   */
  parseImplementsInterfaces() {
    return this.expectOptionalKeyword("implements") ? this.delimitedMany(Ce.AMP, this.parseNamedType) : [];
  }
  /**
   * ```
   * FieldsDefinition : { FieldDefinition+ }
   * ```
   */
  parseFieldsDefinition() {
    return this.optionalMany(
      Ce.BRACE_L,
      this.parseFieldDefinition,
      Ce.BRACE_R
    );
  }
  /**
   * FieldDefinition :
   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
   */
  parseFieldDefinition() {
    const e = this._lexer.token, t = this.parseDescription(), n = this.parseName(), a = this.parseArgumentDefs();
    this.expectToken(Ce.COLON);
    const i = this.parseTypeReference(), o = this.parseConstDirectives();
    return this.node(e, {
      kind: yt.FIELD_DEFINITION,
      description: t,
      name: n,
      arguments: a,
      type: i,
      directives: o
    });
  }
  /**
   * ArgumentsDefinition : ( InputValueDefinition+ )
   */
  parseArgumentDefs() {
    return this.optionalMany(
      Ce.PAREN_L,
      this.parseInputValueDef,
      Ce.PAREN_R
    );
  }
  /**
   * InputValueDefinition :
   *   - Description? Name : Type DefaultValue? Directives[Const]?
   */
  parseInputValueDef() {
    const e = this._lexer.token, t = this.parseDescription(), n = this.parseName();
    this.expectToken(Ce.COLON);
    const a = this.parseTypeReference();
    let i;
    this.expectOptionalToken(Ce.EQUALS) && (i = this.parseConstValueLiteral());
    const o = this.parseConstDirectives();
    return this.node(e, {
      kind: yt.INPUT_VALUE_DEFINITION,
      description: t,
      name: n,
      type: a,
      defaultValue: i,
      directives: o
    });
  }
  /**
   * InterfaceTypeDefinition :
   *   - Description? interface Name Directives[Const]? FieldsDefinition?
   */
  parseInterfaceTypeDefinition() {
    const e = this._lexer.token, t = this.parseDescription();
    this.expectKeyword("interface");
    const n = this.parseName(), a = this.parseImplementsInterfaces(), i = this.parseConstDirectives(), o = this.parseFieldsDefinition();
    return this.node(e, {
      kind: yt.INTERFACE_TYPE_DEFINITION,
      description: t,
      name: n,
      interfaces: a,
      directives: i,
      fields: o
    });
  }
  /**
   * UnionTypeDefinition :
   *   - Description? union Name Directives[Const]? UnionMemberTypes?
   */
  parseUnionTypeDefinition() {
    const e = this._lexer.token, t = this.parseDescription();
    this.expectKeyword("union");
    const n = this.parseName(), a = this.parseConstDirectives(), i = this.parseUnionMemberTypes();
    return this.node(e, {
      kind: yt.UNION_TYPE_DEFINITION,
      description: t,
      name: n,
      directives: a,
      types: i
    });
  }
  /**
   * UnionMemberTypes :
   *   - = `|`? NamedType
   *   - UnionMemberTypes | NamedType
   */
  parseUnionMemberTypes() {
    return this.expectOptionalToken(Ce.EQUALS) ? this.delimitedMany(Ce.PIPE, this.parseNamedType) : [];
  }
  /**
   * EnumTypeDefinition :
   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
   */
  parseEnumTypeDefinition() {
    const e = this._lexer.token, t = this.parseDescription();
    this.expectKeyword("enum");
    const n = this.parseName(), a = this.parseConstDirectives(), i = this.parseEnumValuesDefinition();
    return this.node(e, {
      kind: yt.ENUM_TYPE_DEFINITION,
      description: t,
      name: n,
      directives: a,
      values: i
    });
  }
  /**
   * ```
   * EnumValuesDefinition : { EnumValueDefinition+ }
   * ```
   */
  parseEnumValuesDefinition() {
    return this.optionalMany(
      Ce.BRACE_L,
      this.parseEnumValueDefinition,
      Ce.BRACE_R
    );
  }
  /**
   * EnumValueDefinition : Description? EnumValue Directives[Const]?
   */
  parseEnumValueDefinition() {
    const e = this._lexer.token, t = this.parseDescription(), n = this.parseEnumValueName(), a = this.parseConstDirectives();
    return this.node(e, {
      kind: yt.ENUM_VALUE_DEFINITION,
      description: t,
      name: n,
      directives: a
    });
  }
  /**
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseEnumValueName() {
    if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null")
      throw Tr(
        this._lexer.source,
        this._lexer.token.start,
        `${Ka(
          this._lexer.token
        )} is reserved and cannot be used for an enum value.`
      );
    return this.parseName();
  }
  /**
   * InputObjectTypeDefinition :
   *   - Description? input Name Directives[Const]? InputFieldsDefinition?
   */
  parseInputObjectTypeDefinition() {
    const e = this._lexer.token, t = this.parseDescription();
    this.expectKeyword("input");
    const n = this.parseName(), a = this.parseConstDirectives(), i = this.parseInputFieldsDefinition();
    return this.node(e, {
      kind: yt.INPUT_OBJECT_TYPE_DEFINITION,
      description: t,
      name: n,
      directives: a,
      fields: i
    });
  }
  /**
   * ```
   * InputFieldsDefinition : { InputValueDefinition+ }
   * ```
   */
  parseInputFieldsDefinition() {
    return this.optionalMany(
      Ce.BRACE_L,
      this.parseInputValueDef,
      Ce.BRACE_R
    );
  }
  /**
   * TypeSystemExtension :
   *   - SchemaExtension
   *   - TypeExtension
   *
   * TypeExtension :
   *   - ScalarTypeExtension
   *   - ObjectTypeExtension
   *   - InterfaceTypeExtension
   *   - UnionTypeExtension
   *   - EnumTypeExtension
   *   - InputObjectTypeDefinition
   */
  parseTypeSystemExtension() {
    const e = this._lexer.lookahead();
    if (e.kind === Ce.NAME)
      switch (e.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension();
      }
    throw this.unexpected(e);
  }
  /**
   * ```
   * SchemaExtension :
   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
   *  - extend schema Directives[Const]
   * ```
   */
  parseSchemaExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("schema");
    const t = this.parseConstDirectives(), n = this.optionalMany(
      Ce.BRACE_L,
      this.parseOperationTypeDefinition,
      Ce.BRACE_R
    );
    if (t.length === 0 && n.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: yt.SCHEMA_EXTENSION,
      directives: t,
      operationTypes: n
    });
  }
  /**
   * ScalarTypeExtension :
   *   - extend scalar Name Directives[Const]
   */
  parseScalarTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("scalar");
    const t = this.parseName(), n = this.parseConstDirectives();
    if (n.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: yt.SCALAR_TYPE_EXTENSION,
      name: t,
      directives: n
    });
  }
  /**
   * ObjectTypeExtension :
   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend type Name ImplementsInterfaces? Directives[Const]
   *  - extend type Name ImplementsInterfaces
   */
  parseObjectTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("type");
    const t = this.parseName(), n = this.parseImplementsInterfaces(), a = this.parseConstDirectives(), i = this.parseFieldsDefinition();
    if (n.length === 0 && a.length === 0 && i.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: yt.OBJECT_TYPE_EXTENSION,
      name: t,
      interfaces: n,
      directives: a,
      fields: i
    });
  }
  /**
   * InterfaceTypeExtension :
   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend interface Name ImplementsInterfaces? Directives[Const]
   *  - extend interface Name ImplementsInterfaces
   */
  parseInterfaceTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("interface");
    const t = this.parseName(), n = this.parseImplementsInterfaces(), a = this.parseConstDirectives(), i = this.parseFieldsDefinition();
    if (n.length === 0 && a.length === 0 && i.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: yt.INTERFACE_TYPE_EXTENSION,
      name: t,
      interfaces: n,
      directives: a,
      fields: i
    });
  }
  /**
   * UnionTypeExtension :
   *   - extend union Name Directives[Const]? UnionMemberTypes
   *   - extend union Name Directives[Const]
   */
  parseUnionTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("union");
    const t = this.parseName(), n = this.parseConstDirectives(), a = this.parseUnionMemberTypes();
    if (n.length === 0 && a.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: yt.UNION_TYPE_EXTENSION,
      name: t,
      directives: n,
      types: a
    });
  }
  /**
   * EnumTypeExtension :
   *   - extend enum Name Directives[Const]? EnumValuesDefinition
   *   - extend enum Name Directives[Const]
   */
  parseEnumTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("enum");
    const t = this.parseName(), n = this.parseConstDirectives(), a = this.parseEnumValuesDefinition();
    if (n.length === 0 && a.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: yt.ENUM_TYPE_EXTENSION,
      name: t,
      directives: n,
      values: a
    });
  }
  /**
   * InputObjectTypeExtension :
   *   - extend input Name Directives[Const]? InputFieldsDefinition
   *   - extend input Name Directives[Const]
   */
  parseInputObjectTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("input");
    const t = this.parseName(), n = this.parseConstDirectives(), a = this.parseInputFieldsDefinition();
    if (n.length === 0 && a.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: yt.INPUT_OBJECT_TYPE_EXTENSION,
      name: t,
      directives: n,
      fields: a
    });
  }
  /**
   * ```
   * DirectiveDefinition :
   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
   * ```
   */
  parseDirectiveDefinition() {
    const e = this._lexer.token, t = this.parseDescription();
    this.expectKeyword("directive"), this.expectToken(Ce.AT);
    const n = this.parseName(), a = this.parseArgumentDefs(), i = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    const o = this.parseDirectiveLocations();
    return this.node(e, {
      kind: yt.DIRECTIVE_DEFINITION,
      description: t,
      name: n,
      arguments: a,
      repeatable: i,
      locations: o
    });
  }
  /**
   * DirectiveLocations :
   *   - `|`? DirectiveLocation
   *   - DirectiveLocations | DirectiveLocation
   */
  parseDirectiveLocations() {
    return this.delimitedMany(Ce.PIPE, this.parseDirectiveLocation);
  }
  /*
   * DirectiveLocation :
   *   - ExecutableDirectiveLocation
   *   - TypeSystemDirectiveLocation
   *
   * ExecutableDirectiveLocation : one of
   *   `QUERY`
   *   `MUTATION`
   *   `SUBSCRIPTION`
   *   `FIELD`
   *   `FRAGMENT_DEFINITION`
   *   `FRAGMENT_SPREAD`
   *   `INLINE_FRAGMENT`
   *
   * TypeSystemDirectiveLocation : one of
   *   `SCHEMA`
   *   `SCALAR`
   *   `OBJECT`
   *   `FIELD_DEFINITION`
   *   `ARGUMENT_DEFINITION`
   *   `INTERFACE`
   *   `UNION`
   *   `ENUM`
   *   `ENUM_VALUE`
   *   `INPUT_OBJECT`
   *   `INPUT_FIELD_DEFINITION`
   */
  parseDirectiveLocation() {
    const e = this._lexer.token, t = this.parseName();
    if (Object.prototype.hasOwnProperty.call(yc, t.value))
      return t;
    throw this.unexpected(e);
  }
  // Core parsing utility functions
  /**
   * Returns a node that, if configured to do so, sets a "loc" field as a
   * location object, used to identify the place in the source that created a
   * given parsed object.
   */
  node(e, t) {
    return this._options.noLocation !== !0 && (t.loc = new _w(
      e,
      this._lexer.lastToken,
      this._lexer.source
    )), t;
  }
  /**
   * Determines if the next token is of a given kind
   */
  peek(e) {
    return this._lexer.token.kind === e;
  }
  /**
   * If the next token is of the given kind, return that token after advancing the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectToken(e) {
    const t = this._lexer.token;
    if (t.kind === e)
      return this.advanceLexer(), t;
    throw Tr(
      this._lexer.source,
      t.start,
      `Expected ${Ty(e)}, found ${Ka(t)}.`
    );
  }
  /**
   * If the next token is of the given kind, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalToken(e) {
    return this._lexer.token.kind === e ? (this.advanceLexer(), !0) : !1;
  }
  /**
   * If the next token is a given keyword, advance the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectKeyword(e) {
    const t = this._lexer.token;
    if (t.kind === Ce.NAME && t.value === e)
      this.advanceLexer();
    else
      throw Tr(
        this._lexer.source,
        t.start,
        `Expected "${e}", found ${Ka(t)}.`
      );
  }
  /**
   * If the next token is a given keyword, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalKeyword(e) {
    const t = this._lexer.token;
    return t.kind === Ce.NAME && t.value === e ? (this.advanceLexer(), !0) : !1;
  }
  /**
   * Helper function for creating an error when an unexpected lexed token is encountered.
   */
  unexpected(e) {
    const t = e != null ? e : this._lexer.token;
    return Tr(
      this._lexer.source,
      t.start,
      `Unexpected ${Ka(t)}.`
    );
  }
  /**
   * Returns a possibly empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  any(e, t, n) {
    this.expectToken(e);
    const a = [];
    for (; !this.expectOptionalToken(n); )
      a.push(t.call(this));
    return a;
  }
  /**
   * Returns a list of parse nodes, determined by the parseFn.
   * It can be empty only if open token is missing otherwise it will always return non-empty list
   * that begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  optionalMany(e, t, n) {
    if (this.expectOptionalToken(e)) {
      const a = [];
      do
        a.push(t.call(this));
      while (!this.expectOptionalToken(n));
      return a;
    }
    return [];
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  many(e, t, n) {
    this.expectToken(e);
    const a = [];
    do
      a.push(t.call(this));
    while (!this.expectOptionalToken(n));
    return a;
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
   * Advances the parser to the next lex token after last item in the list.
   */
  delimitedMany(e, t) {
    this.expectOptionalToken(e);
    const n = [];
    do
      n.push(t.call(this));
    while (this.expectOptionalToken(e));
    return n;
  }
  advanceLexer() {
    const { maxTokens: e } = this._options, t = this._lexer.advance();
    if (e !== void 0 && t.kind !== Ce.EOF && (++this._tokenCounter, this._tokenCounter > e))
      throw Tr(
        this._lexer.source,
        t.start,
        `Document contains more that ${e} tokens. Parsing aborted.`
      );
  }
}
function Ka(r) {
  const e = r.value;
  return Ty(r.kind) + (e != null ? ` "${e}"` : "");
}
function Ty(r) {
  return kw(r) ? `"${r}"` : r;
}
function Qw(r) {
  return `"${r.replace(Gw, Jw)}"`;
}
const Gw = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function Jw(r) {
  return Yw[r.charCodeAt(0)];
}
const Yw = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 2F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 3F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 4F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  // 5F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 6F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
], gh = Object.freeze({});
function wn(r, e, t = wy) {
  const n = /* @__PURE__ */ new Map();
  for (const S of Object.values(yt))
    n.set(S, Xw(e, S));
  let a, i = Array.isArray(r), o = [r], u = -1, c = [], h = r, s, d;
  const l = [], y = [];
  do {
    u++;
    const S = u === o.length, P = S && c.length !== 0;
    if (S) {
      if (s = y.length === 0 ? void 0 : l[l.length - 1], h = d, d = y.pop(), P)
        if (i) {
          h = h.slice();
          let U = 0;
          for (const [z, K] of c) {
            const re = z - U;
            K === null ? (h.splice(re, 1), U++) : h[re] = K;
          }
        } else {
          h = Object.defineProperties(
            {},
            Object.getOwnPropertyDescriptors(h)
          );
          for (const [U, z] of c)
            h[U] = z;
        }
      u = a.index, o = a.keys, c = a.edits, i = a.inArray, a = a.prev;
    } else if (d) {
      if (s = i ? u : o[u], h = d[s], h == null)
        continue;
      l.push(s);
    }
    let L;
    if (!Array.isArray(h)) {
      var m, w;
      $p(h) || no(!1, `Invalid AST Node: ${mh(h)}.`);
      const U = S ? (m = n.get(h.kind)) === null || m === void 0 ? void 0 : m.leave : (w = n.get(h.kind)) === null || w === void 0 ? void 0 : w.enter;
      if (L = U == null ? void 0 : U.call(e, h, s, d, l, y), L === gh)
        break;
      if (L === !1) {
        if (!S) {
          l.pop();
          continue;
        }
      } else if (L !== void 0 && (c.push([s, L]), !S))
        if ($p(L))
          h = L;
        else {
          l.pop();
          continue;
        }
    }
    if (L === void 0 && P && c.push([s, h]), S)
      l.pop();
    else {
      var E;
      a = {
        inArray: i,
        index: u,
        keys: o,
        edits: c,
        prev: a
      }, i = Array.isArray(h), o = i ? h : (E = t[h.kind]) !== null && E !== void 0 ? E : [], u = -1, c = [], d && y.push(d), d = h;
    }
  } while (a !== void 0);
  return c.length !== 0 ? c[c.length - 1][1] : r;
}
function Xw(r, e) {
  const t = r[e];
  return typeof t == "object" ? t : typeof t == "function" ? {
    enter: t,
    leave: void 0
  } : {
    enter: r.enter,
    leave: r.leave
  };
}
function ky(r) {
  return wn(r, e_);
}
const Zw = 80, e_ = {
  Name: {
    leave: (r) => r.value
  },
  Variable: {
    leave: (r) => "$" + r.name
  },
  // Document
  Document: {
    leave: (r) => mt(r.definitions, `

`)
  },
  OperationDefinition: {
    leave(r) {
      const e = Kt("(", mt(r.variableDefinitions, ", "), ")"), t = mt(
        [
          r.operation,
          mt([r.name, e]),
          mt(r.directives, " ")
        ],
        " "
      );
      return (t === "query" ? "" : t + " ") + r.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable: r, type: e, defaultValue: t, directives: n }) => r + ": " + e + Kt(" = ", t) + Kt(" ", mt(n, " "))
  },
  SelectionSet: {
    leave: ({ selections: r }) => Jr(r)
  },
  Field: {
    leave({ alias: r, name: e, arguments: t, directives: n, selectionSet: a }) {
      const i = Kt("", r, ": ") + e;
      let o = i + Kt("(", mt(t, ", "), ")");
      return o.length > Zw && (o = i + Kt(`(
`, io(mt(t, `
`)), `
)`)), mt([o, mt(n, " "), a], " ");
    }
  },
  Argument: {
    leave: ({ name: r, value: e }) => r + ": " + e
  },
  // Fragments
  FragmentSpread: {
    leave: ({ name: r, directives: e }) => "..." + r + Kt(" ", mt(e, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition: r, directives: e, selectionSet: t }) => mt(
      [
        "...",
        Kt("on ", r),
        mt(e, " "),
        t
      ],
      " "
    )
  },
  FragmentDefinition: {
    leave: ({ name: r, typeCondition: e, variableDefinitions: t, directives: n, selectionSet: a }) => (
      // or removed in the future.
      `fragment ${r}${Kt("(", mt(t, ", "), ")")} on ${e} ${Kt("", mt(n, " "), " ")}` + a
    )
  },
  // Value
  IntValue: {
    leave: ({ value: r }) => r
  },
  FloatValue: {
    leave: ({ value: r }) => r
  },
  StringValue: {
    leave: ({ value: r, block: e }) => e ? Aw(r) : Qw(r)
  },
  BooleanValue: {
    leave: ({ value: r }) => r ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value: r }) => r
  },
  ListValue: {
    leave: ({ values: r }) => "[" + mt(r, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields: r }) => "{" + mt(r, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name: r, value: e }) => r + ": " + e
  },
  // Directive
  Directive: {
    leave: ({ name: r, arguments: e }) => "@" + r + Kt("(", mt(e, ", "), ")")
  },
  // Type
  NamedType: {
    leave: ({ name: r }) => r
  },
  ListType: {
    leave: ({ type: r }) => "[" + r + "]"
  },
  NonNullType: {
    leave: ({ type: r }) => r + "!"
  },
  // Type System Definitions
  SchemaDefinition: {
    leave: ({ description: r, directives: e, operationTypes: t }) => Kt("", r, `
`) + mt(["schema", mt(e, " "), Jr(t)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation: r, type: e }) => r + ": " + e
  },
  ScalarTypeDefinition: {
    leave: ({ description: r, name: e, directives: t }) => Kt("", r, `
`) + mt(["scalar", e, mt(t, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description: r, name: e, interfaces: t, directives: n, fields: a }) => Kt("", r, `
`) + mt(
      [
        "type",
        e,
        Kt("implements ", mt(t, " & ")),
        mt(n, " "),
        Jr(a)
      ],
      " "
    )
  },
  FieldDefinition: {
    leave: ({ description: r, name: e, arguments: t, type: n, directives: a }) => Kt("", r, `
`) + e + (Hp(t) ? Kt(`(
`, io(mt(t, `
`)), `
)`) : Kt("(", mt(t, ", "), ")")) + ": " + n + Kt(" ", mt(a, " "))
  },
  InputValueDefinition: {
    leave: ({ description: r, name: e, type: t, defaultValue: n, directives: a }) => Kt("", r, `
`) + mt(
      [e + ": " + t, Kt("= ", n), mt(a, " ")],
      " "
    )
  },
  InterfaceTypeDefinition: {
    leave: ({ description: r, name: e, interfaces: t, directives: n, fields: a }) => Kt("", r, `
`) + mt(
      [
        "interface",
        e,
        Kt("implements ", mt(t, " & ")),
        mt(n, " "),
        Jr(a)
      ],
      " "
    )
  },
  UnionTypeDefinition: {
    leave: ({ description: r, name: e, directives: t, types: n }) => Kt("", r, `
`) + mt(
      ["union", e, mt(t, " "), Kt("= ", mt(n, " | "))],
      " "
    )
  },
  EnumTypeDefinition: {
    leave: ({ description: r, name: e, directives: t, values: n }) => Kt("", r, `
`) + mt(["enum", e, mt(t, " "), Jr(n)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description: r, name: e, directives: t }) => Kt("", r, `
`) + mt([e, mt(t, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description: r, name: e, directives: t, fields: n }) => Kt("", r, `
`) + mt(["input", e, mt(t, " "), Jr(n)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description: r, name: e, arguments: t, repeatable: n, locations: a }) => Kt("", r, `
`) + "directive @" + e + (Hp(t) ? Kt(`(
`, io(mt(t, `
`)), `
)`) : Kt("(", mt(t, ", "), ")")) + (n ? " repeatable" : "") + " on " + mt(a, " | ")
  },
  SchemaExtension: {
    leave: ({ directives: r, operationTypes: e }) => mt(
      ["extend schema", mt(r, " "), Jr(e)],
      " "
    )
  },
  ScalarTypeExtension: {
    leave: ({ name: r, directives: e }) => mt(["extend scalar", r, mt(e, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name: r, interfaces: e, directives: t, fields: n }) => mt(
      [
        "extend type",
        r,
        Kt("implements ", mt(e, " & ")),
        mt(t, " "),
        Jr(n)
      ],
      " "
    )
  },
  InterfaceTypeExtension: {
    leave: ({ name: r, interfaces: e, directives: t, fields: n }) => mt(
      [
        "extend interface",
        r,
        Kt("implements ", mt(e, " & ")),
        mt(t, " "),
        Jr(n)
      ],
      " "
    )
  },
  UnionTypeExtension: {
    leave: ({ name: r, directives: e, types: t }) => mt(
      [
        "extend union",
        r,
        mt(e, " "),
        Kt("= ", mt(t, " | "))
      ],
      " "
    )
  },
  EnumTypeExtension: {
    leave: ({ name: r, directives: e, values: t }) => mt(["extend enum", r, mt(e, " "), Jr(t)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name: r, directives: e, fields: t }) => mt(["extend input", r, mt(e, " "), Jr(t)], " ")
  }
};
function mt(r, e = "") {
  var t;
  return (t = r == null ? void 0 : r.filter((n) => n).join(e)) !== null && t !== void 0 ? t : "";
}
function Jr(r) {
  return Kt(`{
`, io(mt(r, `
`)), `
}`);
}
function Kt(r, e, t = "") {
  return e != null && e !== "" ? r + e + t : "";
}
function io(r) {
  return Kt("  ", r.replace(/\n/g, `
  `));
}
function Hp(r) {
  var e;
  return (e = r == null ? void 0 : r.some((t) => t.includes(`
`))) !== null && e !== void 0 ? e : !1;
}
function zp(r) {
  return r.kind === yt.FIELD || r.kind === yt.FRAGMENT_SPREAD || r.kind === yt.INLINE_FRAGMENT;
}
function _a(r, e) {
  var t = r.directives;
  return !t || !t.length ? !0 : n_(t).every(function(n) {
    var a = n.directive, i = n.ifArgument, o = !1;
    return i.value.kind === "Variable" ? (o = e && e[i.value.name.value], Ct(o !== void 0, 67, a.name.value)) : o = i.value.value, a.name.value === "skip" ? !o : o;
  });
}
function ua(r, e, t) {
  var n = new Set(r), a = n.size;
  return wn(e, {
    Directive: function(i) {
      if (n.delete(i.name.value) && (!t || !n.size))
        return gh;
    }
  }), t ? !n.size : n.size < a;
}
function t_(r) {
  return r && ua(["client", "export"], r, !0);
}
function r_(r) {
  var e = r.name.value;
  return e === "skip" || e === "include";
}
function n_(r) {
  var e = [];
  return r && r.length && r.forEach(function(t) {
    if (r_(t)) {
      var n = t.arguments, a = t.name.value;
      Ct(n && n.length === 1, 68, a);
      var i = n[0];
      Ct(i.name && i.name.value === "if", 69, a);
      var o = i.value;
      Ct(o && (o.kind === "Variable" || o.kind === "BooleanValue"), 70, a), e.push({ directive: t, ifArgument: i });
    }
  }), e;
}
const i_ = () => /* @__PURE__ */ Object.create(null), { forEach: a_, slice: Vp } = Array.prototype, { hasOwnProperty: o_ } = Object.prototype;
let Bi = class Iy {
  constructor(e = !0, t = i_) {
    this.weakness = e, this.makeData = t;
  }
  lookup() {
    return this.lookupArray(arguments);
  }
  lookupArray(e) {
    let t = this;
    return a_.call(e, (n) => t = t.getChildTrie(n)), o_.call(t, "data") ? t.data : t.data = this.makeData(Vp.call(e));
  }
  peek() {
    return this.peekArray(arguments);
  }
  peekArray(e) {
    let t = this;
    for (let n = 0, a = e.length; t && n < a; ++n) {
      const i = t.mapFor(e[n], !1);
      t = i && i.get(e[n]);
    }
    return t && t.data;
  }
  remove() {
    return this.removeArray(arguments);
  }
  removeArray(e) {
    let t;
    if (e.length) {
      const n = e[0], a = this.mapFor(n, !1), i = a && a.get(n);
      i && (t = i.removeArray(Vp.call(e, 1)), !i.data && !i.weak && !(i.strong && i.strong.size) && a.delete(n));
    } else
      t = this.data, delete this.data;
    return t;
  }
  getChildTrie(e) {
    const t = this.mapFor(e, !0);
    let n = t.get(e);
    return n || t.set(e, n = new Iy(this.weakness, this.makeData)), n;
  }
  mapFor(e, t) {
    return this.weakness && s_(e) ? this.weak || (t ? this.weak = /* @__PURE__ */ new WeakMap() : void 0) : this.strong || (t ? this.strong = /* @__PURE__ */ new Map() : void 0);
  }
};
function s_(r) {
  switch (typeof r) {
    case "object":
      if (r === null)
        break;
    case "function":
      return !0;
  }
  return !1;
}
var Pi = typeof WeakMap == "function" && !Xr(function() {
  return navigator.product == "ReactNative" && !sa.HermesInternal;
}), Ry = typeof WeakSet == "function", Cy = typeof Symbol == "function" && typeof Symbol.for == "function", Oo = Cy && Symbol.asyncIterator;
Xr(function() {
  return window.document.createElement;
});
Xr(function() {
  return navigator.userAgent.indexOf("jsdom") >= 0;
});
function vr(r) {
  return r !== null && typeof r == "object";
}
function f_(r, e) {
  var t = e, n = [];
  r.definitions.forEach(function(i) {
    if (i.kind === "OperationDefinition")
      throw Nr(
        71,
        i.operation,
        i.name ? " named '".concat(i.name.value, "'") : ""
      );
    i.kind === "FragmentDefinition" && n.push(i);
  }), typeof t == "undefined" && (Ct(n.length === 1, 72, n.length), t = n[0].name.value);
  var a = _e(_e({}, r), { definitions: en([
    {
      kind: "OperationDefinition",
      // OperationTypeNode is an enum
      operation: "query",
      selectionSet: {
        kind: "SelectionSet",
        selections: [
          {
            kind: "FragmentSpread",
            name: {
              kind: "Name",
              value: t
            }
          }
        ]
      }
    }
  ], r.definitions, !0) });
  return a;
}
function Bo(r) {
  r === void 0 && (r = []);
  var e = {};
  return r.forEach(function(t) {
    e[t.name.value] = t;
  }), e;
}
function Po(r, e) {
  switch (r.kind) {
    case "InlineFragment":
      return r;
    case "FragmentSpread": {
      var t = r.name.value;
      if (typeof e == "function")
        return e(t);
      var n = e && e[t];
      return Ct(n, 73, t), n || null;
    }
    default:
      return null;
  }
}
function u_() {
}
class mc {
  constructor(e = 1 / 0, t = u_) {
    this.max = e, this.dispose = t, this.map = /* @__PURE__ */ new Map(), this.newest = null, this.oldest = null;
  }
  has(e) {
    return this.map.has(e);
  }
  get(e) {
    const t = this.getNode(e);
    return t && t.value;
  }
  get size() {
    return this.map.size;
  }
  getNode(e) {
    const t = this.map.get(e);
    if (t && t !== this.newest) {
      const { older: n, newer: a } = t;
      a && (a.older = n), n && (n.newer = a), t.older = this.newest, t.older.newer = t, t.newer = null, this.newest = t, t === this.oldest && (this.oldest = a);
    }
    return t;
  }
  set(e, t) {
    let n = this.getNode(e);
    return n ? n.value = t : (n = {
      key: e,
      value: t,
      newer: null,
      older: this.newest
    }, this.newest && (this.newest.newer = n), this.newest = n, this.oldest = this.oldest || n, this.map.set(e, n), n.value);
  }
  clean() {
    for (; this.oldest && this.map.size > this.max; )
      this.delete(this.oldest.key);
  }
  delete(e) {
    const t = this.map.get(e);
    return t ? (t === this.newest && (this.newest = t.older), t === this.oldest && (this.oldest = t.newer), t.newer && (t.newer.older = t.older), t.older && (t.older.newer = t.newer), this.map.delete(e), this.dispose(t.value, e), !0) : !1;
  }
}
function gc() {
}
const c_ = gc, h_ = typeof WeakRef != "undefined" ? WeakRef : function(r) {
  return { deref: () => r };
}, l_ = typeof WeakMap != "undefined" ? WeakMap : Map, d_ = typeof FinalizationRegistry != "undefined" ? FinalizationRegistry : function() {
  return {
    register: gc,
    unregister: gc
  };
}, p_ = 10024;
class bo {
  constructor(e = 1 / 0, t = c_) {
    this.max = e, this.dispose = t, this.map = new l_(), this.newest = null, this.oldest = null, this.unfinalizedNodes = /* @__PURE__ */ new Set(), this.finalizationScheduled = !1, this.size = 0, this.finalize = () => {
      const n = this.unfinalizedNodes.values();
      for (let a = 0; a < p_; a++) {
        const i = n.next().value;
        if (!i)
          break;
        this.unfinalizedNodes.delete(i);
        const o = i.key;
        delete i.key, i.keyRef = new h_(o), this.registry.register(o, i, i);
      }
      this.unfinalizedNodes.size > 0 ? queueMicrotask(this.finalize) : this.finalizationScheduled = !1;
    }, this.registry = new d_(this.deleteNode.bind(this));
  }
  has(e) {
    return this.map.has(e);
  }
  get(e) {
    const t = this.getNode(e);
    return t && t.value;
  }
  getNode(e) {
    const t = this.map.get(e);
    if (t && t !== this.newest) {
      const { older: n, newer: a } = t;
      a && (a.older = n), n && (n.newer = a), t.older = this.newest, t.older.newer = t, t.newer = null, this.newest = t, t === this.oldest && (this.oldest = a);
    }
    return t;
  }
  set(e, t) {
    let n = this.getNode(e);
    return n ? n.value = t : (n = {
      key: e,
      value: t,
      newer: null,
      older: this.newest
    }, this.newest && (this.newest.newer = n), this.newest = n, this.oldest = this.oldest || n, this.scheduleFinalization(n), this.map.set(e, n), this.size++, n.value);
  }
  clean() {
    for (; this.oldest && this.size > this.max; )
      this.deleteNode(this.oldest);
  }
  deleteNode(e) {
    e === this.newest && (this.newest = e.older), e === this.oldest && (this.oldest = e.newer), e.newer && (e.newer.older = e.older), e.older && (e.older.newer = e.newer), this.size--;
    const t = e.key || e.keyRef && e.keyRef.deref();
    this.dispose(e.value, t), e.keyRef ? this.registry.unregister(e) : this.unfinalizedNodes.delete(e), t && this.map.delete(t);
  }
  delete(e) {
    const t = this.map.get(e);
    return t ? (this.deleteNode(t), !0) : !1;
  }
  scheduleFinalization(e) {
    this.unfinalizedNodes.add(e), this.finalizationScheduled || (this.finalizationScheduled = !0, queueMicrotask(this.finalize));
  }
}
var Hu = /* @__PURE__ */ new WeakSet();
function Oy(r) {
  Hu.has(r) || (Hu.add(r), setTimeout(function() {
    r.clean(), Hu.delete(r);
  }, 100));
}
var By = function(r, e) {
  var t = new bo(r, e);
  return t.set = function(n, a) {
    return Oy(this), bo.prototype.set.call(this, n, a);
  }, t;
}, v_ = function(r, e) {
  var t = new mc(r, e);
  return t.set = function(n, a) {
    return Oy(this), mc.prototype.set.call(this, n, a);
  }, t;
}, y_ = Symbol.for("apollo.cacheSize"), _n = _e({}, dc[y_]), Yn = {};
function Py(r, e) {
  Yn[r] = e;
}
var b_ = globalThis.__DEV__ !== !1 ? __ : void 0, m_ = globalThis.__DEV__ !== !1 ? x_ : void 0, g_ = globalThis.__DEV__ !== !1 ? Dy : void 0;
function w_() {
  var r = {
    parser: 1e3,
    canonicalStringify: 1e3,
    print: 2e3,
    "documentTransform.cache": 2e3,
    "queryManager.getDocumentInfo": 2e3,
    "PersistedQueryLink.persistedQueryHashes": 2e3,
    "fragmentRegistry.transform": 2e3,
    "fragmentRegistry.lookup": 1e3,
    "fragmentRegistry.findFragmentSpreads": 4e3,
    "cache.fragmentQueryDocuments": 1e3,
    "removeTypenameFromVariables.getVariableDefinitions": 2e3,
    "inMemoryCache.maybeBroadcastWatch": 5e3,
    "inMemoryCache.executeSelectionSet": 5e4,
    "inMemoryCache.executeSubSelectedArray": 1e4
  };
  return Object.fromEntries(Object.entries(r).map(function(e) {
    var t = e[0], n = e[1];
    return [
      t,
      _n[t] || n
    ];
  }));
}
function __() {
  var r, e, t, n, a;
  if (globalThis.__DEV__ === !1)
    throw new Error("only supported in development mode");
  return {
    limits: w_(),
    sizes: _e({ print: (r = Yn.print) === null || r === void 0 ? void 0 : r.call(Yn), parser: (e = Yn.parser) === null || e === void 0 ? void 0 : e.call(Yn), canonicalStringify: (t = Yn.canonicalStringify) === null || t === void 0 ? void 0 : t.call(Yn), links: _c(this.link), queryManager: {
      getDocumentInfo: this.queryManager.transformCache.size,
      documentTransforms: qy(this.queryManager.documentTransform)
    } }, (a = (n = this.cache).getMemoryInternals) === null || a === void 0 ? void 0 : a.call(n))
  };
}
function Dy() {
  return {
    cache: {
      fragmentQueryDocuments: On(this.getFragmentDoc)
    }
  };
}
function x_() {
  var r = this.config.fragments;
  return _e(_e({}, Dy.apply(this)), { addTypenameDocumentTransform: qy(this.addTypenameTransform), inMemoryCache: {
    executeSelectionSet: On(this.storeReader.executeSelectionSet),
    executeSubSelectedArray: On(this.storeReader.executeSubSelectedArray),
    maybeBroadcastWatch: On(this.maybeBroadcastWatch)
  }, fragmentRegistry: {
    findFragmentSpreads: On(r == null ? void 0 : r.findFragmentSpreads),
    lookup: On(r == null ? void 0 : r.lookup),
    transform: On(r == null ? void 0 : r.transform)
  } });
}
function S_(r) {
  return !!r && "dirtyKey" in r;
}
function On(r) {
  return S_(r) ? r.size : void 0;
}
function Ny(r) {
  return r != null;
}
function qy(r) {
  return wc(r).map(function(e) {
    return { cache: e };
  });
}
function wc(r) {
  return r ? en(en([
    On(r == null ? void 0 : r.performWork)
  ], wc(r == null ? void 0 : r.left), !0), wc(r == null ? void 0 : r.right), !0).filter(Ny) : [];
}
function _c(r) {
  var e;
  return r ? en(en([
    (e = r == null ? void 0 : r.getMemoryInternals) === null || e === void 0 ? void 0 : e.call(r)
  ], _c(r == null ? void 0 : r.left), !0), _c(r == null ? void 0 : r.right), !0).filter(Ny) : [];
}
var Dn = Object.assign(function(e) {
  return JSON.stringify(e, E_);
}, {
  reset: function() {
    pi = new v_(
      _n.canonicalStringify || 1e3
      /* defaultCacheSizes.canonicalStringify */
    );
  }
});
globalThis.__DEV__ !== !1 && Py("canonicalStringify", function() {
  return pi.size;
});
var pi;
Dn.reset();
function E_(r, e) {
  if (e && typeof e == "object") {
    var t = Object.getPrototypeOf(e);
    if (t === Object.prototype || t === null) {
      var n = Object.keys(e);
      if (n.every(M_))
        return e;
      var a = JSON.stringify(n), i = pi.get(a);
      if (!i) {
        n.sort();
        var o = JSON.stringify(n);
        i = pi.get(o) || n, pi.set(a, i), pi.set(o, i);
      }
      var u = Object.create(t);
      return i.forEach(function(c) {
        u[c] = e[c];
      }), u;
    }
  }
  return e;
}
function M_(r, e, t) {
  return e === 0 || t[e - 1] <= r;
}
function gi(r) {
  return { __ref: String(r) };
}
function rr(r) {
  return !!(r && typeof r == "object" && typeof r.__ref == "string");
}
function A_(r) {
  return vr(r) && r.kind === "Document" && Array.isArray(r.definitions);
}
function T_(r) {
  return r.kind === "StringValue";
}
function k_(r) {
  return r.kind === "BooleanValue";
}
function I_(r) {
  return r.kind === "IntValue";
}
function R_(r) {
  return r.kind === "FloatValue";
}
function C_(r) {
  return r.kind === "Variable";
}
function O_(r) {
  return r.kind === "ObjectValue";
}
function B_(r) {
  return r.kind === "ListValue";
}
function P_(r) {
  return r.kind === "EnumValue";
}
function D_(r) {
  return r.kind === "NullValue";
}
function Si(r, e, t, n) {
  if (I_(t) || R_(t))
    r[e.value] = Number(t.value);
  else if (k_(t) || T_(t))
    r[e.value] = t.value;
  else if (O_(t)) {
    var a = {};
    t.fields.map(function(o) {
      return Si(a, o.name, o.value, n);
    }), r[e.value] = a;
  } else if (C_(t)) {
    var i = (n || {})[t.name.value];
    r[e.value] = i;
  } else if (B_(t))
    r[e.value] = t.values.map(function(o) {
      var u = {};
      return Si(u, e, o, n), u[e.value];
    });
  else if (P_(t))
    r[e.value] = t.value;
  else if (D_(t))
    r[e.value] = null;
  else
    throw Nr(82, e.value, t.kind);
}
function N_(r, e) {
  var t = null;
  r.directives && (t = {}, r.directives.forEach(function(a) {
    t[a.name.value] = {}, a.arguments && a.arguments.forEach(function(i) {
      var o = i.name, u = i.value;
      return Si(t[a.name.value], o, u, e);
    });
  }));
  var n = null;
  return r.arguments && r.arguments.length && (n = {}, r.arguments.forEach(function(a) {
    var i = a.name, o = a.value;
    return Si(n, i, o, e);
  })), Ly(r.name.value, n, t);
}
var q_ = [
  "connection",
  "include",
  "skip",
  "client",
  "rest",
  "export",
  "nonreactive"
], Hi = Dn, Ly = Object.assign(function(r, e, t) {
  if (e && t && t.connection && t.connection.key)
    if (t.connection.filter && t.connection.filter.length > 0) {
      var n = t.connection.filter ? t.connection.filter : [];
      n.sort();
      var a = {};
      return n.forEach(function(u) {
        a[u] = e[u];
      }), "".concat(t.connection.key, "(").concat(Hi(a), ")");
    } else
      return t.connection.key;
  var i = r;
  if (e) {
    var o = Hi(e);
    i += "(".concat(o, ")");
  }
  return t && Object.keys(t).forEach(function(u) {
    q_.indexOf(u) === -1 && (t[u] && Object.keys(t[u]).length ? i += "@".concat(u, "(").concat(Hi(t[u]), ")") : i += "@".concat(u));
  }), i;
}, {
  setStringify: function(r) {
    var e = Hi;
    return Hi = r, e;
  }
});
function Do(r, e) {
  if (r.arguments && r.arguments.length) {
    var t = {};
    return r.arguments.forEach(function(n) {
      var a = n.name, i = n.value;
      return Si(t, a, i, e);
    }), t;
  }
  return null;
}
function Ln(r) {
  return r.alias ? r.alias.value : r.name.value;
}
function xc(r, e, t) {
  for (var n, a = 0, i = e.selections; a < i.length; a++) {
    var o = i[a];
    if (Fn(o)) {
      if (o.name.value === "__typename")
        return r[Ln(o)];
    } else
      n ? n.push(o) : n = [o];
  }
  if (typeof r.__typename == "string")
    return r.__typename;
  if (n)
    for (var u = 0, c = n; u < c.length; u++) {
      var o = c[u], h = xc(r, Po(o, t).selectionSet, t);
      if (typeof h == "string")
        return h;
    }
}
function Fn(r) {
  return r.kind === "Field";
}
function L_(r) {
  return r.kind === "InlineFragment";
}
function xa(r) {
  Ct(r && r.kind === "Document", 74);
  var e = r.definitions.filter(function(t) {
    return t.kind !== "FragmentDefinition";
  }).map(function(t) {
    if (t.kind !== "OperationDefinition")
      throw Nr(75, t.kind);
    return t;
  });
  return Ct(e.length <= 1, 76, e.length), r;
}
function Sa(r) {
  return xa(r), r.definitions.filter(function(e) {
    return e.kind === "OperationDefinition";
  })[0];
}
function Sc(r) {
  return r.definitions.filter(function(e) {
    return e.kind === "OperationDefinition" && !!e.name;
  }).map(function(e) {
    return e.name.value;
  })[0] || null;
}
function No(r) {
  return r.definitions.filter(function(e) {
    return e.kind === "FragmentDefinition";
  });
}
function Fy(r) {
  var e = Sa(r);
  return Ct(e && e.operation === "query", 77), e;
}
function F_(r) {
  Ct(r.kind === "Document", 78), Ct(r.definitions.length <= 1, 79);
  var e = r.definitions[0];
  return Ct(e.kind === "FragmentDefinition", 80), e;
}
function Ea(r) {
  xa(r);
  for (var e, t = 0, n = r.definitions; t < n.length; t++) {
    var a = n[t];
    if (a.kind === "OperationDefinition") {
      var i = a.operation;
      if (i === "query" || i === "mutation" || i === "subscription")
        return a;
    }
    a.kind === "FragmentDefinition" && !e && (e = a);
  }
  if (e)
    return e;
  throw Nr(81);
}
function wh(r) {
  var e = /* @__PURE__ */ Object.create(null), t = r && r.variableDefinitions;
  return t && t.length && t.forEach(function(n) {
    n.defaultValue && Si(e, n.variable.name, n.defaultValue);
  }), e;
}
const U_ = () => /* @__PURE__ */ Object.create(null), { forEach: $_, slice: j_ } = Array.prototype, { hasOwnProperty: H_ } = Object.prototype;
class _h {
  constructor(e = !0, t = U_) {
    this.weakness = e, this.makeData = t;
  }
  lookup(...e) {
    return this.lookupArray(e);
  }
  lookupArray(e) {
    let t = this;
    return $_.call(e, (n) => t = t.getChildTrie(n)), H_.call(t, "data") ? t.data : t.data = this.makeData(j_.call(e));
  }
  peek(...e) {
    return this.peekArray(e);
  }
  peekArray(e) {
    let t = this;
    for (let n = 0, a = e.length; t && n < a; ++n) {
      const i = this.weakness && Wp(e[n]) ? t.weak : t.strong;
      t = i && i.get(e[n]);
    }
    return t && t.data;
  }
  getChildTrie(e) {
    const t = this.weakness && Wp(e) ? this.weak || (this.weak = /* @__PURE__ */ new WeakMap()) : this.strong || (this.strong = /* @__PURE__ */ new Map());
    let n = t.get(e);
    return n || t.set(e, n = new _h(this.weakness, this.makeData)), n;
  }
}
function Wp(r) {
  switch (typeof r) {
    case "object":
      if (r === null)
        break;
    case "function":
      return !0;
  }
  return !1;
}
let Rr = null;
const Kp = {};
let z_ = 1;
const V_ = () => class {
  constructor() {
    this.id = [
      "slot",
      z_++,
      Date.now(),
      Math.random().toString(36).slice(2)
    ].join(":");
  }
  hasValue() {
    for (let e = Rr; e; e = e.parent)
      if (this.id in e.slots) {
        const t = e.slots[this.id];
        if (t === Kp)
          break;
        return e !== Rr && (Rr.slots[this.id] = t), !0;
      }
    return Rr && (Rr.slots[this.id] = Kp), !1;
  }
  getValue() {
    if (this.hasValue())
      return Rr.slots[this.id];
  }
  withValue(e, t, n, a) {
    const i = {
      __proto__: null,
      [this.id]: e
    }, o = Rr;
    Rr = { parent: o, slots: i };
    try {
      return t.apply(a, n);
    } finally {
      Rr = o;
    }
  }
  // Capture the current context and wrap a callback function so that it
  // reestablishes the captured context when called.
  static bind(e) {
    const t = Rr;
    return function() {
      const n = Rr;
      try {
        return Rr = t, e.apply(this, arguments);
      } finally {
        Rr = n;
      }
    };
  }
  // Immediately run a callback function without any captured context.
  static noContext(e, t, n) {
    if (Rr) {
      const a = Rr;
      try {
        return Rr = null, e.apply(n, t);
      } finally {
        Rr = a;
      }
    } else
      return e.apply(n, t);
  }
};
function Qp(r) {
  try {
    return r();
  } catch (e) {
  }
}
const zu = "@wry/context:Slot", W_ = (
  // Prefer globalThis when available.
  // https://github.com/benjamn/wryware/issues/347
  Qp(() => globalThis) || // Fall back to global, which works in Node.js and may be converted by some
  // bundlers to the appropriate identifier (window, self, ...) depending on the
  // bundling target. https://github.com/endojs/endo/issues/576#issuecomment-1178515224
  Qp(() => sa) || // Otherwise, use a dummy host that's local to this module. We used to fall
  // back to using the Array constructor as a namespace, but that was flagged in
  // https://github.com/benjamn/wryware/issues/347, and can be avoided.
  /* @__PURE__ */ Object.create(null)
), Gp = W_, Uy = Gp[zu] || // Earlier versions of this package stored the globalKey property on the Array
// constructor, so we check there as well, to prevent Slot class duplication.
Array[zu] || function(r) {
  try {
    Object.defineProperty(Gp, zu, {
      value: r,
      enumerable: !1,
      writable: !1,
      // When it was possible for globalHost to be the Array constructor (a
      // legacy Slot dedup strategy), it was important for the property to be
      // configurable:true so it could be deleted. That does not seem to be as
      // important when globalHost is the global object, but I don't want to
      // cause similar problems again, and configurable:true seems safest.
      // https://github.com/endojs/endo/issues/576#issuecomment-1178274008
      configurable: !0
    });
  } finally {
    return r;
  }
}(V_()), qo = new Uy(), { hasOwnProperty: K_ } = Object.prototype, xh = Array.from || function(r) {
  const e = [];
  return r.forEach((t) => e.push(t)), e;
};
function mo(r) {
  const { unsubscribe: e } = r;
  typeof e == "function" && (r.unsubscribe = void 0, e());
}
const ca = [], Q_ = 100;
function Ei(r, e) {
  if (!r)
    throw new Error(e || "assertion failure");
}
function $y(r, e) {
  const t = r.length;
  return (
    // Unknown values are not equal to each other.
    t > 0 && // Both values must be ordinary (or both exceptional) to be equal.
    t === e.length && // The underlying value or exception must be the same.
    r[t - 1] === e[t - 1]
  );
}
function jy(r) {
  switch (r.length) {
    case 0:
      throw new Error("unknown value");
    case 1:
      return r[0];
    case 2:
      throw r[1];
  }
}
function Hy(r) {
  return r.slice(0);
}
class Lo {
  constructor(e) {
    this.fn = e, this.parents = /* @__PURE__ */ new Set(), this.childValues = /* @__PURE__ */ new Map(), this.dirtyChildren = null, this.dirty = !0, this.recomputing = !1, this.value = [], this.deps = null, ++Lo.count;
  }
  peek() {
    if (this.value.length === 1 && !Un(this))
      return Jp(this), this.value[0];
  }
  // This is the most important method of the Entry API, because it
  // determines whether the cached this.value can be returned immediately,
  // or must be recomputed. The overall performance of the caching system
  // depends on the truth of the following observations: (1) this.dirty is
  // usually false, (2) this.dirtyChildren is usually null/empty, and thus
  // (3) valueGet(this.value) is usually returned without recomputation.
  recompute(e) {
    return Ei(!this.recomputing, "already recomputing"), Jp(this), Un(this) ? G_(this, e) : jy(this.value);
  }
  setDirty() {
    this.dirty || (this.dirty = !0, zy(this), mo(this));
  }
  dispose() {
    this.setDirty(), Gy(this), Sh(this, (e, t) => {
      e.setDirty(), Jy(e, this);
    });
  }
  forget() {
    this.dispose();
  }
  dependOn(e) {
    e.add(this), this.deps || (this.deps = ca.pop() || /* @__PURE__ */ new Set()), this.deps.add(e);
  }
  forgetDeps() {
    this.deps && (xh(this.deps).forEach((e) => e.delete(this)), this.deps.clear(), ca.push(this.deps), this.deps = null);
  }
}
Lo.count = 0;
function Jp(r) {
  const e = qo.getValue();
  if (e)
    return r.parents.add(e), e.childValues.has(r) || e.childValues.set(r, []), Un(r) ? Wy(e, r) : Ky(e, r), e;
}
function G_(r, e) {
  return Gy(r), qo.withValue(r, J_, [r, e]), X_(r, e) && Y_(r), jy(r.value);
}
function J_(r, e) {
  r.recomputing = !0;
  const { normalizeResult: t } = r;
  let n;
  t && r.value.length === 1 && (n = Hy(r.value)), r.value.length = 0;
  try {
    if (r.value[0] = r.fn.apply(null, e), t && n && !$y(n, r.value))
      try {
        r.value[0] = t(r.value[0], n[0]);
      } catch (a) {
      }
  } catch (a) {
    r.value[1] = a;
  }
  r.recomputing = !1;
}
function Un(r) {
  return r.dirty || !!(r.dirtyChildren && r.dirtyChildren.size);
}
function Y_(r) {
  r.dirty = !1, !Un(r) && Vy(r);
}
function zy(r) {
  Sh(r, Wy);
}
function Vy(r) {
  Sh(r, Ky);
}
function Sh(r, e) {
  const t = r.parents.size;
  if (t) {
    const n = xh(r.parents);
    for (let a = 0; a < t; ++a)
      e(n[a], r);
  }
}
function Wy(r, e) {
  Ei(r.childValues.has(e)), Ei(Un(e));
  const t = !Un(r);
  if (!r.dirtyChildren)
    r.dirtyChildren = ca.pop() || /* @__PURE__ */ new Set();
  else if (r.dirtyChildren.has(e))
    return;
  r.dirtyChildren.add(e), t && zy(r);
}
function Ky(r, e) {
  Ei(r.childValues.has(e)), Ei(!Un(e));
  const t = r.childValues.get(e);
  t.length === 0 ? r.childValues.set(e, Hy(e.value)) : $y(t, e.value) || r.setDirty(), Qy(r, e), !Un(r) && Vy(r);
}
function Qy(r, e) {
  const t = r.dirtyChildren;
  t && (t.delete(e), t.size === 0 && (ca.length < Q_ && ca.push(t), r.dirtyChildren = null));
}
function Gy(r) {
  r.childValues.size > 0 && r.childValues.forEach((e, t) => {
    Jy(r, t);
  }), r.forgetDeps(), Ei(r.dirtyChildren === null);
}
function Jy(r, e) {
  e.parents.delete(r), r.childValues.delete(e), Qy(r, e);
}
function X_(r, e) {
  if (typeof r.subscribe == "function")
    try {
      mo(r), r.unsubscribe = r.subscribe.apply(null, e);
    } catch (t) {
      return r.setDirty(), !1;
    }
  return !0;
}
const Z_ = {
  setDirty: !0,
  dispose: !0,
  forget: !0
  // Fully remove parent Entry from LRU cache and computation graph
};
function Yy(r) {
  const e = /* @__PURE__ */ new Map(), t = r && r.subscribe;
  function n(a) {
    const i = qo.getValue();
    if (i) {
      let o = e.get(a);
      o || e.set(a, o = /* @__PURE__ */ new Set()), i.dependOn(o), typeof t == "function" && (mo(o), o.unsubscribe = t(a));
    }
  }
  return n.dirty = function(i, o) {
    const u = e.get(i);
    if (u) {
      const c = o && K_.call(Z_, o) ? o : "setDirty";
      xh(u).forEach((h) => h[c]()), e.delete(i), mo(u);
    }
  }, n;
}
let Yp;
function e4(...r) {
  return (Yp || (Yp = new _h(typeof WeakMap == "function"))).lookupArray(r);
}
const Vu = /* @__PURE__ */ new Set();
function ha(r, { max: e = Math.pow(2, 16), keyArgs: t, makeCacheKey: n = e4, normalizeResult: a, subscribe: i, cache: o = mc } = /* @__PURE__ */ Object.create(null)) {
  const u = typeof o == "function" ? new o(e, (l) => l.dispose()) : o, c = function() {
    const l = n.apply(null, t ? t.apply(null, arguments) : arguments);
    if (l === void 0)
      return r.apply(null, arguments);
    let y = u.get(l);
    y || (u.set(l, y = new Lo(r)), y.normalizeResult = a, y.subscribe = i, y.forget = () => u.delete(l));
    const m = y.recompute(Array.prototype.slice.call(arguments));
    return u.set(l, y), Vu.add(u), qo.hasValue() || (Vu.forEach((w) => w.clean()), Vu.clear()), m;
  };
  Object.defineProperty(c, "size", {
    get: () => u.size,
    configurable: !1,
    enumerable: !1
  }), Object.freeze(c.options = {
    max: e,
    keyArgs: t,
    makeCacheKey: n,
    normalizeResult: a,
    subscribe: i,
    cache: u
  });
  function h(l) {
    const y = l && u.get(l);
    y && y.setDirty();
  }
  c.dirtyKey = h, c.dirty = function() {
    h(n.apply(null, arguments));
  };
  function s(l) {
    const y = l && u.get(l);
    if (y)
      return y.peek();
  }
  c.peekKey = s, c.peek = function() {
    return s(n.apply(null, arguments));
  };
  function d(l) {
    return l ? u.delete(l) : !1;
  }
  return c.forgetKey = d, c.forget = function() {
    return d(n.apply(null, arguments));
  }, c.makeCacheKey = n, c.getKey = t ? function() {
    return n.apply(null, t.apply(null, arguments));
  } : n, Object.freeze(c);
}
function t4(r) {
  return r;
}
var Xy = (
  /** @class */
  function() {
    function r(e, t) {
      t === void 0 && (t = /* @__PURE__ */ Object.create(null)), this.resultCache = Ry ? /* @__PURE__ */ new WeakSet() : /* @__PURE__ */ new Set(), this.transform = e, t.getCacheKey && (this.getCacheKey = t.getCacheKey), this.cached = t.cache !== !1, this.resetCache();
    }
    return r.prototype.getCacheKey = function(e) {
      return [e];
    }, r.identity = function() {
      return new r(t4, { cache: !1 });
    }, r.split = function(e, t, n) {
      return n === void 0 && (n = r.identity()), Object.assign(new r(
        function(a) {
          var i = e(a) ? t : n;
          return i.transformDocument(a);
        },
        // Reasonably assume both `left` and `right` transforms handle their own caching
        { cache: !1 }
      ), { left: t, right: n });
    }, r.prototype.resetCache = function() {
      var e = this;
      if (this.cached) {
        var t = new Bi(Pi);
        this.performWork = ha(r.prototype.performWork.bind(this), {
          makeCacheKey: function(n) {
            var a = e.getCacheKey(n);
            if (a)
              return Ct(Array.isArray(a), 66), t.lookupArray(a);
          },
          max: _n["documentTransform.cache"],
          cache: bo
        });
      }
    }, r.prototype.performWork = function(e) {
      return xa(e), this.transform(e);
    }, r.prototype.transformDocument = function(e) {
      if (this.resultCache.has(e))
        return e;
      var t = this.performWork(e);
      return this.resultCache.add(t), t;
    }, r.prototype.concat = function(e) {
      var t = this;
      return Object.assign(new r(
        function(n) {
          return e.transformDocument(t.transformDocument(n));
        },
        // Reasonably assume both transforms handle their own caching
        { cache: !1 }
      ), {
        left: this,
        right: e
      });
    }, r;
  }()
), ea, Fo = Object.assign(function(r) {
  var e = ea.get(r);
  return e || (e = ky(r), ea.set(r, e)), e;
}, {
  reset: function() {
    ea = new By(
      _n.print || 2e3
      /* defaultCacheSizes.print */
    );
  }
});
Fo.reset();
globalThis.__DEV__ !== !1 && Py("print", function() {
  return ea ? ea.size : 0;
});
var yr = Array.isArray;
function hn(r) {
  return Array.isArray(r) && r.length > 0;
}
var Xp = {
  kind: yt.FIELD,
  name: {
    kind: yt.NAME,
    value: "__typename"
  }
};
function Zy(r, e) {
  return !r || r.selectionSet.selections.every(function(t) {
    return t.kind === yt.FRAGMENT_SPREAD && Zy(e[t.name.value], e);
  });
}
function r4(r) {
  return Zy(Sa(r) || F_(r), Bo(No(r))) ? null : r;
}
function n4(r) {
  var e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map();
  return r.forEach(function(n) {
    n && (n.name ? e.set(n.name, n) : n.test && t.set(n.test, n));
  }), function(n) {
    var a = e.get(n.name.value);
    return !a && t.size && t.forEach(function(i, o) {
      o(n) && (a = i);
    }), a;
  };
}
function Zp(r) {
  var e = /* @__PURE__ */ new Map();
  return function(n) {
    n === void 0 && (n = r);
    var a = e.get(n);
    return a || e.set(n, a = {
      // Variable and fragment spread names used directly within this
      // operation or fragment definition, as identified by key. These sets
      // will be populated during the first traversal of the document in
      // removeDirectivesFromDocument below.
      variables: /* @__PURE__ */ new Set(),
      fragmentSpreads: /* @__PURE__ */ new Set()
    }), a;
  };
}
function eb(r, e) {
  xa(e);
  for (var t = Zp(""), n = Zp(""), a = function(S) {
    for (var P = 0, L = void 0; P < S.length && (L = S[P]); ++P)
      if (!yr(L)) {
        if (L.kind === yt.OPERATION_DEFINITION)
          return t(L.name && L.name.value);
        if (L.kind === yt.FRAGMENT_DEFINITION)
          return n(L.name.value);
      }
    return globalThis.__DEV__ !== !1 && Ct.error(83), null;
  }, i = 0, o = e.definitions.length - 1; o >= 0; --o)
    e.definitions[o].kind === yt.OPERATION_DEFINITION && ++i;
  var u = n4(r), c = function(S) {
    return hn(S) && S.map(u).some(function(P) {
      return P && P.remove;
    });
  }, h = /* @__PURE__ */ new Map(), s = !1, d = {
    enter: function(S) {
      if (c(S.directives))
        return s = !0, null;
    }
  }, l = wn(e, {
    // These two AST node types share the same implementation, defined above.
    Field: d,
    InlineFragment: d,
    VariableDefinition: {
      enter: function() {
        return !1;
      }
    },
    Variable: {
      enter: function(S, P, L, U, z) {
        var K = a(z);
        K && K.variables.add(S.name.value);
      }
    },
    FragmentSpread: {
      enter: function(S, P, L, U, z) {
        if (c(S.directives))
          return s = !0, null;
        var K = a(z);
        K && K.fragmentSpreads.add(S.name.value);
      }
    },
    FragmentDefinition: {
      enter: function(S, P, L, U) {
        h.set(JSON.stringify(U), S);
      },
      leave: function(S, P, L, U) {
        var z = h.get(JSON.stringify(U));
        if (S === z)
          return S;
        if (
          // This logic applies only if the document contains one or more
          // operations, since removing all fragments from a document containing
          // only fragments makes the document useless.
          i > 0 && S.selectionSet.selections.every(function(K) {
            return K.kind === yt.FIELD && K.name.value === "__typename";
          })
        )
          return n(S.name.value).removed = !0, s = !0, null;
      }
    },
    Directive: {
      leave: function(S) {
        if (u(S))
          return s = !0, null;
      }
    }
  });
  if (!s)
    return e;
  var y = function(S) {
    return S.transitiveVars || (S.transitiveVars = new Set(S.variables), S.removed || S.fragmentSpreads.forEach(function(P) {
      y(n(P)).transitiveVars.forEach(function(L) {
        S.transitiveVars.add(L);
      });
    })), S;
  }, m = /* @__PURE__ */ new Set();
  l.definitions.forEach(function(S) {
    S.kind === yt.OPERATION_DEFINITION ? y(t(S.name && S.name.value)).fragmentSpreads.forEach(function(P) {
      m.add(P);
    }) : S.kind === yt.FRAGMENT_DEFINITION && // If there are no operations in the document, then all fragment
    // definitions count as usages of their own fragment names. This heuristic
    // prevents accidentally removing all fragment definitions from the
    // document just because it contains no operations that use the fragments.
    i === 0 && !n(S.name.value).removed && m.add(S.name.value);
  }), m.forEach(function(S) {
    y(n(S)).fragmentSpreads.forEach(function(P) {
      m.add(P);
    });
  });
  var w = function(S) {
    return !!// A fragment definition will be removed if there are no spreads that refer
    // to it, or the fragment was explicitly removed because it had no fields
    // other than __typename.
    (!m.has(S) || n(S).removed);
  }, E = {
    enter: function(S) {
      if (w(S.name.value))
        return null;
    }
  };
  return r4(wn(l, {
    // If the fragment is going to be removed, then leaving any dangling
    // FragmentSpread nodes with the same name would be a mistake.
    FragmentSpread: E,
    // This is where the fragment definition is actually removed.
    FragmentDefinition: E,
    OperationDefinition: {
      leave: function(S) {
        if (S.variableDefinitions) {
          var P = y(
            // If an operation is anonymous, we use the empty string as its key.
            t(S.name && S.name.value)
          ).transitiveVars;
          if (P.size < S.variableDefinitions.length)
            return _e(_e({}, S), { variableDefinitions: S.variableDefinitions.filter(function(L) {
              return P.has(L.variable.name.value);
            }) });
        }
      }
    }
  }));
}
var Eh = Object.assign(function(r) {
  return wn(r, {
    SelectionSet: {
      enter: function(e, t, n) {
        if (!(n && n.kind === yt.OPERATION_DEFINITION)) {
          var a = e.selections;
          if (a) {
            var i = a.some(function(u) {
              return Fn(u) && (u.name.value === "__typename" || u.name.value.lastIndexOf("__", 0) === 0);
            });
            if (!i) {
              var o = n;
              if (!(Fn(o) && o.directives && o.directives.some(function(u) {
                return u.name.value === "export";
              })))
                return _e(_e({}, e), { selections: en(en([], a, !0), [Xp], !1) });
            }
          }
        }
      }
    }
  });
}, {
  added: function(r) {
    return r === Xp;
  }
});
function i4(r) {
  var e = Ea(r), t = e.operation;
  if (t === "query")
    return r;
  var n = wn(r, {
    OperationDefinition: {
      enter: function(a) {
        return _e(_e({}, a), { operation: "query" });
      }
    }
  });
  return n;
}
function tb(r) {
  xa(r);
  var e = eb([
    {
      test: function(t) {
        return t.name.value === "client";
      },
      remove: !0
    }
  ], r);
  return e;
}
var a4 = Object.prototype.hasOwnProperty;
function ev() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  return Mh(r);
}
function Mh(r) {
  var e = r[0] || {}, t = r.length;
  if (t > 1)
    for (var n = new $n(), a = 1; a < t; ++a)
      e = n.merge(e, r[a]);
  return e;
}
var o4 = function(r, e, t) {
  return this.merge(r[t], e[t]);
}, $n = (
  /** @class */
  function() {
    function r(e) {
      e === void 0 && (e = o4), this.reconciler = e, this.isObject = vr, this.pastCopies = /* @__PURE__ */ new Set();
    }
    return r.prototype.merge = function(e, t) {
      for (var n = this, a = [], i = 2; i < arguments.length; i++)
        a[i - 2] = arguments[i];
      return vr(t) && vr(e) ? (Object.keys(t).forEach(function(o) {
        if (a4.call(e, o)) {
          var u = e[o];
          if (t[o] !== u) {
            var c = n.reconciler.apply(n, en([
              e,
              t,
              o
            ], a, !1));
            c !== u && (e = n.shallowCopyForMerge(e), e[o] = c);
          }
        } else
          e = n.shallowCopyForMerge(e), e[o] = t[o];
      }), e) : t;
    }, r.prototype.shallowCopyForMerge = function(e) {
      return vr(e) && (this.pastCopies.has(e) || (Array.isArray(e) ? e = e.slice(0) : e = _e({ __proto__: Object.getPrototypeOf(e) }, e), this.pastCopies.add(e))), e;
    }, r;
  }()
);
function s4(r, e) {
  var t = typeof Symbol != "undefined" && r[Symbol.iterator] || r["@@iterator"];
  if (t)
    return (t = t.call(r)).next.bind(t);
  if (Array.isArray(r) || (t = f4(r)) || e && r && typeof r.length == "number") {
    t && (r = t);
    var n = 0;
    return function() {
      return n >= r.length ? { done: !0 } : { done: !1, value: r[n++] };
    };
  }
  throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function f4(r, e) {
  if (r) {
    if (typeof r == "string")
      return tv(r, e);
    var t = Object.prototype.toString.call(r).slice(8, -1);
    if (t === "Object" && r.constructor && (t = r.constructor.name), t === "Map" || t === "Set")
      return Array.from(r);
    if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))
      return tv(r, e);
  }
}
function tv(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var t = 0, n = new Array(e); t < e; t++)
    n[t] = r[t];
  return n;
}
function rv(r, e) {
  for (var t = 0; t < e.length; t++) {
    var n = e[t];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(r, n.key, n);
  }
}
function Ah(r, e, t) {
  return e && rv(r.prototype, e), t && rv(r, t), Object.defineProperty(r, "prototype", { writable: !1 }), r;
}
var Th = function() {
  return typeof Symbol == "function";
}, kh = function(r) {
  return Th() && !!Symbol[r];
}, Ih = function(r) {
  return kh(r) ? Symbol[r] : "@@" + r;
};
Th() && !kh("observable") && (Symbol.observable = Symbol("observable"));
var u4 = Ih("iterator"), Ec = Ih("observable"), rb = Ih("species");
function go(r, e) {
  var t = r[e];
  if (t != null) {
    if (typeof t != "function")
      throw new TypeError(t + " is not a function");
    return t;
  }
}
function zi(r) {
  var e = r.constructor;
  return e !== void 0 && (e = e[rb], e === null && (e = void 0)), e !== void 0 ? e : or;
}
function c4(r) {
  return r instanceof or;
}
function Mi(r) {
  Mi.log ? Mi.log(r) : setTimeout(function() {
    throw r;
  });
}
function ao(r) {
  Promise.resolve().then(function() {
    try {
      r();
    } catch (e) {
      Mi(e);
    }
  });
}
function nb(r) {
  var e = r._cleanup;
  if (e !== void 0 && (r._cleanup = void 0, !!e))
    try {
      if (typeof e == "function")
        e();
      else {
        var t = go(e, "unsubscribe");
        t && t.call(e);
      }
    } catch (n) {
      Mi(n);
    }
}
function Mc(r) {
  r._observer = void 0, r._queue = void 0, r._state = "closed";
}
function h4(r) {
  var e = r._queue;
  if (e) {
    r._queue = void 0, r._state = "ready";
    for (var t = 0; t < e.length && (ib(r, e[t].type, e[t].value), r._state !== "closed"); ++t)
      ;
  }
}
function ib(r, e, t) {
  r._state = "running";
  var n = r._observer;
  try {
    var a = go(n, e);
    switch (e) {
      case "next":
        a && a.call(n, t);
        break;
      case "error":
        if (Mc(r), a)
          a.call(n, t);
        else
          throw t;
        break;
      case "complete":
        Mc(r), a && a.call(n);
        break;
    }
  } catch (i) {
    Mi(i);
  }
  r._state === "closed" ? nb(r) : r._state === "running" && (r._state = "ready");
}
function Wu(r, e, t) {
  if (r._state !== "closed") {
    if (r._state === "buffering") {
      r._queue.push({
        type: e,
        value: t
      });
      return;
    }
    if (r._state !== "ready") {
      r._state = "buffering", r._queue = [{
        type: e,
        value: t
      }], ao(function() {
        return h4(r);
      });
      return;
    }
    ib(r, e, t);
  }
}
var l4 = /* @__PURE__ */ function() {
  function r(t, n) {
    this._cleanup = void 0, this._observer = t, this._queue = void 0, this._state = "initializing";
    var a = new d4(this);
    try {
      this._cleanup = n.call(void 0, a);
    } catch (i) {
      a.error(i);
    }
    this._state === "initializing" && (this._state = "ready");
  }
  var e = r.prototype;
  return e.unsubscribe = function() {
    this._state !== "closed" && (Mc(this), nb(this));
  }, Ah(r, [{
    key: "closed",
    get: function() {
      return this._state === "closed";
    }
  }]), r;
}(), d4 = /* @__PURE__ */ function() {
  function r(t) {
    this._subscription = t;
  }
  var e = r.prototype;
  return e.next = function(n) {
    Wu(this._subscription, "next", n);
  }, e.error = function(n) {
    Wu(this._subscription, "error", n);
  }, e.complete = function() {
    Wu(this._subscription, "complete");
  }, Ah(r, [{
    key: "closed",
    get: function() {
      return this._subscription._state === "closed";
    }
  }]), r;
}(), or = /* @__PURE__ */ function() {
  function r(t) {
    if (!(this instanceof r))
      throw new TypeError("Observable cannot be called as a function");
    if (typeof t != "function")
      throw new TypeError("Observable initializer must be a function");
    this._subscriber = t;
  }
  var e = r.prototype;
  return e.subscribe = function(n) {
    return (typeof n != "object" || n === null) && (n = {
      next: n,
      error: arguments[1],
      complete: arguments[2]
    }), new l4(n, this._subscriber);
  }, e.forEach = function(n) {
    var a = this;
    return new Promise(function(i, o) {
      if (typeof n != "function") {
        o(new TypeError(n + " is not a function"));
        return;
      }
      function u() {
        c.unsubscribe(), i();
      }
      var c = a.subscribe({
        next: function(h) {
          try {
            n(h, u);
          } catch (s) {
            o(s), c.unsubscribe();
          }
        },
        error: o,
        complete: i
      });
    });
  }, e.map = function(n) {
    var a = this;
    if (typeof n != "function")
      throw new TypeError(n + " is not a function");
    var i = zi(this);
    return new i(function(o) {
      return a.subscribe({
        next: function(u) {
          try {
            u = n(u);
          } catch (c) {
            return o.error(c);
          }
          o.next(u);
        },
        error: function(u) {
          o.error(u);
        },
        complete: function() {
          o.complete();
        }
      });
    });
  }, e.filter = function(n) {
    var a = this;
    if (typeof n != "function")
      throw new TypeError(n + " is not a function");
    var i = zi(this);
    return new i(function(o) {
      return a.subscribe({
        next: function(u) {
          try {
            if (!n(u))
              return;
          } catch (c) {
            return o.error(c);
          }
          o.next(u);
        },
        error: function(u) {
          o.error(u);
        },
        complete: function() {
          o.complete();
        }
      });
    });
  }, e.reduce = function(n) {
    var a = this;
    if (typeof n != "function")
      throw new TypeError(n + " is not a function");
    var i = zi(this), o = arguments.length > 1, u = !1, c = arguments[1], h = c;
    return new i(function(s) {
      return a.subscribe({
        next: function(d) {
          var l = !u;
          if (u = !0, !l || o)
            try {
              h = n(h, d);
            } catch (y) {
              return s.error(y);
            }
          else
            h = d;
        },
        error: function(d) {
          s.error(d);
        },
        complete: function() {
          if (!u && !o)
            return s.error(new TypeError("Cannot reduce an empty sequence"));
          s.next(h), s.complete();
        }
      });
    });
  }, e.concat = function() {
    for (var n = this, a = arguments.length, i = new Array(a), o = 0; o < a; o++)
      i[o] = arguments[o];
    var u = zi(this);
    return new u(function(c) {
      var h, s = 0;
      function d(l) {
        h = l.subscribe({
          next: function(y) {
            c.next(y);
          },
          error: function(y) {
            c.error(y);
          },
          complete: function() {
            s === i.length ? (h = void 0, c.complete()) : d(u.from(i[s++]));
          }
        });
      }
      return d(n), function() {
        h && (h.unsubscribe(), h = void 0);
      };
    });
  }, e.flatMap = function(n) {
    var a = this;
    if (typeof n != "function")
      throw new TypeError(n + " is not a function");
    var i = zi(this);
    return new i(function(o) {
      var u = [], c = a.subscribe({
        next: function(s) {
          if (n)
            try {
              s = n(s);
            } catch (l) {
              return o.error(l);
            }
          var d = i.from(s).subscribe({
            next: function(l) {
              o.next(l);
            },
            error: function(l) {
              o.error(l);
            },
            complete: function() {
              var l = u.indexOf(d);
              l >= 0 && u.splice(l, 1), h();
            }
          });
          u.push(d);
        },
        error: function(s) {
          o.error(s);
        },
        complete: function() {
          h();
        }
      });
      function h() {
        c.closed && u.length === 0 && o.complete();
      }
      return function() {
        u.forEach(function(s) {
          return s.unsubscribe();
        }), c.unsubscribe();
      };
    });
  }, e[Ec] = function() {
    return this;
  }, r.from = function(n) {
    var a = typeof this == "function" ? this : r;
    if (n == null)
      throw new TypeError(n + " is not an object");
    var i = go(n, Ec);
    if (i) {
      var o = i.call(n);
      if (Object(o) !== o)
        throw new TypeError(o + " is not an object");
      return c4(o) && o.constructor === a ? o : new a(function(u) {
        return o.subscribe(u);
      });
    }
    if (kh("iterator") && (i = go(n, u4), i))
      return new a(function(u) {
        ao(function() {
          if (!u.closed) {
            for (var c = s4(i.call(n)), h; !(h = c()).done; ) {
              var s = h.value;
              if (u.next(s), u.closed)
                return;
            }
            u.complete();
          }
        });
      });
    if (Array.isArray(n))
      return new a(function(u) {
        ao(function() {
          if (!u.closed) {
            for (var c = 0; c < n.length; ++c)
              if (u.next(n[c]), u.closed)
                return;
            u.complete();
          }
        });
      });
    throw new TypeError(n + " is not observable");
  }, r.of = function() {
    for (var n = arguments.length, a = new Array(n), i = 0; i < n; i++)
      a[i] = arguments[i];
    var o = typeof this == "function" ? this : r;
    return new o(function(u) {
      ao(function() {
        if (!u.closed) {
          for (var c = 0; c < a.length; ++c)
            if (u.next(a[c]), u.closed)
              return;
          u.complete();
        }
      });
    });
  }, Ah(r, null, [{
    key: rb,
    get: function() {
      return this;
    }
  }]), r;
}();
Th() && Object.defineProperty(or, Symbol("extensions"), {
  value: {
    symbol: Ec,
    hostReportError: Mi
  },
  configurable: !0
});
function p4(r) {
  var e, t = r.Symbol;
  if (typeof t == "function")
    if (t.observable)
      e = t.observable;
    else {
      typeof t.for == "function" ? e = t.for("https://github.com/benlesh/symbol-observable") : e = t("https://github.com/benlesh/symbol-observable");
      try {
        t.observable = e;
      } catch (n) {
      }
    }
  else
    e = "@@observable";
  return e;
}
var hi;
typeof self != "undefined" ? hi = self : typeof window != "undefined" ? hi = window : typeof sa != "undefined" ? hi = sa : typeof module != "undefined" ? hi = module : hi = Function("return this")();
p4(hi);
var nv = or.prototype, iv = "@@observable";
nv[iv] || (nv[iv] = function() {
  return this;
});
var v4 = Object.prototype.toString;
function ab(r) {
  return Ac(r);
}
function Ac(r, e) {
  switch (v4.call(r)) {
    case "[object Array]": {
      if (e = e || /* @__PURE__ */ new Map(), e.has(r))
        return e.get(r);
      var t = r.slice(0);
      return e.set(r, t), t.forEach(function(a, i) {
        t[i] = Ac(a, e);
      }), t;
    }
    case "[object Object]": {
      if (e = e || /* @__PURE__ */ new Map(), e.has(r))
        return e.get(r);
      var n = Object.create(Object.getPrototypeOf(r));
      return e.set(r, n), Object.keys(r).forEach(function(a) {
        n[a] = Ac(r[a], e);
      }), n;
    }
    default:
      return r;
  }
}
function y4(r) {
  var e = /* @__PURE__ */ new Set([r]);
  return e.forEach(function(t) {
    vr(t) && b4(t) === t && Object.getOwnPropertyNames(t).forEach(function(n) {
      vr(t[n]) && e.add(t[n]);
    });
  }), r;
}
function b4(r) {
  if (globalThis.__DEV__ !== !1 && !Object.isFrozen(r))
    try {
      Object.freeze(r);
    } catch (e) {
      if (e instanceof TypeError)
        return null;
      throw e;
    }
  return r;
}
function Tc(r) {
  return globalThis.__DEV__ !== !1 && y4(r), r;
}
function ta(r, e, t) {
  var n = [];
  r.forEach(function(a) {
    return a[e] && n.push(a);
  }), n.forEach(function(a) {
    return a[e](t);
  });
}
function Ku(r, e, t) {
  return new or(function(n) {
    var a = {
      // Normally we would initialize promiseQueue to Promise.resolve(), but
      // in this case, for backwards compatibility, we need to be careful to
      // invoke the first callback synchronously.
      then: function(c) {
        return new Promise(function(h) {
          return h(c());
        });
      }
    };
    function i(c, h) {
      return function(s) {
        if (c) {
          var d = function() {
            return n.closed ? (
              /* will be swallowed */
              0
            ) : c(s);
          };
          a = a.then(d, d).then(function(l) {
            return n.next(l);
          }, function(l) {
            return n.error(l);
          });
        } else
          n[h](s);
      };
    }
    var o = {
      next: i(e, "next"),
      error: i(t, "error"),
      complete: function() {
        a.then(function() {
          return n.complete();
        });
      }
    }, u = r.subscribe(o);
    return function() {
      return u.unsubscribe();
    };
  });
}
function ob(r) {
  function e(t) {
    Object.defineProperty(r, t, { value: or });
  }
  return Cy && Symbol.species && e(Symbol.species), e("@@species"), r;
}
function av(r) {
  return r && typeof r.then == "function";
}
var li = (
  /** @class */
  function(r) {
    tn(e, r);
    function e(t) {
      var n = r.call(this, function(a) {
        return n.addObserver(a), function() {
          return n.removeObserver(a);
        };
      }) || this;
      return n.observers = /* @__PURE__ */ new Set(), n.promise = new Promise(function(a, i) {
        n.resolve = a, n.reject = i;
      }), n.handlers = {
        next: function(a) {
          n.sub !== null && (n.latest = ["next", a], n.notify("next", a), ta(n.observers, "next", a));
        },
        error: function(a) {
          var i = n.sub;
          i !== null && (i && setTimeout(function() {
            return i.unsubscribe();
          }), n.sub = null, n.latest = ["error", a], n.reject(a), n.notify("error", a), ta(n.observers, "error", a));
        },
        complete: function() {
          var a = n, i = a.sub, o = a.sources, u = o === void 0 ? [] : o;
          if (i !== null) {
            var c = u.shift();
            c ? av(c) ? c.then(function(h) {
              return n.sub = h.subscribe(n.handlers);
            }, n.handlers.error) : n.sub = c.subscribe(n.handlers) : (i && setTimeout(function() {
              return i.unsubscribe();
            }), n.sub = null, n.latest && n.latest[0] === "next" ? n.resolve(n.latest[1]) : n.resolve(), n.notify("complete"), ta(n.observers, "complete"));
          }
        }
      }, n.nextResultListeners = /* @__PURE__ */ new Set(), n.cancel = function(a) {
        n.reject(a), n.sources = [], n.handlers.complete();
      }, n.promise.catch(function(a) {
      }), typeof t == "function" && (t = [new or(t)]), av(t) ? t.then(function(a) {
        return n.start(a);
      }, n.handlers.error) : n.start(t), n;
    }
    return e.prototype.start = function(t) {
      this.sub === void 0 && (this.sources = Array.from(t), this.handlers.complete());
    }, e.prototype.deliverLastMessage = function(t) {
      if (this.latest) {
        var n = this.latest[0], a = t[n];
        a && a.call(t, this.latest[1]), this.sub === null && n === "next" && t.complete && t.complete();
      }
    }, e.prototype.addObserver = function(t) {
      this.observers.has(t) || (this.deliverLastMessage(t), this.observers.add(t));
    }, e.prototype.removeObserver = function(t) {
      this.observers.delete(t) && this.observers.size < 1 && this.handlers.complete();
    }, e.prototype.notify = function(t, n) {
      var a = this.nextResultListeners;
      a.size && (this.nextResultListeners = /* @__PURE__ */ new Set(), a.forEach(function(i) {
        return i(t, n);
      }));
    }, e.prototype.beforeNext = function(t) {
      var n = !1;
      this.nextResultListeners.add(function(a, i) {
        n || (n = !0, t(a, i));
      });
    }, e;
  }(or)
);
ob(li);
function wi(r) {
  return "incremental" in r;
}
function m4(r) {
  return "hasNext" in r && "data" in r;
}
function g4(r) {
  return wi(r) || m4(r);
}
function w4(r) {
  return vr(r) && "payload" in r;
}
function sb(r, e) {
  var t = r, n = new $n();
  return wi(e) && hn(e.incremental) && e.incremental.forEach(function(a) {
    for (var i = a.data, o = a.path, u = o.length - 1; u >= 0; --u) {
      var c = o[u], h = !isNaN(+c), s = h ? [] : {};
      s[c] = i, i = s;
    }
    t = n.merge(t, i);
  }), t;
}
function oo(r) {
  var e = kc(r);
  return hn(e);
}
function kc(r) {
  var e = hn(r.errors) ? r.errors.slice(0) : [];
  return wi(r) && hn(r.incremental) && r.incremental.forEach(function(t) {
    t.errors && e.push.apply(e, t.errors);
  }), e;
}
function Ai() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  var t = /* @__PURE__ */ Object.create(null);
  return r.forEach(function(n) {
    n && Object.keys(n).forEach(function(a) {
      var i = n[a];
      i !== void 0 && (t[a] = i);
    });
  }), t;
}
function Qu(r, e) {
  return Ai(r, e, e.variables && {
    variables: Ai(_e(_e({}, r && r.variables), e.variables))
  });
}
function Gu(r) {
  return new or(function(e) {
    e.error(r);
  });
}
var fb = function(r, e, t) {
  var n = new Error(t);
  throw n.name = "ServerError", n.response = r, n.statusCode = r.status, n.result = e, n;
};
function _4(r) {
  for (var e = [
    "query",
    "operationName",
    "variables",
    "extensions",
    "context"
  ], t = 0, n = Object.keys(r); t < n.length; t++) {
    var a = n[t];
    if (e.indexOf(a) < 0)
      throw Nr(43, a);
  }
  return r;
}
function x4(r, e) {
  var t = _e({}, r), n = function(i) {
    typeof i == "function" ? t = _e(_e({}, t), i(t)) : t = _e(_e({}, t), i);
  }, a = function() {
    return _e({}, t);
  };
  return Object.defineProperty(e, "setContext", {
    enumerable: !1,
    value: n
  }), Object.defineProperty(e, "getContext", {
    enumerable: !1,
    value: a
  }), e;
}
function S4(r) {
  var e = {
    variables: r.variables || {},
    extensions: r.extensions || {},
    operationName: r.operationName,
    query: r.query
  };
  return e.operationName || (e.operationName = typeof e.query != "string" ? Sc(e.query) || void 0 : ""), e;
}
function E4(r, e) {
  var t = _e({}, r), n = new Set(Object.keys(r));
  return wn(e, {
    Variable: function(a, i, o) {
      o && o.kind !== "VariableDefinition" && n.delete(a.name.value);
    }
  }), n.forEach(function(a) {
    delete t[a];
  }), t;
}
function ov(r, e) {
  return e ? e(r) : or.of();
}
function Vi(r) {
  return typeof r == "function" ? new Qr(r) : r;
}
function Qa(r) {
  return r.request.length <= 1;
}
var Qr = (
  /** @class */
  function() {
    function r(e) {
      e && (this.request = e);
    }
    return r.empty = function() {
      return new r(function() {
        return or.of();
      });
    }, r.from = function(e) {
      return e.length === 0 ? r.empty() : e.map(Vi).reduce(function(t, n) {
        return t.concat(n);
      });
    }, r.split = function(e, t, n) {
      var a = Vi(t), i = Vi(n || new r(ov)), o;
      return Qa(a) && Qa(i) ? o = new r(function(u) {
        return e(u) ? a.request(u) || or.of() : i.request(u) || or.of();
      }) : o = new r(function(u, c) {
        return e(u) ? a.request(u, c) || or.of() : i.request(u, c) || or.of();
      }), Object.assign(o, { left: a, right: i });
    }, r.execute = function(e, t) {
      return e.request(x4(t.context, S4(_4(t)))) || or.of();
    }, r.concat = function(e, t) {
      var n = Vi(e);
      if (Qa(n))
        return globalThis.__DEV__ !== !1 && Ct.warn(35, n), n;
      var a = Vi(t), i;
      return Qa(a) ? i = new r(function(o) {
        return n.request(o, function(u) {
          return a.request(u) || or.of();
        }) || or.of();
      }) : i = new r(function(o, u) {
        return n.request(o, function(c) {
          return a.request(c, u) || or.of();
        }) || or.of();
      }), Object.assign(i, { left: n, right: a });
    }, r.prototype.split = function(e, t, n) {
      return this.concat(r.split(e, t, n || new r(ov)));
    }, r.prototype.concat = function(e) {
      return r.concat(this, e);
    }, r.prototype.request = function(e, t) {
      throw Nr(36);
    }, r.prototype.onError = function(e, t) {
      if (t && t.error)
        return t.error(e), !1;
      throw e;
    }, r.prototype.setOnError = function(e) {
      return this.onError = e, this;
    }, r;
  }()
), M4 = Qr.from, A4 = Qr.concat, Ic = Qr.execute;
function T4(r) {
  var e, t = r[Symbol.asyncIterator]();
  return e = {
    next: function() {
      return t.next();
    }
  }, e[Symbol.asyncIterator] = function() {
    return this;
  }, e;
}
function k4(r) {
  var e = null, t = null, n = !1, a = [], i = [];
  function o(d) {
    if (!t) {
      if (i.length) {
        var l = i.shift();
        if (Array.isArray(l) && l[0])
          return l[0]({ value: d, done: !1 });
      }
      a.push(d);
    }
  }
  function u(d) {
    t = d;
    var l = i.slice();
    l.forEach(function(y) {
      y[1](d);
    }), !e || e();
  }
  function c() {
    n = !0;
    var d = i.slice();
    d.forEach(function(l) {
      l[0]({ value: void 0, done: !0 });
    }), !e || e();
  }
  e = function() {
    e = null, r.removeListener("data", o), r.removeListener("error", u), r.removeListener("end", c), r.removeListener("finish", c), r.removeListener("close", c);
  }, r.on("data", o), r.on("error", u), r.on("end", c), r.on("finish", c), r.on("close", c);
  function h() {
    return new Promise(function(d, l) {
      if (t)
        return l(t);
      if (a.length)
        return d({ value: a.shift(), done: !1 });
      if (n)
        return d({ value: void 0, done: !0 });
      i.push([d, l]);
    });
  }
  var s = {
    next: function() {
      return h();
    }
  };
  return Oo && (s[Symbol.asyncIterator] = function() {
    return this;
  }), s;
}
function I4(r) {
  var e = !1, t = {
    next: function() {
      return e ? Promise.resolve({
        value: void 0,
        done: !0
      }) : (e = !0, new Promise(function(n, a) {
        r.then(function(i) {
          n({ value: i, done: !1 });
        }).catch(a);
      }));
    }
  };
  return Oo && (t[Symbol.asyncIterator] = function() {
    return this;
  }), t;
}
function sv(r) {
  var e = {
    next: function() {
      return r.read();
    }
  };
  return Oo && (e[Symbol.asyncIterator] = function() {
    return this;
  }), e;
}
function R4(r) {
  return !!r.body;
}
function C4(r) {
  return !!r.getReader;
}
function O4(r) {
  return !!(Oo && r[Symbol.asyncIterator]);
}
function B4(r) {
  return !!r.stream;
}
function P4(r) {
  return !!r.arrayBuffer;
}
function D4(r) {
  return !!r.pipe;
}
function N4(r) {
  var e = r;
  if (R4(r) && (e = r.body), O4(e))
    return T4(e);
  if (C4(e))
    return sv(e.getReader());
  if (B4(e))
    return sv(e.stream().getReader());
  if (P4(e))
    return I4(e.arrayBuffer());
  if (D4(e))
    return k4(e);
  throw new Error("Unknown body type for responseIterator. Please pass a streamable response.");
}
var Rh = Symbol();
function q4(r) {
  return r.extensions ? Array.isArray(r.extensions[Rh]) : !1;
}
function L4(r) {
  return r.hasOwnProperty("graphQLErrors");
}
var F4 = function(r) {
  var e = en(en(en([], r.graphQLErrors, !0), r.clientErrors, !0), r.protocolErrors, !0);
  return r.networkError && e.push(r.networkError), e.map(function(t) {
    return vr(t) && t.message || "Error message not found.";
  }).join(`
`);
}, ci = (
  /** @class */
  function(r) {
    tn(e, r);
    function e(t) {
      var n = t.graphQLErrors, a = t.protocolErrors, i = t.clientErrors, o = t.networkError, u = t.errorMessage, c = t.extraInfo, h = r.call(this, u) || this;
      return h.name = "ApolloError", h.graphQLErrors = n || [], h.protocolErrors = a || [], h.clientErrors = i || [], h.networkError = o || null, h.message = u || F4(h), h.extraInfo = c, h.__proto__ = e.prototype, h;
    }
    return e;
  }(Error)
), fv = Object.prototype.hasOwnProperty;
function U4(r, e) {
  return Rn(this, void 0, void 0, function() {
    var t, n, a, i, o, u, c, h, s, d, l, y, m, w, E, S, P, L, U, z, K, re, oe, se;
    return Cn(this, function(ve) {
      switch (ve.label) {
        case 0:
          if (TextDecoder === void 0)
            throw new Error("TextDecoder must be defined in the environment: please import a polyfill.");
          t = new TextDecoder("utf-8"), n = (se = r.headers) === null || se === void 0 ? void 0 : se.get("content-type"), a = "boundary=", i = n != null && n.includes(a) ? n == null ? void 0 : n.substring((n == null ? void 0 : n.indexOf(a)) + a.length).replace(/['"]/g, "").replace(/\;(.*)/gm, "").trim() : "-", o = `\r
--`.concat(i), u = "", c = N4(r), h = !0, ve.label = 1;
        case 1:
          return h ? [4, c.next()] : [3, 3];
        case 2:
          for (s = ve.sent(), d = s.value, l = s.done, y = typeof d == "string" ? d : t.decode(d), m = u.length - o.length + 1, h = !l, u += y, w = u.indexOf(o, m); w > -1; ) {
            if (E = void 0, re = [
              u.slice(0, w),
              u.slice(w + o.length)
            ], E = re[0], u = re[1], S = E.indexOf(`\r
\r
`), P = $4(E.slice(0, S)), L = P["content-type"], L && L.toLowerCase().indexOf("application/json") === -1)
              throw new Error("Unsupported patch content type: application/json is required.");
            if (U = E.slice(S), U) {
              if (z = ub(r, U), Object.keys(z).length > 1 || "data" in z || "incremental" in z || "errors" in z || "payload" in z)
                if (w4(z)) {
                  if (K = {}, "payload" in z) {
                    if (Object.keys(z).length === 1 && z.payload === null)
                      return [
                        2
                        /*return*/
                      ];
                    K = _e({}, z.payload);
                  }
                  "errors" in z && (K = _e(_e({}, K), { extensions: _e(_e({}, "extensions" in K ? K.extensions : null), (oe = {}, oe[Rh] = z.errors, oe)) })), e(K);
                } else
                  e(z);
              else if (
                // If the chunk contains only a "hasNext: false", we can call
                // observer.complete() immediately.
                Object.keys(z).length === 1 && "hasNext" in z && !z.hasNext
              )
                return [
                  2
                  /*return*/
                ];
            }
            w = u.indexOf(o);
          }
          return [3, 1];
        case 3:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function $4(r) {
  var e = {};
  return r.split(`
`).forEach(function(t) {
    var n = t.indexOf(":");
    if (n > -1) {
      var a = t.slice(0, n).trim().toLowerCase(), i = t.slice(n + 1).trim();
      e[a] = i;
    }
  }), e;
}
function ub(r, e) {
  if (r.status >= 300) {
    var t = function() {
      try {
        return JSON.parse(e);
      } catch (a) {
        return e;
      }
    };
    fb(r, t(), "Response not successful: Received status code ".concat(r.status));
  }
  try {
    return JSON.parse(e);
  } catch (a) {
    var n = a;
    throw n.name = "ServerParseError", n.response = r, n.statusCode = r.status, n.bodyText = e, n;
  }
}
function j4(r, e) {
  r.result && r.result.errors && r.result.data && e.next(r.result), e.error(r);
}
function H4(r) {
  return function(e) {
    return e.text().then(function(t) {
      return ub(e, t);
    }).then(function(t) {
      return !Array.isArray(t) && !fv.call(t, "data") && !fv.call(t, "errors") && fb(e, t, "Server response was missing for query '".concat(Array.isArray(r) ? r.map(function(n) {
        return n.operationName;
      }) : r.operationName, "'.")), t;
    });
  };
}
var Rc = function(r, e) {
  var t;
  try {
    t = JSON.stringify(r);
  } catch (a) {
    var n = Nr(39, e, a.message);
    throw n.parseError = a, n;
  }
  return t;
}, z4 = {
  includeQuery: !0,
  includeExtensions: !1,
  preserveHeaderCase: !1
}, V4 = {
  // headers are case insensitive (https://stackoverflow.com/a/5259004)
  accept: "*/*",
  // The content-type header describes the type of the body of the request, and
  // so it typically only is sent with requests that actually have bodies. One
  // could imagine that Apollo Client would remove this header when constructing
  // a GET request (which has no body), but we historically have not done that.
  // This means that browsers will preflight all Apollo Client requests (even
  // GET requests). Apollo Server's CSRF prevention feature (introduced in
  // AS3.7) takes advantage of this fact and does not block requests with this
  // header. If you want to drop this header from GET requests, then you should
  // probably replace it with a `apollo-require-preflight` header, or servers
  // with CSRF prevention enabled might block your GET request. See
  // https://www.apollographql.com/docs/apollo-server/security/cors/#preventing-cross-site-request-forgery-csrf
  // for more details.
  "content-type": "application/json"
}, W4 = {
  method: "POST"
}, K4 = {
  http: z4,
  headers: V4,
  options: W4
}, Q4 = function(r, e) {
  return e(r);
};
function G4(r, e) {
  for (var t = [], n = 2; n < arguments.length; n++)
    t[n - 2] = arguments[n];
  var a = {}, i = {};
  t.forEach(function(d) {
    a = _e(_e(_e({}, a), d.options), { headers: _e(_e({}, a.headers), d.headers) }), d.credentials && (a.credentials = d.credentials), i = _e(_e({}, i), d.http);
  }), a.headers && (a.headers = J4(a.headers, i.preserveHeaderCase));
  var o = r.operationName, u = r.extensions, c = r.variables, h = r.query, s = { operationName: o, variables: c };
  return i.includeExtensions && (s.extensions = u), i.includeQuery && (s.query = e(h, Fo)), {
    options: a,
    body: s
  };
}
function J4(r, e) {
  if (!e) {
    var t = /* @__PURE__ */ Object.create(null);
    return Object.keys(Object(r)).forEach(function(i) {
      t[i.toLowerCase()] = r[i];
    }), t;
  }
  var n = /* @__PURE__ */ Object.create(null);
  Object.keys(Object(r)).forEach(function(i) {
    n[i.toLowerCase()] = {
      originalName: i,
      value: r[i]
    };
  });
  var a = /* @__PURE__ */ Object.create(null);
  return Object.keys(n).forEach(function(i) {
    a[n[i].originalName] = n[i].value;
  }), a;
}
var Y4 = function(r) {
  if (!r && typeof fetch == "undefined")
    throw Nr(37);
}, X4 = function(r, e) {
  var t = r.getContext(), n = t.uri;
  return n || (typeof e == "function" ? e(r) : e || "/graphql");
};
function Z4(r, e) {
  var t = [], n = function(d, l) {
    t.push("".concat(d, "=").concat(encodeURIComponent(l)));
  };
  if ("query" in e && n("query", e.query), e.operationName && n("operationName", e.operationName), e.variables) {
    var a = void 0;
    try {
      a = Rc(e.variables, "Variables map");
    } catch (d) {
      return { parseError: d };
    }
    n("variables", a);
  }
  if (e.extensions) {
    var i = void 0;
    try {
      i = Rc(e.extensions, "Extensions map");
    } catch (d) {
      return { parseError: d };
    }
    n("extensions", i);
  }
  var o = "", u = r, c = r.indexOf("#");
  c !== -1 && (o = r.substr(c), u = r.substr(0, c));
  var h = u.indexOf("?") === -1 ? "?" : "&", s = u + h + t.join("&") + o;
  return { newURI: s };
}
var uv = Xr(function() {
  return fetch;
}), e5 = function(r) {
  r === void 0 && (r = {});
  var e = r.uri, t = e === void 0 ? "/graphql" : e, n = r.fetch, a = r.print, i = a === void 0 ? Q4 : a, o = r.includeExtensions, u = r.preserveHeaderCase, c = r.useGETForQueries, h = r.includeUnusedVariables, s = h === void 0 ? !1 : h, d = qn(r, ["uri", "fetch", "print", "includeExtensions", "preserveHeaderCase", "useGETForQueries", "includeUnusedVariables"]);
  globalThis.__DEV__ !== !1 && Y4(n || uv);
  var l = {
    http: { includeExtensions: o, preserveHeaderCase: u },
    options: d.fetchOptions,
    credentials: d.credentials,
    headers: d.headers
  };
  return new Qr(function(y) {
    var m = X4(y, t), w = y.getContext(), E = {};
    if (w.clientAwareness) {
      var S = w.clientAwareness, P = S.name, L = S.version;
      P && (E["apollographql-client-name"] = P), L && (E["apollographql-client-version"] = L);
    }
    var U = _e(_e({}, E), w.headers), z = {
      http: w.http,
      options: w.fetchOptions,
      credentials: w.credentials,
      headers: U
    };
    if (ua(["client"], y.query)) {
      var K = tb(y.query);
      if (!K)
        return Gu(new Error("HttpLink: Trying to send a client-only query to the server. To send to the server, ensure a non-client field is added to the query or set the `transformOptions.removeClientFields` option to `true`."));
      y.query = K;
    }
    var re = G4(y, i, K4, l, z), oe = re.options, se = re.body;
    se.variables && !s && (se.variables = E4(se.variables, y.query));
    var ve;
    !oe.signal && typeof AbortController != "undefined" && (ve = new AbortController(), oe.signal = ve.signal);
    var Q = function(R) {
      return R.kind === "OperationDefinition" && R.operation === "mutation";
    }, A = function(R) {
      return R.kind === "OperationDefinition" && R.operation === "subscription";
    }, b = A(Ea(y.query)), f = ua(["defer"], y.query);
    if (c && !y.query.definitions.some(Q) && (oe.method = "GET"), f || b) {
      oe.headers = oe.headers || {};
      var v = "multipart/mixed;";
      b && f && globalThis.__DEV__ !== !1 && Ct.warn(38), b ? v += "boundary=graphql;subscriptionSpec=1.0,application/json" : f && (v += "deferSpec=20220824,application/json"), oe.headers.accept = v;
    }
    if (oe.method === "GET") {
      var g = Z4(m, se), M = g.newURI, I = g.parseError;
      if (I)
        return Gu(I);
      m = M;
    } else
      try {
        oe.body = Rc(se, "Payload");
      } catch (R) {
        return Gu(R);
      }
    return new or(function(R) {
      var x = n || Xr(function() {
        return fetch;
      }) || uv, T = R.next.bind(R);
      return x(m, oe).then(function(p) {
        var B;
        y.setContext({ response: p });
        var ee = (B = p.headers) === null || B === void 0 ? void 0 : B.get("content-type");
        return ee !== null && /^multipart\/mixed/i.test(ee) ? U4(p, T) : H4(y)(p).then(T);
      }).then(function() {
        ve = void 0, R.complete();
      }).catch(function(p) {
        ve = void 0, j4(p, R);
      }), function() {
        ve && ve.abort();
      };
    });
  });
}, cb = (
  /** @class */
  function(r) {
    tn(e, r);
    function e(t) {
      t === void 0 && (t = {});
      var n = r.call(this, e5(t).request) || this;
      return n.options = t, n;
    }
    return e;
  }(Qr)
);
const { toString: cv, hasOwnProperty: t5 } = Object.prototype, hv = Function.prototype.toString, Cc = /* @__PURE__ */ new Map();
function ur(r, e) {
  try {
    return Oc(r, e);
  } finally {
    Cc.clear();
  }
}
function Oc(r, e) {
  if (r === e)
    return !0;
  const t = cv.call(r), n = cv.call(e);
  if (t !== n)
    return !1;
  switch (t) {
    case "[object Array]":
      if (r.length !== e.length)
        return !1;
    case "[object Object]": {
      if (dv(r, e))
        return !0;
      const a = lv(r), i = lv(e), o = a.length;
      if (o !== i.length)
        return !1;
      for (let u = 0; u < o; ++u)
        if (!t5.call(e, a[u]))
          return !1;
      for (let u = 0; u < o; ++u) {
        const c = a[u];
        if (!Oc(r[c], e[c]))
          return !1;
      }
      return !0;
    }
    case "[object Error]":
      return r.name === e.name && r.message === e.message;
    case "[object Number]":
      if (r !== r)
        return e !== e;
    case "[object Boolean]":
    case "[object Date]":
      return +r == +e;
    case "[object RegExp]":
    case "[object String]":
      return r == `${e}`;
    case "[object Map]":
    case "[object Set]": {
      if (r.size !== e.size)
        return !1;
      if (dv(r, e))
        return !0;
      const a = r.entries(), i = t === "[object Map]";
      for (; ; ) {
        const o = a.next();
        if (o.done)
          break;
        const [u, c] = o.value;
        if (!e.has(u) || i && !Oc(c, e.get(u)))
          return !1;
      }
      return !0;
    }
    case "[object Uint16Array]":
    case "[object Uint8Array]":
    case "[object Uint32Array]":
    case "[object Int32Array]":
    case "[object Int8Array]":
    case "[object Int16Array]":
    case "[object ArrayBuffer]":
      r = new Uint8Array(r), e = new Uint8Array(e);
    case "[object DataView]": {
      let a = r.byteLength;
      if (a === e.byteLength)
        for (; a-- && r[a] === e[a]; )
          ;
      return a === -1;
    }
    case "[object AsyncFunction]":
    case "[object GeneratorFunction]":
    case "[object AsyncGeneratorFunction]":
    case "[object Function]": {
      const a = hv.call(r);
      return a !== hv.call(e) ? !1 : !i5(a, n5);
    }
  }
  return !1;
}
function lv(r) {
  return Object.keys(r).filter(r5, r);
}
function r5(r) {
  return this[r] !== void 0;
}
const n5 = "{ [native code] }";
function i5(r, e) {
  const t = r.length - e.length;
  return t >= 0 && r.indexOf(e, t) === t;
}
function dv(r, e) {
  let t = Cc.get(r);
  if (t) {
    if (t.has(e))
      return !0;
  } else
    Cc.set(r, t = /* @__PURE__ */ new Set());
  return t.add(e), !1;
}
var hb = (
  /** @class */
  function() {
    function r() {
      this.assumeImmutableResults = !1, this.getFragmentDoc = ha(f_, {
        max: _n["cache.fragmentQueryDocuments"] || 1e3,
        cache: bo
      });
    }
    return r.prototype.batch = function(e) {
      var t = this, n = typeof e.optimistic == "string" ? e.optimistic : e.optimistic === !1 ? null : void 0, a;
      return this.performTransaction(function() {
        return a = e.update(t);
      }, n), a;
    }, r.prototype.recordOptimisticTransaction = function(e, t) {
      this.performTransaction(e, t);
    }, r.prototype.transformDocument = function(e) {
      return e;
    }, r.prototype.transformForLink = function(e) {
      return e;
    }, r.prototype.identify = function(e) {
    }, r.prototype.gc = function() {
      return [];
    }, r.prototype.modify = function(e) {
      return !1;
    }, r.prototype.readQuery = function(e, t) {
      return t === void 0 && (t = !!e.optimistic), this.read(_e(_e({}, e), { rootId: e.id || "ROOT_QUERY", optimistic: t }));
    }, r.prototype.readFragment = function(e, t) {
      return t === void 0 && (t = !!e.optimistic), this.read(_e(_e({}, e), { query: this.getFragmentDoc(e.fragment, e.fragmentName), rootId: e.id, optimistic: t }));
    }, r.prototype.writeQuery = function(e) {
      var t = e.id, n = e.data, a = qn(e, ["id", "data"]);
      return this.write(Object.assign(a, {
        dataId: t || "ROOT_QUERY",
        result: n
      }));
    }, r.prototype.writeFragment = function(e) {
      var t = e.id, n = e.data, a = e.fragment, i = e.fragmentName, o = qn(e, ["id", "data", "fragment", "fragmentName"]);
      return this.write(Object.assign(o, {
        query: this.getFragmentDoc(a, i),
        dataId: t,
        result: n
      }));
    }, r.prototype.updateQuery = function(e, t) {
      return this.batch({
        update: function(n) {
          var a = n.readQuery(e), i = t(a);
          return i == null ? a : (n.writeQuery(_e(_e({}, e), { data: i })), i);
        }
      });
    }, r.prototype.updateFragment = function(e, t) {
      return this.batch({
        update: function(n) {
          var a = n.readFragment(e), i = t(a);
          return i == null ? a : (n.writeFragment(_e(_e({}, e), { data: i })), i);
        }
      });
    }, r;
  }()
);
globalThis.__DEV__ !== !1 && (hb.prototype.getMemoryInternals = g_);
var lb = (
  /** @class */
  function(r) {
    tn(e, r);
    function e(t, n, a, i) {
      var o, u = r.call(this, t) || this;
      if (u.message = t, u.path = n, u.query = a, u.variables = i, Array.isArray(u.path)) {
        u.missing = u.message;
        for (var c = u.path.length - 1; c >= 0; --c)
          u.missing = (o = {}, o[u.path[c]] = u.missing, o);
      } else
        u.missing = u.path;
      return u.__proto__ = e.prototype, u;
    }
    return e;
  }(Error)
), Ar = Object.prototype.hasOwnProperty;
function Wi(r) {
  return r == null;
}
function db(r, e) {
  var t = r.__typename, n = r.id, a = r._id;
  if (typeof t == "string" && (e && (e.keyObject = Wi(n) ? Wi(a) ? void 0 : { _id: a } : { id: n }), Wi(n) && !Wi(a) && (n = a), !Wi(n)))
    return "".concat(t, ":").concat(typeof n == "number" || typeof n == "string" ? n : JSON.stringify(n));
}
var pb = {
  dataIdFromObject: db,
  addTypename: !0,
  resultCaching: !0,
  // Thanks to the shouldCanonizeResults helper, this should be the only line
  // you have to change to reenable canonization by default in the future.
  canonizeResults: !1
};
function a5(r) {
  return Ai(pb, r);
}
function vb(r) {
  var e = r.canonizeResults;
  return e === void 0 ? pb.canonizeResults : e;
}
function o5(r, e) {
  return rr(e) ? r.get(e.__ref, "__typename") : e && e.__typename;
}
var yb = /^[_a-z][_0-9a-z]*/i;
function jn(r) {
  var e = r.match(yb);
  return e ? e[0] : r;
}
function Bc(r, e, t) {
  return vr(e) ? yr(e) ? e.every(function(n) {
    return Bc(r, n, t);
  }) : r.selections.every(function(n) {
    if (Fn(n) && _a(n, t)) {
      var a = Ln(n);
      return Ar.call(e, a) && (!n.selectionSet || Bc(n.selectionSet, e[a], t));
    }
    return !0;
  }) : !1;
}
function vi(r) {
  return vr(r) && !rr(r) && !yr(r);
}
function s5() {
  return new $n();
}
function bb(r, e) {
  var t = Bo(No(r));
  return {
    fragmentMap: t,
    lookupFragment: function(n) {
      var a = t[n];
      return !a && e && (a = e.lookup(n)), a || null;
    }
  };
}
var so = /* @__PURE__ */ Object.create(null), Ju = function() {
  return so;
}, pv = /* @__PURE__ */ Object.create(null), la = (
  /** @class */
  function() {
    function r(e, t) {
      var n = this;
      this.policies = e, this.group = t, this.data = /* @__PURE__ */ Object.create(null), this.rootIds = /* @__PURE__ */ Object.create(null), this.refs = /* @__PURE__ */ Object.create(null), this.getFieldValue = function(a, i) {
        return Tc(rr(a) ? n.get(a.__ref, i) : a && a[i]);
      }, this.canRead = function(a) {
        return rr(a) ? n.has(a.__ref) : typeof a == "object";
      }, this.toReference = function(a, i) {
        if (typeof a == "string")
          return gi(a);
        if (rr(a))
          return a;
        var o = n.policies.identify(a)[0];
        if (o) {
          var u = gi(o);
          return i && n.merge(o, a), u;
        }
      };
    }
    return r.prototype.toObject = function() {
      return _e({}, this.data);
    }, r.prototype.has = function(e) {
      return this.lookup(e, !0) !== void 0;
    }, r.prototype.get = function(e, t) {
      if (this.group.depend(e, t), Ar.call(this.data, e)) {
        var n = this.data[e];
        if (n && Ar.call(n, t))
          return n[t];
      }
      if (t === "__typename" && Ar.call(this.policies.rootTypenamesById, e))
        return this.policies.rootTypenamesById[e];
      if (this instanceof kn)
        return this.parent.get(e, t);
    }, r.prototype.lookup = function(e, t) {
      if (t && this.group.depend(e, "__exists"), Ar.call(this.data, e))
        return this.data[e];
      if (this instanceof kn)
        return this.parent.lookup(e, t);
      if (this.policies.rootTypenamesById[e])
        return /* @__PURE__ */ Object.create(null);
    }, r.prototype.merge = function(e, t) {
      var n = this, a;
      rr(e) && (e = e.__ref), rr(t) && (t = t.__ref);
      var i = typeof e == "string" ? this.lookup(a = e) : e, o = typeof t == "string" ? this.lookup(a = t) : t;
      if (o) {
        Ct(typeof a == "string", 1);
        var u = new $n(u5).merge(i, o);
        if (this.data[a] = u, u !== i && (delete this.refs[a], this.group.caching)) {
          var c = /* @__PURE__ */ Object.create(null);
          i || (c.__exists = 1), Object.keys(o).forEach(function(h) {
            if (!i || i[h] !== u[h]) {
              c[h] = 1;
              var s = jn(h);
              s !== h && !n.policies.hasKeyArgs(u.__typename, s) && (c[s] = 1), u[h] === void 0 && !(n instanceof kn) && delete u[h];
            }
          }), c.__typename && !(i && i.__typename) && // Since we return default root __typename strings
          // automatically from store.get, we don't need to dirty the
          // ROOT_QUERY.__typename field if merged.__typename is equal
          // to the default string (usually "Query").
          this.policies.rootTypenamesById[a] === u.__typename && delete c.__typename, Object.keys(c).forEach(function(h) {
            return n.group.dirty(a, h);
          });
        }
      }
    }, r.prototype.modify = function(e, t) {
      var n = this, a = this.lookup(e);
      if (a) {
        var i = /* @__PURE__ */ Object.create(null), o = !1, u = !0, c = {
          DELETE: so,
          INVALIDATE: pv,
          isReference: rr,
          toReference: this.toReference,
          canRead: this.canRead,
          readField: function(h, s) {
            return n.policies.readField(typeof h == "string" ? {
              fieldName: h,
              from: s || gi(e)
            } : h, { store: n });
          }
        };
        if (Object.keys(a).forEach(function(h) {
          var s = jn(h), d = a[h];
          if (d !== void 0) {
            var l = typeof t == "function" ? t : t[h] || t[s];
            if (l) {
              var y = l === Ju ? so : l(Tc(d), _e(_e({}, c), { fieldName: s, storeFieldName: h, storage: n.getStorage(e, h) }));
              if (y === pv)
                n.group.dirty(e, h);
              else if (y === so && (y = void 0), y !== d && (i[h] = y, o = !0, d = y, globalThis.__DEV__ !== !1)) {
                var m = function(z) {
                  if (n.lookup(z.__ref) === void 0)
                    return globalThis.__DEV__ !== !1 && Ct.warn(2, z), !0;
                };
                if (rr(y))
                  m(y);
                else if (Array.isArray(y))
                  for (var w = !1, E = void 0, S = 0, P = y; S < P.length; S++) {
                    var L = P[S];
                    if (rr(L)) {
                      if (w = !0, m(L))
                        break;
                    } else if (typeof L == "object" && L) {
                      var U = n.policies.identify(L)[0];
                      U && (E = L);
                    }
                    if (w && E !== void 0) {
                      globalThis.__DEV__ !== !1 && Ct.warn(3, E);
                      break;
                    }
                  }
              }
            }
            d !== void 0 && (u = !1);
          }
        }), o)
          return this.merge(e, i), u && (this instanceof kn ? this.data[e] = void 0 : delete this.data[e], this.group.dirty(e, "__exists")), !0;
      }
      return !1;
    }, r.prototype.delete = function(e, t, n) {
      var a, i = this.lookup(e);
      if (i) {
        var o = this.getFieldValue(i, "__typename"), u = t && n ? this.policies.getStoreFieldName({ typename: o, fieldName: t, args: n }) : t;
        return this.modify(e, u ? (a = {}, a[u] = Ju, a) : Ju);
      }
      return !1;
    }, r.prototype.evict = function(e, t) {
      var n = !1;
      return e.id && (Ar.call(this.data, e.id) && (n = this.delete(e.id, e.fieldName, e.args)), this instanceof kn && this !== t && (n = this.parent.evict(e, t) || n), (e.fieldName || n) && this.group.dirty(e.id, e.fieldName || "__exists")), n;
    }, r.prototype.clear = function() {
      this.replace(null);
    }, r.prototype.extract = function() {
      var e = this, t = this.toObject(), n = [];
      return this.getRootIdSet().forEach(function(a) {
        Ar.call(e.policies.rootTypenamesById, a) || n.push(a);
      }), n.length && (t.__META = { extraRootIds: n.sort() }), t;
    }, r.prototype.replace = function(e) {
      var t = this;
      if (Object.keys(this.data).forEach(function(i) {
        e && Ar.call(e, i) || t.delete(i);
      }), e) {
        var n = e.__META, a = qn(e, ["__META"]);
        Object.keys(a).forEach(function(i) {
          t.merge(i, a[i]);
        }), n && n.extraRootIds.forEach(this.retain, this);
      }
    }, r.prototype.retain = function(e) {
      return this.rootIds[e] = (this.rootIds[e] || 0) + 1;
    }, r.prototype.release = function(e) {
      if (this.rootIds[e] > 0) {
        var t = --this.rootIds[e];
        return t || delete this.rootIds[e], t;
      }
      return 0;
    }, r.prototype.getRootIdSet = function(e) {
      return e === void 0 && (e = /* @__PURE__ */ new Set()), Object.keys(this.rootIds).forEach(e.add, e), this instanceof kn ? this.parent.getRootIdSet(e) : Object.keys(this.policies.rootTypenamesById).forEach(e.add, e), e;
    }, r.prototype.gc = function() {
      var e = this, t = this.getRootIdSet(), n = this.toObject();
      t.forEach(function(o) {
        Ar.call(n, o) && (Object.keys(e.findChildRefIds(o)).forEach(t.add, t), delete n[o]);
      });
      var a = Object.keys(n);
      if (a.length) {
        for (var i = this; i instanceof kn; )
          i = i.parent;
        a.forEach(function(o) {
          return i.delete(o);
        });
      }
      return a;
    }, r.prototype.findChildRefIds = function(e) {
      if (!Ar.call(this.refs, e)) {
        var t = this.refs[e] = /* @__PURE__ */ Object.create(null), n = this.data[e];
        if (!n)
          return t;
        var a = /* @__PURE__ */ new Set([n]);
        a.forEach(function(i) {
          rr(i) && (t[i.__ref] = !0), vr(i) && Object.keys(i).forEach(function(o) {
            var u = i[o];
            vr(u) && a.add(u);
          });
        });
      }
      return this.refs[e];
    }, r.prototype.makeCacheKey = function() {
      return this.group.keyMaker.lookupArray(arguments);
    }, r;
  }()
), mb = (
  /** @class */
  function() {
    function r(e, t) {
      t === void 0 && (t = null), this.caching = e, this.parent = t, this.d = null, this.resetCaching();
    }
    return r.prototype.resetCaching = function() {
      this.d = this.caching ? Yy() : null, this.keyMaker = new Bi(Pi);
    }, r.prototype.depend = function(e, t) {
      if (this.d) {
        this.d(Yu(e, t));
        var n = jn(t);
        n !== t && this.d(Yu(e, n)), this.parent && this.parent.depend(e, t);
      }
    }, r.prototype.dirty = function(e, t) {
      this.d && this.d.dirty(
        Yu(e, t),
        // When storeFieldName === "__exists", that means the entity identified
        // by dataId has either disappeared from the cache or was newly added,
        // so the result caching system would do well to "forget everything it
        // knows" about that object. To achieve that kind of invalidation, we
        // not only dirty the associated result cache entry, but also remove it
        // completely from the dependency graph. For the optimism implementation
        // details, see https://github.com/benjamn/optimism/pull/195.
        t === "__exists" ? "forget" : "setDirty"
      );
    }, r;
  }()
);
function Yu(r, e) {
  return e + "#" + r;
}
function vv(r, e) {
  ra(r) && r.group.depend(e, "__exists");
}
(function(r) {
  var e = (
    /** @class */
    function(t) {
      tn(n, t);
      function n(a) {
        var i = a.policies, o = a.resultCaching, u = o === void 0 ? !0 : o, c = a.seed, h = t.call(this, i, new mb(u)) || this;
        return h.stump = new f5(h), h.storageTrie = new Bi(Pi), c && h.replace(c), h;
      }
      return n.prototype.addLayer = function(a, i) {
        return this.stump.addLayer(a, i);
      }, n.prototype.removeLayer = function() {
        return this;
      }, n.prototype.getStorage = function() {
        return this.storageTrie.lookupArray(arguments);
      }, n;
    }(r)
  );
  r.Root = e;
})(la || (la = {}));
var kn = (
  /** @class */
  function(r) {
    tn(e, r);
    function e(t, n, a, i) {
      var o = r.call(this, n.policies, i) || this;
      return o.id = t, o.parent = n, o.replay = a, o.group = i, a(o), o;
    }
    return e.prototype.addLayer = function(t, n) {
      return new e(t, this, n, this.group);
    }, e.prototype.removeLayer = function(t) {
      var n = this, a = this.parent.removeLayer(t);
      return t === this.id ? (this.group.caching && Object.keys(this.data).forEach(function(i) {
        var o = n.data[i], u = a.lookup(i);
        u ? o ? o !== u && Object.keys(o).forEach(function(c) {
          ur(o[c], u[c]) || n.group.dirty(i, c);
        }) : (n.group.dirty(i, "__exists"), Object.keys(u).forEach(function(c) {
          n.group.dirty(i, c);
        })) : n.delete(i);
      }), a) : a === this.parent ? this : a.addLayer(this.id, this.replay);
    }, e.prototype.toObject = function() {
      return _e(_e({}, this.parent.toObject()), this.data);
    }, e.prototype.findChildRefIds = function(t) {
      var n = this.parent.findChildRefIds(t);
      return Ar.call(this.data, t) ? _e(_e({}, n), r.prototype.findChildRefIds.call(this, t)) : n;
    }, e.prototype.getStorage = function() {
      for (var t = this.parent; t.parent; )
        t = t.parent;
      return t.getStorage.apply(
        t,
        // @ts-expect-error
        arguments
      );
    }, e;
  }(la)
), f5 = (
  /** @class */
  function(r) {
    tn(e, r);
    function e(t) {
      return r.call(this, "EntityStore.Stump", t, function() {
      }, new mb(t.group.caching, t.group)) || this;
    }
    return e.prototype.removeLayer = function() {
      return this;
    }, e.prototype.merge = function(t, n) {
      return this.parent.merge(t, n);
    }, e;
  }(kn)
);
function u5(r, e, t) {
  var n = r[t], a = e[t];
  return ur(n, a) ? n : a;
}
function ra(r) {
  return !!(r instanceof la && r.group.caching);
}
function c5(r) {
  return vr(r) ? yr(r) ? r.slice(0) : _e({ __proto__: Object.getPrototypeOf(r) }, r) : r;
}
var yv = (
  /** @class */
  function() {
    function r() {
      this.known = new (Ry ? WeakSet : Set)(), this.pool = new Bi(Pi), this.passes = /* @__PURE__ */ new WeakMap(), this.keysByJSON = /* @__PURE__ */ new Map(), this.empty = this.admit({});
    }
    return r.prototype.isKnown = function(e) {
      return vr(e) && this.known.has(e);
    }, r.prototype.pass = function(e) {
      if (vr(e)) {
        var t = c5(e);
        return this.passes.set(t, e), t;
      }
      return e;
    }, r.prototype.admit = function(e) {
      var t = this;
      if (vr(e)) {
        var n = this.passes.get(e);
        if (n)
          return n;
        var a = Object.getPrototypeOf(e);
        switch (a) {
          case Array.prototype: {
            if (this.known.has(e))
              return e;
            var i = e.map(this.admit, this), o = this.pool.lookupArray(i);
            return o.array || (this.known.add(o.array = i), globalThis.__DEV__ !== !1 && Object.freeze(i)), o.array;
          }
          case null:
          case Object.prototype: {
            if (this.known.has(e))
              return e;
            var u = Object.getPrototypeOf(e), c = [u], h = this.sortedKeys(e);
            c.push(h.json);
            var s = c.length;
            h.sorted.forEach(function(y) {
              c.push(t.admit(e[y]));
            });
            var o = this.pool.lookupArray(c);
            if (!o.object) {
              var d = o.object = Object.create(u);
              this.known.add(d), h.sorted.forEach(function(y, m) {
                d[y] = c[s + m];
              }), globalThis.__DEV__ !== !1 && Object.freeze(d);
            }
            return o.object;
          }
        }
      }
      return e;
    }, r.prototype.sortedKeys = function(e) {
      var t = Object.keys(e), n = this.pool.lookupArray(t);
      if (!n.keys) {
        t.sort();
        var a = JSON.stringify(t);
        (n.keys = this.keysByJSON.get(a)) || this.keysByJSON.set(a, n.keys = { sorted: t, json: a });
      }
      return n.keys;
    }, r;
  }()
);
function bv(r) {
  return [
    r.selectionSet,
    r.objectOrReference,
    r.context,
    // We split out this property so we can pass different values
    // independently without modifying options.context itself.
    r.context.canonizeResults
  ];
}
var h5 = (
  /** @class */
  function() {
    function r(e) {
      var t = this;
      this.knownResults = new (Pi ? WeakMap : Map)(), this.config = Ai(e, {
        addTypename: e.addTypename !== !1,
        canonizeResults: vb(e)
      }), this.canon = e.canon || new yv(), this.executeSelectionSet = ha(function(n) {
        var a, i = n.context.canonizeResults, o = bv(n);
        o[3] = !i;
        var u = (a = t.executeSelectionSet).peek.apply(a, o);
        return u ? i ? _e(_e({}, u), {
          // If we previously read this result without canonizing it, we can
          // reuse that result simply by canonizing it now.
          result: t.canon.admit(u.result)
        }) : u : (vv(n.context.store, n.enclosingRef.__ref), t.execSelectionSetImpl(n));
      }, {
        max: this.config.resultCacheMaxSize || _n["inMemoryCache.executeSelectionSet"] || 5e4,
        keyArgs: bv,
        // Note that the parameters of makeCacheKey are determined by the
        // array returned by keyArgs.
        makeCacheKey: function(n, a, i, o) {
          if (ra(i.store))
            return i.store.makeCacheKey(n, rr(a) ? a.__ref : a, i.varString, o);
        }
      }), this.executeSubSelectedArray = ha(function(n) {
        return vv(n.context.store, n.enclosingRef.__ref), t.execSubSelectedArrayImpl(n);
      }, {
        max: this.config.resultCacheMaxSize || _n["inMemoryCache.executeSubSelectedArray"] || 1e4,
        makeCacheKey: function(n) {
          var a = n.field, i = n.array, o = n.context;
          if (ra(o.store))
            return o.store.makeCacheKey(a, i, o.varString);
        }
      });
    }
    return r.prototype.resetCanon = function() {
      this.canon = new yv();
    }, r.prototype.diffQueryAgainstStore = function(e) {
      var t = e.store, n = e.query, a = e.rootId, i = a === void 0 ? "ROOT_QUERY" : a, o = e.variables, u = e.returnPartialData, c = u === void 0 ? !0 : u, h = e.canonizeResults, s = h === void 0 ? this.config.canonizeResults : h, d = this.config.cache.policies;
      o = _e(_e({}, wh(Fy(n))), o);
      var l = gi(i), y = this.executeSelectionSet({
        selectionSet: Ea(n).selectionSet,
        objectOrReference: l,
        enclosingRef: l,
        context: _e({ store: t, query: n, policies: d, variables: o, varString: Dn(o), canonizeResults: s }, bb(n, this.config.fragments))
      }), m;
      if (y.missing && (m = [
        new lb(l5(y.missing), y.missing, n, o)
      ], !c))
        throw m[0];
      return {
        result: y.result,
        complete: !m,
        missing: m
      };
    }, r.prototype.isFresh = function(e, t, n, a) {
      if (ra(a.store) && this.knownResults.get(e) === n) {
        var i = this.executeSelectionSet.peek(
          n,
          t,
          a,
          // If result is canonical, then it could only have been previously
          // cached by the canonizing version of executeSelectionSet, so we can
          // avoid checking both possibilities here.
          this.canon.isKnown(e)
        );
        if (i && e === i.result)
          return !0;
      }
      return !1;
    }, r.prototype.execSelectionSetImpl = function(e) {
      var t = this, n = e.selectionSet, a = e.objectOrReference, i = e.enclosingRef, o = e.context;
      if (rr(a) && !o.policies.rootTypenamesById[a.__ref] && !o.store.has(a.__ref))
        return {
          result: this.canon.empty,
          missing: "Dangling reference to missing ".concat(a.__ref, " object")
        };
      var u = o.variables, c = o.policies, h = o.store, s = h.getFieldValue(a, "__typename"), d = [], l, y = new $n();
      this.config.addTypename && typeof s == "string" && !c.rootIdsByTypename[s] && d.push({ __typename: s });
      function m(L, U) {
        var z;
        return L.missing && (l = y.merge(l, (z = {}, z[U] = L.missing, z))), L.result;
      }
      var w = new Set(n.selections);
      w.forEach(function(L) {
        var U, z;
        if (_a(L, u))
          if (Fn(L)) {
            var K = c.readField({
              fieldName: L.name.value,
              field: L,
              variables: o.variables,
              from: a
            }, o), re = Ln(L);
            K === void 0 ? Eh.added(L) || (l = y.merge(l, (U = {}, U[re] = "Can't find field '".concat(L.name.value, "' on ").concat(rr(a) ? a.__ref + " object" : "object " + JSON.stringify(a, null, 2)), U))) : yr(K) ? K = m(t.executeSubSelectedArray({
              field: L,
              array: K,
              enclosingRef: i,
              context: o
            }), re) : L.selectionSet ? K != null && (K = m(t.executeSelectionSet({
              selectionSet: L.selectionSet,
              objectOrReference: K,
              enclosingRef: rr(K) ? K : i,
              context: o
            }), re)) : o.canonizeResults && (K = t.canon.pass(K)), K !== void 0 && d.push((z = {}, z[re] = K, z));
          } else {
            var oe = Po(L, o.lookupFragment);
            if (!oe && L.kind === yt.FRAGMENT_SPREAD)
              throw Nr(9, L.name.value);
            oe && c.fragmentMatches(oe, s) && oe.selectionSet.selections.forEach(w.add, w);
          }
      });
      var E = Mh(d), S = { result: E, missing: l }, P = o.canonizeResults ? this.canon.admit(S) : Tc(S);
      return P.result && this.knownResults.set(P.result, n), P;
    }, r.prototype.execSubSelectedArrayImpl = function(e) {
      var t = this, n = e.field, a = e.array, i = e.enclosingRef, o = e.context, u, c = new $n();
      function h(s, d) {
        var l;
        return s.missing && (u = c.merge(u, (l = {}, l[d] = s.missing, l))), s.result;
      }
      return n.selectionSet && (a = a.filter(o.store.canRead)), a = a.map(function(s, d) {
        return s === null ? null : yr(s) ? h(t.executeSubSelectedArray({
          field: n,
          array: s,
          enclosingRef: i,
          context: o
        }), d) : n.selectionSet ? h(t.executeSelectionSet({
          selectionSet: n.selectionSet,
          objectOrReference: s,
          enclosingRef: rr(s) ? s : i,
          context: o
        }), d) : (globalThis.__DEV__ !== !1 && d5(o.store, n, s), s);
      }), {
        result: o.canonizeResults ? this.canon.admit(a) : a,
        missing: u
      };
    }, r;
  }()
);
function l5(r) {
  try {
    JSON.stringify(r, function(e, t) {
      if (typeof t == "string")
        throw t;
      return t;
    });
  } catch (e) {
    return e;
  }
}
function d5(r, e, t) {
  if (!e.selectionSet) {
    var n = /* @__PURE__ */ new Set([t]);
    n.forEach(function(a) {
      vr(a) && (Ct(
        !rr(a),
        10,
        o5(r, a),
        e.name.value
      ), Object.values(a).forEach(n.add, n));
    });
  }
}
var Ch = new Uy(), mv = /* @__PURE__ */ new WeakMap();
function na(r) {
  var e = mv.get(r);
  return e || mv.set(r, e = {
    vars: /* @__PURE__ */ new Set(),
    dep: Yy()
  }), e;
}
function gv(r) {
  na(r).vars.forEach(function(e) {
    return e.forgetCache(r);
  });
}
function p5(r) {
  na(r).vars.forEach(function(e) {
    return e.attachCache(r);
  });
}
function v5(r) {
  var e = /* @__PURE__ */ new Set(), t = /* @__PURE__ */ new Set(), n = function(i) {
    if (arguments.length > 0) {
      if (r !== i) {
        r = i, e.forEach(function(c) {
          na(c).dep.dirty(n), y5(c);
        });
        var o = Array.from(t);
        t.clear(), o.forEach(function(c) {
          return c(r);
        });
      }
    } else {
      var u = Ch.getValue();
      u && (a(u), na(u).dep(n));
    }
    return r;
  };
  n.onNextChange = function(i) {
    return t.add(i), function() {
      t.delete(i);
    };
  };
  var a = n.attachCache = function(i) {
    return e.add(i), na(i).vars.add(n), n;
  };
  return n.forgetCache = function(i) {
    return e.delete(i);
  }, n;
}
function y5(r) {
  r.broadcastWatches && r.broadcastWatches();
}
var wv = /* @__PURE__ */ Object.create(null);
function Oh(r) {
  var e = JSON.stringify(r);
  return wv[e] || (wv[e] = /* @__PURE__ */ Object.create(null));
}
function _v(r) {
  var e = Oh(r);
  return e.keyFieldsFn || (e.keyFieldsFn = function(t, n) {
    var a = function(o, u) {
      return n.readField(u, o);
    }, i = n.keyObject = Bh(r, function(o) {
      var u = _i(
        n.storeObject,
        o,
        // Using context.readField to extract paths from context.storeObject
        // allows the extraction to see through Reference objects and respect
        // custom read functions.
        a
      );
      return u === void 0 && t !== n.storeObject && Ar.call(t, o[0]) && (u = _i(t, o, wb)), Ct(u !== void 0, 4, o.join("."), t), u;
    });
    return "".concat(n.typename, ":").concat(JSON.stringify(i));
  });
}
function xv(r) {
  var e = Oh(r);
  return e.keyArgsFn || (e.keyArgsFn = function(t, n) {
    var a = n.field, i = n.variables, o = n.fieldName, u = Bh(r, function(h) {
      var s = h[0], d = s.charAt(0);
      if (d === "@") {
        if (a && hn(a.directives)) {
          var l = s.slice(1), y = a.directives.find(function(S) {
            return S.name.value === l;
          }), m = y && Do(y, i);
          return m && _i(
            m,
            // If keyPath.length === 1, this code calls extractKeyPath with an
            // empty path, which works because it uses directiveArgs as the
            // extracted value.
            h.slice(1)
          );
        }
        return;
      }
      if (d === "$") {
        var w = s.slice(1);
        if (i && Ar.call(i, w)) {
          var E = h.slice(0);
          return E[0] = w, _i(i, E);
        }
        return;
      }
      if (t)
        return _i(t, h);
    }), c = JSON.stringify(u);
    return (t || c !== "{}") && (o += ":" + c), o;
  });
}
function Bh(r, e) {
  var t = new $n();
  return gb(r).reduce(function(n, a) {
    var i, o = e(a);
    if (o !== void 0) {
      for (var u = a.length - 1; u >= 0; --u)
        o = (i = {}, i[a[u]] = o, i);
      n = t.merge(n, o);
    }
    return n;
  }, /* @__PURE__ */ Object.create(null));
}
function gb(r) {
  var e = Oh(r);
  if (!e.paths) {
    var t = e.paths = [], n = [];
    r.forEach(function(a, i) {
      yr(a) ? (gb(a).forEach(function(o) {
        return t.push(n.concat(o));
      }), n.length = 0) : (n.push(a), yr(r[i + 1]) || (t.push(n.slice(0)), n.length = 0));
    });
  }
  return e.paths;
}
function wb(r, e) {
  return r[e];
}
function _i(r, e, t) {
  return t = t || wb, _b(e.reduce(function n(a, i) {
    return yr(a) ? a.map(function(o) {
      return n(o, i);
    }) : a && t(a, i);
  }, r));
}
function _b(r) {
  return vr(r) ? yr(r) ? r.map(_b) : Bh(Object.keys(r).sort(), function(e) {
    return _i(r, e);
  }) : r;
}
function Pc(r) {
  return r.args !== void 0 ? r.args : r.field ? Do(r.field, r.variables) : null;
}
var b5 = function() {
}, Sv = function(r, e) {
  return e.fieldName;
}, Ev = function(r, e, t) {
  var n = t.mergeObjects;
  return n(r, e);
}, Mv = function(r, e) {
  return e;
}, m5 = (
  /** @class */
  function() {
    function r(e) {
      this.config = e, this.typePolicies = /* @__PURE__ */ Object.create(null), this.toBeAdded = /* @__PURE__ */ Object.create(null), this.supertypeMap = /* @__PURE__ */ new Map(), this.fuzzySubtypes = /* @__PURE__ */ new Map(), this.rootIdsByTypename = /* @__PURE__ */ Object.create(null), this.rootTypenamesById = /* @__PURE__ */ Object.create(null), this.usingPossibleTypes = !1, this.config = _e({ dataIdFromObject: db }, e), this.cache = this.config.cache, this.setRootTypename("Query"), this.setRootTypename("Mutation"), this.setRootTypename("Subscription"), e.possibleTypes && this.addPossibleTypes(e.possibleTypes), e.typePolicies && this.addTypePolicies(e.typePolicies);
    }
    return r.prototype.identify = function(e, t) {
      var n, a = this, i = t && (t.typename || ((n = t.storeObject) === null || n === void 0 ? void 0 : n.__typename)) || e.__typename;
      if (i === this.rootTypenamesById.ROOT_QUERY)
        return ["ROOT_QUERY"];
      for (var o = t && t.storeObject || e, u = _e(_e({}, t), { typename: i, storeObject: o, readField: t && t.readField || function() {
        var l = Ph(arguments, o);
        return a.readField(l, {
          store: a.cache.data,
          variables: l.variables
        });
      } }), c, h = i && this.getTypePolicy(i), s = h && h.keyFn || this.config.dataIdFromObject; s; ) {
        var d = s(_e(_e({}, e), o), u);
        if (yr(d))
          s = _v(d);
        else {
          c = d;
          break;
        }
      }
      return c = c ? String(c) : void 0, u.keyObject ? [c, u.keyObject] : [c];
    }, r.prototype.addTypePolicies = function(e) {
      var t = this;
      Object.keys(e).forEach(function(n) {
        var a = e[n], i = a.queryType, o = a.mutationType, u = a.subscriptionType, c = qn(a, ["queryType", "mutationType", "subscriptionType"]);
        i && t.setRootTypename("Query", n), o && t.setRootTypename("Mutation", n), u && t.setRootTypename("Subscription", n), Ar.call(t.toBeAdded, n) ? t.toBeAdded[n].push(c) : t.toBeAdded[n] = [c];
      });
    }, r.prototype.updateTypePolicy = function(e, t) {
      var n = this, a = this.getTypePolicy(e), i = t.keyFields, o = t.fields;
      function u(c, h) {
        c.merge = typeof h == "function" ? h : h === !0 ? Ev : h === !1 ? Mv : c.merge;
      }
      u(a, t.merge), a.keyFn = // Pass false to disable normalization for this typename.
      i === !1 ? b5 : yr(i) ? _v(i) : typeof i == "function" ? i : a.keyFn, o && Object.keys(o).forEach(function(c) {
        var h = n.getFieldPolicy(e, c, !0), s = o[c];
        if (typeof s == "function")
          h.read = s;
        else {
          var d = s.keyArgs, l = s.read, y = s.merge;
          h.keyFn = // Pass false to disable argument-based differentiation of
          // field identities.
          d === !1 ? Sv : yr(d) ? xv(d) : typeof d == "function" ? d : h.keyFn, typeof l == "function" && (h.read = l), u(h, y);
        }
        h.read && h.merge && (h.keyFn = h.keyFn || Sv);
      });
    }, r.prototype.setRootTypename = function(e, t) {
      t === void 0 && (t = e);
      var n = "ROOT_" + e.toUpperCase(), a = this.rootTypenamesById[n];
      t !== a && (Ct(!a || a === e, 5, e), a && delete this.rootIdsByTypename[a], this.rootIdsByTypename[t] = n, this.rootTypenamesById[n] = t);
    }, r.prototype.addPossibleTypes = function(e) {
      var t = this;
      this.usingPossibleTypes = !0, Object.keys(e).forEach(function(n) {
        t.getSupertypeSet(n, !0), e[n].forEach(function(a) {
          t.getSupertypeSet(a, !0).add(n);
          var i = a.match(yb);
          (!i || i[0] !== a) && t.fuzzySubtypes.set(a, new RegExp(a));
        });
      });
    }, r.prototype.getTypePolicy = function(e) {
      var t = this;
      if (!Ar.call(this.typePolicies, e)) {
        var n = this.typePolicies[e] = /* @__PURE__ */ Object.create(null);
        n.fields = /* @__PURE__ */ Object.create(null);
        var a = this.supertypeMap.get(e);
        !a && this.fuzzySubtypes.size && (a = this.getSupertypeSet(e, !0), this.fuzzySubtypes.forEach(function(o, u) {
          if (o.test(e)) {
            var c = t.supertypeMap.get(u);
            c && c.forEach(function(h) {
              return a.add(h);
            });
          }
        })), a && a.size && a.forEach(function(o) {
          var u = t.getTypePolicy(o), c = u.fields, h = qn(u, ["fields"]);
          Object.assign(n, h), Object.assign(n.fields, c);
        });
      }
      var i = this.toBeAdded[e];
      return i && i.length && i.splice(0).forEach(function(o) {
        t.updateTypePolicy(e, o);
      }), this.typePolicies[e];
    }, r.prototype.getFieldPolicy = function(e, t, n) {
      if (e) {
        var a = this.getTypePolicy(e).fields;
        return a[t] || n && (a[t] = /* @__PURE__ */ Object.create(null));
      }
    }, r.prototype.getSupertypeSet = function(e, t) {
      var n = this.supertypeMap.get(e);
      return !n && t && this.supertypeMap.set(e, n = /* @__PURE__ */ new Set()), n;
    }, r.prototype.fragmentMatches = function(e, t, n, a) {
      var i = this;
      if (!e.typeCondition)
        return !0;
      if (!t)
        return !1;
      var o = e.typeCondition.name.value;
      if (t === o)
        return !0;
      if (this.usingPossibleTypes && this.supertypeMap.has(o))
        for (var u = this.getSupertypeSet(t, !0), c = [u], h = function(m) {
          var w = i.getSupertypeSet(m, !1);
          w && w.size && c.indexOf(w) < 0 && c.push(w);
        }, s = !!(n && this.fuzzySubtypes.size), d = !1, l = 0; l < c.length; ++l) {
          var y = c[l];
          if (y.has(o))
            return u.has(o) || (d && globalThis.__DEV__ !== !1 && Ct.warn(6, t, o), u.add(o)), !0;
          y.forEach(h), s && // Start checking fuzzy subtypes only after exhausting all
          // non-fuzzy subtypes (after the final iteration of the loop).
          l === c.length - 1 && // We could wait to compare fragment.selectionSet to result
          // after we verify the supertype, but this check is often less
          // expensive than that search, and we will have to do the
          // comparison anyway whenever we find a potential match.
          Bc(e.selectionSet, n, a) && (s = !1, d = !0, this.fuzzySubtypes.forEach(function(m, w) {
            var E = t.match(m);
            E && E[0] === t && h(w);
          }));
        }
      return !1;
    }, r.prototype.hasKeyArgs = function(e, t) {
      var n = this.getFieldPolicy(e, t, !1);
      return !!(n && n.keyFn);
    }, r.prototype.getStoreFieldName = function(e) {
      var t = e.typename, n = e.fieldName, a = this.getFieldPolicy(t, n, !1), i, o = a && a.keyFn;
      if (o && t)
        for (var u = {
          typename: t,
          fieldName: n,
          field: e.field || null,
          variables: e.variables
        }, c = Pc(e); o; ) {
          var h = o(c, u);
          if (yr(h))
            o = xv(h);
          else {
            i = h || n;
            break;
          }
        }
      return i === void 0 && (i = e.field ? N_(e.field, e.variables) : Ly(n, Pc(e))), i === !1 ? n : n === jn(i) ? i : n + ":" + i;
    }, r.prototype.readField = function(e, t) {
      var n = e.from;
      if (n) {
        var a = e.field || e.fieldName;
        if (a) {
          if (e.typename === void 0) {
            var i = t.store.getFieldValue(n, "__typename");
            i && (e.typename = i);
          }
          var o = this.getStoreFieldName(e), u = jn(o), c = t.store.getFieldValue(n, o), h = this.getFieldPolicy(e.typename, u, !1), s = h && h.read;
          if (s) {
            var d = Av(this, n, e, t, t.store.getStorage(rr(n) ? n.__ref : n, o));
            return Ch.withValue(this.cache, s, [
              c,
              d
            ]);
          }
          return c;
        }
      }
    }, r.prototype.getReadFunction = function(e, t) {
      var n = this.getFieldPolicy(e, t, !1);
      return n && n.read;
    }, r.prototype.getMergeFunction = function(e, t, n) {
      var a = this.getFieldPolicy(e, t, !1), i = a && a.merge;
      return !i && n && (a = this.getTypePolicy(n), i = a && a.merge), i;
    }, r.prototype.runMergeFunction = function(e, t, n, a, i) {
      var o = n.field, u = n.typename, c = n.merge;
      return c === Ev ? xb(a.store)(e, t) : c === Mv ? t : (a.overwrite && (e = void 0), c(e, t, Av(
        this,
        // Unlike options.readField for read functions, we do not fall
        // back to the current object if no foreignObjOrRef is provided,
        // because it's not clear what the current object should be for
        // merge functions: the (possibly undefined) existing object, or
        // the incoming object? If you think your merge function needs
        // to read sibling fields in order to produce a new value for
        // the current field, you might want to rethink your strategy,
        // because that's a recipe for making merge behavior sensitive
        // to the order in which fields are written into the cache.
        // However, readField(name, ref) is useful for merge functions
        // that need to deduplicate child objects and references.
        void 0,
        {
          typename: u,
          fieldName: o.name.value,
          field: o,
          variables: a.variables
        },
        a,
        i || /* @__PURE__ */ Object.create(null)
      )));
    }, r;
  }()
);
function Av(r, e, t, n, a) {
  var i = r.getStoreFieldName(t), o = jn(i), u = t.variables || n.variables, c = n.store, h = c.toReference, s = c.canRead;
  return {
    args: Pc(t),
    field: t.field || null,
    fieldName: o,
    storeFieldName: i,
    variables: u,
    isReference: rr,
    toReference: h,
    storage: a,
    cache: r.cache,
    canRead: s,
    readField: function() {
      return r.readField(Ph(arguments, e, u), n);
    },
    mergeObjects: xb(n.store)
  };
}
function Ph(r, e, t) {
  var n = r[0], a = r[1], i = r.length, o;
  return typeof n == "string" ? o = {
    fieldName: n,
    // Default to objectOrReference only when no second argument was
    // passed for the from parameter, not when undefined is explicitly
    // passed as the second argument.
    from: i > 1 ? a : e
  } : (o = _e({}, n), Ar.call(o, "from") || (o.from = e)), globalThis.__DEV__ !== !1 && o.from === void 0 && globalThis.__DEV__ !== !1 && Ct.warn(7, yy(Array.from(r))), o.variables === void 0 && (o.variables = t), o;
}
function xb(r) {
  return function(t, n) {
    if (yr(t) || yr(n))
      throw Nr(8);
    if (vr(t) && vr(n)) {
      var a = r.getFieldValue(t, "__typename"), i = r.getFieldValue(n, "__typename"), o = a && i && a !== i;
      if (o)
        return n;
      if (rr(t) && vi(n))
        return r.merge(t.__ref, n), t;
      if (vi(t) && rr(n))
        return r.merge(t, n.__ref), n;
      if (vi(t) && vi(n))
        return _e(_e({}, t), n);
    }
    return n;
  };
}
function Xu(r, e, t) {
  var n = "".concat(e).concat(t), a = r.flavors.get(n);
  return a || r.flavors.set(n, a = r.clientOnly === e && r.deferred === t ? r : _e(_e({}, r), { clientOnly: e, deferred: t })), a;
}
var g5 = (
  /** @class */
  function() {
    function r(e, t, n) {
      this.cache = e, this.reader = t, this.fragments = n;
    }
    return r.prototype.writeToStore = function(e, t) {
      var n = this, a = t.query, i = t.result, o = t.dataId, u = t.variables, c = t.overwrite, h = Sa(a), s = s5();
      u = _e(_e({}, wh(h)), u);
      var d = _e(_e({ store: e, written: /* @__PURE__ */ Object.create(null), merge: function(y, m) {
        return s.merge(y, m);
      }, variables: u, varString: Dn(u) }, bb(a, this.fragments)), { overwrite: !!c, incomingById: /* @__PURE__ */ new Map(), clientOnly: !1, deferred: !1, flavors: /* @__PURE__ */ new Map() }), l = this.processSelectionSet({
        result: i || /* @__PURE__ */ Object.create(null),
        dataId: o,
        selectionSet: h.selectionSet,
        mergeTree: { map: /* @__PURE__ */ new Map() },
        context: d
      });
      if (!rr(l))
        throw Nr(11, i);
      return d.incomingById.forEach(function(y, m) {
        var w = y.storeObject, E = y.mergeTree, S = y.fieldNodeSet, P = gi(m);
        if (E && E.map.size) {
          var L = n.applyMerges(E, P, w, d);
          if (rr(L))
            return;
          w = L;
        }
        if (globalThis.__DEV__ !== !1 && !d.overwrite) {
          var U = /* @__PURE__ */ Object.create(null);
          S.forEach(function(re) {
            re.selectionSet && (U[re.name.value] = !0);
          });
          var z = function(re) {
            return U[jn(re)] === !0;
          }, K = function(re) {
            var oe = E && E.map.get(re);
            return !!(oe && oe.info && oe.info.merge);
          };
          Object.keys(w).forEach(function(re) {
            z(re) && !K(re) && w5(P, w, re, d.store);
          });
        }
        e.merge(m, w);
      }), e.retain(l.__ref), l;
    }, r.prototype.processSelectionSet = function(e) {
      var t = this, n = e.dataId, a = e.result, i = e.selectionSet, o = e.context, u = e.mergeTree, c = this.cache.policies, h = /* @__PURE__ */ Object.create(null), s = n && c.rootTypenamesById[n] || xc(a, i, o.fragmentMap) || n && o.store.get(n, "__typename");
      typeof s == "string" && (h.__typename = s);
      var d = function() {
        var L = Ph(arguments, h, o.variables);
        if (rr(L.from)) {
          var U = o.incomingById.get(L.from.__ref);
          if (U) {
            var z = c.readField(_e(_e({}, L), { from: U.storeObject }), o);
            if (z !== void 0)
              return z;
          }
        }
        return c.readField(L, o);
      }, l = /* @__PURE__ */ new Set();
      this.flattenFields(
        i,
        a,
        // This WriteContext will be the default context value for fields returned
        // by the flattenFields method, but some fields may be assigned a modified
        // context, depending on the presence of @client and other directives.
        o,
        s
      ).forEach(function(L, U) {
        var z, K = Ln(U), re = a[K];
        if (l.add(U), re !== void 0) {
          var oe = c.getStoreFieldName({
            typename: s,
            fieldName: U.name.value,
            field: U,
            variables: L.variables
          }), se = Tv(u, oe), ve = t.processFieldValue(
            re,
            U,
            // Reset context.clientOnly and context.deferred to their default
            // values before processing nested selection sets.
            U.selectionSet ? Xu(L, !1, !1) : L,
            se
          ), Q = void 0;
          U.selectionSet && (rr(ve) || vi(ve)) && (Q = d("__typename", ve));
          var A = c.getMergeFunction(s, U.name.value, Q);
          A ? se.info = {
            // TODO Check compatibility against any existing childTree.field?
            field: U,
            typename: s,
            merge: A
          } : kv(u, oe), h = L.merge(h, (z = {}, z[oe] = ve, z));
        } else
          globalThis.__DEV__ !== !1 && !L.clientOnly && !L.deferred && !Eh.added(U) && // If the field has a read function, it may be a synthetic field or
          // provide a default value, so its absence from the written data should
          // not be cause for alarm.
          !c.getReadFunction(s, U.name.value) && globalThis.__DEV__ !== !1 && Ct.error(12, Ln(U), a);
      });
      try {
        var y = c.identify(a, {
          typename: s,
          selectionSet: i,
          fragmentMap: o.fragmentMap,
          storeObject: h,
          readField: d
        }), m = y[0], w = y[1];
        n = n || m, w && (h = o.merge(h, w));
      } catch (L) {
        if (!n)
          throw L;
      }
      if (typeof n == "string") {
        var E = gi(n), S = o.written[n] || (o.written[n] = []);
        if (S.indexOf(i) >= 0 || (S.push(i), this.reader && this.reader.isFresh(a, E, i, o)))
          return E;
        var P = o.incomingById.get(n);
        return P ? (P.storeObject = o.merge(P.storeObject, h), P.mergeTree = Dc(P.mergeTree, u), l.forEach(function(L) {
          return P.fieldNodeSet.add(L);
        })) : o.incomingById.set(n, {
          storeObject: h,
          // Save a reference to mergeTree only if it is not empty, because
          // empty MergeTrees may be recycled by maybeRecycleChildMergeTree and
          // reused for entirely different parts of the result tree.
          mergeTree: wo(u) ? void 0 : u,
          fieldNodeSet: l
        }), E;
      }
      return h;
    }, r.prototype.processFieldValue = function(e, t, n, a) {
      var i = this;
      return !t.selectionSet || e === null ? globalThis.__DEV__ !== !1 ? ab(e) : e : yr(e) ? e.map(function(o, u) {
        var c = i.processFieldValue(o, t, n, Tv(a, u));
        return kv(a, u), c;
      }) : this.processSelectionSet({
        result: e,
        selectionSet: t.selectionSet,
        context: n,
        mergeTree: a
      });
    }, r.prototype.flattenFields = function(e, t, n, a) {
      a === void 0 && (a = xc(t, e, n.fragmentMap));
      var i = /* @__PURE__ */ new Map(), o = this.cache.policies, u = new Bi(!1);
      return function c(h, s) {
        var d = u.lookup(
          h,
          // Because we take inheritedClientOnly and inheritedDeferred into
          // consideration here (in addition to selectionSet), it's possible for
          // the same selection set to be flattened more than once, if it appears
          // in the query with different @client and/or @directive configurations.
          s.clientOnly,
          s.deferred
        );
        d.visited || (d.visited = !0, h.selections.forEach(function(l) {
          if (_a(l, n.variables)) {
            var y = s.clientOnly, m = s.deferred;
            if (
              // Since the presence of @client or @defer on this field can only
              // cause clientOnly or deferred to become true, we can skip the
              // forEach loop if both clientOnly and deferred are already true.
              !(y && m) && hn(l.directives) && l.directives.forEach(function(S) {
                var P = S.name.value;
                if (P === "client" && (y = !0), P === "defer") {
                  var L = Do(S, n.variables);
                  (!L || L.if !== !1) && (m = !0);
                }
              }), Fn(l)
            ) {
              var w = i.get(l);
              w && (y = y && w.clientOnly, m = m && w.deferred), i.set(l, Xu(n, y, m));
            } else {
              var E = Po(l, n.lookupFragment);
              if (!E && l.kind === yt.FRAGMENT_SPREAD)
                throw Nr(13, l.name.value);
              E && o.fragmentMatches(E, a, t, n.variables) && c(E.selectionSet, Xu(n, y, m));
            }
          }
        }));
      }(e, n), i;
    }, r.prototype.applyMerges = function(e, t, n, a, i) {
      var o, u = this;
      if (e.map.size && !rr(n)) {
        var c = (
          // Items in the same position in different arrays are not
          // necessarily related to each other, so when incoming is an array
          // we process its elements as if there was no existing data.
          !yr(n) && // Likewise, existing must be either a Reference or a StoreObject
          // in order for its fields to be safe to merge with the fields of
          // the incoming object.
          (rr(t) || vi(t)) ? t : void 0
        ), h = n;
        c && !i && (i = [rr(c) ? c.__ref : c]);
        var s, d = function(l, y) {
          return yr(l) ? typeof y == "number" ? l[y] : void 0 : a.store.getFieldValue(l, String(y));
        };
        e.map.forEach(function(l, y) {
          var m = d(c, y), w = d(h, y);
          if (w !== void 0) {
            i && i.push(y);
            var E = u.applyMerges(l, m, w, a, i);
            E !== w && (s = s || /* @__PURE__ */ new Map(), s.set(y, E)), i && Ct(i.pop() === y);
          }
        }), s && (n = yr(h) ? h.slice(0) : _e({}, h), s.forEach(function(l, y) {
          n[y] = l;
        }));
      }
      return e.info ? this.cache.policies.runMergeFunction(t, n, e.info, a, i && (o = a.store).getStorage.apply(o, i)) : n;
    }, r;
  }()
), Sb = [];
function Tv(r, e) {
  var t = r.map;
  return t.has(e) || t.set(e, Sb.pop() || { map: /* @__PURE__ */ new Map() }), t.get(e);
}
function Dc(r, e) {
  if (r === e || !e || wo(e))
    return r;
  if (!r || wo(r))
    return e;
  var t = r.info && e.info ? _e(_e({}, r.info), e.info) : r.info || e.info, n = r.map.size && e.map.size, a = n ? /* @__PURE__ */ new Map() : r.map.size ? r.map : e.map, i = { info: t, map: a };
  if (n) {
    var o = new Set(e.map.keys());
    r.map.forEach(function(u, c) {
      i.map.set(c, Dc(u, e.map.get(c))), o.delete(c);
    }), o.forEach(function(u) {
      i.map.set(u, Dc(e.map.get(u), r.map.get(u)));
    });
  }
  return i;
}
function wo(r) {
  return !r || !(r.info || r.map.size);
}
function kv(r, e) {
  var t = r.map, n = t.get(e);
  n && wo(n) && (Sb.push(n), t.delete(e));
}
var Iv = /* @__PURE__ */ new Set();
function w5(r, e, t, n) {
  var a = function(d) {
    var l = n.getFieldValue(d, t);
    return typeof l == "object" && l;
  }, i = a(r);
  if (i) {
    var o = a(e);
    if (o && !rr(i) && !ur(i, o) && !Object.keys(i).every(function(d) {
      return n.getFieldValue(o, d) !== void 0;
    })) {
      var u = n.getFieldValue(r, "__typename") || n.getFieldValue(e, "__typename"), c = jn(t), h = "".concat(u, ".").concat(c);
      if (!Iv.has(h)) {
        Iv.add(h);
        var s = [];
        !yr(i) && !yr(o) && [i, o].forEach(function(d) {
          var l = n.getFieldValue(d, "__typename");
          typeof l == "string" && !s.includes(l) && s.push(l);
        }), globalThis.__DEV__ !== !1 && Ct.warn(14, c, u, s.length ? "either ensure all objects of type " + s.join(" and ") + " have an ID or a custom merge function, or " : "", h, i, o);
      }
    }
  }
}
var Eb = (
  /** @class */
  function(r) {
    tn(e, r);
    function e(t) {
      t === void 0 && (t = {});
      var n = r.call(this) || this;
      return n.watches = /* @__PURE__ */ new Set(), n.addTypenameTransform = new Xy(Eh), n.assumeImmutableResults = !0, n.makeVar = v5, n.txCount = 0, n.config = a5(t), n.addTypename = !!n.config.addTypename, n.policies = new m5({
        cache: n,
        dataIdFromObject: n.config.dataIdFromObject,
        possibleTypes: n.config.possibleTypes,
        typePolicies: n.config.typePolicies
      }), n.init(), n;
    }
    return e.prototype.init = function() {
      var t = this.data = new la.Root({
        policies: this.policies,
        resultCaching: this.config.resultCaching
      });
      this.optimisticData = t.stump, this.resetResultCache();
    }, e.prototype.resetResultCache = function(t) {
      var n = this, a = this.storeReader, i = this.config.fragments;
      this.storeWriter = new g5(this, this.storeReader = new h5({
        cache: this,
        addTypename: this.addTypename,
        resultCacheMaxSize: this.config.resultCacheMaxSize,
        canonizeResults: vb(this.config),
        canon: t ? void 0 : a && a.canon,
        fragments: i
      }), i), this.maybeBroadcastWatch = ha(function(o, u) {
        return n.broadcastWatch(o, u);
      }, {
        max: this.config.resultCacheMaxSize || _n["inMemoryCache.maybeBroadcastWatch"] || 5e3,
        makeCacheKey: function(o) {
          var u = o.optimistic ? n.optimisticData : n.data;
          if (ra(u)) {
            var c = o.optimistic, h = o.id, s = o.variables;
            return u.makeCacheKey(
              o.query,
              // Different watches can have the same query, optimistic
              // status, rootId, and variables, but if their callbacks are
              // different, the (identical) result needs to be delivered to
              // each distinct callback. The easiest way to achieve that
              // separation is to include c.callback in the cache key for
              // maybeBroadcastWatch calls. See issue #5733.
              o.callback,
              Dn({ optimistic: c, id: h, variables: s })
            );
          }
        }
      }), (/* @__PURE__ */ new Set([this.data.group, this.optimisticData.group])).forEach(function(o) {
        return o.resetCaching();
      });
    }, e.prototype.restore = function(t) {
      return this.init(), t && this.data.replace(t), this;
    }, e.prototype.extract = function(t) {
      return t === void 0 && (t = !1), (t ? this.optimisticData : this.data).extract();
    }, e.prototype.read = function(t) {
      var n = t.returnPartialData, a = n === void 0 ? !1 : n;
      try {
        return this.storeReader.diffQueryAgainstStore(_e(_e({}, t), { store: t.optimistic ? this.optimisticData : this.data, config: this.config, returnPartialData: a })).result || null;
      } catch (i) {
        if (i instanceof lb)
          return null;
        throw i;
      }
    }, e.prototype.write = function(t) {
      try {
        return ++this.txCount, this.storeWriter.writeToStore(this.data, t);
      } finally {
        !--this.txCount && t.broadcast !== !1 && this.broadcastWatches();
      }
    }, e.prototype.modify = function(t) {
      if (Ar.call(t, "id") && !t.id)
        return !1;
      var n = t.optimistic ? this.optimisticData : this.data;
      try {
        return ++this.txCount, n.modify(t.id || "ROOT_QUERY", t.fields);
      } finally {
        !--this.txCount && t.broadcast !== !1 && this.broadcastWatches();
      }
    }, e.prototype.diff = function(t) {
      return this.storeReader.diffQueryAgainstStore(_e(_e({}, t), { store: t.optimistic ? this.optimisticData : this.data, rootId: t.id || "ROOT_QUERY", config: this.config }));
    }, e.prototype.watch = function(t) {
      var n = this;
      return this.watches.size || p5(this), this.watches.add(t), t.immediate && this.maybeBroadcastWatch(t), function() {
        n.watches.delete(t) && !n.watches.size && gv(n), n.maybeBroadcastWatch.forget(t);
      };
    }, e.prototype.gc = function(t) {
      var n;
      Dn.reset(), Fo.reset(), this.addTypenameTransform.resetCache(), (n = this.config.fragments) === null || n === void 0 || n.resetCaches();
      var a = this.optimisticData.gc();
      return t && !this.txCount && (t.resetResultCache ? this.resetResultCache(t.resetResultIdentities) : t.resetResultIdentities && this.storeReader.resetCanon()), a;
    }, e.prototype.retain = function(t, n) {
      return (n ? this.optimisticData : this.data).retain(t);
    }, e.prototype.release = function(t, n) {
      return (n ? this.optimisticData : this.data).release(t);
    }, e.prototype.identify = function(t) {
      if (rr(t))
        return t.__ref;
      try {
        return this.policies.identify(t)[0];
      } catch (n) {
        globalThis.__DEV__ !== !1 && Ct.warn(n);
      }
    }, e.prototype.evict = function(t) {
      if (!t.id) {
        if (Ar.call(t, "id"))
          return !1;
        t = _e(_e({}, t), { id: "ROOT_QUERY" });
      }
      try {
        return ++this.txCount, this.optimisticData.evict(t, this.data);
      } finally {
        !--this.txCount && t.broadcast !== !1 && this.broadcastWatches();
      }
    }, e.prototype.reset = function(t) {
      var n = this;
      return this.init(), Dn.reset(), t && t.discardWatches ? (this.watches.forEach(function(a) {
        return n.maybeBroadcastWatch.forget(a);
      }), this.watches.clear(), gv(this)) : this.broadcastWatches(), Promise.resolve();
    }, e.prototype.removeOptimistic = function(t) {
      var n = this.optimisticData.removeLayer(t);
      n !== this.optimisticData && (this.optimisticData = n, this.broadcastWatches());
    }, e.prototype.batch = function(t) {
      var n = this, a = t.update, i = t.optimistic, o = i === void 0 ? !0 : i, u = t.removeOptimistic, c = t.onWatchUpdated, h, s = function(l) {
        var y = n, m = y.data, w = y.optimisticData;
        ++n.txCount, l && (n.data = n.optimisticData = l);
        try {
          return h = a(n);
        } finally {
          --n.txCount, n.data = m, n.optimisticData = w;
        }
      }, d = /* @__PURE__ */ new Set();
      return c && !this.txCount && this.broadcastWatches(_e(_e({}, t), { onWatchUpdated: function(l) {
        return d.add(l), !1;
      } })), typeof o == "string" ? this.optimisticData = this.optimisticData.addLayer(o, s) : o === !1 ? s(this.data) : s(), typeof u == "string" && (this.optimisticData = this.optimisticData.removeLayer(u)), c && d.size ? (this.broadcastWatches(_e(_e({}, t), { onWatchUpdated: function(l, y) {
        var m = c.call(this, l, y);
        return m !== !1 && d.delete(l), m;
      } })), d.size && d.forEach(function(l) {
        return n.maybeBroadcastWatch.dirty(l);
      })) : this.broadcastWatches(t), h;
    }, e.prototype.performTransaction = function(t, n) {
      return this.batch({
        update: t,
        optimistic: n || n !== null
      });
    }, e.prototype.transformDocument = function(t) {
      return this.addTypenameToDocument(this.addFragmentsToDocument(t));
    }, e.prototype.broadcastWatches = function(t) {
      var n = this;
      this.txCount || this.watches.forEach(function(a) {
        return n.maybeBroadcastWatch(a, t);
      });
    }, e.prototype.addFragmentsToDocument = function(t) {
      var n = this.config.fragments;
      return n ? n.transform(t) : t;
    }, e.prototype.addTypenameToDocument = function(t) {
      return this.addTypename ? this.addTypenameTransform.transformDocument(t) : t;
    }, e.prototype.broadcastWatch = function(t, n) {
      var a = t.lastDiff, i = this.diff(t);
      n && (t.optimistic && typeof n.optimistic == "string" && (i.fromOptimisticTransaction = !0), n.onWatchUpdated && n.onWatchUpdated.call(this, t, i, a) === !1) || (!a || !ur(a.result, i.result)) && t.callback(t.lastDiff = i, a);
    }, e;
  }(hb)
);
globalThis.__DEV__ !== !1 && (Eb.prototype.getMemoryInternals = m_);
var ir;
(function(r) {
  r[r.loading = 1] = "loading", r[r.setVariables = 2] = "setVariables", r[r.fetchMore = 3] = "fetchMore", r[r.refetch = 4] = "refetch", r[r.poll = 6] = "poll", r[r.ready = 7] = "ready", r[r.error = 8] = "error";
})(ir || (ir = {}));
function da(r) {
  return r ? r < 7 : !1;
}
function _5(r, e, t, n) {
  var a = e.data, i = qn(e, ["data"]), o = t.data, u = qn(t, ["data"]);
  return ur(i, u) && fo(Ea(r).selectionSet, a, o, {
    fragmentMap: Bo(No(r)),
    variables: n
  });
}
function fo(r, e, t, n) {
  if (e === t)
    return !0;
  var a = /* @__PURE__ */ new Set();
  return r.selections.every(function(i) {
    if (a.has(i) || (a.add(i), !_a(i, n.variables)) || Rv(i))
      return !0;
    if (Fn(i)) {
      var o = Ln(i), u = e && e[o], c = t && t[o], h = i.selectionSet;
      if (!h)
        return ur(u, c);
      var s = Array.isArray(u), d = Array.isArray(c);
      if (s !== d)
        return !1;
      if (s && d) {
        var l = u.length;
        if (c.length !== l)
          return !1;
        for (var y = 0; y < l; ++y)
          if (!fo(h, u[y], c[y], n))
            return !1;
        return !0;
      }
      return fo(h, u, c, n);
    } else {
      var m = Po(i, n.fragmentMap);
      if (m)
        return Rv(m) ? !0 : fo(
          m.selectionSet,
          // Notice that we reuse the same aResult and bResult values here,
          // since the fragment ...spread does not specify a field name, but
          // consists of multiple fields (within the fragment's selection set)
          // that should be applied to the current result value(s).
          e,
          t,
          n
        );
    }
  });
}
function Rv(r) {
  return !!r.directives && r.directives.some(x5);
}
function x5(r) {
  return r.name.value === "nonreactive";
}
var Cv = Object.assign, S5 = Object.hasOwnProperty, Nc = (
  /** @class */
  function(r) {
    tn(e, r);
    function e(t) {
      var n = t.queryManager, a = t.queryInfo, i = t.options, o = r.call(this, function(E) {
        try {
          var S = E._subscription._observer;
          S && !S.error && (S.error = E5);
        } catch (U) {
        }
        var P = !o.observers.size;
        o.observers.add(E);
        var L = o.last;
        return L && L.error ? E.error && E.error(L.error) : L && L.result && E.next && E.next(L.result), P && o.reobserve().catch(function() {
        }), function() {
          o.observers.delete(E) && !o.observers.size && o.tearDownQuery();
        };
      }) || this;
      o.observers = /* @__PURE__ */ new Set(), o.subscriptions = /* @__PURE__ */ new Set(), o.queryInfo = a, o.queryManager = n, o.waitForOwnResult = Zu(i.fetchPolicy), o.isTornDown = !1;
      var u = n.defaultOptions.watchQuery, c = u === void 0 ? {} : u, h = c.fetchPolicy, s = h === void 0 ? "cache-first" : h, d = i.fetchPolicy, l = d === void 0 ? s : d, y = i.initialFetchPolicy, m = y === void 0 ? l === "standby" ? s : l : y;
      o.options = _e(_e({}, i), {
        // Remember the initial options.fetchPolicy so we can revert back to this
        // policy when variables change. This information can also be specified
        // (or overridden) by providing options.initialFetchPolicy explicitly.
        initialFetchPolicy: m,
        // This ensures this.options.fetchPolicy always has a string value, in
        // case options.fetchPolicy was not provided.
        fetchPolicy: l
      }), o.queryId = a.queryId || n.generateQueryId();
      var w = Sa(o.query);
      return o.queryName = w && w.name && w.name.value, o;
    }
    return Object.defineProperty(e.prototype, "query", {
      // The `query` computed property will always reflect the document transformed
      // by the last run query. `this.options.query` will always reflect the raw
      // untransformed query to ensure document transforms with runtime conditionals
      // are run on the original document.
      get: function() {
        return this.lastQuery || this.options.query;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "variables", {
      // Computed shorthand for this.options.variables, preserved for
      // backwards compatibility.
      /**
       * An object containing the variables that were provided for the query.
       */
      get: function() {
        return this.options.variables;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.result = function() {
      var t = this;
      return new Promise(function(n, a) {
        var i = {
          next: function(u) {
            n(u), t.observers.delete(i), t.observers.size || t.queryManager.removeQuery(t.queryId), setTimeout(function() {
              o.unsubscribe();
            }, 0);
          },
          error: a
        }, o = t.subscribe(i);
      });
    }, e.prototype.resetDiff = function() {
      this.queryInfo.resetDiff();
    }, e.prototype.getCurrentResult = function(t) {
      t === void 0 && (t = !0);
      var n = this.getLastResult(!0), a = this.queryInfo.networkStatus || n && n.networkStatus || ir.ready, i = _e(_e({}, n), { loading: da(a), networkStatus: a }), o = this.options.fetchPolicy, u = o === void 0 ? "cache-first" : o;
      if (
        // These fetch policies should never deliver data from the cache, unless
        // redelivering a previously delivered result.
        !(Zu(u) || // If this.options.query has @client(always: true) fields, we cannot
        // trust diff.result, since it was read from the cache without running
        // local resolvers (and it's too late to run resolvers now, since we must
        // return a result synchronously).
        this.queryManager.getDocumentInfo(this.query).hasForcedResolvers)
      )
        if (this.waitForOwnResult)
          this.queryInfo.updateWatch();
        else {
          var c = this.queryInfo.getDiff();
          (c.complete || this.options.returnPartialData) && (i.data = c.result), ur(i.data, {}) && (i.data = void 0), c.complete ? (delete i.partial, c.complete && i.networkStatus === ir.loading && (u === "cache-first" || u === "cache-only") && (i.networkStatus = ir.ready, i.loading = !1)) : i.partial = !0, globalThis.__DEV__ !== !1 && !c.complete && !this.options.partialRefetch && !i.loading && !i.data && !i.error && Ab(c.missing);
        }
      return t && this.updateLastResult(i), i;
    }, e.prototype.isDifferentFromLastResult = function(t, n) {
      if (!this.last)
        return !0;
      var a = this.queryManager.getDocumentInfo(this.query).hasNonreactiveDirective ? !_5(this.query, this.last.result, t, this.variables) : !ur(this.last.result, t);
      return a || n && !ur(this.last.variables, n);
    }, e.prototype.getLast = function(t, n) {
      var a = this.last;
      if (a && a[t] && (!n || ur(a.variables, this.variables)))
        return a[t];
    }, e.prototype.getLastResult = function(t) {
      return this.getLast("result", t);
    }, e.prototype.getLastError = function(t) {
      return this.getLast("error", t);
    }, e.prototype.resetLastResults = function() {
      delete this.last, this.isTornDown = !1;
    }, e.prototype.resetQueryStoreErrors = function() {
      this.queryManager.resetErrors(this.queryId);
    }, e.prototype.refetch = function(t) {
      var n, a = {
        // Always disable polling for refetches.
        pollInterval: 0
      }, i = this.options.fetchPolicy;
      if (i === "cache-and-network" ? a.fetchPolicy = i : i === "no-cache" ? a.fetchPolicy = "no-cache" : a.fetchPolicy = "network-only", globalThis.__DEV__ !== !1 && t && S5.call(t, "variables")) {
        var o = Fy(this.query), u = o.variableDefinitions;
        (!u || !u.some(function(c) {
          return c.variable.name.value === "variables";
        })) && globalThis.__DEV__ !== !1 && Ct.warn(
          20,
          t,
          ((n = o.name) === null || n === void 0 ? void 0 : n.value) || o
        );
      }
      return t && !ur(this.options.variables, t) && (a.variables = this.options.variables = _e(_e({}, this.options.variables), t)), this.queryInfo.resetLastWrite(), this.reobserve(a, ir.refetch);
    }, e.prototype.fetchMore = function(t) {
      var n = this, a = _e(_e({}, t.query ? t : _e(_e(_e(_e({}, this.options), { query: this.options.query }), t), { variables: _e(_e({}, this.options.variables), t.variables) })), {
        // The fetchMore request goes immediately to the network and does
        // not automatically write its result to the cache (hence no-cache
        // instead of network-only), because we allow the caller of
        // fetchMore to provide an updateQuery callback that determines how
        // the data gets written to the cache.
        fetchPolicy: "no-cache"
      });
      a.query = this.transformDocument(a.query);
      var i = this.queryManager.generateQueryId();
      this.lastQuery = t.query ? this.transformDocument(this.options.query) : a.query;
      var o = this.queryInfo, u = o.networkStatus;
      o.networkStatus = ir.fetchMore, a.notifyOnNetworkStatusChange && this.observe();
      var c = /* @__PURE__ */ new Set();
      return this.queryManager.fetchQuery(i, a, ir.fetchMore).then(function(h) {
        return n.queryManager.removeQuery(i), o.networkStatus === ir.fetchMore && (o.networkStatus = u), n.queryManager.cache.batch({
          update: function(s) {
            var d = t.updateQuery;
            d ? s.updateQuery({
              query: n.query,
              variables: n.variables,
              returnPartialData: !0,
              optimistic: !1
            }, function(l) {
              return d(l, {
                fetchMoreResult: h.data,
                variables: a.variables
              });
            }) : s.writeQuery({
              query: a.query,
              variables: a.variables,
              data: h.data
            });
          },
          onWatchUpdated: function(s) {
            c.add(s.query);
          }
        }), h;
      }).finally(function() {
        c.has(n.query) || Mb(n);
      });
    }, e.prototype.subscribeToMore = function(t) {
      var n = this, a = this.queryManager.startGraphQLSubscription({
        query: t.document,
        variables: t.variables,
        context: t.context
      }).subscribe({
        next: function(i) {
          var o = t.updateQuery;
          o && n.updateQuery(function(u, c) {
            var h = c.variables;
            return o(u, {
              subscriptionData: i,
              variables: h
            });
          });
        },
        error: function(i) {
          if (t.onError) {
            t.onError(i);
            return;
          }
          globalThis.__DEV__ !== !1 && Ct.error(21, i);
        }
      });
      return this.subscriptions.add(a), function() {
        n.subscriptions.delete(a) && a.unsubscribe();
      };
    }, e.prototype.setOptions = function(t) {
      return this.reobserve(t);
    }, e.prototype.silentSetOptions = function(t) {
      var n = Ai(this.options, t || {});
      Cv(this.options, n);
    }, e.prototype.setVariables = function(t) {
      return ur(this.variables, t) ? this.observers.size ? this.result() : Promise.resolve() : (this.options.variables = t, this.observers.size ? this.reobserve({
        // Reset options.fetchPolicy to its original value.
        fetchPolicy: this.options.initialFetchPolicy,
        variables: t
      }, ir.setVariables) : Promise.resolve());
    }, e.prototype.updateQuery = function(t) {
      var n = this.queryManager, a = n.cache.diff({
        query: this.options.query,
        variables: this.variables,
        returnPartialData: !0,
        optimistic: !1
      }).result, i = t(a, {
        variables: this.variables
      });
      i && (n.cache.writeQuery({
        query: this.options.query,
        data: i,
        variables: this.variables
      }), n.broadcastQueries());
    }, e.prototype.startPolling = function(t) {
      this.options.pollInterval = t, this.updatePolling();
    }, e.prototype.stopPolling = function() {
      this.options.pollInterval = 0, this.updatePolling();
    }, e.prototype.applyNextFetchPolicy = function(t, n) {
      if (n.nextFetchPolicy) {
        var a = n.fetchPolicy, i = a === void 0 ? "cache-first" : a, o = n.initialFetchPolicy, u = o === void 0 ? i : o;
        i === "standby" || (typeof n.nextFetchPolicy == "function" ? n.fetchPolicy = n.nextFetchPolicy(i, {
          reason: t,
          options: n,
          observable: this,
          initialFetchPolicy: u
        }) : t === "variables-changed" ? n.fetchPolicy = u : n.fetchPolicy = n.nextFetchPolicy);
      }
      return n.fetchPolicy;
    }, e.prototype.fetch = function(t, n, a) {
      return this.queryManager.setObservableQuery(this), this.queryManager.fetchConcastWithInfo(this.queryId, t, n, a);
    }, e.prototype.updatePolling = function() {
      var t = this;
      if (!this.queryManager.ssrMode) {
        var n = this, a = n.pollingInfo, i = n.options.pollInterval;
        if (!i) {
          a && (clearTimeout(a.timeout), delete this.pollingInfo);
          return;
        }
        if (!(a && a.interval === i)) {
          Ct(i, 22);
          var o = a || (this.pollingInfo = {});
          o.interval = i;
          var u = function() {
            var h, s;
            t.pollingInfo && (!da(t.queryInfo.networkStatus) && !(!((s = (h = t.options).skipPollAttempt) === null || s === void 0) && s.call(h)) ? t.reobserve({
              // Most fetchPolicy options don't make sense to use in a polling context, as
              // users wouldn't want to be polling the cache directly. However, network-only and
              // no-cache are both useful for when the user wants to control whether or not the
              // polled results are written to the cache.
              fetchPolicy: t.options.initialFetchPolicy === "no-cache" ? "no-cache" : "network-only"
            }, ir.poll).then(c, c) : c());
          }, c = function() {
            var h = t.pollingInfo;
            h && (clearTimeout(h.timeout), h.timeout = setTimeout(u, h.interval));
          };
          c();
        }
      }
    }, e.prototype.updateLastResult = function(t, n) {
      n === void 0 && (n = this.variables);
      var a = this.getLastError();
      return a && this.last && !ur(n, this.last.variables) && (a = void 0), this.last = _e({ result: this.queryManager.assumeImmutableResults ? t : ab(t), variables: n }, a ? { error: a } : null);
    }, e.prototype.reobserveAsConcast = function(t, n) {
      var a = this;
      this.isTornDown = !1;
      var i = (
        // Refetching uses a disposable Concast to allow refetches using different
        // options/variables, without permanently altering the options of the
        // original ObservableQuery.
        n === ir.refetch || // The fetchMore method does not actually call the reobserve method, but,
        // if it did, it would definitely use a disposable Concast.
        n === ir.fetchMore || // Polling uses a disposable Concast so the polling options (which force
        // fetchPolicy to be "network-only" or "no-cache") won't override the original options.
        n === ir.poll
      ), o = this.options.variables, u = this.options.fetchPolicy, c = Ai(this.options, t || {}), h = i ? (
        // Disposable Concast fetches receive a shallow copy of this.options
        // (merged with newOptions), leaving this.options unmodified.
        c
      ) : Cv(this.options, c), s = this.transformDocument(h.query);
      this.lastQuery = s, i || (this.updatePolling(), t && t.variables && !ur(t.variables, o) && // Don't mess with the fetchPolicy if it's currently "standby".
      h.fetchPolicy !== "standby" && // If we're changing the fetchPolicy anyway, don't try to change it here
      // using applyNextFetchPolicy. The explicit options.fetchPolicy wins.
      h.fetchPolicy === u && (this.applyNextFetchPolicy("variables-changed", h), n === void 0 && (n = ir.setVariables))), this.waitForOwnResult && (this.waitForOwnResult = Zu(h.fetchPolicy));
      var d = function() {
        a.concast === m && (a.waitForOwnResult = !1);
      }, l = h.variables && _e({}, h.variables), y = this.fetch(h, n, s), m = y.concast, w = y.fromLink, E = {
        next: function(S) {
          ur(a.variables, l) && (d(), a.reportResult(S, l));
        },
        error: function(S) {
          ur(a.variables, l) && (d(), a.reportError(S, l));
        }
      };
      return !i && (w || !this.concast) && (this.concast && this.observer && this.concast.removeObserver(this.observer), this.concast = m, this.observer = E), m.addObserver(E), m;
    }, e.prototype.reobserve = function(t, n) {
      return this.reobserveAsConcast(t, n).promise;
    }, e.prototype.resubscribeAfterError = function() {
      for (var t = [], n = 0; n < arguments.length; n++)
        t[n] = arguments[n];
      var a = this.last;
      this.resetLastResults();
      var i = this.subscribe.apply(this, t);
      return this.last = a, i;
    }, e.prototype.observe = function() {
      this.reportResult(
        // Passing false is important so that this.getCurrentResult doesn't
        // save the fetchMore result as this.lastResult, causing it to be
        // ignored due to the this.isDifferentFromLastResult check in
        // this.reportResult.
        this.getCurrentResult(!1),
        this.variables
      );
    }, e.prototype.reportResult = function(t, n) {
      var a = this.getLastError(), i = this.isDifferentFromLastResult(t, n);
      (a || !t.partial || this.options.returnPartialData) && this.updateLastResult(t, n), (a || i) && ta(this.observers, "next", t);
    }, e.prototype.reportError = function(t, n) {
      var a = _e(_e({}, this.getLastResult()), { error: t, errors: t.graphQLErrors, networkStatus: ir.error, loading: !1 });
      this.updateLastResult(a, n), ta(this.observers, "error", this.last.error = t);
    }, e.prototype.hasObservers = function() {
      return this.observers.size > 0;
    }, e.prototype.tearDownQuery = function() {
      this.isTornDown || (this.concast && this.observer && (this.concast.removeObserver(this.observer), delete this.concast, delete this.observer), this.stopPolling(), this.subscriptions.forEach(function(t) {
        return t.unsubscribe();
      }), this.subscriptions.clear(), this.queryManager.stopQuery(this.queryId), this.observers.clear(), this.isTornDown = !0);
    }, e.prototype.transformDocument = function(t) {
      return this.queryManager.transform(t);
    }, e;
  }(or)
);
ob(Nc);
function Mb(r) {
  var e = r.options, t = e.fetchPolicy, n = e.nextFetchPolicy;
  return t === "cache-and-network" || t === "network-only" ? r.reobserve({
    fetchPolicy: "cache-first",
    // Use a temporary nextFetchPolicy function that replaces itself with the
    // previous nextFetchPolicy value and returns the original fetchPolicy.
    nextFetchPolicy: function(a, i) {
      return this.nextFetchPolicy = n, typeof this.nextFetchPolicy == "function" ? this.nextFetchPolicy(a, i) : t;
    }
  }) : r.reobserve();
}
function E5(r) {
  globalThis.__DEV__ !== !1 && Ct.error(23, r.message, r.stack);
}
function Ab(r) {
  globalThis.__DEV__ !== !1 && r && globalThis.__DEV__ !== !1 && Ct.debug(24, r);
}
function Zu(r) {
  return r === "network-only" || r === "no-cache" || r === "standby";
}
var Tb = (
  /** @class */
  function() {
    function r(e) {
      var t = e.cache, n = e.client, a = e.resolvers, i = e.fragmentMatcher;
      this.selectionsToResolveCache = /* @__PURE__ */ new WeakMap(), this.cache = t, n && (this.client = n), a && this.addResolvers(a), i && this.setFragmentMatcher(i);
    }
    return r.prototype.addResolvers = function(e) {
      var t = this;
      this.resolvers = this.resolvers || {}, Array.isArray(e) ? e.forEach(function(n) {
        t.resolvers = ev(t.resolvers, n);
      }) : this.resolvers = ev(this.resolvers, e);
    }, r.prototype.setResolvers = function(e) {
      this.resolvers = {}, this.addResolvers(e);
    }, r.prototype.getResolvers = function() {
      return this.resolvers || {};
    }, r.prototype.runResolvers = function(e) {
      return Rn(this, arguments, void 0, function(t) {
        var n = t.document, a = t.remoteResult, i = t.context, o = t.variables, u = t.onlyRunForcedResolvers, c = u === void 0 ? !1 : u;
        return Cn(this, function(h) {
          return n ? [2, this.resolveDocument(n, a.data, i, o, this.fragmentMatcher, c).then(function(s) {
            return _e(_e({}, a), { data: s.result });
          })] : [2, a];
        });
      });
    }, r.prototype.setFragmentMatcher = function(e) {
      this.fragmentMatcher = e;
    }, r.prototype.getFragmentMatcher = function() {
      return this.fragmentMatcher;
    }, r.prototype.clientQuery = function(e) {
      return ua(["client"], e) && this.resolvers ? e : null;
    }, r.prototype.serverQuery = function(e) {
      return tb(e);
    }, r.prototype.prepareContext = function(e) {
      var t = this.cache;
      return _e(_e({}, e), {
        cache: t,
        // Getting an entry's cache key is useful for local state resolvers.
        getCacheKey: function(n) {
          return t.identify(n);
        }
      });
    }, r.prototype.addExportedVariables = function(e) {
      return Rn(this, arguments, void 0, function(t, n, a) {
        return n === void 0 && (n = {}), a === void 0 && (a = {}), Cn(this, function(i) {
          return t ? [2, this.resolveDocument(t, this.buildRootValueFromCache(t, n) || {}, this.prepareContext(a), n).then(function(o) {
            return _e(_e({}, n), o.exportedVariables);
          })] : [2, _e({}, n)];
        });
      });
    }, r.prototype.shouldForceResolvers = function(e) {
      var t = !1;
      return wn(e, {
        Directive: {
          enter: function(n) {
            if (n.name.value === "client" && n.arguments && (t = n.arguments.some(function(a) {
              return a.name.value === "always" && a.value.kind === "BooleanValue" && a.value.value === !0;
            }), t))
              return gh;
          }
        }
      }), t;
    }, r.prototype.buildRootValueFromCache = function(e, t) {
      return this.cache.diff({
        query: i4(e),
        variables: t,
        returnPartialData: !0,
        optimistic: !1
      }).result;
    }, r.prototype.resolveDocument = function(e, t) {
      return Rn(this, arguments, void 0, function(n, a, i, o, u, c) {
        var h, s, d, l, y, m, w, E, S, P, L;
        return i === void 0 && (i = {}), o === void 0 && (o = {}), u === void 0 && (u = function() {
          return !0;
        }), c === void 0 && (c = !1), Cn(this, function(U) {
          return h = Ea(n), s = No(n), d = Bo(s), l = this.collectSelectionsToResolve(h, d), y = h.operation, m = y ? y.charAt(0).toUpperCase() + y.slice(1) : "Query", w = this, E = w.cache, S = w.client, P = {
            fragmentMap: d,
            context: _e(_e({}, i), { cache: E, client: S }),
            variables: o,
            fragmentMatcher: u,
            defaultOperationType: m,
            exportedVariables: {},
            selectionsToResolve: l,
            onlyRunForcedResolvers: c
          }, L = !1, [2, this.resolveSelectionSet(h.selectionSet, L, a, P).then(function(z) {
            return {
              result: z,
              exportedVariables: P.exportedVariables
            };
          })];
        });
      });
    }, r.prototype.resolveSelectionSet = function(e, t, n, a) {
      return Rn(this, void 0, void 0, function() {
        var i, o, u, c, h, s = this;
        return Cn(this, function(d) {
          return i = a.fragmentMap, o = a.context, u = a.variables, c = [n], h = function(l) {
            return Rn(s, void 0, void 0, function() {
              var y, m;
              return Cn(this, function(w) {
                return !t && !a.selectionsToResolve.has(l) ? [
                  2
                  /*return*/
                ] : _a(l, u) ? Fn(l) ? [2, this.resolveField(l, t, n, a).then(function(E) {
                  var S;
                  typeof E != "undefined" && c.push((S = {}, S[Ln(l)] = E, S));
                })] : (L_(l) ? y = l : (y = i[l.name.value], Ct(y, 18, l.name.value)), y && y.typeCondition && (m = y.typeCondition.name.value, a.fragmentMatcher(n, m, o)) ? [2, this.resolveSelectionSet(y.selectionSet, t, n, a).then(function(E) {
                  c.push(E);
                })] : [
                  2
                  /*return*/
                ]) : [
                  2
                  /*return*/
                ];
              });
            });
          }, [2, Promise.all(e.selections.map(h)).then(function() {
            return Mh(c);
          })];
        });
      });
    }, r.prototype.resolveField = function(e, t, n, a) {
      return Rn(this, void 0, void 0, function() {
        var i, o, u, c, h, s, d, l, y, m = this;
        return Cn(this, function(w) {
          return n ? (i = a.variables, o = e.name.value, u = Ln(e), c = o !== u, h = n[u] || n[o], s = Promise.resolve(h), (!a.onlyRunForcedResolvers || this.shouldForceResolvers(e)) && (d = n.__typename || a.defaultOperationType, l = this.resolvers && this.resolvers[d], l && (y = l[c ? o : u], y && (s = Promise.resolve(
            // In case the resolve function accesses reactive variables,
            // set cacheSlot to the current cache instance.
            Ch.withValue(this.cache, y, [
              n,
              Do(e, i),
              a.context,
              { field: e, fragmentMap: a.fragmentMap }
            ])
          )))), [2, s.then(function(E) {
            var S, P;
            if (E === void 0 && (E = h), e.directives && e.directives.forEach(function(U) {
              U.name.value === "export" && U.arguments && U.arguments.forEach(function(z) {
                z.name.value === "as" && z.value.kind === "StringValue" && (a.exportedVariables[z.value.value] = E);
              });
            }), !e.selectionSet || E == null)
              return E;
            var L = (P = (S = e.directives) === null || S === void 0 ? void 0 : S.some(function(U) {
              return U.name.value === "client";
            })) !== null && P !== void 0 ? P : !1;
            if (Array.isArray(E))
              return m.resolveSubSelectedArray(e, t || L, E, a);
            if (e.selectionSet)
              return m.resolveSelectionSet(e.selectionSet, t || L, E, a);
          })]) : [2, null];
        });
      });
    }, r.prototype.resolveSubSelectedArray = function(e, t, n, a) {
      var i = this;
      return Promise.all(n.map(function(o) {
        if (o === null)
          return null;
        if (Array.isArray(o))
          return i.resolveSubSelectedArray(e, t, o, a);
        if (e.selectionSet)
          return i.resolveSelectionSet(e.selectionSet, t, o, a);
      }));
    }, r.prototype.collectSelectionsToResolve = function(e, t) {
      var n = function(o) {
        return !Array.isArray(o);
      }, a = this.selectionsToResolveCache;
      function i(o) {
        if (!a.has(o)) {
          var u = /* @__PURE__ */ new Set();
          a.set(o, u), wn(o, {
            Directive: function(c, h, s, d, l) {
              c.name.value === "client" && l.forEach(function(y) {
                n(y) && zp(y) && u.add(y);
              });
            },
            FragmentSpread: function(c, h, s, d, l) {
              var y = t[c.name.value];
              Ct(y, 19, c.name.value);
              var m = i(y);
              m.size > 0 && (l.forEach(function(w) {
                n(w) && zp(w) && u.add(w);
              }), u.add(c), m.forEach(function(w) {
                u.add(w);
              }));
            }
          });
        }
        return a.get(o);
      }
      return i(e);
    }, r;
  }()
), yi = new (Pi ? WeakMap : Map)();
function ec(r, e) {
  var t = r[e];
  typeof t == "function" && (r[e] = function() {
    return yi.set(
      r,
      // The %1e15 allows the count to wrap around to 0 safely every
      // quadrillion evictions, so there's no risk of overflow. To be
      // clear, this is more of a pedantic principle than something
      // that matters in any conceivable practical scenario.
      (yi.get(r) + 1) % 1e15
    ), t.apply(this, arguments);
  });
}
function Ov(r) {
  r.notifyTimeout && (clearTimeout(r.notifyTimeout), r.notifyTimeout = void 0);
}
var tc = (
  /** @class */
  function() {
    function r(e, t) {
      t === void 0 && (t = e.generateQueryId()), this.queryId = t, this.listeners = /* @__PURE__ */ new Set(), this.document = null, this.lastRequestId = 1, this.stopped = !1, this.dirty = !1, this.observableQuery = null;
      var n = this.cache = e.cache;
      yi.has(n) || (yi.set(n, 0), ec(n, "evict"), ec(n, "modify"), ec(n, "reset"));
    }
    return r.prototype.init = function(e) {
      var t = e.networkStatus || ir.loading;
      return this.variables && this.networkStatus !== ir.loading && !ur(this.variables, e.variables) && (t = ir.setVariables), ur(e.variables, this.variables) || (this.lastDiff = void 0), Object.assign(this, {
        document: e.document,
        variables: e.variables,
        networkError: null,
        graphQLErrors: this.graphQLErrors || [],
        networkStatus: t
      }), e.observableQuery && this.setObservableQuery(e.observableQuery), e.lastRequestId && (this.lastRequestId = e.lastRequestId), this;
    }, r.prototype.reset = function() {
      Ov(this), this.dirty = !1;
    }, r.prototype.resetDiff = function() {
      this.lastDiff = void 0;
    }, r.prototype.getDiff = function() {
      var e = this.getDiffOptions();
      if (this.lastDiff && ur(e, this.lastDiff.options))
        return this.lastDiff.diff;
      this.updateWatch(this.variables);
      var t = this.observableQuery;
      if (t && t.options.fetchPolicy === "no-cache")
        return { complete: !1 };
      var n = this.cache.diff(e);
      return this.updateLastDiff(n, e), n;
    }, r.prototype.updateLastDiff = function(e, t) {
      this.lastDiff = e ? {
        diff: e,
        options: t || this.getDiffOptions()
      } : void 0;
    }, r.prototype.getDiffOptions = function(e) {
      var t;
      return e === void 0 && (e = this.variables), {
        query: this.document,
        variables: e,
        returnPartialData: !0,
        optimistic: !0,
        canonizeResults: (t = this.observableQuery) === null || t === void 0 ? void 0 : t.options.canonizeResults
      };
    }, r.prototype.setDiff = function(e) {
      var t = this, n, a = this.lastDiff && this.lastDiff.diff;
      e && !e.complete && !(!((n = this.observableQuery) === null || n === void 0) && n.options.returnPartialData) && // In the case of a cache eviction, the diff will become partial so we
      // schedule a notification to send a network request (this.oqListener) to
      // go and fetch the missing data.
      !(a && a.complete) || (this.updateLastDiff(e), !this.dirty && !ur(a && a.result, e && e.result) && (this.dirty = !0, this.notifyTimeout || (this.notifyTimeout = setTimeout(function() {
        return t.notify();
      }, 0))));
    }, r.prototype.setObservableQuery = function(e) {
      var t = this;
      e !== this.observableQuery && (this.oqListener && this.listeners.delete(this.oqListener), this.observableQuery = e, e ? (e.queryInfo = this, this.listeners.add(this.oqListener = function() {
        var n = t.getDiff();
        n.fromOptimisticTransaction ? e.observe() : Mb(e);
      })) : delete this.oqListener);
    }, r.prototype.notify = function() {
      var e = this;
      Ov(this), this.shouldNotify() && this.listeners.forEach(function(t) {
        return t(e);
      }), this.dirty = !1;
    }, r.prototype.shouldNotify = function() {
      if (!this.dirty || !this.listeners.size)
        return !1;
      if (da(this.networkStatus) && this.observableQuery) {
        var e = this.observableQuery.options.fetchPolicy;
        if (e !== "cache-only" && e !== "cache-and-network")
          return !1;
      }
      return !0;
    }, r.prototype.stop = function() {
      if (!this.stopped) {
        this.stopped = !0, this.reset(), this.cancel(), this.cancel = r.prototype.cancel;
        var e = this.observableQuery;
        e && e.stopPolling();
      }
    }, r.prototype.cancel = function() {
    }, r.prototype.updateWatch = function(e) {
      var t = this;
      e === void 0 && (e = this.variables);
      var n = this.observableQuery;
      if (!(n && n.options.fetchPolicy === "no-cache")) {
        var a = _e(_e({}, this.getDiffOptions(e)), { watcher: this, callback: function(i) {
          return t.setDiff(i);
        } });
        (!this.lastWatch || !ur(a, this.lastWatch)) && (this.cancel(), this.cancel = this.cache.watch(this.lastWatch = a));
      }
    }, r.prototype.resetLastWrite = function() {
      this.lastWrite = void 0;
    }, r.prototype.shouldWrite = function(e, t) {
      var n = this.lastWrite;
      return !(n && // If cache.evict has been called since the last time we wrote this
      // data into the cache, there's a chance writing this result into
      // the cache will repair what was evicted.
      n.dmCount === yi.get(this.cache) && ur(t, n.variables) && ur(e.data, n.result.data));
    }, r.prototype.markResult = function(e, t, n, a) {
      var i = this, o = new $n(), u = hn(e.errors) ? e.errors.slice(0) : [];
      if (this.reset(), "incremental" in e && hn(e.incremental)) {
        var c = sb(this.getDiff().result, e);
        e.data = c;
      } else if ("hasNext" in e && e.hasNext) {
        var h = this.getDiff();
        e.data = o.merge(h.result, e.data);
      }
      this.graphQLErrors = u, n.fetchPolicy === "no-cache" ? this.updateLastDiff({ result: e.data, complete: !0 }, this.getDiffOptions(n.variables)) : a !== 0 && (qc(e, n.errorPolicy) ? this.cache.performTransaction(function(s) {
        if (i.shouldWrite(e, n.variables))
          s.writeQuery({
            query: t,
            data: e.data,
            variables: n.variables,
            overwrite: a === 1
          }), i.lastWrite = {
            result: e,
            variables: n.variables,
            dmCount: yi.get(i.cache)
          };
        else if (i.lastDiff && i.lastDiff.diff.complete) {
          e.data = i.lastDiff.diff.result;
          return;
        }
        var d = i.getDiffOptions(n.variables), l = s.diff(d);
        !i.stopped && ur(i.variables, n.variables) && i.updateWatch(n.variables), i.updateLastDiff(l, d), l.complete && (e.data = l.result);
      }) : this.lastWrite = void 0);
    }, r.prototype.markReady = function() {
      return this.networkError = null, this.networkStatus = ir.ready;
    }, r.prototype.markError = function(e) {
      return this.networkStatus = ir.error, this.lastWrite = void 0, this.reset(), e.graphQLErrors && (this.graphQLErrors = e.graphQLErrors), e.networkError && (this.networkError = e.networkError), e;
    }, r;
  }()
);
function qc(r, e) {
  e === void 0 && (e = "none");
  var t = e === "ignore" || e === "all", n = !oo(r);
  return !n && t && r.data && (n = !0), n;
}
var M5 = Object.prototype.hasOwnProperty, Bv = /* @__PURE__ */ Object.create(null), A5 = (
  /** @class */
  function() {
    function r(e) {
      var t = e.cache, n = e.link, a = e.defaultOptions, i = e.documentTransform, o = e.queryDeduplication, u = o === void 0 ? !1 : o, c = e.onBroadcast, h = e.ssrMode, s = h === void 0 ? !1 : h, d = e.clientAwareness, l = d === void 0 ? {} : d, y = e.localState, m = e.assumeImmutableResults, w = m === void 0 ? !!t.assumeImmutableResults : m, E = e.defaultContext, S = this;
      this.clientAwareness = {}, this.queries = /* @__PURE__ */ new Map(), this.fetchCancelFns = /* @__PURE__ */ new Map(), this.transformCache = new By(
        _n["queryManager.getDocumentInfo"] || 2e3
        /* defaultCacheSizes["queryManager.getDocumentInfo"] */
      ), this.queryIdCounter = 1, this.requestIdCounter = 1, this.mutationIdCounter = 1, this.inFlightLinkObservables = new Bi(!1);
      var P = new Xy(
        function(L) {
          return S.cache.transformDocument(L);
        },
        // Allow the apollo cache to manage its own transform caches
        { cache: !1 }
      );
      this.cache = t, this.link = n, this.defaultOptions = a || /* @__PURE__ */ Object.create(null), this.queryDeduplication = u, this.clientAwareness = l, this.localState = y || new Tb({ cache: t }), this.ssrMode = s, this.assumeImmutableResults = w, this.documentTransform = i ? P.concat(i).concat(P) : P, this.defaultContext = E || /* @__PURE__ */ Object.create(null), (this.onBroadcast = c) && (this.mutationStore = /* @__PURE__ */ Object.create(null));
    }
    return r.prototype.stop = function() {
      var e = this;
      this.queries.forEach(function(t, n) {
        e.stopQueryNoBroadcast(n);
      }), this.cancelPendingFetches(Nr(25));
    }, r.prototype.cancelPendingFetches = function(e) {
      this.fetchCancelFns.forEach(function(t) {
        return t(e);
      }), this.fetchCancelFns.clear();
    }, r.prototype.mutate = function(e) {
      return Rn(this, arguments, void 0, function(t) {
        var n, a, i, o, u, c, h, s = t.mutation, d = t.variables, l = t.optimisticResponse, y = t.updateQueries, m = t.refetchQueries, w = m === void 0 ? [] : m, E = t.awaitRefetchQueries, S = E === void 0 ? !1 : E, P = t.update, L = t.onQueryUpdated, U = t.fetchPolicy, z = U === void 0 ? ((c = this.defaultOptions.mutate) === null || c === void 0 ? void 0 : c.fetchPolicy) || "network-only" : U, K = t.errorPolicy, re = K === void 0 ? ((h = this.defaultOptions.mutate) === null || h === void 0 ? void 0 : h.errorPolicy) || "none" : K, oe = t.keepRootFields, se = t.context;
        return Cn(this, function(ve) {
          switch (ve.label) {
            case 0:
              return Ct(s, 26), Ct(z === "network-only" || z === "no-cache", 27), n = this.generateMutationId(), s = this.cache.transformForLink(this.transform(s)), a = this.getDocumentInfo(s).hasClientExports, d = this.getVariables(s, d), a ? [4, this.localState.addExportedVariables(s, d, se)] : [3, 2];
            case 1:
              d = ve.sent(), ve.label = 2;
            case 2:
              return i = this.mutationStore && (this.mutationStore[n] = {
                mutation: s,
                variables: d,
                loading: !0,
                error: null
              }), o = l && this.markMutationOptimistic(l, {
                mutationId: n,
                document: s,
                variables: d,
                fetchPolicy: z,
                errorPolicy: re,
                context: se,
                updateQueries: y,
                update: P,
                keepRootFields: oe
              }), this.broadcastQueries(), u = this, [2, new Promise(function(Q, A) {
                return Ku(u.getObservableFromLink(s, _e(_e({}, se), { optimisticResponse: o ? l : void 0 }), d, !1), function(b) {
                  if (oo(b) && re === "none")
                    throw new ci({
                      graphQLErrors: kc(b)
                    });
                  i && (i.loading = !1, i.error = null);
                  var f = _e({}, b);
                  return typeof w == "function" && (w = w(f)), re === "ignore" && oo(f) && delete f.errors, u.markMutationResult({
                    mutationId: n,
                    result: f,
                    document: s,
                    variables: d,
                    fetchPolicy: z,
                    errorPolicy: re,
                    context: se,
                    update: P,
                    updateQueries: y,
                    awaitRefetchQueries: S,
                    refetchQueries: w,
                    removeOptimistic: o ? n : void 0,
                    onQueryUpdated: L,
                    keepRootFields: oe
                  });
                }).subscribe({
                  next: function(b) {
                    u.broadcastQueries(), (!("hasNext" in b) || b.hasNext === !1) && Q(b);
                  },
                  error: function(b) {
                    i && (i.loading = !1, i.error = b), o && u.cache.removeOptimistic(n), u.broadcastQueries(), A(b instanceof ci ? b : new ci({
                      networkError: b
                    }));
                  }
                });
              })];
          }
        });
      });
    }, r.prototype.markMutationResult = function(e, t) {
      var n = this;
      t === void 0 && (t = this.cache);
      var a = e.result, i = [], o = e.fetchPolicy === "no-cache";
      if (!o && qc(a, e.errorPolicy)) {
        if (wi(a) || i.push({
          result: a.data,
          dataId: "ROOT_MUTATION",
          query: e.document,
          variables: e.variables
        }), wi(a) && hn(a.incremental)) {
          var u = t.diff({
            id: "ROOT_MUTATION",
            // The cache complains if passed a mutation where it expects a
            // query, so we transform mutations and subscriptions to queries
            // (only once, thanks to this.transformCache).
            query: this.getDocumentInfo(e.document).asQuery,
            variables: e.variables,
            optimistic: !1,
            returnPartialData: !0
          }), c = void 0;
          u.result && (c = sb(u.result, a)), typeof c != "undefined" && (a.data = c, i.push({
            result: c,
            dataId: "ROOT_MUTATION",
            query: e.document,
            variables: e.variables
          }));
        }
        var h = e.updateQueries;
        h && this.queries.forEach(function(d, l) {
          var y = d.observableQuery, m = y && y.queryName;
          if (!(!m || !M5.call(h, m))) {
            var w = h[m], E = n.queries.get(l), S = E.document, P = E.variables, L = t.diff({
              query: S,
              variables: P,
              returnPartialData: !0,
              optimistic: !1
            }), U = L.result, z = L.complete;
            if (z && U) {
              var K = w(U, {
                mutationResult: a,
                queryName: S && Sc(S) || void 0,
                queryVariables: P
              });
              K && i.push({
                result: K,
                dataId: "ROOT_QUERY",
                query: S,
                variables: P
              });
            }
          }
        });
      }
      if (i.length > 0 || (e.refetchQueries || "").length > 0 || e.update || e.onQueryUpdated || e.removeOptimistic) {
        var s = [];
        if (this.refetchQueries({
          updateCache: function(d) {
            o || i.forEach(function(w) {
              return d.write(w);
            });
            var l = e.update, y = !g4(a) || wi(a) && !a.hasNext;
            if (l) {
              if (!o) {
                var m = d.diff({
                  id: "ROOT_MUTATION",
                  // The cache complains if passed a mutation where it expects a
                  // query, so we transform mutations and subscriptions to queries
                  // (only once, thanks to this.transformCache).
                  query: n.getDocumentInfo(e.document).asQuery,
                  variables: e.variables,
                  optimistic: !1,
                  returnPartialData: !0
                });
                m.complete && (a = _e(_e({}, a), { data: m.result }), "incremental" in a && delete a.incremental, "hasNext" in a && delete a.hasNext);
              }
              y && l(d, a, {
                context: e.context,
                variables: e.variables
              });
            }
            !o && !e.keepRootFields && y && d.modify({
              id: "ROOT_MUTATION",
              fields: function(w, E) {
                var S = E.fieldName, P = E.DELETE;
                return S === "__typename" ? w : P;
              }
            });
          },
          include: e.refetchQueries,
          // Write the final mutation.result to the root layer of the cache.
          optimistic: !1,
          // Remove the corresponding optimistic layer at the same time as we
          // write the final non-optimistic result.
          removeOptimistic: e.removeOptimistic,
          // Let the caller of client.mutate optionally determine the refetching
          // behavior for watched queries after the mutation.update function runs.
          // If no onQueryUpdated function was provided for this mutation, pass
          // null instead of undefined to disable the default refetching behavior.
          onQueryUpdated: e.onQueryUpdated || null
        }).forEach(function(d) {
          return s.push(d);
        }), e.awaitRefetchQueries || e.onQueryUpdated)
          return Promise.all(s).then(function() {
            return a;
          });
      }
      return Promise.resolve(a);
    }, r.prototype.markMutationOptimistic = function(e, t) {
      var n = this, a = typeof e == "function" ? e(t.variables, { IGNORE: Bv }) : e;
      return a === Bv ? !1 : (this.cache.recordOptimisticTransaction(function(i) {
        try {
          n.markMutationResult(_e(_e({}, t), { result: { data: a } }), i);
        } catch (o) {
          globalThis.__DEV__ !== !1 && Ct.error(o);
        }
      }, t.mutationId), !0);
    }, r.prototype.fetchQuery = function(e, t, n) {
      return this.fetchConcastWithInfo(e, t, n).concast.promise;
    }, r.prototype.getQueryStore = function() {
      var e = /* @__PURE__ */ Object.create(null);
      return this.queries.forEach(function(t, n) {
        e[n] = {
          variables: t.variables,
          networkStatus: t.networkStatus,
          networkError: t.networkError,
          graphQLErrors: t.graphQLErrors
        };
      }), e;
    }, r.prototype.resetErrors = function(e) {
      var t = this.queries.get(e);
      t && (t.networkError = void 0, t.graphQLErrors = []);
    }, r.prototype.transform = function(e) {
      return this.documentTransform.transformDocument(e);
    }, r.prototype.getDocumentInfo = function(e) {
      var t = this.transformCache;
      if (!t.has(e)) {
        var n = {
          // TODO These three calls (hasClientExports, shouldForceResolvers, and
          // usesNonreactiveDirective) are performing independent full traversals
          // of the transformed document. We should consider merging these
          // traversals into a single pass in the future, though the work is
          // cached after the first time.
          hasClientExports: t_(e),
          hasForcedResolvers: this.localState.shouldForceResolvers(e),
          hasNonreactiveDirective: ua(["nonreactive"], e),
          clientQuery: this.localState.clientQuery(e),
          serverQuery: eb([
            { name: "client", remove: !0 },
            { name: "connection" },
            { name: "nonreactive" }
          ], e),
          defaultVars: wh(Sa(e)),
          // Transform any mutation or subscription operations to query operations
          // so we can read/write them from/to the cache.
          asQuery: _e(_e({}, e), { definitions: e.definitions.map(function(a) {
            return a.kind === "OperationDefinition" && a.operation !== "query" ? _e(_e({}, a), { operation: "query" }) : a;
          }) })
        };
        t.set(e, n);
      }
      return t.get(e);
    }, r.prototype.getVariables = function(e, t) {
      return _e(_e({}, this.getDocumentInfo(e).defaultVars), t);
    }, r.prototype.watchQuery = function(e) {
      var t = this.transform(e.query);
      e = _e(_e({}, e), { variables: this.getVariables(t, e.variables) }), typeof e.notifyOnNetworkStatusChange == "undefined" && (e.notifyOnNetworkStatusChange = !1);
      var n = new tc(this), a = new Nc({
        queryManager: this,
        queryInfo: n,
        options: e
      });
      return a.lastQuery = t, this.queries.set(a.queryId, n), n.init({
        document: t,
        observableQuery: a,
        variables: a.variables
      }), a;
    }, r.prototype.query = function(e, t) {
      var n = this;
      return t === void 0 && (t = this.generateQueryId()), Ct(e.query, 28), Ct(e.query.kind === "Document", 29), Ct(!e.returnPartialData, 30), Ct(!e.pollInterval, 31), this.fetchQuery(t, _e(_e({}, e), { query: this.transform(e.query) })).finally(function() {
        return n.stopQuery(t);
      });
    }, r.prototype.generateQueryId = function() {
      return String(this.queryIdCounter++);
    }, r.prototype.generateRequestId = function() {
      return this.requestIdCounter++;
    }, r.prototype.generateMutationId = function() {
      return String(this.mutationIdCounter++);
    }, r.prototype.stopQueryInStore = function(e) {
      this.stopQueryInStoreNoBroadcast(e), this.broadcastQueries();
    }, r.prototype.stopQueryInStoreNoBroadcast = function(e) {
      var t = this.queries.get(e);
      t && t.stop();
    }, r.prototype.clearStore = function(e) {
      return e === void 0 && (e = {
        discardWatches: !0
      }), this.cancelPendingFetches(Nr(32)), this.queries.forEach(function(t) {
        t.observableQuery ? t.networkStatus = ir.loading : t.stop();
      }), this.mutationStore && (this.mutationStore = /* @__PURE__ */ Object.create(null)), this.cache.reset(e);
    }, r.prototype.getObservableQueries = function(e) {
      var t = this;
      e === void 0 && (e = "active");
      var n = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Set();
      return Array.isArray(e) && e.forEach(function(o) {
        typeof o == "string" ? a.set(o, !1) : A_(o) ? a.set(t.transform(o), !1) : vr(o) && o.query && i.add(o);
      }), this.queries.forEach(function(o, u) {
        var c = o.observableQuery, h = o.document;
        if (c) {
          if (e === "all") {
            n.set(u, c);
            return;
          }
          var s = c.queryName, d = c.options.fetchPolicy;
          if (d === "standby" || e === "active" && !c.hasObservers())
            return;
          (e === "active" || s && a.has(s) || h && a.has(h)) && (n.set(u, c), s && a.set(s, !0), h && a.set(h, !0));
        }
      }), i.size && i.forEach(function(o) {
        var u = pc("legacyOneTimeQuery"), c = t.getQuery(u).init({
          document: o.query,
          variables: o.variables
        }), h = new Nc({
          queryManager: t,
          queryInfo: c,
          options: _e(_e({}, o), { fetchPolicy: "network-only" })
        });
        Ct(h.queryId === u), c.setObservableQuery(h), n.set(u, h);
      }), globalThis.__DEV__ !== !1 && a.size && a.forEach(function(o, u) {
        o || globalThis.__DEV__ !== !1 && Ct.warn(typeof u == "string" ? 33 : 34, u);
      }), n;
    }, r.prototype.reFetchObservableQueries = function(e) {
      var t = this;
      e === void 0 && (e = !1);
      var n = [];
      return this.getObservableQueries(e ? "all" : "active").forEach(function(a, i) {
        var o = a.options.fetchPolicy;
        a.resetLastResults(), (e || o !== "standby" && o !== "cache-only") && n.push(a.refetch()), t.getQuery(i).setDiff(null);
      }), this.broadcastQueries(), Promise.all(n);
    }, r.prototype.setObservableQuery = function(e) {
      this.getQuery(e.queryId).setObservableQuery(e);
    }, r.prototype.startGraphQLSubscription = function(e) {
      var t = this, n = e.query, a = e.fetchPolicy, i = e.errorPolicy, o = i === void 0 ? "none" : i, u = e.variables, c = e.context, h = c === void 0 ? {} : c;
      n = this.transform(n), u = this.getVariables(n, u);
      var s = function(l) {
        return t.getObservableFromLink(n, h, l).map(function(y) {
          a !== "no-cache" && (qc(y, o) && t.cache.write({
            query: n,
            result: y.data,
            dataId: "ROOT_SUBSCRIPTION",
            variables: l
          }), t.broadcastQueries());
          var m = oo(y), w = q4(y);
          if (m || w) {
            var E = {};
            if (m && (E.graphQLErrors = y.errors), w && (E.protocolErrors = y.extensions[Rh]), o === "none" || w)
              throw new ci(E);
          }
          return o === "ignore" && delete y.errors, y;
        });
      };
      if (this.getDocumentInfo(n).hasClientExports) {
        var d = this.localState.addExportedVariables(n, u, h).then(s);
        return new or(function(l) {
          var y = null;
          return d.then(function(m) {
            return y = m.subscribe(l);
          }, l.error), function() {
            return y && y.unsubscribe();
          };
        });
      }
      return s(u);
    }, r.prototype.stopQuery = function(e) {
      this.stopQueryNoBroadcast(e), this.broadcastQueries();
    }, r.prototype.stopQueryNoBroadcast = function(e) {
      this.stopQueryInStoreNoBroadcast(e), this.removeQuery(e);
    }, r.prototype.removeQuery = function(e) {
      this.fetchCancelFns.delete(e), this.queries.has(e) && (this.getQuery(e).stop(), this.queries.delete(e));
    }, r.prototype.broadcastQueries = function() {
      this.onBroadcast && this.onBroadcast(), this.queries.forEach(function(e) {
        return e.notify();
      });
    }, r.prototype.getLocalState = function() {
      return this.localState;
    }, r.prototype.getObservableFromLink = function(e, t, n, a) {
      var i = this, o;
      a === void 0 && (a = (o = t == null ? void 0 : t.queryDeduplication) !== null && o !== void 0 ? o : this.queryDeduplication);
      var u, c = this.getDocumentInfo(e), h = c.serverQuery, s = c.clientQuery;
      if (h) {
        var d = this, l = d.inFlightLinkObservables, y = d.link, m = {
          query: h,
          variables: n,
          operationName: Sc(h) || void 0,
          context: this.prepareContext(_e(_e({}, t), { forceFetch: !a }))
        };
        if (t = m.context, a) {
          var w = Fo(h), E = Dn(n), S = l.lookup(w, E);
          if (u = S.observable, !u) {
            var P = new li([
              Ic(y, m)
            ]);
            u = S.observable = P, P.beforeNext(function() {
              l.remove(w, E);
            });
          }
        } else
          u = new li([
            Ic(y, m)
          ]);
      } else
        u = new li([or.of({ data: {} })]), t = this.prepareContext(t);
      return s && (u = Ku(u, function(L) {
        return i.localState.runResolvers({
          document: s,
          remoteResult: L,
          context: t,
          variables: n
        });
      })), u;
    }, r.prototype.getResultsFromLink = function(e, t, n) {
      var a = e.lastRequestId = this.generateRequestId(), i = this.cache.transformForLink(n.query);
      return Ku(this.getObservableFromLink(i, n.context, n.variables), function(o) {
        var u = kc(o), c = u.length > 0;
        if (a >= e.lastRequestId) {
          if (c && n.errorPolicy === "none")
            throw e.markError(new ci({
              graphQLErrors: u
            }));
          e.markResult(o, i, n, t), e.markReady();
        }
        var h = {
          data: o.data,
          loading: !1,
          networkStatus: ir.ready
        };
        return c && n.errorPolicy !== "ignore" && (h.errors = u, h.networkStatus = ir.error), h;
      }, function(o) {
        var u = L4(o) ? o : new ci({ networkError: o });
        throw a >= e.lastRequestId && e.markError(u), u;
      });
    }, r.prototype.fetchConcastWithInfo = function(e, t, n, a) {
      var i = this;
      n === void 0 && (n = ir.loading), a === void 0 && (a = t.query);
      var o = this.getVariables(a, t.variables), u = this.getQuery(e), c = this.defaultOptions.watchQuery, h = t.fetchPolicy, s = h === void 0 ? c && c.fetchPolicy || "cache-first" : h, d = t.errorPolicy, l = d === void 0 ? c && c.errorPolicy || "none" : d, y = t.returnPartialData, m = y === void 0 ? !1 : y, w = t.notifyOnNetworkStatusChange, E = w === void 0 ? !1 : w, S = t.context, P = S === void 0 ? {} : S, L = Object.assign({}, t, {
        query: a,
        variables: o,
        fetchPolicy: s,
        errorPolicy: l,
        returnPartialData: m,
        notifyOnNetworkStatusChange: E,
        context: P
      }), U = function(se) {
        L.variables = se;
        var ve = i.fetchQueryByPolicy(u, L, n);
        return (
          // If we're in standby, postpone advancing options.fetchPolicy using
          // applyNextFetchPolicy.
          L.fetchPolicy !== "standby" && // The "standby" policy currently returns [] from fetchQueryByPolicy, so
          // this is another way to detect when nothing was done/fetched.
          ve.sources.length > 0 && u.observableQuery && u.observableQuery.applyNextFetchPolicy("after-fetch", t), ve
        );
      }, z = function() {
        return i.fetchCancelFns.delete(e);
      };
      this.fetchCancelFns.set(e, function(se) {
        z(), setTimeout(function() {
          return K.cancel(se);
        });
      });
      var K, re;
      if (this.getDocumentInfo(L.query).hasClientExports)
        K = new li(this.localState.addExportedVariables(L.query, L.variables, L.context).then(U).then(function(se) {
          return se.sources;
        })), re = !0;
      else {
        var oe = U(L.variables);
        re = oe.fromLink, K = new li(oe.sources);
      }
      return K.promise.then(z, z), {
        concast: K,
        fromLink: re
      };
    }, r.prototype.refetchQueries = function(e) {
      var t = this, n = e.updateCache, a = e.include, i = e.optimistic, o = i === void 0 ? !1 : i, u = e.removeOptimistic, c = u === void 0 ? o ? pc("refetchQueries") : void 0 : u, h = e.onQueryUpdated, s = /* @__PURE__ */ new Map();
      a && this.getObservableQueries(a).forEach(function(l, y) {
        s.set(y, {
          oq: l,
          lastDiff: t.getQuery(y).getDiff()
        });
      });
      var d = /* @__PURE__ */ new Map();
      return n && this.cache.batch({
        update: n,
        // Since you can perform any combination of cache reads and/or writes in
        // the cache.batch update function, its optimistic option can be either
        // a boolean or a string, representing three distinct modes of
        // operation:
        //
        // * false: read/write only the root layer
        // * true: read/write the topmost layer
        // * string: read/write a fresh optimistic layer with that ID string
        //
        // When typeof optimistic === "string", a new optimistic layer will be
        // temporarily created within cache.batch with that string as its ID. If
        // we then pass that same string as the removeOptimistic option, we can
        // make cache.batch immediately remove the optimistic layer after
        // running the updateCache function, triggering only one broadcast.
        //
        // However, the refetchQueries method accepts only true or false for its
        // optimistic option (not string). We interpret true to mean a temporary
        // optimistic layer should be created, to allow efficiently rolling back
        // the effect of the updateCache function, which involves passing a
        // string instead of true as the optimistic option to cache.batch, when
        // refetchQueries receives optimistic: true.
        //
        // In other words, we are deliberately not supporting the use case of
        // writing to an *existing* optimistic layer (using the refetchQueries
        // updateCache function), since that would potentially interfere with
        // other optimistic updates in progress. Instead, you can read/write
        // only the root layer by passing optimistic: false to refetchQueries,
        // or you can read/write a brand new optimistic layer that will be
        // automatically removed by passing optimistic: true.
        optimistic: o && c || !1,
        // The removeOptimistic option can also be provided by itself, even if
        // optimistic === false, to remove some previously-added optimistic
        // layer safely and efficiently, like we do in markMutationResult.
        //
        // If an explicit removeOptimistic string is provided with optimistic:
        // true, the removeOptimistic string will determine the ID of the
        // temporary optimistic layer, in case that ever matters.
        removeOptimistic: c,
        onWatchUpdated: function(l, y, m) {
          var w = l.watcher instanceof tc && l.watcher.observableQuery;
          if (w) {
            if (h) {
              s.delete(w.queryId);
              var E = h(w, y, m);
              return E === !0 && (E = w.refetch()), E !== !1 && d.set(w, E), E;
            }
            h !== null && s.set(w.queryId, { oq: w, lastDiff: m, diff: y });
          }
        }
      }), s.size && s.forEach(function(l, y) {
        var m = l.oq, w = l.lastDiff, E = l.diff, S;
        if (h) {
          if (!E) {
            var P = m.queryInfo;
            P.reset(), E = P.getDiff();
          }
          S = h(m, E, w);
        }
        (!h || S === !0) && (S = m.refetch()), S !== !1 && d.set(m, S), y.indexOf("legacyOneTimeQuery") >= 0 && t.stopQueryNoBroadcast(y);
      }), c && this.cache.removeOptimistic(c), d;
    }, r.prototype.fetchQueryByPolicy = function(e, t, n) {
      var a = this, i = t.query, o = t.variables, u = t.fetchPolicy, c = t.refetchWritePolicy, h = t.errorPolicy, s = t.returnPartialData, d = t.context, l = t.notifyOnNetworkStatusChange, y = e.networkStatus;
      e.init({
        document: i,
        variables: o,
        networkStatus: n
      });
      var m = function() {
        return e.getDiff();
      }, w = function(U, z) {
        z === void 0 && (z = e.networkStatus || ir.loading);
        var K = U.result;
        globalThis.__DEV__ !== !1 && !s && !ur(K, {}) && Ab(U.missing);
        var re = function(oe) {
          return or.of(_e({ data: oe, loading: da(z), networkStatus: z }, U.complete ? null : { partial: !0 }));
        };
        return K && a.getDocumentInfo(i).hasForcedResolvers ? a.localState.runResolvers({
          document: i,
          remoteResult: { data: K },
          context: d,
          variables: o,
          onlyRunForcedResolvers: !0
        }).then(function(oe) {
          return re(oe.data || void 0);
        }) : h === "none" && z === ir.refetch && Array.isArray(U.missing) ? re(void 0) : re(K);
      }, E = u === "no-cache" ? 0 : n === ir.refetch && c !== "merge" ? 1 : 2, S = function() {
        return a.getResultsFromLink(e, E, {
          query: i,
          variables: o,
          context: d,
          fetchPolicy: u,
          errorPolicy: h
        });
      }, P = l && typeof y == "number" && y !== n && da(n);
      switch (u) {
        default:
        case "cache-first": {
          var L = m();
          return L.complete ? {
            fromLink: !1,
            sources: [w(L, e.markReady())]
          } : s || P ? {
            fromLink: !0,
            sources: [w(L), S()]
          } : { fromLink: !0, sources: [S()] };
        }
        case "cache-and-network": {
          var L = m();
          return L.complete || s || P ? {
            fromLink: !0,
            sources: [w(L), S()]
          } : { fromLink: !0, sources: [S()] };
        }
        case "cache-only":
          return {
            fromLink: !1,
            sources: [w(m(), e.markReady())]
          };
        case "network-only":
          return P ? {
            fromLink: !0,
            sources: [w(m()), S()]
          } : { fromLink: !0, sources: [S()] };
        case "no-cache":
          return P ? {
            fromLink: !0,
            // Note that queryInfo.getDiff() for no-cache queries does not call
            // cache.diff, but instead returns a { complete: false } stub result
            // when there is no queryInfo.diff already defined.
            sources: [w(e.getDiff()), S()]
          } : { fromLink: !0, sources: [S()] };
        case "standby":
          return { fromLink: !1, sources: [] };
      }
    }, r.prototype.getQuery = function(e) {
      return e && !this.queries.has(e) && this.queries.set(e, new tc(this, e)), this.queries.get(e);
    }, r.prototype.prepareContext = function(e) {
      e === void 0 && (e = {});
      var t = this.localState.prepareContext(e);
      return _e(_e(_e({}, this.defaultContext), t), { clientAwareness: this.clientAwareness });
    }, r;
  }()
), Pv = !1, kb = (
  /** @class */
  function() {
    function r(e) {
      var t = this;
      if (this.resetStoreCallbacks = [], this.clearStoreCallbacks = [], !e.cache)
        throw Nr(15);
      var n = e.uri, a = e.credentials, i = e.headers, o = e.cache, u = e.documentTransform, c = e.ssrMode, h = c === void 0 ? !1 : c, s = e.ssrForceFetchDelay, d = s === void 0 ? 0 : s, l = e.connectToDevTools, y = l === void 0 ? typeof window == "object" && !window.__APOLLO_CLIENT__ && globalThis.__DEV__ !== !1 : l, m = e.queryDeduplication, w = m === void 0 ? !0 : m, E = e.defaultOptions, S = e.defaultContext, P = e.assumeImmutableResults, L = P === void 0 ? o.assumeImmutableResults : P, U = e.resolvers, z = e.typeDefs, K = e.fragmentMatcher, re = e.name, oe = e.version, se = e.link;
      se || (se = n ? new cb({ uri: n, credentials: a, headers: i }) : Qr.empty()), this.link = se, this.cache = o, this.disableNetworkFetches = h || d > 0, this.queryDeduplication = w, this.defaultOptions = E || /* @__PURE__ */ Object.create(null), this.typeDefs = z, d && setTimeout(function() {
        return t.disableNetworkFetches = !1;
      }, d), this.watchQuery = this.watchQuery.bind(this), this.query = this.query.bind(this), this.mutate = this.mutate.bind(this), this.resetStore = this.resetStore.bind(this), this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this), this.version = ph, this.localState = new Tb({
        cache: o,
        client: this,
        resolvers: U,
        fragmentMatcher: K
      }), this.queryManager = new A5({
        cache: this.cache,
        link: this.link,
        defaultOptions: this.defaultOptions,
        defaultContext: S,
        documentTransform: u,
        queryDeduplication: w,
        ssrMode: h,
        clientAwareness: {
          name: re,
          version: oe
        },
        localState: this.localState,
        assumeImmutableResults: L,
        onBroadcast: y ? function() {
          t.devToolsHookCb && t.devToolsHookCb({
            action: {},
            state: {
              queries: t.queryManager.getQueryStore(),
              mutations: t.queryManager.mutationStore || {}
            },
            dataWithOptimisticResults: t.cache.extract(!0)
          });
        } : void 0
      }), y && this.connectToDevTools();
    }
    return r.prototype.connectToDevTools = function() {
      if (typeof window == "object") {
        var e = window, t = Symbol.for("apollo.devtools");
        (e[t] = e[t] || []).push(this), e.__APOLLO_CLIENT__ = this;
      }
      !Pv && globalThis.__DEV__ !== !1 && (Pv = !0, setTimeout(function() {
        if (typeof window != "undefined" && window.document && window.top === window.self && !window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {
          var n = window.navigator, a = n && n.userAgent, i = void 0;
          typeof a == "string" && (a.indexOf("Chrome/") > -1 ? i = "https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm" : a.indexOf("Firefox/") > -1 && (i = "https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/")), i && globalThis.__DEV__ !== !1 && Ct.log("Download the Apollo DevTools for a better development experience: %s", i);
        }
      }, 1e4));
    }, Object.defineProperty(r.prototype, "documentTransform", {
      /**
       * The `DocumentTransform` used to modify GraphQL documents before a request
       * is made. If a custom `DocumentTransform` is not provided, this will be the
       * default document transform.
       */
      get: function() {
        return this.queryManager.documentTransform;
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.stop = function() {
      this.queryManager.stop();
    }, r.prototype.watchQuery = function(e) {
      return this.defaultOptions.watchQuery && (e = Qu(this.defaultOptions.watchQuery, e)), this.disableNetworkFetches && (e.fetchPolicy === "network-only" || e.fetchPolicy === "cache-and-network") && (e = _e(_e({}, e), { fetchPolicy: "cache-first" })), this.queryManager.watchQuery(e);
    }, r.prototype.query = function(e) {
      return this.defaultOptions.query && (e = Qu(this.defaultOptions.query, e)), Ct(e.fetchPolicy !== "cache-and-network", 16), this.disableNetworkFetches && e.fetchPolicy === "network-only" && (e = _e(_e({}, e), { fetchPolicy: "cache-first" })), this.queryManager.query(e);
    }, r.prototype.mutate = function(e) {
      return this.defaultOptions.mutate && (e = Qu(this.defaultOptions.mutate, e)), this.queryManager.mutate(e);
    }, r.prototype.subscribe = function(e) {
      return this.queryManager.startGraphQLSubscription(e);
    }, r.prototype.readQuery = function(e, t) {
      return t === void 0 && (t = !1), this.cache.readQuery(e, t);
    }, r.prototype.readFragment = function(e, t) {
      return t === void 0 && (t = !1), this.cache.readFragment(e, t);
    }, r.prototype.writeQuery = function(e) {
      var t = this.cache.writeQuery(e);
      return e.broadcast !== !1 && this.queryManager.broadcastQueries(), t;
    }, r.prototype.writeFragment = function(e) {
      var t = this.cache.writeFragment(e);
      return e.broadcast !== !1 && this.queryManager.broadcastQueries(), t;
    }, r.prototype.__actionHookForDevTools = function(e) {
      this.devToolsHookCb = e;
    }, r.prototype.__requestRaw = function(e) {
      return Ic(this.link, e);
    }, r.prototype.resetStore = function() {
      var e = this;
      return Promise.resolve().then(function() {
        return e.queryManager.clearStore({
          discardWatches: !1
        });
      }).then(function() {
        return Promise.all(e.resetStoreCallbacks.map(function(t) {
          return t();
        }));
      }).then(function() {
        return e.reFetchObservableQueries();
      });
    }, r.prototype.clearStore = function() {
      var e = this;
      return Promise.resolve().then(function() {
        return e.queryManager.clearStore({
          discardWatches: !0
        });
      }).then(function() {
        return Promise.all(e.clearStoreCallbacks.map(function(t) {
          return t();
        }));
      });
    }, r.prototype.onResetStore = function(e) {
      var t = this;
      return this.resetStoreCallbacks.push(e), function() {
        t.resetStoreCallbacks = t.resetStoreCallbacks.filter(function(n) {
          return n !== e;
        });
      };
    }, r.prototype.onClearStore = function(e) {
      var t = this;
      return this.clearStoreCallbacks.push(e), function() {
        t.clearStoreCallbacks = t.clearStoreCallbacks.filter(function(n) {
          return n !== e;
        });
      };
    }, r.prototype.reFetchObservableQueries = function(e) {
      return this.queryManager.reFetchObservableQueries(e);
    }, r.prototype.refetchQueries = function(e) {
      var t = this.queryManager.refetchQueries(e), n = [], a = [];
      t.forEach(function(o, u) {
        n.push(u), a.push(o);
      });
      var i = Promise.all(a);
      return i.queries = n, i.results = a, i.catch(function(o) {
        globalThis.__DEV__ !== !1 && Ct.debug(17, o);
      }), i;
    }, r.prototype.getObservableQueries = function(e) {
      return e === void 0 && (e = "active"), this.queryManager.getObservableQueries(e);
    }, r.prototype.extract = function(e) {
      return this.cache.extract(e);
    }, r.prototype.restore = function(e) {
      return this.cache.restore(e);
    }, r.prototype.addResolvers = function(e) {
      this.localState.addResolvers(e);
    }, r.prototype.setResolvers = function(e) {
      this.localState.setResolvers(e);
    }, r.prototype.getResolvers = function() {
      return this.localState.getResolvers();
    }, r.prototype.setLocalStateFragmentMatcher = function(e) {
      this.localState.setFragmentMatcher(e);
    }, r.prototype.setLink = function(e) {
      this.link = this.queryManager.link = e;
    }, Object.defineProperty(r.prototype, "defaultContext", {
      get: function() {
        return this.queryManager.defaultContext;
      },
      enumerable: !1,
      configurable: !0
    }), r;
  }()
);
globalThis.__DEV__ !== !1 && (kb.prototype.getMemoryInternals = b_);
var uo = /* @__PURE__ */ new Map(), Lc = /* @__PURE__ */ new Map(), Ib = !0, _o = !1;
function Rb(r) {
  return r.replace(/[\s,]+/g, " ").trim();
}
function T5(r) {
  return Rb(r.source.body.substring(r.start, r.end));
}
function k5(r) {
  var e = /* @__PURE__ */ new Set(), t = [];
  return r.definitions.forEach(function(n) {
    if (n.kind === "FragmentDefinition") {
      var a = n.name.value, i = T5(n.loc), o = Lc.get(a);
      o && !o.has(i) ? Ib && console.warn("Warning: fragment with name " + a + ` already exists.
graphql-tag enforces all fragment names across your application to be unique; read more about
this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names`) : o || Lc.set(a, o = /* @__PURE__ */ new Set()), o.add(i), e.has(i) || (e.add(i), t.push(n));
    } else
      t.push(n);
  }), _e(_e({}, r), { definitions: t });
}
function I5(r) {
  var e = new Set(r.definitions);
  e.forEach(function(n) {
    n.loc && delete n.loc, Object.keys(n).forEach(function(a) {
      var i = n[a];
      i && typeof i == "object" && e.add(i);
    });
  });
  var t = r.loc;
  return t && (delete t.startToken, delete t.endToken), r;
}
function R5(r) {
  var e = Rb(r);
  if (!uo.has(e)) {
    var t = Ww(r, {
      experimentalFragmentVariables: _o,
      allowLegacyFragmentVariables: _o
    });
    if (!t || t.kind !== "Document")
      throw new Error("Not a valid GraphQL document.");
    uo.set(e, I5(k5(t)));
  }
  return uo.get(e);
}
function fr(r) {
  for (var e = [], t = 1; t < arguments.length; t++)
    e[t - 1] = arguments[t];
  typeof r == "string" && (r = [r]);
  var n = r[0];
  return e.forEach(function(a, i) {
    a && a.kind === "Document" ? n += a.loc.source.body : n += a, n += r[i + 1];
  }), R5(n);
}
function C5() {
  uo.clear(), Lc.clear();
}
function O5() {
  Ib = !1;
}
function B5() {
  _o = !0;
}
function P5() {
  _o = !1;
}
var Ki = {
  gql: fr,
  resetCaches: C5,
  disableFragmentWarnings: O5,
  enableExperimentalFragmentVariables: B5,
  disableExperimentalFragmentVariables: P5
};
(function(r) {
  r.gql = Ki.gql, r.resetCaches = Ki.resetCaches, r.disableFragmentWarnings = Ki.disableFragmentWarnings, r.enableExperimentalFragmentVariables = Ki.enableExperimentalFragmentVariables, r.disableExperimentalFragmentVariables = Ki.disableExperimentalFragmentVariables;
})(fr || (fr = {}));
fr.default = fr;
class D5 extends Fr {
  constructor(e) {
    super(e), this.$__query = fr`query ($bundle: String!) {
      ContinuId(bundle: $bundle) {
        address,
        bundleHash,
        tokenSlug,
        position,
        batchId,
        characters,
        pubkey,
        amount,
        createdAt
      }
    }`;
  }
  /**
   * Returns a Response object
   *
   * @param {object} json
   * @return {ResponseContinuId}
   */
  createResponse(e) {
    return new dw({
      query: this,
      json: e
    });
  }
}
class N5 extends Cr {
  /**
   * Class constructor
   *
   * @param {Query} query
   * @param {object} json
   */
  constructor({
    query: e,
    json: t
  }) {
    super({
      query: e,
      json: t,
      dataKey: "data.WalletBundle"
    });
  }
  /**
   * Returns a wallet bundle with normalized metadata
   *
   * @return {{}|null}
   */
  payload() {
    const e = this.data();
    if (!e || e.length === 0)
      return null;
    const t = {};
    return e.forEach((n) => {
      n.metas = lo.aggregateMeta(n.metas), t[n.bundleHash] = n;
    }), t;
  }
}
class q5 extends Fr {
  constructor(e) {
    super(e), this.$__query = fr`query( $bundleHashes: [ String! ] ) {
      WalletBundle( bundleHashes: $bundleHashes ) {
        bundleHash,
        metas {
          molecularHash,
          position,
          key,
          value,
          createdAt
        },
        createdAt
      }
    }`;
  }
  /**
   * Builds a Response object out of a JSON string
   *
   * @param {object} json
   * @return {ResponseWalletBundle}
   */
  createResponse(e) {
    return new N5({
      query: this,
      json: e
    });
  }
}
class Uo extends Cr {
  /**
   * Class constructor
   *
   * @param {Query} query
   * @param {object} json
   */
  constructor({
    query: e,
    json: t
  }) {
    super({
      query: e,
      json: t,
      dataKey: "data.Wallet"
    });
  }
  /**
   * Returns a Knish.IO client Wallet class instance out of object data
   *
   * @param {object} data
   * @param {string|null} secret
   * @return {Wallet}
   */
  static toClientWallet({
    data: e,
    secret: t = null
  }) {
    let n;
    if (e.position === null || typeof e.position == "undefined" ? n = tr.create({
      bundle: e.bundleHash,
      token: e.tokenSlug,
      batchId: e.batchId,
      characters: e.characters
    }) : (n = new tr({
      secret: t,
      token: e.tokenSlug,
      position: e.position,
      batchId: e.batchId,
      characters: e.characters
    }), n.address = e.address, n.bundle = e.bundleHash), e.token && (n.tokenName = e.token.name, n.tokenAmount = e.token.amount, n.tokenSupply = e.token.supply, n.tokenFungibility = e.token.fungibility), e.tokenUnits.length)
      for (const a of e.tokenUnits)
        n.tokenUnits.push(xi.createFromGraphQL(a));
    if (e.tradeRates.length)
      for (const a of e.tradeRates)
        n.tradeRates[a.tokenSlug] = a.amount;
    return n.balance = Number(e.amount), n.pubkey = e.pubkey, n.createdAt = e.createdAt, n;
  }
  /**
   * Returns a list of Wallet class instances
   *
   * @param secret
   * @return {null|[Wallet]}
   */
  getWallets(e = null) {
    const t = this.data();
    if (!t)
      return null;
    const n = [];
    for (const a of t)
      n.push(Uo.toClientWallet({
        data: a,
        secret: e
      }));
    return n;
  }
  /**
   * Returns response payload
   *
   * @return {null|[Wallet]}
   */
  payload() {
    return this.getWallets();
  }
}
class L5 extends Fr {
  constructor(e) {
    super(e), this.$__query = fr`query( $bundleHash: String, $tokenSlug: String ) {
      Wallet( bundleHash: $bundleHash, tokenSlug: $tokenSlug ) {
        address,
        bundleHash,
        token {
          name,
          amount,
          fungibility,
          supply
        },
        tokenSlug,
        batchId,
        position,
        amount,
        characters,
        pubkey,
        createdAt,
        tokenUnits {
          id,
          name,
          metas
        },
        tradeRates {
          tokenSlug,
          amount
        }
      }
    }`;
  }
  /**
   * Builds a Response object out of a JSON string
   *
   * @param {object} json
   * @return {ResponseWalletList}
   */
  createResponse(e) {
    return new Uo({
      query: this,
      json: e
    });
  }
}
class F5 extends Cr {
  /**
   * Class constructor
   *
   * @param {Query} query
   * @param {object} json
   */
  constructor({
    query: e,
    json: t
  }) {
    super({
      query: e,
      json: t,
      dataKey: "data.Balance"
    });
  }
  /**
   * Returns a wallet with balance
   *
   * @return {null|Wallet}
   */
  payload() {
    const e = this.data();
    return !e || !e.bundleHash || !e.tokenSlug ? null : Uo.toClientWallet({
      data: e
    });
  }
}
class U5 extends Fr {
  /**
   * Class constructor
   *
   * @param apolloClient
   */
  constructor(e) {
    super(e), this.$__query = fr`query( $address: String, $bundleHash: String, $type: String, $token: String, $position: String ) {
      Balance( address: $address, bundleHash: $bundleHash, type: $type, token: $token, position: $position ) {
        address,
        bundleHash,
        type,
        tokenSlug,
        batchId,
        position,
        amount,
        characters,
        pubkey,
        createdAt,
        tokenUnits {
          id,
          name,
          metas
        },
        tradeRates {
          tokenSlug,
          amount
        }
      }
    }`;
  }
  /**
   * @param {object} json
   * @return {ResponseBalance}
   */
  createResponse(e) {
    return new F5({
      query: this,
      json: e
    });
  }
}
class $5 extends Cr {
  /**
   * Class constructor
   *
   * @param {Query} query
   * @param {object} json
   */
  constructor({
    query: e,
    json: t
  }) {
    super({
      query: e,
      json: t,
      dataKey: "data.MetaType"
    });
  }
  /**
   * Returns meta type instance results
   *
   * @return {null|*}
   */
  payload() {
    const e = this.data();
    if (!e || e.length === 0)
      return null;
    const t = {
      instances: {},
      instanceCount: {},
      paginatorInfo: {}
    }, n = e.pop();
    return n.instances && (t.instances = n.instances), n.instanceCount && (t.instanceCount = n.instanceCount), n.paginatorInfo && (t.paginatorInfo = n.paginatorInfo), t;
  }
}
class rc extends Fr {
  /**
   * Class constructor
   *
   * @param apolloClient
   */
  constructor(e) {
    super(e), this.$__query = fr`query( $metaType: String, $metaTypes: [ String! ], $metaId: String, $metaIds: [ String! ], $key: String, $keys: [ String! ], $value: String, $values: [ String! ], $count: String, $latest: Boolean, $filter: [ MetaFilter! ], $latestMetas: Boolean, $queryArgs: QueryArgs, $countBy: String ) {
      MetaType( metaType: $metaType, metaTypes: $metaTypes, metaId: $metaId, metaIds: $metaIds, key: $key, keys: $keys, value: $value, values: $values, count: $count, filter: $filter, latestMetas: $latestMetas, queryArgs: $queryArgs, countBy: $countBy ) {
        metaType,
        instanceCount {
          key,
          value
        },
        instances {
          metaType,
          metaId,
          createdAt,
          metas(latest:$latest) {
            molecularHash,
            position,
            key,
            value,
            createdAt
          }
        },
        paginatorInfo {
          currentPage,
          total
        }
      }
    }`;
  }
  /**
   * Builds a GraphQL-friendly variables object based on input fields
   *
   * @param {string|array|null} metaType
   * @param {string|array|null} metaId
   * @param {string|array|null} key
   * @param {string|array|null} value
   * @param {boolean|null} latest
   * @param {boolean|null} latestMetas
   * @param {object|null} filter
   * @param {object|null} queryArgs
   * @param {string|null} count
   * @param {string|null} countBy
   * @return {{}}
   */
  static createVariables({
    metaType: e = null,
    metaId: t = null,
    key: n = null,
    value: a = null,
    latest: i = null,
    latestMetas: o = !0,
    filter: u = null,
    queryArgs: c = null,
    count: h = null,
    countBy: s = null
  }) {
    const d = {};
    return e && (d[typeof e == "string" ? "metaType" : "metaTypes"] = e), t && (d[typeof t == "string" ? "metaId" : "metaIds"] = t), n && (d[typeof n == "string" ? "key" : "keys"] = n), a && (d[typeof a == "string" ? "value" : "values"] = a), i && (d.latest = !!i), o && (d.latestMetas = !!o), u && (d.filter = u), c && ((typeof c.limit == "undefined" || c.limit === 0) && (c.limit = "*"), d.queryArgs = c), h && (d.count = h), s && (d.countBy = s), d;
  }
  /**
   * Returns a Response object
   *
   * @param {object} json
   * @return {ResponseMetaType}
   */
  createResponse(e) {
    return new $5({
      query: this,
      json: e
    });
  }
}
class pa extends Fr {
  constructor(e) {
    super(e), this.$__query = fr`query( $batchId: String ) {
      Batch( batchId: $batchId ) {
        ${pa.getFields()},
        children {
          ${pa.getFields()}
        }
      }
    }`;
  }
  static getFields() {
    return `batchId,
              molecularHash,
              type,
              status,
              createdAt,
              wallet {
                  address,
                  bundleHash,
                  amount,
                  tokenSlug,
                  token {
                      name,
                      amount
                  },
                  tokenUnits {
                      id,
                      name,
                      metas
                  }
              },
              fromWallet {
                  address,
                  bundleHash,
                  amount,
                  batchId
              },
              toWallet {
                  address,
                  bundleHash,
                  amount,
                  batchId
              },
              sourceTokenUnits {
                  id,
                  name,
                  metas
              },
              transferTokenUnits {
                  id,
                  name,
                  metas
              },
              metas {
                  key,
                  value,
              },
              throughMetas {
                  key,
                  value
              }`;
  }
  /**
   * Returns a Response object
   *
   * @param {object} json
   * @return {Response}
   */
  createResponse(e) {
    const t = new Cr({
      query: this,
      json: e
    });
    return t.dataKey = "data.Batch", t;
  }
}
class j5 extends Fr {
  constructor(e) {
    super(e), this.$__query = fr`query( $batchId: String ) {
      BatchHistory( batchId: $batchId ) {
        ${pa.getFields()}
      }
    }`;
  }
  /**
   * Returns a Response object
   *
   * @param {object} json
   * @return {Response}
   */
  createResponse(e) {
    const t = new Cr({
      query: this,
      json: e
    });
    return t.dataKey = "data.BatchHistory", t;
  }
}
class rn extends Cr {
  /**
   * Class constructor
   *
   * @param {MutationProposeMolecule} query
   * @param {object} json
   */
  constructor({
    query: e,
    json: t
  }) {
    super({
      query: e,
      json: t,
      dataKey: "data.ProposeMolecule"
    }), this.$__clientMolecule = e.molecule();
  }
  /**
   * Initialize response object with payload data
   */
  init() {
    const e = dr.get(this.data(), "payload");
    try {
      this.$__payload = Object.prototype.toString.call(e) === "[object String]" ? JSON.parse(e) : e;
    } catch (t) {
      this.$__payload = null;
    }
  }
  /**
   * Returns the client molecule
   */
  clientMolecule() {
    return this.$__clientMolecule;
  }
  /**
   * Returns the resulting molecule
   *
   * @return {Molecule|null}
   */
  molecule() {
    const e = this.data();
    if (!e)
      return null;
    const t = new mn({});
    return t.molecularHash = dr.get(e, "molecularHash"), t.status = dr.get(e, "status"), t.createdAt = dr.get(e, "createdAt"), t;
  }
  /**
   * Returns whether molecule was accepted or not
   *
   * @return {boolean}
   */
  success() {
    return this.status() === "accepted";
  }
  /**
   * Returns the status of the proposal
   *
   * @return {string}
   */
  status() {
    return dr.get(this.data(), "status", "rejected");
  }
  /**
   * Returns the reason for rejection
   *
   * @return {string}
   */
  reason() {
    return dr.get(this.data(), "reason", "Invalid response from server");
  }
  /**
   * Returns payload object
   *
   * @return {null}
   */
  payload() {
    return this.$__payload;
  }
}
class Dh extends Fr {
  /**
   *
   * @param {ApolloClient} apolloClient
   */
  constructor(e) {
    super(e);
  }
  /**
   * Creates a new Request for the given parameters
   *
   * @param {{}} variables
   * @returns {{variables: (Object|null), query: null}}
   */
  createQuery({ variables: e = null }) {
    const t = super.createQuery({ variables: e });
    return t.mutation = t.query, delete t.query, t;
  }
  /**
   * Sends the Query to a Knish.IO node and returns the Response
   *
   * @param variables
   * @returns {Promise<Response>}
   */
  execute(t) {
    return wt(this, arguments, function* ({ variables: e = null }) {
      this.$__request = this.createQuery({
        variables: e
      });
      const n = yield this.client.mutate(this.$__request);
      return this.$__response = yield this.createResponseRaw(n), this.$__response;
    });
  }
}
class kr extends Dh {
  /**
   *
   * @param {ApolloClient} apolloClient
   * @param molecule
   */
  constructor(e, t = null) {
    super(e), this.$__molecule = t, this.$__remainderWallet = null, this.$__query = fr`mutation( $molecule: MoleculeInput! ) {
      ProposeMolecule( molecule: $molecule ) {
        molecularHash,
        height,
        depth,
        status,
        reason,
        payload,
        createdAt,
        receivedAt,
        processedAt,
        broadcastedAt,
      }
    }`;
  }
  /**
   * Returns an object of query variables
   *
   * @param {object} variables
   * @return {object}
   */
  compiledVariables(e) {
    const t = super.compiledVariables(e);
    return Go(Wn({}, t), { molecule: this.molecule() });
  }
  /**
   * Creates a new response from a JSON string
   *
   * @param {object} json
   * @return {ResponseProposeMolecule}
   */
  createResponse(e) {
    return new rn({
      query: this,
      json: e
    });
  }
  /**
   * Executes the query
   *
   * @param {object} variables
   * @return {Promise}
   */
  execute(t) {
    return wt(this, arguments, function* ({ variables: e = null }) {
      return e = e || {}, e.molecule = this.molecule(), nl(kr.prototype, this, "execute").call(this, {
        variables: e
      });
    });
  }
  /**
   * Returns the remainder wallet
   *
   * @return {null}
   */
  remainderWallet() {
    return this.$__remainderWallet;
  }
  /**
   * Returns the molecule we are proposing
   *
   * @return {Molecule}
   */
  molecule() {
    return this.$__molecule;
  }
}
class H5 extends rn {
  /**
   * return the authorization key
   *
   * @param key
   * @return {*}
   */
  payloadKey(e) {
    if (!dr.has(this.payload(), e))
      throw new Zi(`ResponseRequestAuthorization::payloadKey() - '${e}' key was not found in the payload!`);
    return dr.get(this.payload(), e);
  }
  /**
   * Returns the auth token
   *
   * @return {string}
   */
  token() {
    return this.payloadKey("token");
  }
  /**
   * Returns timestamp
   *
   * @return {string}
   */
  time() {
    return this.payloadKey("time");
  }
  /**
   *
   * @return {string}
   */
  encrypt() {
    return this.payloadKey("encrypt");
  }
  /**
   *
   * @return {string}
   */
  pubKey() {
    return this.payloadKey("key");
  }
}
class z5 extends kr {
  /**
   *
   * @param {object} meta
   */
  fillMolecule({ meta: e }) {
    this.$__molecule.initAuthorization({ meta: e }), this.$__molecule.sign({}), this.$__molecule.check();
  }
  /**
   * Returns a Response object
   *
   * @param {object} json
   * @return {ResponseRequestAuthorization}
   */
  createResponse(e) {
    return new H5({
      query: this,
      json: e
    });
  }
}
class V5 extends rn {
}
class W5 extends kr {
  fillMolecule({
    recipientWallet: e,
    amount: t,
    meta: n = null
  }) {
    this.$__molecule.initTokenCreation({
      recipientWallet: e,
      amount: t,
      meta: n || {}
    }), this.$__molecule.sign({
      bundle: e.bundle
    }), this.$__molecule.check();
  }
  /**
   * Builds a new Response object from a JSON string
   *
   * @param {object} json
   * @return {ResponseCreateToken}
   */
  createResponse(e) {
    return new V5({
      query: this,
      json: e
    });
  }
}
class K5 extends rn {
}
class Q5 extends kr {
  /**
   * Fills a Molecule with the appropriate atoms and prepares for broadcast
   *
   * @param {string} token
   * @param {Number} amount
   * @param {string} metaType
   * @param {string} metaId
   * @param {object} meta
   * @param {string|null} batchId
   */
  fillMolecule({
    token: e,
    amount: t,
    metaType: n,
    metaId: a,
    meta: i = null,
    batchId: o = null
  }) {
    this.$__molecule.initTokenRequest({
      token: e,
      amount: t,
      metaType: n,
      metaId: a,
      meta: i || {},
      batchId: o
    }), this.$__molecule.sign({}), this.$__molecule.check();
  }
  /**
   * Builds a Response object out of a JSON string
   *
   * @param {object} json
   * @return {ResponseRequestTokens}
   */
  createResponse(e) {
    return new K5({
      query: this,
      json: e
    });
  }
}
class G5 extends rn {
  /**
   * Returns result of the transfer
   *
   * @return {{reason: null, status: null}}
   */
  payload() {
    const e = {
      reason: null,
      status: null
    }, t = this.data();
    return e.reason = typeof t.reason == "undefined" ? "Invalid response from server" : t.reason, e.status = typeof t.status == "undefined" ? "rejected" : t.status, e;
  }
}
class J5 extends kr {
  /**
   * Fills the Molecule with provided wallet and amount data
   *
   * @param recipientWallet
   * @param amount
   */
  fillMolecule({
    recipientWallet: e,
    amount: t
  }) {
    this.$__molecule.initValue({
      recipientWallet: e,
      amount: t
    }), this.$__molecule.sign({}), this.$__molecule.check(this.$__molecule.sourceWallet);
  }
  /**
   * Builds a Response object out of a JSON string
   *
   * @param {object} json
   * @return {ResponseTransferTokens}
   */
  createResponse(e) {
    return new G5({
      query: this,
      json: e
    });
  }
}
class Y5 extends rn {
}
class X5 extends kr {
  fillMolecule({
    type: e,
    contact: t,
    code: n
  }) {
    this.$__molecule.initIdentifierCreation({
      type: e,
      contact: t,
      code: n
    }), this.$__molecule.sign({}), this.$__molecule.check();
  }
  /**
   * Builds a Response object out of a JSON string
   *
   * @param {object} json
   * @return {ResponseCreateIdentifier}
   */
  createResponse(e) {
    return new Y5({
      query: this,
      json: e
    });
  }
}
class Z5 extends rn {
}
class e8 extends kr {
  /**
   * Class constructor
   *
   * @param {string} token
   * @param {string|null} batchId
   */
  fillMolecule({
    token: e,
    batchId: t = null
  }) {
    const n = tr.create({
      secret: this.$__molecule.secret,
      bundle: this.$__molecule.bundle,
      token: e,
      batchId: t
    });
    this.$__molecule.initShadowWalletClaim(n), this.$__molecule.sign({}), this.$__molecule.check();
  }
  /**
   * Builds a Response object out of a JSON string
   *
   * @param {object} json
   * @return {ResponseClaimShadowWallet}
   */
  createResponse(e) {
    return new Z5({
      query: this,
      json: e
    });
  }
}
class t8 extends rn {
}
class r8 extends kr {
  /**
   * Fills a molecule with an appropriate metadata atom
   *
   * @param {string} metaType
   * @param {string} metaId
   * @param {array|object} meta
   * @param {object} policy
   */
  fillMolecule({
    metaType: e,
    metaId: t,
    meta: n,
    policy: a
  }) {
    this.$__molecule.initMeta({
      meta: n,
      metaType: e,
      metaId: t,
      policy: a
    }), this.$__molecule.sign({}), this.$__molecule.check();
  }
  /**
   * Builds a new Response object from a JSON string
   *
   * @param {object} json
   * @return {ResponseCreateMeta}
   */
  createResponse(e) {
    return new t8({
      query: this,
      json: e
    });
  }
}
class n8 extends rn {
}
class i8 extends kr {
  fillMolecule(e) {
    this.$__molecule.initWalletCreation(e), this.$__molecule.sign({}), this.$__molecule.check();
  }
  /**
   * Returns a Response object
   *
   * @param {object} json
   * @return {ResponseCreateWallet}
   */
  createResponse(e) {
    return new n8({
      query: this,
      json: e
    });
  }
}
class a8 extends Cr {
  /**
   * Class constructor
   *
   * @param {MutationRequestAuthorizationGuest} query
   * @param json
   */
  constructor({
    query: e,
    json: t
  }) {
    super({
      query: e,
      json: t,
      dataKey: "data.AccessToken"
    });
  }
  /**
   * Returns the reason for rejection
   *
   * @return {string}
   */
  reason() {
    return "Invalid response from server";
  }
  /**
   * Returns whether molecule was accepted or not
   *
   * @return {boolean}
   */
  success() {
    return this.payload() !== null;
  }
  /**
   * Returns a wallet with balance
   *
   * @return {null|Wallet}
   */
  payload() {
    return this.data();
  }
  /**
   * Returns the authorization key
   *
   * @param key
   * @return {*}
   */
  payloadKey(e) {
    if (!dr.has(this.payload(), e))
      throw new Zi(`ResponseAuthorizationGuest::payloadKey() - '${e}' key is not found in the payload!`);
    return dr.get(this.payload(), e);
  }
  /**
   * Returns the auth token
   *
   * @return {*}
   */
  token() {
    return this.payloadKey("token");
  }
  /**
   * Returns timestamp
   *
   * @return {*}
   */
  time() {
    return this.payloadKey("time");
  }
  /**
   * Returns timestamp
   *
   * @return {string}
   */
  pubKey() {
    return this.payloadKey("key");
  }
  /**
   *
   * @return {string}
   */
  encrypt() {
    return this.payloadKey("encrypt");
  }
}
class o8 extends Dh {
  /**
   * Class constructor
   *
   * @param apolloClient
   */
  constructor(e) {
    super(e), this.$__query = fr`mutation( $cellSlug: String, $pubkey: String, $encrypt: Boolean ) {
      AccessToken( cellSlug: $cellSlug, pubkey: $pubkey, encrypt: $encrypt ) {
        token,
        pubkey,
        expiresAt
      }
    }`;
  }
  /**
   * Returns a Response object
   *
   * @param {object} json
   * @return {ResponseRequestAuthorizationGuest}
   */
  createResponse(e) {
    return new a8({
      query: this,
      json: e
    });
  }
}
class Dv extends sr {
  /**
   * Class constructor
   *
   * @param {string} message
   * @param {string|null} fileName
   * @param {number|null} lineNumber
   */
  constructor(e = "The shadow wallet does not exist", t = null, n = null) {
    super(e, t, n), this.name = "WalletShadowException";
  }
}
class s8 extends sr {
  /**
   * Class constructor
   *
   * @param {string} message
   * @param {string|null} fileName
   * @param {number|null} lineNumber
   */
  constructor(e = "Stackable tokens with unit IDs cannot have decimal places!", t = null, n = null) {
    super(e, t, n), this.name = "StackableUnitDecimalsException";
  }
}
class Ga extends sr {
  /**
   * Class constructor
   *
   * @param {string} message
   * @param {string|null} fileName
   * @param {number|null} lineNumber
   */
  constructor(e = "Stackable tokens with unit IDs cannot have an amount!", t = null, n = null) {
    super(e, t, n), this.name = "StackableUnitAmountException";
  }
}
function Cb(r) {
  return r.query.definitions.find((n) => n.kind === "OperationDefinition").selectionSet.selections.find((n) => n.kind === "Field").name.value;
}
function f8(r) {
  return r.query.definitions.find((t) => t.kind === "OperationDefinition").operation;
}
function u8({
  graphQLErrors: r,
  networkError: e,
  operation: t,
  forward: n,
  response: a
}) {
  if (r && r.map(({
    message: i,
    debugMessage: o,
    locations: u,
    path: c
  }) => console.error(
    `[GraphQL error]: ${i}\r
`,
    `  Message : ${o}\r
`,
    `  Path    : ${c}\r
`,
    `  Location: ${u}\r
`
  )), e) {
    const {
      name: i,
      statusCode: o,
      result: u = {}
    } = e;
    console.error(`[Network error]: ${i}, status code: ${o}`);
  }
}
var Pr = typeof globalThis != "undefined" && globalThis || typeof self != "undefined" && self || typeof Pr != "undefined" && Pr, qr = {
  searchParams: "URLSearchParams" in Pr,
  iterable: "Symbol" in Pr && "iterator" in Symbol,
  blob: "FileReader" in Pr && "Blob" in Pr && function() {
    try {
      return new Blob(), !0;
    } catch (r) {
      return !1;
    }
  }(),
  formData: "FormData" in Pr,
  arrayBuffer: "ArrayBuffer" in Pr
};
function c8(r) {
  return r && DataView.prototype.isPrototypeOf(r);
}
if (qr.arrayBuffer)
  var h8 = [
    "[object Int8Array]",
    "[object Uint8Array]",
    "[object Uint8ClampedArray]",
    "[object Int16Array]",
    "[object Uint16Array]",
    "[object Int32Array]",
    "[object Uint32Array]",
    "[object Float32Array]",
    "[object Float64Array]"
  ], l8 = ArrayBuffer.isView || function(r) {
    return r && h8.indexOf(Object.prototype.toString.call(r)) > -1;
  };
function Ma(r) {
  if (typeof r != "string" && (r = String(r)), /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(r) || r === "")
    throw new TypeError('Invalid character in header field name: "' + r + '"');
  return r.toLowerCase();
}
function Nh(r) {
  return typeof r != "string" && (r = String(r)), r;
}
function qh(r) {
  var e = {
    next: function() {
      var t = r.shift();
      return { done: t === void 0, value: t };
    }
  };
  return qr.iterable && (e[Symbol.iterator] = function() {
    return e;
  }), e;
}
function _r(r) {
  this.map = {}, r instanceof _r ? r.forEach(function(e, t) {
    this.append(t, e);
  }, this) : Array.isArray(r) ? r.forEach(function(e) {
    this.append(e[0], e[1]);
  }, this) : r && Object.getOwnPropertyNames(r).forEach(function(e) {
    this.append(e, r[e]);
  }, this);
}
_r.prototype.append = function(r, e) {
  r = Ma(r), e = Nh(e);
  var t = this.map[r];
  this.map[r] = t ? t + ", " + e : e;
};
_r.prototype.delete = function(r) {
  delete this.map[Ma(r)];
};
_r.prototype.get = function(r) {
  return r = Ma(r), this.has(r) ? this.map[r] : null;
};
_r.prototype.has = function(r) {
  return this.map.hasOwnProperty(Ma(r));
};
_r.prototype.set = function(r, e) {
  this.map[Ma(r)] = Nh(e);
};
_r.prototype.forEach = function(r, e) {
  for (var t in this.map)
    this.map.hasOwnProperty(t) && r.call(e, this.map[t], t, this);
};
_r.prototype.keys = function() {
  var r = [];
  return this.forEach(function(e, t) {
    r.push(t);
  }), qh(r);
};
_r.prototype.values = function() {
  var r = [];
  return this.forEach(function(e) {
    r.push(e);
  }), qh(r);
};
_r.prototype.entries = function() {
  var r = [];
  return this.forEach(function(e, t) {
    r.push([t, e]);
  }), qh(r);
};
qr.iterable && (_r.prototype[Symbol.iterator] = _r.prototype.entries);
function nc(r) {
  if (r.bodyUsed)
    return Promise.reject(new TypeError("Already read"));
  r.bodyUsed = !0;
}
function Ob(r) {
  return new Promise(function(e, t) {
    r.onload = function() {
      e(r.result);
    }, r.onerror = function() {
      t(r.error);
    };
  });
}
function d8(r) {
  var e = new FileReader(), t = Ob(e);
  return e.readAsArrayBuffer(r), t;
}
function p8(r) {
  var e = new FileReader(), t = Ob(e);
  return e.readAsText(r), t;
}
function v8(r) {
  for (var e = new Uint8Array(r), t = new Array(e.length), n = 0; n < e.length; n++)
    t[n] = String.fromCharCode(e[n]);
  return t.join("");
}
function Nv(r) {
  if (r.slice)
    return r.slice(0);
  var e = new Uint8Array(r.byteLength);
  return e.set(new Uint8Array(r)), e.buffer;
}
function Bb() {
  return this.bodyUsed = !1, this._initBody = function(r) {
    this.bodyUsed = this.bodyUsed, this._bodyInit = r, r ? typeof r == "string" ? this._bodyText = r : qr.blob && Blob.prototype.isPrototypeOf(r) ? this._bodyBlob = r : qr.formData && FormData.prototype.isPrototypeOf(r) ? this._bodyFormData = r : qr.searchParams && URLSearchParams.prototype.isPrototypeOf(r) ? this._bodyText = r.toString() : qr.arrayBuffer && qr.blob && c8(r) ? (this._bodyArrayBuffer = Nv(r.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : qr.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(r) || l8(r)) ? this._bodyArrayBuffer = Nv(r) : this._bodyText = r = Object.prototype.toString.call(r) : this._bodyText = "", this.headers.get("content-type") || (typeof r == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : qr.searchParams && URLSearchParams.prototype.isPrototypeOf(r) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
  }, qr.blob && (this.blob = function() {
    var r = nc(this);
    if (r)
      return r;
    if (this._bodyBlob)
      return Promise.resolve(this._bodyBlob);
    if (this._bodyArrayBuffer)
      return Promise.resolve(new Blob([this._bodyArrayBuffer]));
    if (this._bodyFormData)
      throw new Error("could not read FormData body as blob");
    return Promise.resolve(new Blob([this._bodyText]));
  }, this.arrayBuffer = function() {
    if (this._bodyArrayBuffer) {
      var r = nc(this);
      return r || (ArrayBuffer.isView(this._bodyArrayBuffer) ? Promise.resolve(
        this._bodyArrayBuffer.buffer.slice(
          this._bodyArrayBuffer.byteOffset,
          this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
        )
      ) : Promise.resolve(this._bodyArrayBuffer));
    } else
      return this.blob().then(d8);
  }), this.text = function() {
    var r = nc(this);
    if (r)
      return r;
    if (this._bodyBlob)
      return p8(this._bodyBlob);
    if (this._bodyArrayBuffer)
      return Promise.resolve(v8(this._bodyArrayBuffer));
    if (this._bodyFormData)
      throw new Error("could not read FormData body as text");
    return Promise.resolve(this._bodyText);
  }, qr.formData && (this.formData = function() {
    return this.text().then(m8);
  }), this.json = function() {
    return this.text().then(JSON.parse);
  }, this;
}
var y8 = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
function b8(r) {
  var e = r.toUpperCase();
  return y8.indexOf(e) > -1 ? e : r;
}
function ai(r, e) {
  if (!(this instanceof ai))
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  e = e || {};
  var t = e.body;
  if (r instanceof ai) {
    if (r.bodyUsed)
      throw new TypeError("Already read");
    this.url = r.url, this.credentials = r.credentials, e.headers || (this.headers = new _r(r.headers)), this.method = r.method, this.mode = r.mode, this.signal = r.signal, !t && r._bodyInit != null && (t = r._bodyInit, r.bodyUsed = !0);
  } else
    this.url = String(r);
  if (this.credentials = e.credentials || this.credentials || "same-origin", (e.headers || !this.headers) && (this.headers = new _r(e.headers)), this.method = b8(e.method || this.method || "GET"), this.mode = e.mode || this.mode || null, this.signal = e.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && t)
    throw new TypeError("Body not allowed for GET or HEAD requests");
  if (this._initBody(t), (this.method === "GET" || this.method === "HEAD") && (e.cache === "no-store" || e.cache === "no-cache")) {
    var n = /([?&])_=[^&]*/;
    if (n.test(this.url))
      this.url = this.url.replace(n, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
    else {
      var a = /\?/;
      this.url += (a.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
    }
  }
}
ai.prototype.clone = function() {
  return new ai(this, { body: this._bodyInit });
};
function m8(r) {
  var e = new FormData();
  return r.trim().split("&").forEach(function(t) {
    if (t) {
      var n = t.split("="), a = n.shift().replace(/\+/g, " "), i = n.join("=").replace(/\+/g, " ");
      e.append(decodeURIComponent(a), decodeURIComponent(i));
    }
  }), e;
}
function g8(r) {
  var e = new _r(), t = r.replace(/\r?\n[\t ]+/g, " ");
  return t.split("\r").map(function(n) {
    return n.indexOf(`
`) === 0 ? n.substr(1, n.length) : n;
  }).forEach(function(n) {
    var a = n.split(":"), i = a.shift().trim();
    if (i) {
      var o = a.join(":").trim();
      e.append(i, o);
    }
  }), e;
}
Bb.call(ai.prototype);
function ln(r, e) {
  if (!(this instanceof ln))
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  e || (e = {}), this.type = "default", this.status = e.status === void 0 ? 200 : e.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = e.statusText === void 0 ? "" : "" + e.statusText, this.headers = new _r(e.headers), this.url = e.url || "", this._initBody(r);
}
Bb.call(ln.prototype);
ln.prototype.clone = function() {
  return new ln(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new _r(this.headers),
    url: this.url
  });
};
ln.error = function() {
  var r = new ln(null, { status: 0, statusText: "" });
  return r.type = "error", r;
};
var w8 = [301, 302, 303, 307, 308];
ln.redirect = function(r, e) {
  if (w8.indexOf(e) === -1)
    throw new RangeError("Invalid status code");
  return new ln(null, { status: e, headers: { location: r } });
};
var ei = Pr.DOMException;
try {
  new ei();
} catch (r) {
  ei = function(e, t) {
    this.message = e, this.name = t;
    var n = Error(e);
    this.stack = n.stack;
  }, ei.prototype = Object.create(Error.prototype), ei.prototype.constructor = ei;
}
function Pb(r, e) {
  return new Promise(function(t, n) {
    var a = new ai(r, e);
    if (a.signal && a.signal.aborted)
      return n(new ei("Aborted", "AbortError"));
    var i = new XMLHttpRequest();
    function o() {
      i.abort();
    }
    i.onload = function() {
      var c = {
        status: i.status,
        statusText: i.statusText,
        headers: g8(i.getAllResponseHeaders() || "")
      };
      c.url = "responseURL" in i ? i.responseURL : c.headers.get("X-Request-URL");
      var h = "response" in i ? i.response : i.responseText;
      setTimeout(function() {
        t(new ln(h, c));
      }, 0);
    }, i.onerror = function() {
      setTimeout(function() {
        n(new TypeError("Network request failed"));
      }, 0);
    }, i.ontimeout = function() {
      setTimeout(function() {
        n(new TypeError("Network request failed"));
      }, 0);
    }, i.onabort = function() {
      setTimeout(function() {
        n(new ei("Aborted", "AbortError"));
      }, 0);
    };
    function u(c) {
      try {
        return c === "" && Pr.location.href ? Pr.location.href : c;
      } catch (h) {
        return c;
      }
    }
    i.open(a.method, u(a.url), !0), a.credentials === "include" ? i.withCredentials = !0 : a.credentials === "omit" && (i.withCredentials = !1), "responseType" in i && (qr.blob ? i.responseType = "blob" : qr.arrayBuffer && a.headers.get("Content-Type") && a.headers.get("Content-Type").indexOf("application/octet-stream") !== -1 && (i.responseType = "arraybuffer")), e && typeof e.headers == "object" && !(e.headers instanceof _r) ? Object.getOwnPropertyNames(e.headers).forEach(function(c) {
      i.setRequestHeader(c, Nh(e.headers[c]));
    }) : a.headers.forEach(function(c, h) {
      i.setRequestHeader(h, c);
    }), a.signal && (a.signal.addEventListener("abort", o), i.onreadystatechange = function() {
      i.readyState === 4 && a.signal.removeEventListener("abort", o);
    }), i.send(typeof a._bodyInit == "undefined" ? null : a._bodyInit);
  });
}
Pb.polyfill = !0;
Pr.fetch || (Pr.fetch = Pb, Pr.Headers = _r, Pr.Request = ai, Pr.Response = ln);
var _8 = self.fetch.bind(self);
const x8 = /* @__PURE__ */ ki(_8);
function Db(r) {
  return new Qr(function(e, t) {
    return new or(function(n) {
      var a, i, o;
      try {
        a = t(e).subscribe({
          next: function(u) {
            if (u.errors && (o = r({
              graphQLErrors: u.errors,
              response: u,
              operation: e,
              forward: t
            }), o)) {
              i = o.subscribe({
                next: n.next.bind(n),
                error: n.error.bind(n),
                complete: n.complete.bind(n)
              });
              return;
            }
            n.next(u);
          },
          error: function(u) {
            if (o = r({
              operation: e,
              networkError: u,
              //Network errors can return GraphQL errors on for example a 403
              graphQLErrors: u && u.result && u.result.errors,
              forward: t
            }), o) {
              i = o.subscribe({
                next: n.next.bind(n),
                error: n.error.bind(n),
                complete: n.complete.bind(n)
              });
              return;
            }
            n.error(u);
          },
          complete: function() {
            o || n.complete.bind(n)();
          }
        });
      } catch (u) {
        r({ networkError: u, operation: e, forward: t }), n.error(u);
      }
      return function() {
        a && a.unsubscribe(), i && a.unsubscribe();
      };
    });
  });
}
(function(r) {
  tn(e, r);
  function e(t) {
    var n = r.call(this) || this;
    return n.link = Db(t), n;
  }
  return e.prototype.request = function(t, n) {
    return this.link.request(t, n);
  }, e;
})(Qr);
class S8 extends cb {
  constructor(e) {
    super(e);
  }
  /**
   *
   * @param {Operation} operation
   * @param {NextLink | undefined} forward
   * @returns {Observable<FetchResult> | null}
   */
  request(e, t) {
    return t(e);
  }
}
var Nb = { exports: {} };
/*!
 * Pusher JavaScript Library v7.6.0
 * https://pusher.com/
 *
 * Copyright 2020, Pusher
 * Released under the MIT licence.
 */
(function(r, e) {
  (function(n, a) {
    r.exports = a();
  })(window, function() {
    return (
      /******/
      function(t) {
        var n = {};
        function a(i) {
          if (n[i])
            return n[i].exports;
          var o = n[i] = {
            /******/
            i,
            /******/
            l: !1,
            /******/
            exports: {}
            /******/
          };
          return t[i].call(o.exports, o, o.exports, a), o.l = !0, o.exports;
        }
        return a.m = t, a.c = n, a.d = function(i, o, u) {
          a.o(i, o) || Object.defineProperty(i, o, { enumerable: !0, get: u });
        }, a.r = function(i) {
          typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(i, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(i, "__esModule", { value: !0 });
        }, a.t = function(i, o) {
          if (o & 1 && (i = a(i)), o & 8 || o & 4 && typeof i == "object" && i && i.__esModule)
            return i;
          var u = /* @__PURE__ */ Object.create(null);
          if (a.r(u), Object.defineProperty(u, "default", { enumerable: !0, value: i }), o & 2 && typeof i != "string")
            for (var c in i)
              a.d(u, c, function(h) {
                return i[h];
              }.bind(null, c));
          return u;
        }, a.n = function(i) {
          var o = i && i.__esModule ? (
            /******/
            function() {
              return i.default;
            }
          ) : (
            /******/
            function() {
              return i;
            }
          );
          return a.d(o, "a", o), o;
        }, a.o = function(i, o) {
          return Object.prototype.hasOwnProperty.call(i, o);
        }, a.p = "", a(a.s = 2);
      }([
        /* 0 */
        /***/
        function(t, n, a) {
          var i = this && this.__extends || /* @__PURE__ */ function() {
            var w = function(E, S) {
              return w = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(P, L) {
                P.__proto__ = L;
              } || function(P, L) {
                for (var U in L)
                  L.hasOwnProperty(U) && (P[U] = L[U]);
              }, w(E, S);
            };
            return function(E, S) {
              w(E, S);
              function P() {
                this.constructor = E;
              }
              E.prototype = S === null ? Object.create(S) : (P.prototype = S.prototype, new P());
            };
          }();
          Object.defineProperty(n, "__esModule", { value: !0 });
          var o = 256, u = (
            /** @class */
            function() {
              function w(E) {
                E === void 0 && (E = "="), this._paddingCharacter = E;
              }
              return w.prototype.encodedLength = function(E) {
                return this._paddingCharacter ? (E + 2) / 3 * 4 | 0 : (E * 8 + 5) / 6 | 0;
              }, w.prototype.encode = function(E) {
                for (var S = "", P = 0; P < E.length - 2; P += 3) {
                  var L = E[P] << 16 | E[P + 1] << 8 | E[P + 2];
                  S += this._encodeByte(L >>> 3 * 6 & 63), S += this._encodeByte(L >>> 2 * 6 & 63), S += this._encodeByte(L >>> 1 * 6 & 63), S += this._encodeByte(L >>> 0 * 6 & 63);
                }
                var U = E.length - P;
                if (U > 0) {
                  var L = E[P] << 16 | (U === 2 ? E[P + 1] << 8 : 0);
                  S += this._encodeByte(L >>> 3 * 6 & 63), S += this._encodeByte(L >>> 2 * 6 & 63), U === 2 ? S += this._encodeByte(L >>> 1 * 6 & 63) : S += this._paddingCharacter || "", S += this._paddingCharacter || "";
                }
                return S;
              }, w.prototype.maxDecodedLength = function(E) {
                return this._paddingCharacter ? E / 4 * 3 | 0 : (E * 6 + 7) / 8 | 0;
              }, w.prototype.decodedLength = function(E) {
                return this.maxDecodedLength(E.length - this._getPaddingLength(E));
              }, w.prototype.decode = function(E) {
                if (E.length === 0)
                  return new Uint8Array(0);
                for (var S = this._getPaddingLength(E), P = E.length - S, L = new Uint8Array(this.maxDecodedLength(P)), U = 0, z = 0, K = 0, re = 0, oe = 0, se = 0, ve = 0; z < P - 4; z += 4)
                  re = this._decodeChar(E.charCodeAt(z + 0)), oe = this._decodeChar(E.charCodeAt(z + 1)), se = this._decodeChar(E.charCodeAt(z + 2)), ve = this._decodeChar(E.charCodeAt(z + 3)), L[U++] = re << 2 | oe >>> 4, L[U++] = oe << 4 | se >>> 2, L[U++] = se << 6 | ve, K |= re & o, K |= oe & o, K |= se & o, K |= ve & o;
                if (z < P - 1 && (re = this._decodeChar(E.charCodeAt(z)), oe = this._decodeChar(E.charCodeAt(z + 1)), L[U++] = re << 2 | oe >>> 4, K |= re & o, K |= oe & o), z < P - 2 && (se = this._decodeChar(E.charCodeAt(z + 2)), L[U++] = oe << 4 | se >>> 2, K |= se & o), z < P - 3 && (ve = this._decodeChar(E.charCodeAt(z + 3)), L[U++] = se << 6 | ve, K |= ve & o), K !== 0)
                  throw new Error("Base64Coder: incorrect characters for decoding");
                return L;
              }, w.prototype._encodeByte = function(E) {
                var S = E;
                return S += 65, S += 25 - E >>> 8 & 6, S += 51 - E >>> 8 & -75, S += 61 - E >>> 8 & -15, S += 62 - E >>> 8 & 3, String.fromCharCode(S);
              }, w.prototype._decodeChar = function(E) {
                var S = o;
                return S += (42 - E & E - 44) >>> 8 & -o + E - 43 + 62, S += (46 - E & E - 48) >>> 8 & -o + E - 47 + 63, S += (47 - E & E - 58) >>> 8 & -o + E - 48 + 52, S += (64 - E & E - 91) >>> 8 & -o + E - 65 + 0, S += (96 - E & E - 123) >>> 8 & -o + E - 97 + 26, S;
              }, w.prototype._getPaddingLength = function(E) {
                var S = 0;
                if (this._paddingCharacter) {
                  for (var P = E.length - 1; P >= 0 && E[P] === this._paddingCharacter; P--)
                    S++;
                  if (E.length < 4 || S > 2)
                    throw new Error("Base64Coder: incorrect padding");
                }
                return S;
              }, w;
            }()
          );
          n.Coder = u;
          var c = new u();
          function h(w) {
            return c.encode(w);
          }
          n.encode = h;
          function s(w) {
            return c.decode(w);
          }
          n.decode = s;
          var d = (
            /** @class */
            function(w) {
              i(E, w);
              function E() {
                return w !== null && w.apply(this, arguments) || this;
              }
              return E.prototype._encodeByte = function(S) {
                var P = S;
                return P += 65, P += 25 - S >>> 8 & 6, P += 51 - S >>> 8 & -75, P += 61 - S >>> 8 & -13, P += 62 - S >>> 8 & 49, String.fromCharCode(P);
              }, E.prototype._decodeChar = function(S) {
                var P = o;
                return P += (44 - S & S - 46) >>> 8 & -o + S - 45 + 62, P += (94 - S & S - 96) >>> 8 & -o + S - 95 + 63, P += (47 - S & S - 58) >>> 8 & -o + S - 48 + 52, P += (64 - S & S - 91) >>> 8 & -o + S - 65 + 0, P += (96 - S & S - 123) >>> 8 & -o + S - 97 + 26, P;
              }, E;
            }(u)
          );
          n.URLSafeCoder = d;
          var l = new d();
          function y(w) {
            return l.encode(w);
          }
          n.encodeURLSafe = y;
          function m(w) {
            return l.decode(w);
          }
          n.decodeURLSafe = m, n.encodedLength = function(w) {
            return c.encodedLength(w);
          }, n.maxDecodedLength = function(w) {
            return c.maxDecodedLength(w);
          }, n.decodedLength = function(w) {
            return c.decodedLength(w);
          };
        },
        /* 1 */
        /***/
        function(t, n, a) {
          Object.defineProperty(n, "__esModule", { value: !0 });
          var i = "utf8: invalid string", o = "utf8: invalid source encoding";
          function u(s) {
            for (var d = new Uint8Array(c(s)), l = 0, y = 0; y < s.length; y++) {
              var m = s.charCodeAt(y);
              m < 128 ? d[l++] = m : m < 2048 ? (d[l++] = 192 | m >> 6, d[l++] = 128 | m & 63) : m < 55296 ? (d[l++] = 224 | m >> 12, d[l++] = 128 | m >> 6 & 63, d[l++] = 128 | m & 63) : (y++, m = (m & 1023) << 10, m |= s.charCodeAt(y) & 1023, m += 65536, d[l++] = 240 | m >> 18, d[l++] = 128 | m >> 12 & 63, d[l++] = 128 | m >> 6 & 63, d[l++] = 128 | m & 63);
            }
            return d;
          }
          n.encode = u;
          function c(s) {
            for (var d = 0, l = 0; l < s.length; l++) {
              var y = s.charCodeAt(l);
              if (y < 128)
                d += 1;
              else if (y < 2048)
                d += 2;
              else if (y < 55296)
                d += 3;
              else if (y <= 57343) {
                if (l >= s.length - 1)
                  throw new Error(i);
                l++, d += 4;
              } else
                throw new Error(i);
            }
            return d;
          }
          n.encodedLength = c;
          function h(s) {
            for (var d = [], l = 0; l < s.length; l++) {
              var y = s[l];
              if (y & 128) {
                var m = void 0;
                if (y < 224) {
                  if (l >= s.length)
                    throw new Error(o);
                  var w = s[++l];
                  if ((w & 192) !== 128)
                    throw new Error(o);
                  y = (y & 31) << 6 | w & 63, m = 128;
                } else if (y < 240) {
                  if (l >= s.length - 1)
                    throw new Error(o);
                  var w = s[++l], E = s[++l];
                  if ((w & 192) !== 128 || (E & 192) !== 128)
                    throw new Error(o);
                  y = (y & 15) << 12 | (w & 63) << 6 | E & 63, m = 2048;
                } else if (y < 248) {
                  if (l >= s.length - 2)
                    throw new Error(o);
                  var w = s[++l], E = s[++l], S = s[++l];
                  if ((w & 192) !== 128 || (E & 192) !== 128 || (S & 192) !== 128)
                    throw new Error(o);
                  y = (y & 15) << 18 | (w & 63) << 12 | (E & 63) << 6 | S & 63, m = 65536;
                } else
                  throw new Error(o);
                if (y < m || y >= 55296 && y <= 57343)
                  throw new Error(o);
                if (y >= 65536) {
                  if (y > 1114111)
                    throw new Error(o);
                  y -= 65536, d.push(String.fromCharCode(55296 | y >> 10)), y = 56320 | y & 1023;
                }
              }
              d.push(String.fromCharCode(y));
            }
            return d.join("");
          }
          n.decode = h;
        },
        /* 2 */
        /***/
        function(t, n, a) {
          t.exports = a(3).default;
        },
        /* 3 */
        /***/
        function(t, n, a) {
          a.r(n);
          var i = function() {
            function C(k, O) {
              this.lastId = 0, this.prefix = k, this.name = O;
            }
            return C.prototype.create = function(k) {
              this.lastId++;
              var O = this.lastId, H = this.prefix + O, V = this.name + "[" + O + "]", te = !1, Ee = function() {
                te || (k.apply(null, arguments), te = !0);
              };
              return this[O] = Ee, { number: O, id: H, name: V, callback: Ee };
            }, C.prototype.remove = function(k) {
              delete this[k.number];
            }, C;
          }(), o = new i("_pusher_script_", "Pusher.ScriptReceivers"), u = {
            VERSION: "7.6.0",
            PROTOCOL: 7,
            wsPort: 80,
            wssPort: 443,
            wsPath: "",
            httpHost: "sockjs.pusher.com",
            httpPort: 80,
            httpsPort: 443,
            httpPath: "/pusher",
            stats_host: "stats.pusher.com",
            authEndpoint: "/pusher/auth",
            authTransport: "ajax",
            activityTimeout: 12e4,
            pongTimeout: 3e4,
            unavailableTimeout: 1e4,
            cluster: "mt1",
            userAuthentication: {
              endpoint: "/pusher/user-auth",
              transport: "ajax"
            },
            channelAuthorization: {
              endpoint: "/pusher/auth",
              transport: "ajax"
            },
            cdn_http: "http://js.pusher.com",
            cdn_https: "https://js.pusher.com",
            dependency_suffix: ""
          }, c = u, h = function() {
            function C(k) {
              this.options = k, this.receivers = k.receivers || o, this.loading = {};
            }
            return C.prototype.load = function(k, O, H) {
              var V = this;
              if (V.loading[k] && V.loading[k].length > 0)
                V.loading[k].push(H);
              else {
                V.loading[k] = [H];
                var te = Dt.createScriptRequest(V.getPath(k, O)), Ee = V.receivers.create(function(Ke) {
                  if (V.receivers.remove(Ee), V.loading[k]) {
                    var At = V.loading[k];
                    delete V.loading[k];
                    for (var ct = function(gr) {
                      gr || te.cleanup();
                    }, Vt = 0; Vt < At.length; Vt++)
                      At[Vt](Ke, ct);
                  }
                });
                te.send(Ee);
              }
            }, C.prototype.getRoot = function(k) {
              var O, H = Dt.getDocument().location.protocol;
              return k && k.useTLS || H === "https:" ? O = this.options.cdn_https : O = this.options.cdn_http, O.replace(/\/*$/, "") + "/" + this.options.version;
            }, C.prototype.getPath = function(k, O) {
              return this.getRoot(O) + "/" + k + this.options.suffix + ".js";
            }, C;
          }(), s = h, d = new i("_pusher_dependencies", "Pusher.DependenciesReceivers"), l = new s({
            cdn_http: c.cdn_http,
            cdn_https: c.cdn_https,
            version: c.VERSION,
            suffix: c.dependency_suffix,
            receivers: d
          }), y = {
            baseUrl: "https://pusher.com",
            urls: {
              authenticationEndpoint: {
                path: "/docs/channels/server_api/authenticating_users"
              },
              authorizationEndpoint: {
                path: "/docs/channels/server_api/authorizing-users/"
              },
              javascriptQuickStart: {
                path: "/docs/javascript_quick_start"
              },
              triggeringClientEvents: {
                path: "/docs/client_api_guide/client_events#trigger-events"
              },
              encryptedChannelSupport: {
                fullUrl: "https://github.com/pusher/pusher-js/tree/cc491015371a4bde5743d1c87a0fbac0feb53195#encrypted-channel-support"
              }
            }
          }, m = function(C) {
            var k = "See:", O = y.urls[C];
            if (!O)
              return "";
            var H;
            return O.fullUrl ? H = O.fullUrl : O.path && (H = y.baseUrl + O.path), H ? k + " " + H : "";
          }, w = { buildLogSuffix: m }, E;
          (function(C) {
            C.UserAuthentication = "user-authentication", C.ChannelAuthorization = "channel-authorization";
          })(E || (E = {}));
          var S = /* @__PURE__ */ function() {
            var C = function(k, O) {
              return C = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(H, V) {
                H.__proto__ = V;
              } || function(H, V) {
                for (var te in V)
                  V.hasOwnProperty(te) && (H[te] = V[te]);
              }, C(k, O);
            };
            return function(k, O) {
              C(k, O);
              function H() {
                this.constructor = k;
              }
              k.prototype = O === null ? Object.create(O) : (H.prototype = O.prototype, new H());
            };
          }(), P = function(C) {
            S(k, C);
            function k(O) {
              var H = this.constructor, V = C.call(this, O) || this;
              return Object.setPrototypeOf(V, H.prototype), V;
            }
            return k;
          }(Error), L = function(C) {
            S(k, C);
            function k(O) {
              var H = this.constructor, V = C.call(this, O) || this;
              return Object.setPrototypeOf(V, H.prototype), V;
            }
            return k;
          }(Error), U = function(C) {
            S(k, C);
            function k(O) {
              var H = this.constructor, V = C.call(this, O) || this;
              return Object.setPrototypeOf(V, H.prototype), V;
            }
            return k;
          }(Error), z = function(C) {
            S(k, C);
            function k(O) {
              var H = this.constructor, V = C.call(this, O) || this;
              return Object.setPrototypeOf(V, H.prototype), V;
            }
            return k;
          }(Error), K = function(C) {
            S(k, C);
            function k(O) {
              var H = this.constructor, V = C.call(this, O) || this;
              return Object.setPrototypeOf(V, H.prototype), V;
            }
            return k;
          }(Error), re = function(C) {
            S(k, C);
            function k(O) {
              var H = this.constructor, V = C.call(this, O) || this;
              return Object.setPrototypeOf(V, H.prototype), V;
            }
            return k;
          }(Error), oe = function(C) {
            S(k, C);
            function k(O) {
              var H = this.constructor, V = C.call(this, O) || this;
              return Object.setPrototypeOf(V, H.prototype), V;
            }
            return k;
          }(Error), se = function(C) {
            S(k, C);
            function k(O) {
              var H = this.constructor, V = C.call(this, O) || this;
              return Object.setPrototypeOf(V, H.prototype), V;
            }
            return k;
          }(Error), ve = function(C) {
            S(k, C);
            function k(O, H) {
              var V = this.constructor, te = C.call(this, H) || this;
              return te.status = O, Object.setPrototypeOf(te, V.prototype), te;
            }
            return k;
          }(Error), Q = function(C, k, O, H, V) {
            var te = Dt.createXHR();
            te.open("POST", O.endpoint, !0), te.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
            for (var Ee in O.headers)
              te.setRequestHeader(Ee, O.headers[Ee]);
            if (O.headersProvider != null) {
              var Ke = O.headersProvider();
              for (var Ee in Ke)
                te.setRequestHeader(Ee, Ke[Ee]);
            }
            return te.onreadystatechange = function() {
              if (te.readyState === 4)
                if (te.status === 200) {
                  var At = void 0, ct = !1;
                  try {
                    At = JSON.parse(te.responseText), ct = !0;
                  } catch (gr) {
                    V(new ve(200, "JSON returned from " + H.toString() + " endpoint was invalid, yet status code was 200. Data was: " + te.responseText), null);
                  }
                  ct && V(null, At);
                } else {
                  var Vt = "";
                  switch (H) {
                    case E.UserAuthentication:
                      Vt = w.buildLogSuffix("authenticationEndpoint");
                      break;
                    case E.ChannelAuthorization:
                      Vt = "Clients must be authorized to join private or presence channels. " + w.buildLogSuffix("authorizationEndpoint");
                      break;
                  }
                  V(new ve(te.status, "Unable to retrieve auth string from " + H.toString() + " endpoint - " + ("received status: " + te.status + " from " + O.endpoint + ". " + Vt)), null);
                }
            }, te.send(k), te;
          }, A = Q;
          function b(C) {
            return R(M(C));
          }
          var f = String.fromCharCode, v = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", g = function(C) {
            var k = C.charCodeAt(0);
            return k < 128 ? C : k < 2048 ? f(192 | k >>> 6) + f(128 | k & 63) : f(224 | k >>> 12 & 15) + f(128 | k >>> 6 & 63) + f(128 | k & 63);
          }, M = function(C) {
            return C.replace(/[^\x00-\x7F]/g, g);
          }, I = function(C) {
            var k = [0, 2, 1][C.length % 3], O = C.charCodeAt(0) << 16 | (C.length > 1 ? C.charCodeAt(1) : 0) << 8 | (C.length > 2 ? C.charCodeAt(2) : 0), H = [
              v.charAt(O >>> 18),
              v.charAt(O >>> 12 & 63),
              k >= 2 ? "=" : v.charAt(O >>> 6 & 63),
              k >= 1 ? "=" : v.charAt(O & 63)
            ];
            return H.join("");
          }, R = window.btoa || function(C) {
            return C.replace(/[\s\S]{1,3}/g, I);
          }, x = function() {
            function C(k, O, H, V) {
              var te = this;
              this.clear = O, this.timer = k(function() {
                te.timer && (te.timer = V(te.timer));
              }, H);
            }
            return C.prototype.isRunning = function() {
              return this.timer !== null;
            }, C.prototype.ensureAborted = function() {
              this.timer && (this.clear(this.timer), this.timer = null);
            }, C;
          }(), T = x, p = /* @__PURE__ */ function() {
            var C = function(k, O) {
              return C = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(H, V) {
                H.__proto__ = V;
              } || function(H, V) {
                for (var te in V)
                  V.hasOwnProperty(te) && (H[te] = V[te]);
              }, C(k, O);
            };
            return function(k, O) {
              C(k, O);
              function H() {
                this.constructor = k;
              }
              k.prototype = O === null ? Object.create(O) : (H.prototype = O.prototype, new H());
            };
          }();
          function B(C) {
            window.clearTimeout(C);
          }
          function ee(C) {
            window.clearInterval(C);
          }
          var ae = function(C) {
            p(k, C);
            function k(O, H) {
              return C.call(this, setTimeout, B, O, function(V) {
                return H(), null;
              }) || this;
            }
            return k;
          }(T), Z = function(C) {
            p(k, C);
            function k(O, H) {
              return C.call(this, setInterval, ee, O, function(V) {
                return H(), V;
              }) || this;
            }
            return k;
          }(T), ne = {
            now: function() {
              return Date.now ? Date.now() : (/* @__PURE__ */ new Date()).valueOf();
            },
            defer: function(C) {
              return new ae(0, C);
            },
            method: function(C) {
              var k = Array.prototype.slice.call(arguments, 1);
              return function(O) {
                return O[C].apply(O, k.concat(arguments));
              };
            }
          }, fe = ne;
          function le(C) {
            for (var k = [], O = 1; O < arguments.length; O++)
              k[O - 1] = arguments[O];
            for (var H = 0; H < k.length; H++) {
              var V = k[H];
              for (var te in V)
                V[te] && V[te].constructor && V[te].constructor === Object ? C[te] = le(C[te] || {}, V[te]) : C[te] = V[te];
            }
            return C;
          }
          function ke() {
            for (var C = ["Pusher"], k = 0; k < arguments.length; k++)
              typeof arguments[k] == "string" ? C.push(arguments[k]) : C.push(lt(arguments[k]));
            return C.join(" : ");
          }
          function X(C, k) {
            var O = Array.prototype.indexOf;
            if (C === null)
              return -1;
            if (O && C.indexOf === O)
              return C.indexOf(k);
            for (var H = 0, V = C.length; H < V; H++)
              if (C[H] === k)
                return H;
            return -1;
          }
          function G(C, k) {
            for (var O in C)
              Object.prototype.hasOwnProperty.call(C, O) && k(C[O], O, C);
          }
          function we(C) {
            var k = [];
            return G(C, function(O, H) {
              k.push(H);
            }), k;
          }
          function Ae(C) {
            var k = [];
            return G(C, function(O) {
              k.push(O);
            }), k;
          }
          function Oe(C, k, O) {
            for (var H = 0; H < C.length; H++)
              k.call(O || window, C[H], H, C);
          }
          function qe(C, k) {
            for (var O = [], H = 0; H < C.length; H++)
              O.push(k(C[H], H, C, O));
            return O;
          }
          function Ue(C, k) {
            var O = {};
            return G(C, function(H, V) {
              O[V] = k(H);
            }), O;
          }
          function ze(C, k) {
            k = k || function(V) {
              return !!V;
            };
            for (var O = [], H = 0; H < C.length; H++)
              k(C[H], H, C, O) && O.push(C[H]);
            return O;
          }
          function ge(C, k) {
            var O = {};
            return G(C, function(H, V) {
              (k && k(H, V, C, O) || H) && (O[V] = H);
            }), O;
          }
          function ht(C) {
            var k = [];
            return G(C, function(O, H) {
              k.push([H, O]);
            }), k;
          }
          function $e(C, k) {
            for (var O = 0; O < C.length; O++)
              if (k(C[O], O, C))
                return !0;
            return !1;
          }
          function Et(C, k) {
            for (var O = 0; O < C.length; O++)
              if (!k(C[O], O, C))
                return !1;
            return !0;
          }
          function ot(C) {
            return Ue(C, function(k) {
              return typeof k == "object" && (k = lt(k)), encodeURIComponent(b(k.toString()));
            });
          }
          function Ve(C) {
            var k = ge(C, function(H) {
              return H !== void 0;
            }), O = qe(ht(ot(k)), fe.method("join", "=")).join("&");
            return O;
          }
          function Mt(C) {
            var k = [], O = [];
            return function H(V, te) {
              var Ee, Ke, At;
              switch (typeof V) {
                case "object":
                  if (!V)
                    return null;
                  for (Ee = 0; Ee < k.length; Ee += 1)
                    if (k[Ee] === V)
                      return { $ref: O[Ee] };
                  if (k.push(V), O.push(te), Object.prototype.toString.apply(V) === "[object Array]")
                    for (At = [], Ee = 0; Ee < V.length; Ee += 1)
                      At[Ee] = H(V[Ee], te + "[" + Ee + "]");
                  else {
                    At = {};
                    for (Ke in V)
                      Object.prototype.hasOwnProperty.call(V, Ke) && (At[Ke] = H(V[Ke], te + "[" + JSON.stringify(Ke) + "]"));
                  }
                  return At;
                case "number":
                case "string":
                case "boolean":
                  return V;
              }
            }(C, "$");
          }
          function lt(C) {
            try {
              return JSON.stringify(C);
            } catch (k) {
              return JSON.stringify(Mt(C));
            }
          }
          var Xe = function() {
            function C() {
              this.globalLog = function(k) {
                window.console && window.console.log && window.console.log(k);
              };
            }
            return C.prototype.debug = function() {
              for (var k = [], O = 0; O < arguments.length; O++)
                k[O] = arguments[O];
              this.log(this.globalLog, k);
            }, C.prototype.warn = function() {
              for (var k = [], O = 0; O < arguments.length; O++)
                k[O] = arguments[O];
              this.log(this.globalLogWarn, k);
            }, C.prototype.error = function() {
              for (var k = [], O = 0; O < arguments.length; O++)
                k[O] = arguments[O];
              this.log(this.globalLogError, k);
            }, C.prototype.globalLogWarn = function(k) {
              window.console && window.console.warn ? window.console.warn(k) : this.globalLog(k);
            }, C.prototype.globalLogError = function(k) {
              window.console && window.console.error ? window.console.error(k) : this.globalLogWarn(k);
            }, C.prototype.log = function(k) {
              var O = ke.apply(this, arguments);
              if (Wo.log)
                Wo.log(O);
              else if (Wo.logToConsole) {
                var H = k.bind(this);
                H(O);
              }
            }, C;
          }(), st = new Xe(), gt = function(C, k, O, H, V) {
            (O.headers !== void 0 || O.headersProvider != null) && st.warn("To send headers with the " + H.toString() + " request, you must use AJAX, rather than JSONP.");
            var te = C.nextAuthCallbackID.toString();
            C.nextAuthCallbackID++;
            var Ee = C.getDocument(), Ke = Ee.createElement("script");
            C.auth_callbacks[te] = function(Vt) {
              V(null, Vt);
            };
            var At = "Pusher.auth_callbacks['" + te + "']";
            Ke.src = O.endpoint + "?callback=" + encodeURIComponent(At) + "&" + k;
            var ct = Ee.getElementsByTagName("head")[0] || Ee.documentElement;
            ct.insertBefore(Ke, ct.firstChild);
          }, W = gt, q = function() {
            function C(k) {
              this.src = k;
            }
            return C.prototype.send = function(k) {
              var O = this, H = "Error loading " + O.src;
              O.script = document.createElement("script"), O.script.id = k.id, O.script.src = O.src, O.script.type = "text/javascript", O.script.charset = "UTF-8", O.script.addEventListener ? (O.script.onerror = function() {
                k.callback(H);
              }, O.script.onload = function() {
                k.callback(null);
              }) : O.script.onreadystatechange = function() {
                (O.script.readyState === "loaded" || O.script.readyState === "complete") && k.callback(null);
              }, O.script.async === void 0 && document.attachEvent && /opera/i.test(navigator.userAgent) ? (O.errorScript = document.createElement("script"), O.errorScript.id = k.id + "_error", O.errorScript.text = k.name + "('" + H + "');", O.script.async = O.errorScript.async = !1) : O.script.async = !0;
              var V = document.getElementsByTagName("head")[0];
              V.insertBefore(O.script, V.firstChild), O.errorScript && V.insertBefore(O.errorScript, O.script.nextSibling);
            }, C.prototype.cleanup = function() {
              this.script && (this.script.onload = this.script.onerror = null, this.script.onreadystatechange = null), this.script && this.script.parentNode && this.script.parentNode.removeChild(this.script), this.errorScript && this.errorScript.parentNode && this.errorScript.parentNode.removeChild(this.errorScript), this.script = null, this.errorScript = null;
            }, C;
          }(), F = q, J = function() {
            function C(k, O) {
              this.url = k, this.data = O;
            }
            return C.prototype.send = function(k) {
              if (!this.request) {
                var O = Ve(this.data), H = this.url + "/" + k.number + "?" + O;
                this.request = Dt.createScriptRequest(H), this.request.send(k);
              }
            }, C.prototype.cleanup = function() {
              this.request && this.request.cleanup();
            }, C;
          }(), he = J, de = function(C, k) {
            return function(O, H) {
              var V = "http" + (k ? "s" : "") + "://", te = V + (C.host || C.options.host) + C.options.path, Ee = Dt.createJSONPRequest(te, O), Ke = Dt.ScriptReceivers.create(function(At, ct) {
                o.remove(Ke), Ee.cleanup(), ct && ct.host && (C.host = ct.host), H && H(At, ct);
              });
              Ee.send(Ke);
            };
          }, pe = {
            name: "jsonp",
            getAgent: de
          }, Je = pe;
          function tt(C, k, O) {
            var H = C + (k.useTLS ? "s" : ""), V = k.useTLS ? k.hostTLS : k.hostNonTLS;
            return H + "://" + V + O;
          }
          function Ne(C, k) {
            var O = "/app/" + C, H = "?protocol=" + c.PROTOCOL + "&client=js&version=" + c.VERSION + (k ? "&" + k : "");
            return O + H;
          }
          var St = {
            getInitial: function(C, k) {
              var O = (k.httpPath || "") + Ne(C, "flash=false");
              return tt("ws", k, O);
            }
          }, rt = {
            getInitial: function(C, k) {
              var O = (k.httpPath || "/pusher") + Ne(C);
              return tt("http", k, O);
            }
          }, dt = {
            getInitial: function(C, k) {
              return tt("http", k, k.httpPath || "/pusher");
            },
            getPath: function(C, k) {
              return Ne(C);
            }
          }, Zt = function() {
            function C() {
              this._callbacks = {};
            }
            return C.prototype.get = function(k) {
              return this._callbacks[at(k)];
            }, C.prototype.add = function(k, O, H) {
              var V = at(k);
              this._callbacks[V] = this._callbacks[V] || [], this._callbacks[V].push({
                fn: O,
                context: H
              });
            }, C.prototype.remove = function(k, O, H) {
              if (!k && !O && !H) {
                this._callbacks = {};
                return;
              }
              var V = k ? [at(k)] : we(this._callbacks);
              O || H ? this.removeCallback(V, O, H) : this.removeAllCallbacks(V);
            }, C.prototype.removeCallback = function(k, O, H) {
              Oe(k, function(V) {
                this._callbacks[V] = ze(this._callbacks[V] || [], function(te) {
                  return O && O !== te.fn || H && H !== te.context;
                }), this._callbacks[V].length === 0 && delete this._callbacks[V];
              }, this);
            }, C.prototype.removeAllCallbacks = function(k) {
              Oe(k, function(O) {
                delete this._callbacks[O];
              }, this);
            }, C;
          }(), bt = Zt;
          function at(C) {
            return "_" + C;
          }
          var jt = function() {
            function C(k) {
              this.callbacks = new bt(), this.global_callbacks = [], this.failThrough = k;
            }
            return C.prototype.bind = function(k, O, H) {
              return this.callbacks.add(k, O, H), this;
            }, C.prototype.bind_global = function(k) {
              return this.global_callbacks.push(k), this;
            }, C.prototype.unbind = function(k, O, H) {
              return this.callbacks.remove(k, O, H), this;
            }, C.prototype.unbind_global = function(k) {
              return k ? (this.global_callbacks = ze(this.global_callbacks || [], function(O) {
                return O !== k;
              }), this) : (this.global_callbacks = [], this);
            }, C.prototype.unbind_all = function() {
              return this.unbind(), this.unbind_global(), this;
            }, C.prototype.emit = function(k, O, H) {
              for (var V = 0; V < this.global_callbacks.length; V++)
                this.global_callbacks[V](k, O);
              var te = this.callbacks.get(k), Ee = [];
              if (H ? Ee.push(O, H) : O && Ee.push(O), te && te.length > 0)
                for (var V = 0; V < te.length; V++)
                  te[V].fn.apply(te[V].context || window, Ee);
              else
                this.failThrough && this.failThrough(k, O);
              return this;
            }, C;
          }(), _t = jt, ft = /* @__PURE__ */ function() {
            var C = function(k, O) {
              return C = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(H, V) {
                H.__proto__ = V;
              } || function(H, V) {
                for (var te in V)
                  V.hasOwnProperty(te) && (H[te] = V[te]);
              }, C(k, O);
            };
            return function(k, O) {
              C(k, O);
              function H() {
                this.constructor = k;
              }
              k.prototype = O === null ? Object.create(O) : (H.prototype = O.prototype, new H());
            };
          }(), Yt = function(C) {
            ft(k, C);
            function k(O, H, V, te, Ee) {
              var Ke = C.call(this) || this;
              return Ke.initialize = Dt.transportConnectionInitializer, Ke.hooks = O, Ke.name = H, Ke.priority = V, Ke.key = te, Ke.options = Ee, Ke.state = "new", Ke.timeline = Ee.timeline, Ke.activityTimeout = Ee.activityTimeout, Ke.id = Ke.timeline.generateUniqueID(), Ke;
            }
            return k.prototype.handlesActivityChecks = function() {
              return !!this.hooks.handlesActivityChecks;
            }, k.prototype.supportsPing = function() {
              return !!this.hooks.supportsPing;
            }, k.prototype.connect = function() {
              var O = this;
              if (this.socket || this.state !== "initialized")
                return !1;
              var H = this.hooks.urls.getInitial(this.key, this.options);
              try {
                this.socket = this.hooks.getSocket(H, this.options);
              } catch (V) {
                return fe.defer(function() {
                  O.onError(V), O.changeState("closed");
                }), !1;
              }
              return this.bindListeners(), st.debug("Connecting", { transport: this.name, url: H }), this.changeState("connecting"), !0;
            }, k.prototype.close = function() {
              return this.socket ? (this.socket.close(), !0) : !1;
            }, k.prototype.send = function(O) {
              var H = this;
              return this.state === "open" ? (fe.defer(function() {
                H.socket && H.socket.send(O);
              }), !0) : !1;
            }, k.prototype.ping = function() {
              this.state === "open" && this.supportsPing() && this.socket.ping();
            }, k.prototype.onOpen = function() {
              this.hooks.beforeOpen && this.hooks.beforeOpen(this.socket, this.hooks.urls.getPath(this.key, this.options)), this.changeState("open"), this.socket.onopen = void 0;
            }, k.prototype.onError = function(O) {
              this.emit("error", { type: "WebSocketError", error: O }), this.timeline.error(this.buildTimelineMessage({ error: O.toString() }));
            }, k.prototype.onClose = function(O) {
              O ? this.changeState("closed", {
                code: O.code,
                reason: O.reason,
                wasClean: O.wasClean
              }) : this.changeState("closed"), this.unbindListeners(), this.socket = void 0;
            }, k.prototype.onMessage = function(O) {
              this.emit("message", O);
            }, k.prototype.onActivity = function() {
              this.emit("activity");
            }, k.prototype.bindListeners = function() {
              var O = this;
              this.socket.onopen = function() {
                O.onOpen();
              }, this.socket.onerror = function(H) {
                O.onError(H);
              }, this.socket.onclose = function(H) {
                O.onClose(H);
              }, this.socket.onmessage = function(H) {
                O.onMessage(H);
              }, this.supportsPing() && (this.socket.onactivity = function() {
                O.onActivity();
              });
            }, k.prototype.unbindListeners = function() {
              this.socket && (this.socket.onopen = void 0, this.socket.onerror = void 0, this.socket.onclose = void 0, this.socket.onmessage = void 0, this.supportsPing() && (this.socket.onactivity = void 0));
            }, k.prototype.changeState = function(O, H) {
              this.state = O, this.timeline.info(this.buildTimelineMessage({
                state: O,
                params: H
              })), this.emit(O, H);
            }, k.prototype.buildTimelineMessage = function(O) {
              return le({ cid: this.id }, O);
            }, k;
          }(_t), kt = Yt, Ze = function() {
            function C(k) {
              this.hooks = k;
            }
            return C.prototype.isSupported = function(k) {
              return this.hooks.isSupported(k);
            }, C.prototype.createConnection = function(k, O, H, V) {
              return new kt(this.hooks, k, O, H, V);
            }, C;
          }(), Ht = Ze, j = new Ht({
            urls: St,
            handlesActivityChecks: !1,
            supportsPing: !1,
            isInitialized: function() {
              return !!Dt.getWebSocketAPI();
            },
            isSupported: function() {
              return !!Dt.getWebSocketAPI();
            },
            getSocket: function(C) {
              return Dt.createWebSocket(C);
            }
          }), N = {
            urls: rt,
            handlesActivityChecks: !1,
            supportsPing: !0,
            isInitialized: function() {
              return !0;
            }
          }, D = le({
            getSocket: function(C) {
              return Dt.HTTPFactory.createStreamingSocket(C);
            }
          }, N), _ = le({
            getSocket: function(C) {
              return Dt.HTTPFactory.createPollingSocket(C);
            }
          }, N), $ = {
            isSupported: function() {
              return Dt.isXHRSupported();
            }
          }, Y = new Ht(le({}, D, $)), ie = new Ht(le({}, _, $)), ce = {
            ws: j,
            xhr_streaming: Y,
            xhr_polling: ie
          }, me = ce, Me = new Ht({
            file: "sockjs",
            urls: dt,
            handlesActivityChecks: !0,
            supportsPing: !1,
            isSupported: function() {
              return !0;
            },
            isInitialized: function() {
              return window.SockJS !== void 0;
            },
            getSocket: function(C, k) {
              return new window.SockJS(C, null, {
                js_path: l.getPath("sockjs", {
                  useTLS: k.useTLS
                }),
                ignore_null_origin: k.ignoreNullOrigin
              });
            },
            beforeOpen: function(C, k) {
              C.send(JSON.stringify({
                path: k
              }));
            }
          }), Se = {
            isSupported: function(C) {
              var k = Dt.isXDRSupported(C.useTLS);
              return k;
            }
          }, Ge = new Ht(le({}, D, Se)), Be = new Ht(le({}, _, Se));
          me.xdr_streaming = Ge, me.xdr_polling = Be, me.sockjs = Me;
          var Ye = me, Pe = /* @__PURE__ */ function() {
            var C = function(k, O) {
              return C = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(H, V) {
                H.__proto__ = V;
              } || function(H, V) {
                for (var te in V)
                  V.hasOwnProperty(te) && (H[te] = V[te]);
              }, C(k, O);
            };
            return function(k, O) {
              C(k, O);
              function H() {
                this.constructor = k;
              }
              k.prototype = O === null ? Object.create(O) : (H.prototype = O.prototype, new H());
            };
          }(), et = function(C) {
            Pe(k, C);
            function k() {
              var O = C.call(this) || this, H = O;
              return window.addEventListener !== void 0 && (window.addEventListener("online", function() {
                H.emit("online");
              }, !1), window.addEventListener("offline", function() {
                H.emit("offline");
              }, !1)), O;
            }
            return k.prototype.isOnline = function() {
              return window.navigator.onLine === void 0 ? !0 : window.navigator.onLine;
            }, k;
          }(_t), nt = new et(), Qe = function() {
            function C(k, O, H) {
              this.manager = k, this.transport = O, this.minPingDelay = H.minPingDelay, this.maxPingDelay = H.maxPingDelay, this.pingDelay = void 0;
            }
            return C.prototype.createConnection = function(k, O, H, V) {
              var te = this;
              V = le({}, V, {
                activityTimeout: this.pingDelay
              });
              var Ee = this.transport.createConnection(k, O, H, V), Ke = null, At = function() {
                Ee.unbind("open", At), Ee.bind("closed", ct), Ke = fe.now();
              }, ct = function(Vt) {
                if (Ee.unbind("closed", ct), Vt.code === 1002 || Vt.code === 1003)
                  te.manager.reportDeath();
                else if (!Vt.wasClean && Ke) {
                  var gr = fe.now() - Ke;
                  gr < 2 * te.maxPingDelay && (te.manager.reportDeath(), te.pingDelay = Math.max(gr / 2, te.minPingDelay));
                }
              };
              return Ee.bind("open", At), Ee;
            }, C.prototype.isSupported = function(k) {
              return this.manager.isAlive() && this.transport.isSupported(k);
            }, C;
          }(), pt = Qe, ut = {
            decodeMessage: function(C) {
              try {
                var k = JSON.parse(C.data), O = k.data;
                if (typeof O == "string")
                  try {
                    O = JSON.parse(k.data);
                  } catch (V) {
                  }
                var H = {
                  event: k.event,
                  channel: k.channel,
                  data: O
                };
                return k.user_id && (H.user_id = k.user_id), H;
              } catch (V) {
                throw { type: "MessageParseError", error: V, data: C.data };
              }
            },
            encodeMessage: function(C) {
              return JSON.stringify(C);
            },
            processHandshake: function(C) {
              var k = ut.decodeMessage(C);
              if (k.event === "pusher:connection_established") {
                if (!k.data.activity_timeout)
                  throw "No activity timeout specified in handshake";
                return {
                  action: "connected",
                  id: k.data.socket_id,
                  activityTimeout: k.data.activity_timeout * 1e3
                };
              } else {
                if (k.event === "pusher:error")
                  return {
                    action: this.getCloseAction(k.data),
                    error: this.getCloseError(k.data)
                  };
                throw "Invalid handshake";
              }
            },
            getCloseAction: function(C) {
              return C.code < 4e3 ? C.code >= 1002 && C.code <= 1004 ? "backoff" : null : C.code === 4e3 ? "tls_only" : C.code < 4100 ? "refused" : C.code < 4200 ? "backoff" : C.code < 4300 ? "retry" : "refused";
            },
            getCloseError: function(C) {
              return C.code !== 1e3 && C.code !== 1001 ? {
                type: "PusherError",
                data: {
                  code: C.code,
                  message: C.reason || C.message
                }
              } : null;
            }
          }, Le = ut, it = /* @__PURE__ */ function() {
            var C = function(k, O) {
              return C = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(H, V) {
                H.__proto__ = V;
              } || function(H, V) {
                for (var te in V)
                  V.hasOwnProperty(te) && (H[te] = V[te]);
              }, C(k, O);
            };
            return function(k, O) {
              C(k, O);
              function H() {
                this.constructor = k;
              }
              k.prototype = O === null ? Object.create(O) : (H.prototype = O.prototype, new H());
            };
          }(), je = function(C) {
            it(k, C);
            function k(O, H) {
              var V = C.call(this) || this;
              return V.id = O, V.transport = H, V.activityTimeout = H.activityTimeout, V.bindListeners(), V;
            }
            return k.prototype.handlesActivityChecks = function() {
              return this.transport.handlesActivityChecks();
            }, k.prototype.send = function(O) {
              return this.transport.send(O);
            }, k.prototype.send_event = function(O, H, V) {
              var te = { event: O, data: H };
              return V && (te.channel = V), st.debug("Event sent", te), this.send(Le.encodeMessage(te));
            }, k.prototype.ping = function() {
              this.transport.supportsPing() ? this.transport.ping() : this.send_event("pusher:ping", {});
            }, k.prototype.close = function() {
              this.transport.close();
            }, k.prototype.bindListeners = function() {
              var O = this, H = {
                message: function(te) {
                  var Ee;
                  try {
                    Ee = Le.decodeMessage(te);
                  } catch (Ke) {
                    O.emit("error", {
                      type: "MessageParseError",
                      error: Ke,
                      data: te.data
                    });
                  }
                  if (Ee !== void 0) {
                    switch (st.debug("Event recd", Ee), Ee.event) {
                      case "pusher:error":
                        O.emit("error", {
                          type: "PusherError",
                          data: Ee.data
                        });
                        break;
                      case "pusher:ping":
                        O.emit("ping");
                        break;
                      case "pusher:pong":
                        O.emit("pong");
                        break;
                    }
                    O.emit("message", Ee);
                  }
                },
                activity: function() {
                  O.emit("activity");
                },
                error: function(te) {
                  O.emit("error", te);
                },
                closed: function(te) {
                  V(), te && te.code && O.handleCloseEvent(te), O.transport = null, O.emit("closed");
                }
              }, V = function() {
                G(H, function(te, Ee) {
                  O.transport.unbind(Ee, te);
                });
              };
              G(H, function(te, Ee) {
                O.transport.bind(Ee, te);
              });
            }, k.prototype.handleCloseEvent = function(O) {
              var H = Le.getCloseAction(O), V = Le.getCloseError(O);
              V && this.emit("error", V), H && this.emit(H, { action: H, error: V });
            }, k;
          }(_t), He = je, We = function() {
            function C(k, O) {
              this.transport = k, this.callback = O, this.bindListeners();
            }
            return C.prototype.close = function() {
              this.unbindListeners(), this.transport.close();
            }, C.prototype.bindListeners = function() {
              var k = this;
              this.onMessage = function(O) {
                k.unbindListeners();
                var H;
                try {
                  H = Le.processHandshake(O);
                } catch (V) {
                  k.finish("error", { error: V }), k.transport.close();
                  return;
                }
                H.action === "connected" ? k.finish("connected", {
                  connection: new He(H.id, k.transport),
                  activityTimeout: H.activityTimeout
                }) : (k.finish(H.action, { error: H.error }), k.transport.close());
              }, this.onClosed = function(O) {
                k.unbindListeners();
                var H = Le.getCloseAction(O) || "backoff", V = Le.getCloseError(O);
                k.finish(H, { error: V });
              }, this.transport.bind("message", this.onMessage), this.transport.bind("closed", this.onClosed);
            }, C.prototype.unbindListeners = function() {
              this.transport.unbind("message", this.onMessage), this.transport.unbind("closed", this.onClosed);
            }, C.prototype.finish = function(k, O) {
              this.callback(le({ transport: this.transport, action: k }, O));
            }, C;
          }(), Fe = We, ye = function() {
            function C(k, O) {
              this.timeline = k, this.options = O || {};
            }
            return C.prototype.send = function(k, O) {
              this.timeline.isEmpty() || this.timeline.send(Dt.TimelineTransport.getAgent(this, k), O);
            }, C;
          }(), be = ye, Re = /* @__PURE__ */ function() {
            var C = function(k, O) {
              return C = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(H, V) {
                H.__proto__ = V;
              } || function(H, V) {
                for (var te in V)
                  V.hasOwnProperty(te) && (H[te] = V[te]);
              }, C(k, O);
            };
            return function(k, O) {
              C(k, O);
              function H() {
                this.constructor = k;
              }
              k.prototype = O === null ? Object.create(O) : (H.prototype = O.prototype, new H());
            };
          }(), Te = function(C) {
            Re(k, C);
            function k(O, H) {
              var V = C.call(this, function(te, Ee) {
                st.debug("No callbacks on " + O + " for " + te);
              }) || this;
              return V.name = O, V.pusher = H, V.subscribed = !1, V.subscriptionPending = !1, V.subscriptionCancelled = !1, V;
            }
            return k.prototype.authorize = function(O, H) {
              return H(null, { auth: "" });
            }, k.prototype.trigger = function(O, H) {
              if (O.indexOf("client-") !== 0)
                throw new P("Event '" + O + "' does not start with 'client-'");
              if (!this.subscribed) {
                var V = w.buildLogSuffix("triggeringClientEvents");
                st.warn("Client event triggered before channel 'subscription_succeeded' event . " + V);
              }
              return this.pusher.send_event(O, H, this.name);
            }, k.prototype.disconnect = function() {
              this.subscribed = !1, this.subscriptionPending = !1;
            }, k.prototype.handleEvent = function(O) {
              var H = O.event, V = O.data;
              if (H === "pusher_internal:subscription_succeeded")
                this.handleSubscriptionSucceededEvent(O);
              else if (H === "pusher_internal:subscription_count")
                this.handleSubscriptionCountEvent(O);
              else if (H.indexOf("pusher_internal:") !== 0) {
                var te = {};
                this.emit(H, V, te);
              }
            }, k.prototype.handleSubscriptionSucceededEvent = function(O) {
              this.subscriptionPending = !1, this.subscribed = !0, this.subscriptionCancelled ? this.pusher.unsubscribe(this.name) : this.emit("pusher:subscription_succeeded", O.data);
            }, k.prototype.handleSubscriptionCountEvent = function(O) {
              O.data.subscription_count && (this.subscriptionCount = O.data.subscription_count), this.emit("pusher:subscription_count", O.data);
            }, k.prototype.subscribe = function() {
              var O = this;
              this.subscribed || (this.subscriptionPending = !0, this.subscriptionCancelled = !1, this.authorize(this.pusher.connection.socket_id, function(H, V) {
                H ? (O.subscriptionPending = !1, st.error(H.toString()), O.emit("pusher:subscription_error", Object.assign({}, {
                  type: "AuthError",
                  error: H.message
                }, H instanceof ve ? { status: H.status } : {}))) : O.pusher.send_event("pusher:subscribe", {
                  auth: V.auth,
                  channel_data: V.channel_data,
                  channel: O.name
                });
              }));
            }, k.prototype.unsubscribe = function() {
              this.subscribed = !1, this.pusher.send_event("pusher:unsubscribe", {
                channel: this.name
              });
            }, k.prototype.cancelSubscription = function() {
              this.subscriptionCancelled = !0;
            }, k.prototype.reinstateSubscription = function() {
              this.subscriptionCancelled = !1;
            }, k;
          }(_t), Ie = Te, De = /* @__PURE__ */ function() {
            var C = function(k, O) {
              return C = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(H, V) {
                H.__proto__ = V;
              } || function(H, V) {
                for (var te in V)
                  V.hasOwnProperty(te) && (H[te] = V[te]);
              }, C(k, O);
            };
            return function(k, O) {
              C(k, O);
              function H() {
                this.constructor = k;
              }
              k.prototype = O === null ? Object.create(O) : (H.prototype = O.prototype, new H());
            };
          }(), xt = function(C) {
            De(k, C);
            function k() {
              return C !== null && C.apply(this, arguments) || this;
            }
            return k.prototype.authorize = function(O, H) {
              return this.pusher.config.channelAuthorizer({
                channelName: this.name,
                socketId: O
              }, H);
            }, k;
          }(Ie), Rt = xt, Ot = function() {
            function C() {
              this.reset();
            }
            return C.prototype.get = function(k) {
              return Object.prototype.hasOwnProperty.call(this.members, k) ? {
                id: k,
                info: this.members[k]
              } : null;
            }, C.prototype.each = function(k) {
              var O = this;
              G(this.members, function(H, V) {
                k(O.get(V));
              });
            }, C.prototype.setMyID = function(k) {
              this.myID = k;
            }, C.prototype.onSubscription = function(k) {
              this.members = k.presence.hash, this.count = k.presence.count, this.me = this.get(this.myID);
            }, C.prototype.addMember = function(k) {
              return this.get(k.user_id) === null && this.count++, this.members[k.user_id] = k.user_info, this.get(k.user_id);
            }, C.prototype.removeMember = function(k) {
              var O = this.get(k.user_id);
              return O && (delete this.members[k.user_id], this.count--), O;
            }, C.prototype.reset = function() {
              this.members = {}, this.count = 0, this.myID = null, this.me = null;
            }, C;
          }(), It = Ot, ue = /* @__PURE__ */ function() {
            var C = function(k, O) {
              return C = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(H, V) {
                H.__proto__ = V;
              } || function(H, V) {
                for (var te in V)
                  V.hasOwnProperty(te) && (H[te] = V[te]);
              }, C(k, O);
            };
            return function(k, O) {
              C(k, O);
              function H() {
                this.constructor = k;
              }
              k.prototype = O === null ? Object.create(O) : (H.prototype = O.prototype, new H());
            };
          }(), qt = function(C, k, O, H) {
            function V(te) {
              return te instanceof O ? te : new O(function(Ee) {
                Ee(te);
              });
            }
            return new (O || (O = Promise))(function(te, Ee) {
              function Ke(Vt) {
                try {
                  ct(H.next(Vt));
                } catch (gr) {
                  Ee(gr);
                }
              }
              function At(Vt) {
                try {
                  ct(H.throw(Vt));
                } catch (gr) {
                  Ee(gr);
                }
              }
              function ct(Vt) {
                Vt.done ? te(Vt.value) : V(Vt.value).then(Ke, At);
              }
              ct((H = H.apply(C, k || [])).next());
            });
          }, Qt = function(C, k) {
            var O = { label: 0, sent: function() {
              if (te[0] & 1)
                throw te[1];
              return te[1];
            }, trys: [], ops: [] }, H, V, te, Ee;
            return Ee = { next: Ke(0), throw: Ke(1), return: Ke(2) }, typeof Symbol == "function" && (Ee[Symbol.iterator] = function() {
              return this;
            }), Ee;
            function Ke(ct) {
              return function(Vt) {
                return At([ct, Vt]);
              };
            }
            function At(ct) {
              if (H)
                throw new TypeError("Generator is already executing.");
              for (; O; )
                try {
                  if (H = 1, V && (te = ct[0] & 2 ? V.return : ct[0] ? V.throw || ((te = V.return) && te.call(V), 0) : V.next) && !(te = te.call(V, ct[1])).done)
                    return te;
                  switch (V = 0, te && (ct = [ct[0] & 2, te.value]), ct[0]) {
                    case 0:
                    case 1:
                      te = ct;
                      break;
                    case 4:
                      return O.label++, { value: ct[1], done: !1 };
                    case 5:
                      O.label++, V = ct[1], ct = [0];
                      continue;
                    case 7:
                      ct = O.ops.pop(), O.trys.pop();
                      continue;
                    default:
                      if (te = O.trys, !(te = te.length > 0 && te[te.length - 1]) && (ct[0] === 6 || ct[0] === 2)) {
                        O = 0;
                        continue;
                      }
                      if (ct[0] === 3 && (!te || ct[1] > te[0] && ct[1] < te[3])) {
                        O.label = ct[1];
                        break;
                      }
                      if (ct[0] === 6 && O.label < te[1]) {
                        O.label = te[1], te = ct;
                        break;
                      }
                      if (te && O.label < te[2]) {
                        O.label = te[2], O.ops.push(ct);
                        break;
                      }
                      te[2] && O.ops.pop(), O.trys.pop();
                      continue;
                  }
                  ct = k.call(C, O);
                } catch (Vt) {
                  ct = [6, Vt], V = 0;
                } finally {
                  H = te = 0;
                }
              if (ct[0] & 5)
                throw ct[1];
              return { value: ct[0] ? ct[1] : void 0, done: !0 };
            }
          }, Gt = function(C) {
            ue(k, C);
            function k(O, H) {
              var V = C.call(this, O, H) || this;
              return V.members = new It(), V;
            }
            return k.prototype.authorize = function(O, H) {
              var V = this;
              C.prototype.authorize.call(this, O, function(te, Ee) {
                return qt(V, void 0, void 0, function() {
                  var Ke, At;
                  return Qt(this, function(ct) {
                    switch (ct.label) {
                      case 0:
                        return te ? [3, 3] : (Ee = Ee, Ee.channel_data == null ? [3, 1] : (Ke = JSON.parse(Ee.channel_data), this.members.setMyID(Ke.user_id), [3, 3]));
                      case 1:
                        return [4, this.pusher.user.signinDonePromise];
                      case 2:
                        if (ct.sent(), this.pusher.user.user_data != null)
                          this.members.setMyID(this.pusher.user.user_data.id);
                        else
                          return At = w.buildLogSuffix("authorizationEndpoint"), st.error("Invalid auth response for channel '" + this.name + "', " + ("expected 'channel_data' field. " + At + ", ") + "or the user should be signed in."), H("Invalid auth response"), [2];
                        ct.label = 3;
                      case 3:
                        return H(te, Ee), [2];
                    }
                  });
                });
              });
            }, k.prototype.handleEvent = function(O) {
              var H = O.event;
              if (H.indexOf("pusher_internal:") === 0)
                this.handleInternalEvent(O);
              else {
                var V = O.data, te = {};
                O.user_id && (te.user_id = O.user_id), this.emit(H, V, te);
              }
            }, k.prototype.handleInternalEvent = function(O) {
              var H = O.event, V = O.data;
              switch (H) {
                case "pusher_internal:subscription_succeeded":
                  this.handleSubscriptionSucceededEvent(O);
                  break;
                case "pusher_internal:subscription_count":
                  this.handleSubscriptionCountEvent(O);
                  break;
                case "pusher_internal:member_added":
                  var te = this.members.addMember(V);
                  this.emit("pusher:member_added", te);
                  break;
                case "pusher_internal:member_removed":
                  var Ee = this.members.removeMember(V);
                  Ee && this.emit("pusher:member_removed", Ee);
                  break;
              }
            }, k.prototype.handleSubscriptionSucceededEvent = function(O) {
              this.subscriptionPending = !1, this.subscribed = !0, this.subscriptionCancelled ? this.pusher.unsubscribe(this.name) : (this.members.onSubscription(O.data), this.emit("pusher:subscription_succeeded", this.members));
            }, k.prototype.disconnect = function() {
              this.members.reset(), C.prototype.disconnect.call(this);
            }, k;
          }(Rt), Pt = Gt, Wt = a(1), zt = a(0), pr = /* @__PURE__ */ function() {
            var C = function(k, O) {
              return C = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(H, V) {
                H.__proto__ = V;
              } || function(H, V) {
                for (var te in V)
                  V.hasOwnProperty(te) && (H[te] = V[te]);
              }, C(k, O);
            };
            return function(k, O) {
              C(k, O);
              function H() {
                this.constructor = k;
              }
              k.prototype = O === null ? Object.create(O) : (H.prototype = O.prototype, new H());
            };
          }(), er = function(C) {
            pr(k, C);
            function k(O, H, V) {
              var te = C.call(this, O, H) || this;
              return te.key = null, te.nacl = V, te;
            }
            return k.prototype.authorize = function(O, H) {
              var V = this;
              C.prototype.authorize.call(this, O, function(te, Ee) {
                if (te) {
                  H(te, Ee);
                  return;
                }
                var Ke = Ee.shared_secret;
                if (!Ke) {
                  H(new Error("No shared_secret key in auth payload for encrypted channel: " + V.name), null);
                  return;
                }
                V.key = Object(zt.decode)(Ke), delete Ee.shared_secret, H(null, Ee);
              });
            }, k.prototype.trigger = function(O, H) {
              throw new re("Client events are not currently supported for encrypted channels");
            }, k.prototype.handleEvent = function(O) {
              var H = O.event, V = O.data;
              if (H.indexOf("pusher_internal:") === 0 || H.indexOf("pusher:") === 0) {
                C.prototype.handleEvent.call(this, O);
                return;
              }
              this.handleEncryptedEvent(H, V);
            }, k.prototype.handleEncryptedEvent = function(O, H) {
              var V = this;
              if (!this.key) {
                st.debug("Received encrypted event before key has been retrieved from the authEndpoint");
                return;
              }
              if (!H.ciphertext || !H.nonce) {
                st.error("Unexpected format for encrypted event, expected object with `ciphertext` and `nonce` fields, got: " + H);
                return;
              }
              var te = Object(zt.decode)(H.ciphertext);
              if (te.length < this.nacl.secretbox.overheadLength) {
                st.error("Expected encrypted event ciphertext length to be " + this.nacl.secretbox.overheadLength + ", got: " + te.length);
                return;
              }
              var Ee = Object(zt.decode)(H.nonce);
              if (Ee.length < this.nacl.secretbox.nonceLength) {
                st.error("Expected encrypted event nonce length to be " + this.nacl.secretbox.nonceLength + ", got: " + Ee.length);
                return;
              }
              var Ke = this.nacl.secretbox.open(te, Ee, this.key);
              if (Ke === null) {
                st.debug("Failed to decrypt an event, probably because it was encrypted with a different key. Fetching a new key from the authEndpoint..."), this.authorize(this.pusher.connection.socket_id, function(At, ct) {
                  if (At) {
                    st.error("Failed to make a request to the authEndpoint: " + ct + ". Unable to fetch new key, so dropping encrypted event");
                    return;
                  }
                  if (Ke = V.nacl.secretbox.open(te, Ee, V.key), Ke === null) {
                    st.error("Failed to decrypt event with new key. Dropping encrypted event");
                    return;
                  }
                  V.emit(O, V.getDataToEmit(Ke));
                });
                return;
              }
              this.emit(O, this.getDataToEmit(Ke));
            }, k.prototype.getDataToEmit = function(O) {
              var H = Object(Wt.decode)(O);
              try {
                return JSON.parse(H);
              } catch (V) {
                return H;
              }
            }, k;
          }(Rt), cr = er, hr = /* @__PURE__ */ function() {
            var C = function(k, O) {
              return C = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(H, V) {
                H.__proto__ = V;
              } || function(H, V) {
                for (var te in V)
                  V.hasOwnProperty(te) && (H[te] = V[te]);
              }, C(k, O);
            };
            return function(k, O) {
              C(k, O);
              function H() {
                this.constructor = k;
              }
              k.prototype = O === null ? Object.create(O) : (H.prototype = O.prototype, new H());
            };
          }(), lr = function(C) {
            hr(k, C);
            function k(O, H) {
              var V = C.call(this) || this;
              V.state = "initialized", V.connection = null, V.key = O, V.options = H, V.timeline = V.options.timeline, V.usingTLS = V.options.useTLS, V.errorCallbacks = V.buildErrorCallbacks(), V.connectionCallbacks = V.buildConnectionCallbacks(V.errorCallbacks), V.handshakeCallbacks = V.buildHandshakeCallbacks(V.errorCallbacks);
              var te = Dt.getNetwork();
              return te.bind("online", function() {
                V.timeline.info({ netinfo: "online" }), (V.state === "connecting" || V.state === "unavailable") && V.retryIn(0);
              }), te.bind("offline", function() {
                V.timeline.info({ netinfo: "offline" }), V.connection && V.sendActivityCheck();
              }), V.updateStrategy(), V;
            }
            return k.prototype.connect = function() {
              if (!(this.connection || this.runner)) {
                if (!this.strategy.isSupported()) {
                  this.updateState("failed");
                  return;
                }
                this.updateState("connecting"), this.startConnecting(), this.setUnavailableTimer();
              }
            }, k.prototype.send = function(O) {
              return this.connection ? this.connection.send(O) : !1;
            }, k.prototype.send_event = function(O, H, V) {
              return this.connection ? this.connection.send_event(O, H, V) : !1;
            }, k.prototype.disconnect = function() {
              this.disconnectInternally(), this.updateState("disconnected");
            }, k.prototype.isUsingTLS = function() {
              return this.usingTLS;
            }, k.prototype.startConnecting = function() {
              var O = this, H = function(V, te) {
                V ? O.runner = O.strategy.connect(0, H) : te.action === "error" ? (O.emit("error", {
                  type: "HandshakeError",
                  error: te.error
                }), O.timeline.error({ handshakeError: te.error })) : (O.abortConnecting(), O.handshakeCallbacks[te.action](te));
              };
              this.runner = this.strategy.connect(0, H);
            }, k.prototype.abortConnecting = function() {
              this.runner && (this.runner.abort(), this.runner = null);
            }, k.prototype.disconnectInternally = function() {
              if (this.abortConnecting(), this.clearRetryTimer(), this.clearUnavailableTimer(), this.connection) {
                var O = this.abandonConnection();
                O.close();
              }
            }, k.prototype.updateStrategy = function() {
              this.strategy = this.options.getStrategy({
                key: this.key,
                timeline: this.timeline,
                useTLS: this.usingTLS
              });
            }, k.prototype.retryIn = function(O) {
              var H = this;
              this.timeline.info({ action: "retry", delay: O }), O > 0 && this.emit("connecting_in", Math.round(O / 1e3)), this.retryTimer = new ae(O || 0, function() {
                H.disconnectInternally(), H.connect();
              });
            }, k.prototype.clearRetryTimer = function() {
              this.retryTimer && (this.retryTimer.ensureAborted(), this.retryTimer = null);
            }, k.prototype.setUnavailableTimer = function() {
              var O = this;
              this.unavailableTimer = new ae(this.options.unavailableTimeout, function() {
                O.updateState("unavailable");
              });
            }, k.prototype.clearUnavailableTimer = function() {
              this.unavailableTimer && this.unavailableTimer.ensureAborted();
            }, k.prototype.sendActivityCheck = function() {
              var O = this;
              this.stopActivityCheck(), this.connection.ping(), this.activityTimer = new ae(this.options.pongTimeout, function() {
                O.timeline.error({ pong_timed_out: O.options.pongTimeout }), O.retryIn(0);
              });
            }, k.prototype.resetActivityCheck = function() {
              var O = this;
              this.stopActivityCheck(), this.connection && !this.connection.handlesActivityChecks() && (this.activityTimer = new ae(this.activityTimeout, function() {
                O.sendActivityCheck();
              }));
            }, k.prototype.stopActivityCheck = function() {
              this.activityTimer && this.activityTimer.ensureAborted();
            }, k.prototype.buildConnectionCallbacks = function(O) {
              var H = this;
              return le({}, O, {
                message: function(V) {
                  H.resetActivityCheck(), H.emit("message", V);
                },
                ping: function() {
                  H.send_event("pusher:pong", {});
                },
                activity: function() {
                  H.resetActivityCheck();
                },
                error: function(V) {
                  H.emit("error", V);
                },
                closed: function() {
                  H.abandonConnection(), H.shouldRetry() && H.retryIn(1e3);
                }
              });
            }, k.prototype.buildHandshakeCallbacks = function(O) {
              var H = this;
              return le({}, O, {
                connected: function(V) {
                  H.activityTimeout = Math.min(H.options.activityTimeout, V.activityTimeout, V.connection.activityTimeout || 1 / 0), H.clearUnavailableTimer(), H.setConnection(V.connection), H.socket_id = H.connection.id, H.updateState("connected", { socket_id: H.socket_id });
                }
              });
            }, k.prototype.buildErrorCallbacks = function() {
              var O = this, H = function(V) {
                return function(te) {
                  te.error && O.emit("error", { type: "WebSocketError", error: te.error }), V(te);
                };
              };
              return {
                tls_only: H(function() {
                  O.usingTLS = !0, O.updateStrategy(), O.retryIn(0);
                }),
                refused: H(function() {
                  O.disconnect();
                }),
                backoff: H(function() {
                  O.retryIn(1e3);
                }),
                retry: H(function() {
                  O.retryIn(0);
                })
              };
            }, k.prototype.setConnection = function(O) {
              this.connection = O;
              for (var H in this.connectionCallbacks)
                this.connection.bind(H, this.connectionCallbacks[H]);
              this.resetActivityCheck();
            }, k.prototype.abandonConnection = function() {
              if (this.connection) {
                this.stopActivityCheck();
                for (var O in this.connectionCallbacks)
                  this.connection.unbind(O, this.connectionCallbacks[O]);
                var H = this.connection;
                return this.connection = null, H;
              }
            }, k.prototype.updateState = function(O, H) {
              var V = this.state;
              if (this.state = O, V !== O) {
                var te = O;
                te === "connected" && (te += " with new socket ID " + H.socket_id), st.debug("State changed", V + " -> " + te), this.timeline.info({ state: O, params: H }), this.emit("state_change", { previous: V, current: O }), this.emit(O, H);
              }
            }, k.prototype.shouldRetry = function() {
              return this.state === "connecting" || this.state === "connected";
            }, k;
          }(_t), br = lr, Sr = function() {
            function C() {
              this.channels = {};
            }
            return C.prototype.add = function(k, O) {
              return this.channels[k] || (this.channels[k] = Mr(k, O)), this.channels[k];
            }, C.prototype.all = function() {
              return Ae(this.channels);
            }, C.prototype.find = function(k) {
              return this.channels[k];
            }, C.prototype.remove = function(k) {
              var O = this.channels[k];
              return delete this.channels[k], O;
            }, C.prototype.disconnect = function() {
              G(this.channels, function(k) {
                k.disconnect();
              });
            }, C;
          }(), Er = Sr;
          function Mr(C, k) {
            if (C.indexOf("private-encrypted-") === 0) {
              if (k.config.nacl)
                return pn.createEncryptedChannel(C, k, k.config.nacl);
              var O = "Tried to subscribe to a private-encrypted- channel but no nacl implementation available", H = w.buildLogSuffix("encryptedChannelSupport");
              throw new re(O + ". " + H);
            } else {
              if (C.indexOf("private-") === 0)
                return pn.createPrivateChannel(C, k);
              if (C.indexOf("presence-") === 0)
                return pn.createPresenceChannel(C, k);
              if (C.indexOf("#") === 0)
                throw new L('Cannot create a channel with name "' + C + '".');
              return pn.createChannel(C, k);
            }
          }
          var jb = {
            createChannels: function() {
              return new Er();
            },
            createConnectionManager: function(C, k) {
              return new br(C, k);
            },
            createChannel: function(C, k) {
              return new Ie(C, k);
            },
            createPrivateChannel: function(C, k) {
              return new Rt(C, k);
            },
            createPresenceChannel: function(C, k) {
              return new Pt(C, k);
            },
            createEncryptedChannel: function(C, k, O) {
              return new cr(C, k, O);
            },
            createTimelineSender: function(C, k) {
              return new be(C, k);
            },
            createHandshake: function(C, k) {
              return new Fe(C, k);
            },
            createAssistantToTheTransportManager: function(C, k, O) {
              return new pt(C, k, O);
            }
          }, pn = jb, Hb = function() {
            function C(k) {
              this.options = k || {}, this.livesLeft = this.options.lives || 1 / 0;
            }
            return C.prototype.getAssistant = function(k) {
              return pn.createAssistantToTheTransportManager(this, k, {
                minPingDelay: this.options.minPingDelay,
                maxPingDelay: this.options.maxPingDelay
              });
            }, C.prototype.isAlive = function() {
              return this.livesLeft > 0;
            }, C.prototype.reportDeath = function() {
              this.livesLeft -= 1;
            }, C;
          }(), Fh = Hb, zb = function() {
            function C(k, O) {
              this.strategies = k, this.loop = !!O.loop, this.failFast = !!O.failFast, this.timeout = O.timeout, this.timeoutLimit = O.timeoutLimit;
            }
            return C.prototype.isSupported = function() {
              return $e(this.strategies, fe.method("isSupported"));
            }, C.prototype.connect = function(k, O) {
              var H = this, V = this.strategies, te = 0, Ee = this.timeout, Ke = null, At = function(ct, Vt) {
                Vt ? O(null, Vt) : (te = te + 1, H.loop && (te = te % V.length), te < V.length ? (Ee && (Ee = Ee * 2, H.timeoutLimit && (Ee = Math.min(Ee, H.timeoutLimit))), Ke = H.tryStrategy(V[te], k, { timeout: Ee, failFast: H.failFast }, At)) : O(!0));
              };
              return Ke = this.tryStrategy(V[te], k, { timeout: Ee, failFast: this.failFast }, At), {
                abort: function() {
                  Ke.abort();
                },
                forceMinPriority: function(ct) {
                  k = ct, Ke && Ke.forceMinPriority(ct);
                }
              };
            }, C.prototype.tryStrategy = function(k, O, H, V) {
              var te = null, Ee = null;
              return H.timeout > 0 && (te = new ae(H.timeout, function() {
                Ee.abort(), V(!0);
              })), Ee = k.connect(O, function(Ke, At) {
                Ke && te && te.isRunning() && !H.failFast || (te && te.ensureAborted(), V(Ke, At));
              }), {
                abort: function() {
                  te && te.ensureAborted(), Ee.abort();
                },
                forceMinPriority: function(Ke) {
                  Ee.forceMinPriority(Ke);
                }
              };
            }, C;
          }(), zn = zb, Vb = function() {
            function C(k) {
              this.strategies = k;
            }
            return C.prototype.isSupported = function() {
              return $e(this.strategies, fe.method("isSupported"));
            }, C.prototype.connect = function(k, O) {
              return Wb(this.strategies, k, function(H, V) {
                return function(te, Ee) {
                  if (V[H].error = te, te) {
                    Kb(V) && O(!0);
                    return;
                  }
                  Oe(V, function(Ke) {
                    Ke.forceMinPriority(Ee.transport.priority);
                  }), O(null, Ee);
                };
              });
            }, C;
          }(), jo = Vb;
          function Wb(C, k, O) {
            var H = qe(C, function(V, te, Ee, Ke) {
              return V.connect(k, O(te, Ke));
            });
            return {
              abort: function() {
                Oe(H, Qb);
              },
              forceMinPriority: function(V) {
                Oe(H, function(te) {
                  te.forceMinPriority(V);
                });
              }
            };
          }
          function Kb(C) {
            return Et(C, function(k) {
              return !!k.error;
            });
          }
          function Qb(C) {
            !C.error && !C.aborted && (C.abort(), C.aborted = !0);
          }
          var Gb = function() {
            function C(k, O, H) {
              this.strategy = k, this.transports = O, this.ttl = H.ttl || 1800 * 1e3, this.usingTLS = H.useTLS, this.timeline = H.timeline;
            }
            return C.prototype.isSupported = function() {
              return this.strategy.isSupported();
            }, C.prototype.connect = function(k, O) {
              var H = this.usingTLS, V = Yb(H), te = [this.strategy];
              if (V && V.timestamp + this.ttl >= fe.now()) {
                var Ee = this.transports[V.transport];
                Ee && (this.timeline.info({
                  cached: !0,
                  transport: V.transport,
                  latency: V.latency
                }), te.push(new zn([Ee], {
                  timeout: V.latency * 2 + 1e3,
                  failFast: !0
                })));
              }
              var Ke = fe.now(), At = te.pop().connect(k, function ct(Vt, gr) {
                Vt ? (Uh(H), te.length > 0 ? (Ke = fe.now(), At = te.pop().connect(k, ct)) : O(Vt)) : (Xb(H, gr.transport.name, fe.now() - Ke), O(null, gr));
              });
              return {
                abort: function() {
                  At.abort();
                },
                forceMinPriority: function(ct) {
                  k = ct, At && At.forceMinPriority(ct);
                }
              };
            }, C;
          }(), Jb = Gb;
          function Ho(C) {
            return "pusherTransport" + (C ? "TLS" : "NonTLS");
          }
          function Yb(C) {
            var k = Dt.getLocalStorage();
            if (k)
              try {
                var O = k[Ho(C)];
                if (O)
                  return JSON.parse(O);
              } catch (H) {
                Uh(C);
              }
            return null;
          }
          function Xb(C, k, O) {
            var H = Dt.getLocalStorage();
            if (H)
              try {
                H[Ho(C)] = lt({
                  timestamp: fe.now(),
                  transport: k,
                  latency: O
                });
              } catch (V) {
              }
          }
          function Uh(C) {
            var k = Dt.getLocalStorage();
            if (k)
              try {
                delete k[Ho(C)];
              } catch (O) {
              }
          }
          var Zb = function() {
            function C(k, O) {
              var H = O.delay;
              this.strategy = k, this.options = { delay: H };
            }
            return C.prototype.isSupported = function() {
              return this.strategy.isSupported();
            }, C.prototype.connect = function(k, O) {
              var H = this.strategy, V, te = new ae(this.options.delay, function() {
                V = H.connect(k, O);
              });
              return {
                abort: function() {
                  te.ensureAborted(), V && V.abort();
                },
                forceMinPriority: function(Ee) {
                  k = Ee, V && V.forceMinPriority(Ee);
                }
              };
            }, C;
          }(), Ta = Zb, em = function() {
            function C(k, O, H) {
              this.test = k, this.trueBranch = O, this.falseBranch = H;
            }
            return C.prototype.isSupported = function() {
              var k = this.test() ? this.trueBranch : this.falseBranch;
              return k.isSupported();
            }, C.prototype.connect = function(k, O) {
              var H = this.test() ? this.trueBranch : this.falseBranch;
              return H.connect(k, O);
            }, C;
          }(), Di = em, tm = function() {
            function C(k) {
              this.strategy = k;
            }
            return C.prototype.isSupported = function() {
              return this.strategy.isSupported();
            }, C.prototype.connect = function(k, O) {
              var H = this.strategy.connect(k, function(V, te) {
                te && H.abort(), O(V, te);
              });
              return H;
            }, C;
          }(), rm = tm;
          function Ni(C) {
            return function() {
              return C.isSupported();
            };
          }
          var nm = function(C, k, O) {
            var H = {};
            function V(Zh, cg, hg, lg, dg) {
              var el = O(C, Zh, cg, hg, lg, dg);
              return H[Zh] = el, el;
            }
            var te = Object.assign({}, k, {
              hostNonTLS: C.wsHost + ":" + C.wsPort,
              hostTLS: C.wsHost + ":" + C.wssPort,
              httpPath: C.wsPath
            }), Ee = Object.assign({}, te, {
              useTLS: !0
            }), Ke = Object.assign({}, k, {
              hostNonTLS: C.httpHost + ":" + C.httpPort,
              hostTLS: C.httpHost + ":" + C.httpsPort,
              httpPath: C.httpPath
            }), At = {
              loop: !0,
              timeout: 15e3,
              timeoutLimit: 6e4
            }, ct = new Fh({
              lives: 2,
              minPingDelay: 1e4,
              maxPingDelay: C.activityTimeout
            }), Vt = new Fh({
              lives: 2,
              minPingDelay: 1e4,
              maxPingDelay: C.activityTimeout
            }), gr = V("ws", "ws", 3, te, ct), nn = V("wss", "ws", 3, Ee, ct), ag = V("sockjs", "sockjs", 1, Ke), Kh = V("xhr_streaming", "xhr_streaming", 1, Ke, Vt), og = V("xdr_streaming", "xdr_streaming", 1, Ke, Vt), Qh = V("xhr_polling", "xhr_polling", 1, Ke), sg = V("xdr_polling", "xdr_polling", 1, Ke), Gh = new zn([gr], At), fg = new zn([nn], At), ug = new zn([ag], At), Jh = new zn([
              new Di(Ni(Kh), Kh, og)
            ], At), Yh = new zn([
              new Di(Ni(Qh), Qh, sg)
            ], At), Xh = new zn([
              new Di(Ni(Jh), new jo([
                Jh,
                new Ta(Yh, { delay: 4e3 })
              ]), Yh)
            ], At), Ko = new Di(Ni(Xh), Xh, ug), Qo;
            return k.useTLS ? Qo = new jo([
              Gh,
              new Ta(Ko, { delay: 2e3 })
            ]) : Qo = new jo([
              Gh,
              new Ta(fg, { delay: 2e3 }),
              new Ta(Ko, { delay: 5e3 })
            ]), new Jb(new rm(new Di(Ni(gr), Qo, Ko)), H, {
              ttl: 18e5,
              timeline: k.timeline,
              useTLS: k.useTLS
            });
          }, im = nm, am = function() {
            var C = this;
            C.timeline.info(C.buildTimelineMessage({
              transport: C.name + (C.options.useTLS ? "s" : "")
            })), C.hooks.isInitialized() ? C.changeState("initialized") : C.hooks.file ? (C.changeState("initializing"), l.load(C.hooks.file, { useTLS: C.options.useTLS }, function(k, O) {
              C.hooks.isInitialized() ? (C.changeState("initialized"), O(!0)) : (k && C.onError(k), C.onClose(), O(!1));
            })) : C.onClose();
          }, om = {
            getRequest: function(C) {
              var k = new window.XDomainRequest();
              return k.ontimeout = function() {
                C.emit("error", new U()), C.close();
              }, k.onerror = function(O) {
                C.emit("error", O), C.close();
              }, k.onprogress = function() {
                k.responseText && k.responseText.length > 0 && C.onChunk(200, k.responseText);
              }, k.onload = function() {
                k.responseText && k.responseText.length > 0 && C.onChunk(200, k.responseText), C.emit("finished", 200), C.close();
              }, k;
            },
            abortRequest: function(C) {
              C.ontimeout = C.onerror = C.onprogress = C.onload = null, C.abort();
            }
          }, sm = om, fm = /* @__PURE__ */ function() {
            var C = function(k, O) {
              return C = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(H, V) {
                H.__proto__ = V;
              } || function(H, V) {
                for (var te in V)
                  V.hasOwnProperty(te) && (H[te] = V[te]);
              }, C(k, O);
            };
            return function(k, O) {
              C(k, O);
              function H() {
                this.constructor = k;
              }
              k.prototype = O === null ? Object.create(O) : (H.prototype = O.prototype, new H());
            };
          }(), um = 256 * 1024, cm = function(C) {
            fm(k, C);
            function k(O, H, V) {
              var te = C.call(this) || this;
              return te.hooks = O, te.method = H, te.url = V, te;
            }
            return k.prototype.start = function(O) {
              var H = this;
              this.position = 0, this.xhr = this.hooks.getRequest(this), this.unloader = function() {
                H.close();
              }, Dt.addUnloadListener(this.unloader), this.xhr.open(this.method, this.url, !0), this.xhr.setRequestHeader && this.xhr.setRequestHeader("Content-Type", "application/json"), this.xhr.send(O);
            }, k.prototype.close = function() {
              this.unloader && (Dt.removeUnloadListener(this.unloader), this.unloader = null), this.xhr && (this.hooks.abortRequest(this.xhr), this.xhr = null);
            }, k.prototype.onChunk = function(O, H) {
              for (; ; ) {
                var V = this.advanceBuffer(H);
                if (V)
                  this.emit("chunk", { status: O, data: V });
                else
                  break;
              }
              this.isBufferTooLong(H) && this.emit("buffer_too_long");
            }, k.prototype.advanceBuffer = function(O) {
              var H = O.slice(this.position), V = H.indexOf(`
`);
              return V !== -1 ? (this.position += V + 1, H.slice(0, V)) : null;
            }, k.prototype.isBufferTooLong = function(O) {
              return this.position === O.length && O.length > um;
            }, k;
          }(_t), hm = cm, zo;
          (function(C) {
            C[C.CONNECTING = 0] = "CONNECTING", C[C.OPEN = 1] = "OPEN", C[C.CLOSED = 3] = "CLOSED";
          })(zo || (zo = {}));
          var Vn = zo, lm = 1, dm = function() {
            function C(k, O) {
              this.hooks = k, this.session = jh(1e3) + "/" + bm(8), this.location = pm(O), this.readyState = Vn.CONNECTING, this.openStream();
            }
            return C.prototype.send = function(k) {
              return this.sendRaw(JSON.stringify([k]));
            }, C.prototype.ping = function() {
              this.hooks.sendHeartbeat(this);
            }, C.prototype.close = function(k, O) {
              this.onClose(k, O, !0);
            }, C.prototype.sendRaw = function(k) {
              if (this.readyState === Vn.OPEN)
                try {
                  return Dt.createSocketRequest("POST", $h(vm(this.location, this.session))).start(k), !0;
                } catch (O) {
                  return !1;
                }
              else
                return !1;
            }, C.prototype.reconnect = function() {
              this.closeStream(), this.openStream();
            }, C.prototype.onClose = function(k, O, H) {
              this.closeStream(), this.readyState = Vn.CLOSED, this.onclose && this.onclose({
                code: k,
                reason: O,
                wasClean: H
              });
            }, C.prototype.onChunk = function(k) {
              if (k.status === 200) {
                this.readyState === Vn.OPEN && this.onActivity();
                var O, H = k.data.slice(0, 1);
                switch (H) {
                  case "o":
                    O = JSON.parse(k.data.slice(1) || "{}"), this.onOpen(O);
                    break;
                  case "a":
                    O = JSON.parse(k.data.slice(1) || "[]");
                    for (var V = 0; V < O.length; V++)
                      this.onEvent(O[V]);
                    break;
                  case "m":
                    O = JSON.parse(k.data.slice(1) || "null"), this.onEvent(O);
                    break;
                  case "h":
                    this.hooks.onHeartbeat(this);
                    break;
                  case "c":
                    O = JSON.parse(k.data.slice(1) || "[]"), this.onClose(O[0], O[1], !0);
                    break;
                }
              }
            }, C.prototype.onOpen = function(k) {
              this.readyState === Vn.CONNECTING ? (k && k.hostname && (this.location.base = ym(this.location.base, k.hostname)), this.readyState = Vn.OPEN, this.onopen && this.onopen()) : this.onClose(1006, "Server lost session", !0);
            }, C.prototype.onEvent = function(k) {
              this.readyState === Vn.OPEN && this.onmessage && this.onmessage({ data: k });
            }, C.prototype.onActivity = function() {
              this.onactivity && this.onactivity();
            }, C.prototype.onError = function(k) {
              this.onerror && this.onerror(k);
            }, C.prototype.openStream = function() {
              var k = this;
              this.stream = Dt.createSocketRequest("POST", $h(this.hooks.getReceiveURL(this.location, this.session))), this.stream.bind("chunk", function(O) {
                k.onChunk(O);
              }), this.stream.bind("finished", function(O) {
                k.hooks.onFinished(k, O);
              }), this.stream.bind("buffer_too_long", function() {
                k.reconnect();
              });
              try {
                this.stream.start();
              } catch (O) {
                fe.defer(function() {
                  k.onError(O), k.onClose(1006, "Could not start streaming", !1);
                });
              }
            }, C.prototype.closeStream = function() {
              this.stream && (this.stream.unbind_all(), this.stream.close(), this.stream = null);
            }, C;
          }();
          function pm(C) {
            var k = /([^\?]*)\/*(\??.*)/.exec(C);
            return {
              base: k[1],
              queryString: k[2]
            };
          }
          function vm(C, k) {
            return C.base + "/" + k + "/xhr_send";
          }
          function $h(C) {
            var k = C.indexOf("?") === -1 ? "?" : "&";
            return C + k + "t=" + +/* @__PURE__ */ new Date() + "&n=" + lm++;
          }
          function ym(C, k) {
            var O = /(https?:\/\/)([^\/:]+)((\/|:)?.*)/.exec(C);
            return O[1] + k + O[3];
          }
          function jh(C) {
            return Dt.randomInt(C);
          }
          function bm(C) {
            for (var k = [], O = 0; O < C; O++)
              k.push(jh(32).toString(32));
            return k.join("");
          }
          var mm = dm, gm = {
            getReceiveURL: function(C, k) {
              return C.base + "/" + k + "/xhr_streaming" + C.queryString;
            },
            onHeartbeat: function(C) {
              C.sendRaw("[]");
            },
            sendHeartbeat: function(C) {
              C.sendRaw("[]");
            },
            onFinished: function(C, k) {
              C.onClose(1006, "Connection interrupted (" + k + ")", !1);
            }
          }, wm = gm, _m = {
            getReceiveURL: function(C, k) {
              return C.base + "/" + k + "/xhr" + C.queryString;
            },
            onHeartbeat: function() {
            },
            sendHeartbeat: function(C) {
              C.sendRaw("[]");
            },
            onFinished: function(C, k) {
              k === 200 ? C.reconnect() : C.onClose(1006, "Connection interrupted (" + k + ")", !1);
            }
          }, xm = _m, Sm = {
            getRequest: function(C) {
              var k = Dt.getXHRAPI(), O = new k();
              return O.onreadystatechange = O.onprogress = function() {
                switch (O.readyState) {
                  case 3:
                    O.responseText && O.responseText.length > 0 && C.onChunk(O.status, O.responseText);
                    break;
                  case 4:
                    O.responseText && O.responseText.length > 0 && C.onChunk(O.status, O.responseText), C.emit("finished", O.status), C.close();
                    break;
                }
              }, O;
            },
            abortRequest: function(C) {
              C.onreadystatechange = null, C.abort();
            }
          }, Em = Sm, Mm = {
            createStreamingSocket: function(C) {
              return this.createSocket(wm, C);
            },
            createPollingSocket: function(C) {
              return this.createSocket(xm, C);
            },
            createSocket: function(C, k) {
              return new mm(C, k);
            },
            createXHR: function(C, k) {
              return this.createRequest(Em, C, k);
            },
            createRequest: function(C, k, O) {
              return new hm(C, k, O);
            }
          }, Hh = Mm;
          Hh.createXDR = function(C, k) {
            return this.createRequest(sm, C, k);
          };
          var Am = Hh, Tm = {
            nextAuthCallbackID: 1,
            auth_callbacks: {},
            ScriptReceivers: o,
            DependenciesReceivers: d,
            getDefaultStrategy: im,
            Transports: Ye,
            transportConnectionInitializer: am,
            HTTPFactory: Am,
            TimelineTransport: Je,
            getXHRAPI: function() {
              return window.XMLHttpRequest;
            },
            getWebSocketAPI: function() {
              return window.WebSocket || window.MozWebSocket;
            },
            setup: function(C) {
              var k = this;
              window.Pusher = C;
              var O = function() {
                k.onDocumentBody(C.ready);
              };
              window.JSON ? O() : l.load("json2", {}, O);
            },
            getDocument: function() {
              return document;
            },
            getProtocol: function() {
              return this.getDocument().location.protocol;
            },
            getAuthorizers: function() {
              return { ajax: A, jsonp: W };
            },
            onDocumentBody: function(C) {
              var k = this;
              document.body ? C() : setTimeout(function() {
                k.onDocumentBody(C);
              }, 0);
            },
            createJSONPRequest: function(C, k) {
              return new he(C, k);
            },
            createScriptRequest: function(C) {
              return new F(C);
            },
            getLocalStorage: function() {
              try {
                return window.localStorage;
              } catch (C) {
                return;
              }
            },
            createXHR: function() {
              return this.getXHRAPI() ? this.createXMLHttpRequest() : this.createMicrosoftXHR();
            },
            createXMLHttpRequest: function() {
              var C = this.getXHRAPI();
              return new C();
            },
            createMicrosoftXHR: function() {
              return new ActiveXObject("Microsoft.XMLHTTP");
            },
            getNetwork: function() {
              return nt;
            },
            createWebSocket: function(C) {
              var k = this.getWebSocketAPI();
              return new k(C);
            },
            createSocketRequest: function(C, k) {
              if (this.isXHRSupported())
                return this.HTTPFactory.createXHR(C, k);
              if (this.isXDRSupported(k.indexOf("https:") === 0))
                return this.HTTPFactory.createXDR(C, k);
              throw "Cross-origin HTTP requests are not supported";
            },
            isXHRSupported: function() {
              var C = this.getXHRAPI();
              return !!C && new C().withCredentials !== void 0;
            },
            isXDRSupported: function(C) {
              var k = C ? "https:" : "http:", O = this.getProtocol();
              return !!window.XDomainRequest && O === k;
            },
            addUnloadListener: function(C) {
              window.addEventListener !== void 0 ? window.addEventListener("unload", C, !1) : window.attachEvent !== void 0 && window.attachEvent("onunload", C);
            },
            removeUnloadListener: function(C) {
              window.addEventListener !== void 0 ? window.removeEventListener("unload", C, !1) : window.detachEvent !== void 0 && window.detachEvent("onunload", C);
            },
            randomInt: function(C) {
              var k = function() {
                var O = window.crypto || window.msCrypto, H = O.getRandomValues(new Uint32Array(1))[0];
                return H / Math.pow(2, 32);
              };
              return Math.floor(k() * C);
            }
          }, Dt = Tm, Vo;
          (function(C) {
            C[C.ERROR = 3] = "ERROR", C[C.INFO = 6] = "INFO", C[C.DEBUG = 7] = "DEBUG";
          })(Vo || (Vo = {}));
          var ka = Vo, km = function() {
            function C(k, O, H) {
              this.key = k, this.session = O, this.events = [], this.options = H || {}, this.sent = 0, this.uniqueID = 0;
            }
            return C.prototype.log = function(k, O) {
              k <= this.options.level && (this.events.push(le({}, O, { timestamp: fe.now() })), this.options.limit && this.events.length > this.options.limit && this.events.shift());
            }, C.prototype.error = function(k) {
              this.log(ka.ERROR, k);
            }, C.prototype.info = function(k) {
              this.log(ka.INFO, k);
            }, C.prototype.debug = function(k) {
              this.log(ka.DEBUG, k);
            }, C.prototype.isEmpty = function() {
              return this.events.length === 0;
            }, C.prototype.send = function(k, O) {
              var H = this, V = le({
                session: this.session,
                bundle: this.sent + 1,
                key: this.key,
                lib: "js",
                version: this.options.version,
                cluster: this.options.cluster,
                features: this.options.features,
                timeline: this.events
              }, this.options.params);
              return this.events = [], k(V, function(te, Ee) {
                te || H.sent++, O && O(te, Ee);
              }), !0;
            }, C.prototype.generateUniqueID = function() {
              return this.uniqueID++, this.uniqueID;
            }, C;
          }(), Im = km, Rm = function() {
            function C(k, O, H, V) {
              this.name = k, this.priority = O, this.transport = H, this.options = V || {};
            }
            return C.prototype.isSupported = function() {
              return this.transport.isSupported({
                useTLS: this.options.useTLS
              });
            }, C.prototype.connect = function(k, O) {
              var H = this;
              if (this.isSupported()) {
                if (this.priority < k)
                  return zh(new z(), O);
              } else
                return zh(new se(), O);
              var V = !1, te = this.transport.createConnection(this.name, this.priority, this.options.key, this.options), Ee = null, Ke = function() {
                te.unbind("initialized", Ke), te.connect();
              }, At = function() {
                Ee = pn.createHandshake(te, function(nn) {
                  V = !0, gr(), O(null, nn);
                });
              }, ct = function(nn) {
                gr(), O(nn);
              }, Vt = function() {
                gr();
                var nn;
                nn = lt(te), O(new K(nn));
              }, gr = function() {
                te.unbind("initialized", Ke), te.unbind("open", At), te.unbind("error", ct), te.unbind("closed", Vt);
              };
              return te.bind("initialized", Ke), te.bind("open", At), te.bind("error", ct), te.bind("closed", Vt), te.initialize(), {
                abort: function() {
                  V || (gr(), Ee ? Ee.close() : te.close());
                },
                forceMinPriority: function(nn) {
                  V || H.priority < nn && (Ee ? Ee.close() : te.close());
                }
              };
            }, C;
          }(), Cm = Rm;
          function zh(C, k) {
            return fe.defer(function() {
              k(C);
            }), {
              abort: function() {
              },
              forceMinPriority: function() {
              }
            };
          }
          var Om = Dt.Transports, Bm = function(C, k, O, H, V, te) {
            var Ee = Om[O];
            if (!Ee)
              throw new oe(O);
            var Ke = (!C.enabledTransports || X(C.enabledTransports, k) !== -1) && (!C.disabledTransports || X(C.disabledTransports, k) === -1), At;
            return Ke ? (V = Object.assign({ ignoreNullOrigin: C.ignoreNullOrigin }, V), At = new Cm(k, H, te ? te.getAssistant(Ee) : Ee, V)) : At = Pm, At;
          }, Pm = {
            isSupported: function() {
              return !1;
            },
            connect: function(C, k) {
              var O = fe.defer(function() {
                k(new se());
              });
              return {
                abort: function() {
                  O.ensureAborted();
                },
                forceMinPriority: function() {
                }
              };
            }
          }, Dm = function(C, k) {
            var O = "socket_id=" + encodeURIComponent(C.socketId);
            for (var H in k.params)
              O += "&" + encodeURIComponent(H) + "=" + encodeURIComponent(k.params[H]);
            if (k.paramsProvider != null) {
              var V = k.paramsProvider();
              for (var H in V)
                O += "&" + encodeURIComponent(H) + "=" + encodeURIComponent(V[H]);
            }
            return O;
          }, Nm = function(C) {
            if (typeof Dt.getAuthorizers()[C.transport] == "undefined")
              throw "'" + C.transport + "' is not a recognized auth transport";
            return function(k, O) {
              var H = Dm(k, C);
              Dt.getAuthorizers()[C.transport](Dt, H, C, E.UserAuthentication, O);
            };
          }, qm = Nm, Lm = function(C, k) {
            var O = "socket_id=" + encodeURIComponent(C.socketId);
            O += "&channel_name=" + encodeURIComponent(C.channelName);
            for (var H in k.params)
              O += "&" + encodeURIComponent(H) + "=" + encodeURIComponent(k.params[H]);
            if (k.paramsProvider != null) {
              var V = k.paramsProvider();
              for (var H in V)
                O += "&" + encodeURIComponent(H) + "=" + encodeURIComponent(V[H]);
            }
            return O;
          }, Fm = function(C) {
            if (typeof Dt.getAuthorizers()[C.transport] == "undefined")
              throw "'" + C.transport + "' is not a recognized auth transport";
            return function(k, O) {
              var H = Lm(k, C);
              Dt.getAuthorizers()[C.transport](Dt, H, C, E.ChannelAuthorization, O);
            };
          }, Um = Fm, $m = function(C, k, O) {
            var H = {
              authTransport: k.transport,
              authEndpoint: k.endpoint,
              auth: {
                params: k.params,
                headers: k.headers
              }
            };
            return function(V, te) {
              var Ee = C.channel(V.channelName), Ke = O(Ee, H);
              Ke.authorize(V.socketId, te);
            };
          }, oi = function() {
            return oi = Object.assign || function(C) {
              for (var k, O = 1, H = arguments.length; O < H; O++) {
                k = arguments[O];
                for (var V in k)
                  Object.prototype.hasOwnProperty.call(k, V) && (C[V] = k[V]);
              }
              return C;
            }, oi.apply(this, arguments);
          };
          function jm(C, k) {
            var O = {
              activityTimeout: C.activityTimeout || c.activityTimeout,
              cluster: C.cluster || c.cluster,
              httpPath: C.httpPath || c.httpPath,
              httpPort: C.httpPort || c.httpPort,
              httpsPort: C.httpsPort || c.httpsPort,
              pongTimeout: C.pongTimeout || c.pongTimeout,
              statsHost: C.statsHost || c.stats_host,
              unavailableTimeout: C.unavailableTimeout || c.unavailableTimeout,
              wsPath: C.wsPath || c.wsPath,
              wsPort: C.wsPort || c.wsPort,
              wssPort: C.wssPort || c.wssPort,
              enableStats: Wm(C),
              httpHost: Hm(C),
              useTLS: Vm(C),
              wsHost: zm(C),
              userAuthenticator: Km(C),
              channelAuthorizer: Gm(C, k)
            };
            return "disabledTransports" in C && (O.disabledTransports = C.disabledTransports), "enabledTransports" in C && (O.enabledTransports = C.enabledTransports), "ignoreNullOrigin" in C && (O.ignoreNullOrigin = C.ignoreNullOrigin), "timelineParams" in C && (O.timelineParams = C.timelineParams), "nacl" in C && (O.nacl = C.nacl), O;
          }
          function Hm(C) {
            return C.httpHost ? C.httpHost : C.cluster ? "sockjs-" + C.cluster + ".pusher.com" : c.httpHost;
          }
          function zm(C) {
            return C.wsHost ? C.wsHost : C.cluster ? Vh(C.cluster) : Vh(c.cluster);
          }
          function Vh(C) {
            return "ws-" + C + ".pusher.com";
          }
          function Vm(C) {
            return Dt.getProtocol() === "https:" ? !0 : C.forceTLS !== !1;
          }
          function Wm(C) {
            return "enableStats" in C ? C.enableStats : "disableStats" in C ? !C.disableStats : !1;
          }
          function Km(C) {
            var k = oi(oi({}, c.userAuthentication), C.userAuthentication);
            return "customHandler" in k && k.customHandler != null ? k.customHandler : qm(k);
          }
          function Qm(C, k) {
            var O;
            return "channelAuthorization" in C ? O = oi(oi({}, c.channelAuthorization), C.channelAuthorization) : (O = {
              transport: C.authTransport || c.authTransport,
              endpoint: C.authEndpoint || c.authEndpoint
            }, "auth" in C && ("params" in C.auth && (O.params = C.auth.params), "headers" in C.auth && (O.headers = C.auth.headers)), "authorizer" in C && (O.customHandler = $m(k, O, C.authorizer))), O;
          }
          function Gm(C, k) {
            var O = Qm(C, k);
            return "customHandler" in O && O.customHandler != null ? O.customHandler : Um(O);
          }
          var Jm = /* @__PURE__ */ function() {
            var C = function(k, O) {
              return C = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(H, V) {
                H.__proto__ = V;
              } || function(H, V) {
                for (var te in V)
                  V.hasOwnProperty(te) && (H[te] = V[te]);
              }, C(k, O);
            };
            return function(k, O) {
              C(k, O);
              function H() {
                this.constructor = k;
              }
              k.prototype = O === null ? Object.create(O) : (H.prototype = O.prototype, new H());
            };
          }(), Ym = function(C) {
            Jm(k, C);
            function k(O) {
              var H = C.call(this, function(V, te) {
                st.debug("No callbacks on watchlist events for " + V);
              }) || this;
              return H.pusher = O, H.bindWatchlistInternalEvent(), H;
            }
            return k.prototype.handleEvent = function(O) {
              var H = this;
              O.data.events.forEach(function(V) {
                H.emit(V.name, V);
              });
            }, k.prototype.bindWatchlistInternalEvent = function() {
              var O = this;
              this.pusher.connection.bind("message", function(H) {
                var V = H.event;
                V === "pusher_internal:watchlist_events" && O.handleEvent(H);
              });
            }, k;
          }(_t), Xm = Ym;
          function Zm() {
            var C, k, O = new Promise(function(H, V) {
              C = H, k = V;
            });
            return { promise: O, resolve: C, reject: k };
          }
          var eg = Zm, tg = /* @__PURE__ */ function() {
            var C = function(k, O) {
              return C = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(H, V) {
                H.__proto__ = V;
              } || function(H, V) {
                for (var te in V)
                  V.hasOwnProperty(te) && (H[te] = V[te]);
              }, C(k, O);
            };
            return function(k, O) {
              C(k, O);
              function H() {
                this.constructor = k;
              }
              k.prototype = O === null ? Object.create(O) : (H.prototype = O.prototype, new H());
            };
          }(), rg = function(C) {
            tg(k, C);
            function k(O) {
              var H = C.call(this, function(V, te) {
                st.debug("No callbacks on user for " + V);
              }) || this;
              return H.signin_requested = !1, H.user_data = null, H.serverToUserChannel = null, H.signinDonePromise = null, H._signinDoneResolve = null, H._onAuthorize = function(V, te) {
                if (V) {
                  st.warn("Error during signin: " + V), H._cleanup();
                  return;
                }
                H.pusher.send_event("pusher:signin", {
                  auth: te.auth,
                  user_data: te.user_data
                });
              }, H.pusher = O, H.pusher.connection.bind("state_change", function(V) {
                var te = V.previous, Ee = V.current;
                te !== "connected" && Ee === "connected" && H._signin(), te === "connected" && Ee !== "connected" && (H._cleanup(), H._newSigninPromiseIfNeeded());
              }), H.watchlist = new Xm(O), H.pusher.connection.bind("message", function(V) {
                var te = V.event;
                te === "pusher:signin_success" && H._onSigninSuccess(V.data), H.serverToUserChannel && H.serverToUserChannel.name === V.channel && H.serverToUserChannel.handleEvent(V);
              }), H;
            }
            return k.prototype.signin = function() {
              this.signin_requested || (this.signin_requested = !0, this._signin());
            }, k.prototype._signin = function() {
              this.signin_requested && (this._newSigninPromiseIfNeeded(), this.pusher.connection.state === "connected" && this.pusher.config.userAuthenticator({
                socketId: this.pusher.connection.socket_id
              }, this._onAuthorize));
            }, k.prototype._onSigninSuccess = function(O) {
              try {
                this.user_data = JSON.parse(O.user_data);
              } catch (H) {
                st.error("Failed parsing user data after signin: " + O.user_data), this._cleanup();
                return;
              }
              if (typeof this.user_data.id != "string" || this.user_data.id === "") {
                st.error("user_data doesn't contain an id. user_data: " + this.user_data), this._cleanup();
                return;
              }
              this._signinDoneResolve(), this._subscribeChannels();
            }, k.prototype._subscribeChannels = function() {
              var O = this, H = function(V) {
                V.subscriptionPending && V.subscriptionCancelled ? V.reinstateSubscription() : !V.subscriptionPending && O.pusher.connection.state === "connected" && V.subscribe();
              };
              this.serverToUserChannel = new Ie("#server-to-user-" + this.user_data.id, this.pusher), this.serverToUserChannel.bind_global(function(V, te) {
                V.indexOf("pusher_internal:") === 0 || V.indexOf("pusher:") === 0 || O.emit(V, te);
              }), H(this.serverToUserChannel);
            }, k.prototype._cleanup = function() {
              this.user_data = null, this.serverToUserChannel && (this.serverToUserChannel.unbind_all(), this.serverToUserChannel.disconnect(), this.serverToUserChannel = null), this.signin_requested && this._signinDoneResolve();
            }, k.prototype._newSigninPromiseIfNeeded = function() {
              if (this.signin_requested && !(this.signinDonePromise && !this.signinDonePromise.done)) {
                var O = eg(), H = O.promise, V = O.resolve;
                H.done = !1;
                var te = function() {
                  H.done = !0;
                };
                H.then(te).catch(te), this.signinDonePromise = H, this._signinDoneResolve = V;
              }
            }, k;
          }(_t), ng = rg, Wh = function() {
            function C(k, O) {
              var H = this;
              if (ig(k), O = O || {}, !O.cluster && !(O.wsHost || O.httpHost)) {
                var V = w.buildLogSuffix("javascriptQuickStart");
                st.warn("You should always specify a cluster when connecting. " + V);
              }
              "disableStats" in O && st.warn("The disableStats option is deprecated in favor of enableStats"), this.key = k, this.config = jm(O, this), this.channels = pn.createChannels(), this.global_emitter = new _t(), this.sessionID = Dt.randomInt(1e9), this.timeline = new Im(this.key, this.sessionID, {
                cluster: this.config.cluster,
                features: C.getClientFeatures(),
                params: this.config.timelineParams || {},
                limit: 50,
                level: ka.INFO,
                version: c.VERSION
              }), this.config.enableStats && (this.timelineSender = pn.createTimelineSender(this.timeline, {
                host: this.config.statsHost,
                path: "/timeline/v2/" + Dt.TimelineTransport.name
              }));
              var te = function(Ee) {
                return Dt.getDefaultStrategy(H.config, Ee, Bm);
              };
              this.connection = pn.createConnectionManager(this.key, {
                getStrategy: te,
                timeline: this.timeline,
                activityTimeout: this.config.activityTimeout,
                pongTimeout: this.config.pongTimeout,
                unavailableTimeout: this.config.unavailableTimeout,
                useTLS: !!this.config.useTLS
              }), this.connection.bind("connected", function() {
                H.subscribeAll(), H.timelineSender && H.timelineSender.send(H.connection.isUsingTLS());
              }), this.connection.bind("message", function(Ee) {
                var Ke = Ee.event, At = Ke.indexOf("pusher_internal:") === 0;
                if (Ee.channel) {
                  var ct = H.channel(Ee.channel);
                  ct && ct.handleEvent(Ee);
                }
                At || H.global_emitter.emit(Ee.event, Ee.data);
              }), this.connection.bind("connecting", function() {
                H.channels.disconnect();
              }), this.connection.bind("disconnected", function() {
                H.channels.disconnect();
              }), this.connection.bind("error", function(Ee) {
                st.warn(Ee);
              }), C.instances.push(this), this.timeline.info({ instances: C.instances.length }), this.user = new ng(this), C.isReady && this.connect();
            }
            return C.ready = function() {
              C.isReady = !0;
              for (var k = 0, O = C.instances.length; k < O; k++)
                C.instances[k].connect();
            }, C.getClientFeatures = function() {
              return we(ge({ ws: Dt.Transports.ws }, function(k) {
                return k.isSupported({});
              }));
            }, C.prototype.channel = function(k) {
              return this.channels.find(k);
            }, C.prototype.allChannels = function() {
              return this.channels.all();
            }, C.prototype.connect = function() {
              if (this.connection.connect(), this.timelineSender && !this.timelineSenderTimer) {
                var k = this.connection.isUsingTLS(), O = this.timelineSender;
                this.timelineSenderTimer = new Z(6e4, function() {
                  O.send(k);
                });
              }
            }, C.prototype.disconnect = function() {
              this.connection.disconnect(), this.timelineSenderTimer && (this.timelineSenderTimer.ensureAborted(), this.timelineSenderTimer = null);
            }, C.prototype.bind = function(k, O, H) {
              return this.global_emitter.bind(k, O, H), this;
            }, C.prototype.unbind = function(k, O, H) {
              return this.global_emitter.unbind(k, O, H), this;
            }, C.prototype.bind_global = function(k) {
              return this.global_emitter.bind_global(k), this;
            }, C.prototype.unbind_global = function(k) {
              return this.global_emitter.unbind_global(k), this;
            }, C.prototype.unbind_all = function(k) {
              return this.global_emitter.unbind_all(), this;
            }, C.prototype.subscribeAll = function() {
              var k;
              for (k in this.channels.channels)
                this.channels.channels.hasOwnProperty(k) && this.subscribe(k);
            }, C.prototype.subscribe = function(k) {
              var O = this.channels.add(k, this);
              return O.subscriptionPending && O.subscriptionCancelled ? O.reinstateSubscription() : !O.subscriptionPending && this.connection.state === "connected" && O.subscribe(), O;
            }, C.prototype.unsubscribe = function(k) {
              var O = this.channels.find(k);
              O && O.subscriptionPending ? O.cancelSubscription() : (O = this.channels.remove(k), O && O.subscribed && O.unsubscribe());
            }, C.prototype.send_event = function(k, O, H) {
              return this.connection.send_event(k, O, H);
            }, C.prototype.shouldUseTLS = function() {
              return this.config.useTLS;
            }, C.prototype.signin = function() {
              this.user.signin();
            }, C.instances = [], C.isReady = !1, C.logToConsole = !1, C.Runtime = Dt, C.ScriptReceivers = Dt.ScriptReceivers, C.DependenciesReceivers = Dt.DependenciesReceivers, C.auth_callbacks = Dt.auth_callbacks, C;
          }(), Wo = n.default = Wh;
          function ig(C) {
            if (C == null)
              throw "You must pass your app key when you instantiate Pusher.";
          }
          Dt.setup(Wh);
        }
        /******/
      ])
    );
  });
})(Nb);
var E8 = Nb.exports;
const M8 = /* @__PURE__ */ ki(E8);
var Fc = { exports: {} };
/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
(function(r, e) {
  (function(t, n) {
    n(e);
  })(Jt, function(t) {
    function n() {
      for (var N = arguments.length, D = Array(N), _ = 0; _ < N; _++)
        D[_] = arguments[_];
      if (D.length > 1) {
        D[0] = D[0].slice(0, -1);
        for (var $ = D.length - 1, Y = 1; Y < $; ++Y)
          D[Y] = D[Y].slice(1, -1);
        return D[$] = D[$].slice(1), D.join("");
      } else
        return D[0];
    }
    function a(N) {
      return "(?:" + N + ")";
    }
    function i(N) {
      return N === void 0 ? "undefined" : N === null ? "null" : Object.prototype.toString.call(N).split(" ").pop().split("]").shift().toLowerCase();
    }
    function o(N) {
      return N.toUpperCase();
    }
    function u(N) {
      return N != null ? N instanceof Array ? N : typeof N.length != "number" || N.split || N.setInterval || N.call ? [N] : Array.prototype.slice.call(N) : [];
    }
    function c(N, D) {
      var _ = N;
      if (D)
        for (var $ in D)
          _[$] = D[$];
      return _;
    }
    function h(N) {
      var D = "[A-Za-z]", _ = "[0-9]", $ = n(_, "[A-Fa-f]"), Y = a(a("%[EFef]" + $ + "%" + $ + $ + "%" + $ + $) + "|" + a("%[89A-Fa-f]" + $ + "%" + $ + $) + "|" + a("%" + $ + $)), ie = "[\\:\\/\\?\\#\\[\\]\\@]", ce = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", me = n(ie, ce), Me = N ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", Se = N ? "[\\uE000-\\uF8FF]" : "[]", Ge = n(D, _, "[\\-\\.\\_\\~]", Me);
      a(D + n(D, _, "[\\+\\-\\.]") + "*"), a(a(Y + "|" + n(Ge, ce, "[\\:]")) + "*");
      var Be = a(a("25[0-5]") + "|" + a("2[0-4]" + _) + "|" + a("1" + _ + _) + "|" + a("0?[1-9]" + _) + "|0?0?" + _), Ye = a(Be + "\\." + Be + "\\." + Be + "\\." + Be), Pe = a($ + "{1,4}"), et = a(a(Pe + "\\:" + Pe) + "|" + Ye), nt = a(a(Pe + "\\:") + "{6}" + et), Qe = a("\\:\\:" + a(Pe + "\\:") + "{5}" + et), pt = a(a(Pe) + "?\\:\\:" + a(Pe + "\\:") + "{4}" + et), ut = a(a(a(Pe + "\\:") + "{0,1}" + Pe) + "?\\:\\:" + a(Pe + "\\:") + "{3}" + et), Le = a(a(a(Pe + "\\:") + "{0,2}" + Pe) + "?\\:\\:" + a(Pe + "\\:") + "{2}" + et), it = a(a(a(Pe + "\\:") + "{0,3}" + Pe) + "?\\:\\:" + Pe + "\\:" + et), je = a(a(a(Pe + "\\:") + "{0,4}" + Pe) + "?\\:\\:" + et), He = a(a(a(Pe + "\\:") + "{0,5}" + Pe) + "?\\:\\:" + Pe), We = a(a(a(Pe + "\\:") + "{0,6}" + Pe) + "?\\:\\:"), Fe = a([nt, Qe, pt, ut, Le, it, je, He, We].join("|")), ye = a(a(Ge + "|" + Y) + "+");
      a("[vV]" + $ + "+\\." + n(Ge, ce, "[\\:]") + "+"), a(a(Y + "|" + n(Ge, ce)) + "*");
      var be = a(Y + "|" + n(Ge, ce, "[\\:\\@]"));
      return a(a(Y + "|" + n(Ge, ce, "[\\@]")) + "+"), a(a(be + "|" + n("[\\/\\?]", Se)) + "*"), {
        NOT_SCHEME: new RegExp(n("[^]", D, _, "[\\+\\-\\.]"), "g"),
        NOT_USERINFO: new RegExp(n("[^\\%\\:]", Ge, ce), "g"),
        NOT_HOST: new RegExp(n("[^\\%\\[\\]\\:]", Ge, ce), "g"),
        NOT_PATH: new RegExp(n("[^\\%\\/\\:\\@]", Ge, ce), "g"),
        NOT_PATH_NOSCHEME: new RegExp(n("[^\\%\\/\\@]", Ge, ce), "g"),
        NOT_QUERY: new RegExp(n("[^\\%]", Ge, ce, "[\\:\\@\\/\\?]", Se), "g"),
        NOT_FRAGMENT: new RegExp(n("[^\\%]", Ge, ce, "[\\:\\@\\/\\?]"), "g"),
        ESCAPE: new RegExp(n("[^]", Ge, ce), "g"),
        UNRESERVED: new RegExp(Ge, "g"),
        OTHER_CHARS: new RegExp(n("[^\\%]", Ge, me), "g"),
        PCT_ENCODED: new RegExp(Y, "g"),
        IPV4ADDRESS: new RegExp("^(" + Ye + ")$"),
        IPV6ADDRESS: new RegExp("^\\[?(" + Fe + ")" + a(a("\\%25|\\%(?!" + $ + "{2})") + "(" + ye + ")") + "?\\]?$")
        //RFC 6874, with relaxed parsing rules
      };
    }
    var s = h(!1), d = h(!0), l = /* @__PURE__ */ function() {
      function N(D, _) {
        var $ = [], Y = !0, ie = !1, ce = void 0;
        try {
          for (var me = D[Symbol.iterator](), Me; !(Y = (Me = me.next()).done) && ($.push(Me.value), !(_ && $.length === _)); Y = !0)
            ;
        } catch (Se) {
          ie = !0, ce = Se;
        } finally {
          try {
            !Y && me.return && me.return();
          } finally {
            if (ie)
              throw ce;
          }
        }
        return $;
      }
      return function(D, _) {
        if (Array.isArray(D))
          return D;
        if (Symbol.iterator in Object(D))
          return N(D, _);
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      };
    }(), y = function(N) {
      if (Array.isArray(N)) {
        for (var D = 0, _ = Array(N.length); D < N.length; D++)
          _[D] = N[D];
        return _;
      } else
        return Array.from(N);
    }, m = 2147483647, w = 36, E = 1, S = 26, P = 38, L = 700, U = 72, z = 128, K = "-", re = /^xn--/, oe = /[^\0-\x7E]/, se = /[\x2E\u3002\uFF0E\uFF61]/g, ve = {
      overflow: "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    }, Q = w - E, A = Math.floor, b = String.fromCharCode;
    function f(N) {
      throw new RangeError(ve[N]);
    }
    function v(N, D) {
      for (var _ = [], $ = N.length; $--; )
        _[$] = D(N[$]);
      return _;
    }
    function g(N, D) {
      var _ = N.split("@"), $ = "";
      _.length > 1 && ($ = _[0] + "@", N = _[1]), N = N.replace(se, ".");
      var Y = N.split("."), ie = v(Y, D).join(".");
      return $ + ie;
    }
    function M(N) {
      for (var D = [], _ = 0, $ = N.length; _ < $; ) {
        var Y = N.charCodeAt(_++);
        if (Y >= 55296 && Y <= 56319 && _ < $) {
          var ie = N.charCodeAt(_++);
          (ie & 64512) == 56320 ? D.push(((Y & 1023) << 10) + (ie & 1023) + 65536) : (D.push(Y), _--);
        } else
          D.push(Y);
      }
      return D;
    }
    var I = function(D) {
      return String.fromCodePoint.apply(String, y(D));
    }, R = function(D) {
      return D - 48 < 10 ? D - 22 : D - 65 < 26 ? D - 65 : D - 97 < 26 ? D - 97 : w;
    }, x = function(D, _) {
      return D + 22 + 75 * (D < 26) - ((_ != 0) << 5);
    }, T = function(D, _, $) {
      var Y = 0;
      for (
        D = $ ? A(D / L) : D >> 1, D += A(D / _);
        /* no initialization */
        D > Q * S >> 1;
        Y += w
      )
        D = A(D / Q);
      return A(Y + (Q + 1) * D / (D + P));
    }, p = function(D) {
      var _ = [], $ = D.length, Y = 0, ie = z, ce = U, me = D.lastIndexOf(K);
      me < 0 && (me = 0);
      for (var Me = 0; Me < me; ++Me)
        D.charCodeAt(Me) >= 128 && f("not-basic"), _.push(D.charCodeAt(Me));
      for (var Se = me > 0 ? me + 1 : 0; Se < $; ) {
        for (
          var Ge = Y, Be = 1, Ye = w;
          ;
          /* no condition */
          Ye += w
        ) {
          Se >= $ && f("invalid-input");
          var Pe = R(D.charCodeAt(Se++));
          (Pe >= w || Pe > A((m - Y) / Be)) && f("overflow"), Y += Pe * Be;
          var et = Ye <= ce ? E : Ye >= ce + S ? S : Ye - ce;
          if (Pe < et)
            break;
          var nt = w - et;
          Be > A(m / nt) && f("overflow"), Be *= nt;
        }
        var Qe = _.length + 1;
        ce = T(Y - Ge, Qe, Ge == 0), A(Y / Qe) > m - ie && f("overflow"), ie += A(Y / Qe), Y %= Qe, _.splice(Y++, 0, ie);
      }
      return String.fromCodePoint.apply(String, _);
    }, B = function(D) {
      var _ = [];
      D = M(D);
      var $ = D.length, Y = z, ie = 0, ce = U, me = !0, Me = !1, Se = void 0;
      try {
        for (var Ge = D[Symbol.iterator](), Be; !(me = (Be = Ge.next()).done); me = !0) {
          var Ye = Be.value;
          Ye < 128 && _.push(b(Ye));
        }
      } catch (It) {
        Me = !0, Se = It;
      } finally {
        try {
          !me && Ge.return && Ge.return();
        } finally {
          if (Me)
            throw Se;
        }
      }
      var Pe = _.length, et = Pe;
      for (Pe && _.push(K); et < $; ) {
        var nt = m, Qe = !0, pt = !1, ut = void 0;
        try {
          for (var Le = D[Symbol.iterator](), it; !(Qe = (it = Le.next()).done); Qe = !0) {
            var je = it.value;
            je >= Y && je < nt && (nt = je);
          }
        } catch (It) {
          pt = !0, ut = It;
        } finally {
          try {
            !Qe && Le.return && Le.return();
          } finally {
            if (pt)
              throw ut;
          }
        }
        var He = et + 1;
        nt - Y > A((m - ie) / He) && f("overflow"), ie += (nt - Y) * He, Y = nt;
        var We = !0, Fe = !1, ye = void 0;
        try {
          for (var be = D[Symbol.iterator](), Re; !(We = (Re = be.next()).done); We = !0) {
            var Te = Re.value;
            if (Te < Y && ++ie > m && f("overflow"), Te == Y) {
              for (
                var Ie = ie, De = w;
                ;
                /* no condition */
                De += w
              ) {
                var xt = De <= ce ? E : De >= ce + S ? S : De - ce;
                if (Ie < xt)
                  break;
                var Rt = Ie - xt, Ot = w - xt;
                _.push(b(x(xt + Rt % Ot, 0))), Ie = A(Rt / Ot);
              }
              _.push(b(x(Ie, 0))), ce = T(ie, He, et == Pe), ie = 0, ++et;
            }
          }
        } catch (It) {
          Fe = !0, ye = It;
        } finally {
          try {
            !We && be.return && be.return();
          } finally {
            if (Fe)
              throw ye;
          }
        }
        ++ie, ++Y;
      }
      return _.join("");
    }, ee = function(D) {
      return g(D, function(_) {
        return re.test(_) ? p(_.slice(4).toLowerCase()) : _;
      });
    }, ae = function(D) {
      return g(D, function(_) {
        return oe.test(_) ? "xn--" + B(_) : _;
      });
    }, Z = {
      /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */
      version: "2.1.0",
      /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */
      ucs2: {
        decode: M,
        encode: I
      },
      decode: p,
      encode: B,
      toASCII: ae,
      toUnicode: ee
    }, ne = {};
    function fe(N) {
      var D = N.charCodeAt(0), _ = void 0;
      return D < 16 ? _ = "%0" + D.toString(16).toUpperCase() : D < 128 ? _ = "%" + D.toString(16).toUpperCase() : D < 2048 ? _ = "%" + (D >> 6 | 192).toString(16).toUpperCase() + "%" + (D & 63 | 128).toString(16).toUpperCase() : _ = "%" + (D >> 12 | 224).toString(16).toUpperCase() + "%" + (D >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (D & 63 | 128).toString(16).toUpperCase(), _;
    }
    function le(N) {
      for (var D = "", _ = 0, $ = N.length; _ < $; ) {
        var Y = parseInt(N.substr(_ + 1, 2), 16);
        if (Y < 128)
          D += String.fromCharCode(Y), _ += 3;
        else if (Y >= 194 && Y < 224) {
          if ($ - _ >= 6) {
            var ie = parseInt(N.substr(_ + 4, 2), 16);
            D += String.fromCharCode((Y & 31) << 6 | ie & 63);
          } else
            D += N.substr(_, 6);
          _ += 6;
        } else if (Y >= 224) {
          if ($ - _ >= 9) {
            var ce = parseInt(N.substr(_ + 4, 2), 16), me = parseInt(N.substr(_ + 7, 2), 16);
            D += String.fromCharCode((Y & 15) << 12 | (ce & 63) << 6 | me & 63);
          } else
            D += N.substr(_, 9);
          _ += 9;
        } else
          D += N.substr(_, 3), _ += 3;
      }
      return D;
    }
    function ke(N, D) {
      function _($) {
        var Y = le($);
        return Y.match(D.UNRESERVED) ? Y : $;
      }
      return N.scheme && (N.scheme = String(N.scheme).replace(D.PCT_ENCODED, _).toLowerCase().replace(D.NOT_SCHEME, "")), N.userinfo !== void 0 && (N.userinfo = String(N.userinfo).replace(D.PCT_ENCODED, _).replace(D.NOT_USERINFO, fe).replace(D.PCT_ENCODED, o)), N.host !== void 0 && (N.host = String(N.host).replace(D.PCT_ENCODED, _).toLowerCase().replace(D.NOT_HOST, fe).replace(D.PCT_ENCODED, o)), N.path !== void 0 && (N.path = String(N.path).replace(D.PCT_ENCODED, _).replace(N.scheme ? D.NOT_PATH : D.NOT_PATH_NOSCHEME, fe).replace(D.PCT_ENCODED, o)), N.query !== void 0 && (N.query = String(N.query).replace(D.PCT_ENCODED, _).replace(D.NOT_QUERY, fe).replace(D.PCT_ENCODED, o)), N.fragment !== void 0 && (N.fragment = String(N.fragment).replace(D.PCT_ENCODED, _).replace(D.NOT_FRAGMENT, fe).replace(D.PCT_ENCODED, o)), N;
    }
    function X(N) {
      return N.replace(/^0*(.*)/, "$1") || "0";
    }
    function G(N, D) {
      var _ = N.match(D.IPV4ADDRESS) || [], $ = l(_, 2), Y = $[1];
      return Y ? Y.split(".").map(X).join(".") : N;
    }
    function we(N, D) {
      var _ = N.match(D.IPV6ADDRESS) || [], $ = l(_, 3), Y = $[1], ie = $[2];
      if (Y) {
        for (var ce = Y.toLowerCase().split("::").reverse(), me = l(ce, 2), Me = me[0], Se = me[1], Ge = Se ? Se.split(":").map(X) : [], Be = Me.split(":").map(X), Ye = D.IPV4ADDRESS.test(Be[Be.length - 1]), Pe = Ye ? 7 : 8, et = Be.length - Pe, nt = Array(Pe), Qe = 0; Qe < Pe; ++Qe)
          nt[Qe] = Ge[Qe] || Be[et + Qe] || "";
        Ye && (nt[Pe - 1] = G(nt[Pe - 1], D));
        var pt = nt.reduce(function(He, We, Fe) {
          if (!We || We === "0") {
            var ye = He[He.length - 1];
            ye && ye.index + ye.length === Fe ? ye.length++ : He.push({ index: Fe, length: 1 });
          }
          return He;
        }, []), ut = pt.sort(function(He, We) {
          return We.length - He.length;
        })[0], Le = void 0;
        if (ut && ut.length > 1) {
          var it = nt.slice(0, ut.index), je = nt.slice(ut.index + ut.length);
          Le = it.join(":") + "::" + je.join(":");
        } else
          Le = nt.join(":");
        return ie && (Le += "%" + ie), Le;
      } else
        return N;
    }
    var Ae = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i, Oe = "".match(/(){0}/)[1] === void 0;
    function qe(N) {
      var D = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ = {}, $ = D.iri !== !1 ? d : s;
      D.reference === "suffix" && (N = (D.scheme ? D.scheme + ":" : "") + "//" + N);
      var Y = N.match(Ae);
      if (Y) {
        Oe ? (_.scheme = Y[1], _.userinfo = Y[3], _.host = Y[4], _.port = parseInt(Y[5], 10), _.path = Y[6] || "", _.query = Y[7], _.fragment = Y[8], isNaN(_.port) && (_.port = Y[5])) : (_.scheme = Y[1] || void 0, _.userinfo = N.indexOf("@") !== -1 ? Y[3] : void 0, _.host = N.indexOf("//") !== -1 ? Y[4] : void 0, _.port = parseInt(Y[5], 10), _.path = Y[6] || "", _.query = N.indexOf("?") !== -1 ? Y[7] : void 0, _.fragment = N.indexOf("#") !== -1 ? Y[8] : void 0, isNaN(_.port) && (_.port = N.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? Y[4] : void 0)), _.host && (_.host = we(G(_.host, $), $)), _.scheme === void 0 && _.userinfo === void 0 && _.host === void 0 && _.port === void 0 && !_.path && _.query === void 0 ? _.reference = "same-document" : _.scheme === void 0 ? _.reference = "relative" : _.fragment === void 0 ? _.reference = "absolute" : _.reference = "uri", D.reference && D.reference !== "suffix" && D.reference !== _.reference && (_.error = _.error || "URI is not a " + D.reference + " reference.");
        var ie = ne[(D.scheme || _.scheme || "").toLowerCase()];
        if (!D.unicodeSupport && (!ie || !ie.unicodeSupport)) {
          if (_.host && (D.domainHost || ie && ie.domainHost))
            try {
              _.host = Z.toASCII(_.host.replace($.PCT_ENCODED, le).toLowerCase());
            } catch (ce) {
              _.error = _.error || "Host's domain name can not be converted to ASCII via punycode: " + ce;
            }
          ke(_, s);
        } else
          ke(_, $);
        ie && ie.parse && ie.parse(_, D);
      } else
        _.error = _.error || "URI can not be parsed.";
      return _;
    }
    function Ue(N, D) {
      var _ = D.iri !== !1 ? d : s, $ = [];
      return N.userinfo !== void 0 && ($.push(N.userinfo), $.push("@")), N.host !== void 0 && $.push(we(G(String(N.host), _), _).replace(_.IPV6ADDRESS, function(Y, ie, ce) {
        return "[" + ie + (ce ? "%25" + ce : "") + "]";
      })), (typeof N.port == "number" || typeof N.port == "string") && ($.push(":"), $.push(String(N.port))), $.length ? $.join("") : void 0;
    }
    var ze = /^\.\.?\//, ge = /^\/\.(\/|$)/, ht = /^\/\.\.(\/|$)/, $e = /^\/?(?:.|\n)*?(?=\/|$)/;
    function Et(N) {
      for (var D = []; N.length; )
        if (N.match(ze))
          N = N.replace(ze, "");
        else if (N.match(ge))
          N = N.replace(ge, "/");
        else if (N.match(ht))
          N = N.replace(ht, "/"), D.pop();
        else if (N === "." || N === "..")
          N = "";
        else {
          var _ = N.match($e);
          if (_) {
            var $ = _[0];
            N = N.slice($.length), D.push($);
          } else
            throw new Error("Unexpected dot segment condition");
        }
      return D.join("");
    }
    function ot(N) {
      var D = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ = D.iri ? d : s, $ = [], Y = ne[(D.scheme || N.scheme || "").toLowerCase()];
      if (Y && Y.serialize && Y.serialize(N, D), N.host && !_.IPV6ADDRESS.test(N.host)) {
        if (D.domainHost || Y && Y.domainHost)
          try {
            N.host = D.iri ? Z.toUnicode(N.host) : Z.toASCII(N.host.replace(_.PCT_ENCODED, le).toLowerCase());
          } catch (me) {
            N.error = N.error || "Host's domain name can not be converted to " + (D.iri ? "Unicode" : "ASCII") + " via punycode: " + me;
          }
      }
      ke(N, _), D.reference !== "suffix" && N.scheme && ($.push(N.scheme), $.push(":"));
      var ie = Ue(N, D);
      if (ie !== void 0 && (D.reference !== "suffix" && $.push("//"), $.push(ie), N.path && N.path.charAt(0) !== "/" && $.push("/")), N.path !== void 0) {
        var ce = N.path;
        !D.absolutePath && (!Y || !Y.absolutePath) && (ce = Et(ce)), ie === void 0 && (ce = ce.replace(/^\/\//, "/%2F")), $.push(ce);
      }
      return N.query !== void 0 && ($.push("?"), $.push(N.query)), N.fragment !== void 0 && ($.push("#"), $.push(N.fragment)), $.join("");
    }
    function Ve(N, D) {
      var _ = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, $ = arguments[3], Y = {};
      return $ || (N = qe(ot(N, _), _), D = qe(ot(D, _), _)), _ = _ || {}, !_.tolerant && D.scheme ? (Y.scheme = D.scheme, Y.userinfo = D.userinfo, Y.host = D.host, Y.port = D.port, Y.path = Et(D.path || ""), Y.query = D.query) : (D.userinfo !== void 0 || D.host !== void 0 || D.port !== void 0 ? (Y.userinfo = D.userinfo, Y.host = D.host, Y.port = D.port, Y.path = Et(D.path || ""), Y.query = D.query) : (D.path ? (D.path.charAt(0) === "/" ? Y.path = Et(D.path) : ((N.userinfo !== void 0 || N.host !== void 0 || N.port !== void 0) && !N.path ? Y.path = "/" + D.path : N.path ? Y.path = N.path.slice(0, N.path.lastIndexOf("/") + 1) + D.path : Y.path = D.path, Y.path = Et(Y.path)), Y.query = D.query) : (Y.path = N.path, D.query !== void 0 ? Y.query = D.query : Y.query = N.query), Y.userinfo = N.userinfo, Y.host = N.host, Y.port = N.port), Y.scheme = N.scheme), Y.fragment = D.fragment, Y;
    }
    function Mt(N, D, _) {
      var $ = c({ scheme: "null" }, _);
      return ot(Ve(qe(N, $), qe(D, $), $, !0), $);
    }
    function lt(N, D) {
      return typeof N == "string" ? N = ot(qe(N, D), D) : i(N) === "object" && (N = qe(ot(N, D), D)), N;
    }
    function Xe(N, D, _) {
      return typeof N == "string" ? N = ot(qe(N, _), _) : i(N) === "object" && (N = ot(N, _)), typeof D == "string" ? D = ot(qe(D, _), _) : i(D) === "object" && (D = ot(D, _)), N === D;
    }
    function st(N, D) {
      return N && N.toString().replace(!D || !D.iri ? s.ESCAPE : d.ESCAPE, fe);
    }
    function gt(N, D) {
      return N && N.toString().replace(!D || !D.iri ? s.PCT_ENCODED : d.PCT_ENCODED, le);
    }
    var W = {
      scheme: "http",
      domainHost: !0,
      parse: function(D, _) {
        return D.host || (D.error = D.error || "HTTP URIs must have a host."), D;
      },
      serialize: function(D, _) {
        var $ = String(D.scheme).toLowerCase() === "https";
        return (D.port === ($ ? 443 : 80) || D.port === "") && (D.port = void 0), D.path || (D.path = "/"), D;
      }
    }, q = {
      scheme: "https",
      domainHost: W.domainHost,
      parse: W.parse,
      serialize: W.serialize
    };
    function F(N) {
      return typeof N.secure == "boolean" ? N.secure : String(N.scheme).toLowerCase() === "wss";
    }
    var J = {
      scheme: "ws",
      domainHost: !0,
      parse: function(D, _) {
        var $ = D;
        return $.secure = F($), $.resourceName = ($.path || "/") + ($.query ? "?" + $.query : ""), $.path = void 0, $.query = void 0, $;
      },
      serialize: function(D, _) {
        if ((D.port === (F(D) ? 443 : 80) || D.port === "") && (D.port = void 0), typeof D.secure == "boolean" && (D.scheme = D.secure ? "wss" : "ws", D.secure = void 0), D.resourceName) {
          var $ = D.resourceName.split("?"), Y = l($, 2), ie = Y[0], ce = Y[1];
          D.path = ie && ie !== "/" ? ie : void 0, D.query = ce, D.resourceName = void 0;
        }
        return D.fragment = void 0, D;
      }
    }, he = {
      scheme: "wss",
      domainHost: J.domainHost,
      parse: J.parse,
      serialize: J.serialize
    }, de = {}, pe = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]", Je = "[0-9A-Fa-f]", tt = a(a("%[EFef]" + Je + "%" + Je + Je + "%" + Je + Je) + "|" + a("%[89A-Fa-f]" + Je + "%" + Je + Je) + "|" + a("%" + Je + Je)), Ne = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]", St = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]", rt = n(St, '[\\"\\\\]'), dt = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]", Zt = new RegExp(pe, "g"), bt = new RegExp(tt, "g"), at = new RegExp(n("[^]", Ne, "[\\.]", '[\\"]', rt), "g"), jt = new RegExp(n("[^]", pe, dt), "g"), _t = jt;
    function ft(N) {
      var D = le(N);
      return D.match(Zt) ? D : N;
    }
    var Yt = {
      scheme: "mailto",
      parse: function(D, _) {
        var $ = D, Y = $.to = $.path ? $.path.split(",") : [];
        if ($.path = void 0, $.query) {
          for (var ie = !1, ce = {}, me = $.query.split("&"), Me = 0, Se = me.length; Me < Se; ++Me) {
            var Ge = me[Me].split("=");
            switch (Ge[0]) {
              case "to":
                for (var Be = Ge[1].split(","), Ye = 0, Pe = Be.length; Ye < Pe; ++Ye)
                  Y.push(Be[Ye]);
                break;
              case "subject":
                $.subject = gt(Ge[1], _);
                break;
              case "body":
                $.body = gt(Ge[1], _);
                break;
              default:
                ie = !0, ce[gt(Ge[0], _)] = gt(Ge[1], _);
                break;
            }
          }
          ie && ($.headers = ce);
        }
        $.query = void 0;
        for (var et = 0, nt = Y.length; et < nt; ++et) {
          var Qe = Y[et].split("@");
          if (Qe[0] = gt(Qe[0]), _.unicodeSupport)
            Qe[1] = gt(Qe[1], _).toLowerCase();
          else
            try {
              Qe[1] = Z.toASCII(gt(Qe[1], _).toLowerCase());
            } catch (pt) {
              $.error = $.error || "Email address's domain name can not be converted to ASCII via punycode: " + pt;
            }
          Y[et] = Qe.join("@");
        }
        return $;
      },
      serialize: function(D, _) {
        var $ = D, Y = u(D.to);
        if (Y) {
          for (var ie = 0, ce = Y.length; ie < ce; ++ie) {
            var me = String(Y[ie]), Me = me.lastIndexOf("@"), Se = me.slice(0, Me).replace(bt, ft).replace(bt, o).replace(at, fe), Ge = me.slice(Me + 1);
            try {
              Ge = _.iri ? Z.toUnicode(Ge) : Z.toASCII(gt(Ge, _).toLowerCase());
            } catch (et) {
              $.error = $.error || "Email address's domain name can not be converted to " + (_.iri ? "Unicode" : "ASCII") + " via punycode: " + et;
            }
            Y[ie] = Se + "@" + Ge;
          }
          $.path = Y.join(",");
        }
        var Be = D.headers = D.headers || {};
        D.subject && (Be.subject = D.subject), D.body && (Be.body = D.body);
        var Ye = [];
        for (var Pe in Be)
          Be[Pe] !== de[Pe] && Ye.push(Pe.replace(bt, ft).replace(bt, o).replace(jt, fe) + "=" + Be[Pe].replace(bt, ft).replace(bt, o).replace(_t, fe));
        return Ye.length && ($.query = Ye.join("&")), $;
      }
    }, kt = /^([^\:]+)\:(.*)/, Ze = {
      scheme: "urn",
      parse: function(D, _) {
        var $ = D.path && D.path.match(kt), Y = D;
        if ($) {
          var ie = _.scheme || Y.scheme || "urn", ce = $[1].toLowerCase(), me = $[2], Me = ie + ":" + (_.nid || ce), Se = ne[Me];
          Y.nid = ce, Y.nss = me, Y.path = void 0, Se && (Y = Se.parse(Y, _));
        } else
          Y.error = Y.error || "URN can not be parsed.";
        return Y;
      },
      serialize: function(D, _) {
        var $ = _.scheme || D.scheme || "urn", Y = D.nid, ie = $ + ":" + (_.nid || Y), ce = ne[ie];
        ce && (D = ce.serialize(D, _));
        var me = D, Me = D.nss;
        return me.path = (Y || _.nid) + ":" + Me, me;
      }
    }, Ht = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/, j = {
      scheme: "urn:uuid",
      parse: function(D, _) {
        var $ = D;
        return $.uuid = $.nss, $.nss = void 0, !_.tolerant && (!$.uuid || !$.uuid.match(Ht)) && ($.error = $.error || "UUID is not valid."), $;
      },
      serialize: function(D, _) {
        var $ = D;
        return $.nss = (D.uuid || "").toLowerCase(), $;
      }
    };
    ne[W.scheme] = W, ne[q.scheme] = q, ne[J.scheme] = J, ne[he.scheme] = he, ne[Yt.scheme] = Yt, ne[Ze.scheme] = Ze, ne[j.scheme] = j, t.SCHEMES = ne, t.pctEncChar = fe, t.pctDecChars = le, t.parse = qe, t.removeDotSegments = Et, t.serialize = ot, t.resolveComponents = Ve, t.resolve = Mt, t.normalize = lt, t.equal = Xe, t.escapeComponent = st, t.unescapeComponent = gt, Object.defineProperty(t, "__esModule", { value: !0 });
  });
})(Fc, Fc.exports);
var qb = Fc.exports;
class A8 extends Qr {
  // constructor( options ) {
  constructor({
    socketUri: e,
    authEndpoint: t,
    appKey: n = "knishio"
  }) {
    console.log("PusherLink::constructor()..."), super(), this.socketUri = e, this.authEndpoint = t, this.appKey = n, this.setAuthToken(""), this.setTransport(this.getSocketUri());
  }
  /**
   *
   * @param {string} socketUri
   */
  setTransport(e) {
    console.log(`Connecting to socket endpoint ${e}...`);
    const t = qb.parse(e);
    if (!["ws", "wss"].includes(t.scheme))
      throw new $r("Incorrect scheme for the socket");
    this.transport = new M8(this.appKey, {
      auth: {
        headers: {
          "X-Auth-Token": this.getAuthToken(),
          Accept: "application/json"
        }
      },
      wsHost: t.host,
      wsPort: t.port,
      forceTLS: t.scheme === "wss",
      encrypted: !0,
      enabledTransports: [t.scheme],
      authEndpoint: this.authEndpoint
    });
  }
  disconnect() {
    this.transport.disconnect();
  }
  /**
   *
   * @param {string} name
   * @returns {Channel|null}
   */
  channel(e) {
    return this.transport.channel(e) || null;
  }
  /**
   *
   * @return {string}
   */
  getAuthToken() {
    return this.auth;
  }
  /**
   * @param {string} auth
   */
  setAuthToken(e) {
    this.auth = e;
  }
  /**
   * @return {string|null}
   */
  getSocketUri() {
    return this.socketUri;
  }
  request(e, t) {
    this.transport.config.auth.headers["X-Auth-Token"] = this.getAuthToken();
    const n = new or((i) => {
    }), a = n.subscribe.bind(n);
    return n.subscribe = (i, o, u) => {
      a(i, o, u);
      const c = T8(i, o, u);
      let h;
      return t(e).subscribe({
        next: (s) => {
          if (h = dr.get(s, "extensions.lighthouse_subscriptions.channel"), !h) {
            c.next(s), c.complete();
            return;
          }
          this.subscribeToChannel(h, c);
        }
      }), {
        closed: !1,
        unsubscribe: () => {
          h && this.unsubscribeFromChannel(h);
        }
      };
    }, n;
  }
  subscribeToChannel(e, t) {
    this.transport.subscribe(e).bind("lighthouse-subscription", (n) => {
      n.more || (this.unsubscribeFromChannel(e), t.complete());
      const a = n.result;
      a && t.next(a);
    });
  }
  unsubscribeFromChannel(e) {
    this.transport.unsubscribe(e);
  }
}
function T8(r, e, t) {
  return typeof r == "function" ? {
    next: (n) => r(n),
    error: (n) => e && e(n),
    complete: () => t && t()
  } : {
    next: (n) => r.next && r.next(n),
    error: (n) => r.error && r.error(n),
    complete: () => r.complete && r.complete()
  };
}
class k8 extends Qr {
  constructor() {
    super(), this.auth = "";
  }
  /**
   *
   * @return {string}
   */
  getAuthToken() {
    return this.auth;
  }
  /**
   * @param {string} auth
   */
  setAuthToken(e) {
    this.auth = e;
  }
  /**
   *
   * @param {Operation} operation
   * @param {NextLink | undefined} forward
   * @returns {Observable<FetchResult> | null}
   */
  request(e, t) {
    return e.setContext(({ headers: n = {} }) => ({
      headers: Go(Wn({}, n), {
        "X-Auth-Token": this.getAuthToken()
      })
    })), t(e);
  }
}
class I8 extends Qr {
  constructor() {
    super(), this.__wallet = null, this.__pubkey = null;
  }
  /**
   * @param {null|Wallet} wallet
   */
  setWallet(e) {
    this.__wallet = e;
  }
  /**
   * @return {null|Wallet}
   */
  getWallet() {
    return this.__wallet;
  }
  /**
   * @param {null|string} pubkey
   */
  setPubKey(e) {
    this.__pubkey = e;
  }
  /**
   * @return {null|string}
   */
  getPubKey() {
    return this.__pubkey;
  }
  /**
   *
   * @param {Operation} operation
   * @param {NextLink | undefined} forward
   * @returns {Observable<FetchResult> | null}
   */
  request(e, t) {
    const n = Cb(e), a = f8(e), i = a === "mutation" && n === "ProposeMolecule", o = [
      a === "query" && ["__schema", "ContinuId"].includes(n),
      a === "mutation" && n === "AccessToken",
      i && dr.get(e, "variables.molecule.atoms.0.isotope") === "U"
    ], u = {
      query: ky(e.query),
      variables: JSON.stringify(e.variables)
    }, c = this.getWallet(), h = this.getPubKey();
    for (const s in o)
      if (o[s])
        return t(e);
    if (!h)
      throw new $r("CipherLink::request() - Node public key missing!");
    if (!c)
      throw new $r("CipherLink::request() - Authorized wallet missing!");
    return e.operationName = null, e.query = fr`query ( $Hash: String! ) { CipherHash ( Hash: $Hash ) { hash } }`, e.variables = { Hash: JSON.stringify(c.encryptMessage(u, h)) }, t(e).map((s) => {
      let d = s.data;
      if (d.data && (d = d.data), d.CipherHash && d.CipherHash.hash) {
        const l = JSON.parse(d.CipherHash.hash), y = c.decryptMessage(l);
        if (y === null)
          throw new $r("CipherLink::request() - Unable to decrypt response!");
        return y;
      }
      return s;
    });
  }
}
class R8 extends kb {
  /**
   * @param {string} serverUri
   * @param {object|null} soketi
   * @param {boolean} encrypt
   */
  constructor({
    serverUri: e,
    soketi: t = null,
    encrypt: n = !1
  }) {
    const a = Wn({
      socketUri: null,
      appKey: "knishio"
    }, t || {}), i = [], o = new S8({
      uri: e,
      fetch: x8,
      transportBatching: !0
    }), u = new k8();
    let c = null, h = null;
    if (i.push(u), n && (c = new I8(), i.push(c)), a && a.socketUri) {
      const s = qb.parse(e);
      h = new A8({
        socketUri: a.socketUri,
        authEndpoint: `${s.scheme}://${s.host}/graphql/subscriptions/auth`,
        appKey: a.appKey
      }), i.push(h);
    }
    i.push(A4(Db(u8), o)), super({
      link: M4(i),
      cache: new Eb(),
      connectToDevTools: !0,
      defaultOptions: {
        watchQuery: {
          fetchPolicy: "no-cache",
          errorPolicy: "ignore"
        },
        query: {
          fetchPolicy: "no-cache",
          errorPolicy: "all"
        },
        mutate: {
          fetchPolicy: "no-cache",
          errorPolicy: "all"
        },
        subscribe: {
          fetchPolicy: "no-cache",
          errorPolicy: "all"
        }
      }
    }), this.__serverUri = e, this.__soketi = a, this.__authLink = u, this.__socket = h, this.__cipherLink = c, this.__pubkey = null, this.__wallet = null;
  }
  /**
   * @return {string}
   */
  getAuthToken() {
    return this.__authLink.getAuthToken();
  }
  /**
   *
   * @return {string|null}
   */
  getPubKey() {
    return this.__pubkey;
  }
  /**
   * @return {Wallet|null}
   */
  getWallet() {
    return this.__wallet;
  }
  /**
   * @param {string} token
   * @param {string|null} pubkey
   * @param {Wallet|null} wallet
   */
  setAuthData({
    token: e,
    pubkey: t = null,
    wallet: n = null
  }) {
    this.__wallet = n, this.__pubkey = t, this.__authLink.setAuthToken(e), this.__socket && this.__socket.setAuthToken(e), this.__cipherLink && (this.__cipherLink.setWallet(this.__wallet), this.__cipherLink.setPubKey(this.__pubkey));
  }
  socketDisconnect() {
    this.__socket && this.__socket.disconnect();
  }
  /**
   *
   * @param {string} channel
   */
  unsubscribeFromChannel(e) {
    this.__socket && this.__socket.unsubscribeFromChannel(e);
  }
  /**
   * @return {string}
   */
  getServerUri() {
    return this.__serverUri;
  }
  /**
   * @return {string|null}
   */
  getSocketUri() {
    return this.__soketi.socketUri;
  }
}
class C8 {
  /**
   * @param {string} serverUri
   * @param {object|null} socket
   * @param {boolean} encrypt
   */
  constructor({
    serverUri: e,
    socket: t = null,
    encrypt: n = !1
  }) {
    this.$__subscribers = {}, this.$__uri = e, this.$__socket = Wn({
      socketUri: null,
      appKey: "knishio"
    }, t || {}), this.$__client = null, this.restartTransport(n);
  }
  /**
   * If you have subscriptions, you unsubscribe
   *
   * @param {boolean} encrypt
   */
  restartTransport(e = !1) {
    const t = new R8({
      serverUri: this.$__uri,
      soketi: this.$__socket,
      encrypt: e
    });
    this.$__client && (t.setAuthData({
      token: this.$__client.getAuthToken(),
      pubkey: this.$__client.getPubKey(),
      wallet: this.$__client.getWallet()
    }), this.socketDisconnect()), this.$__client = t;
  }
  /**
   * Sets the encryption mode for this session
   *
   * @param {boolean} encrypt
   */
  setEncryption(e = !1) {
    this.restartTransport(e);
  }
  /**
   * @param {string} operationName
   */
  unsubscribe(e) {
    this.$__subscribers.hasOwnProperty(e) && (this.$__subscribers[e].unsubscribe(), this.$__client.unsubscribeFromChannel(e), delete this.$__subscribers[e]);
  }
  /**
   *
   */
  unsubscribeAll() {
    for (const e in this.$__subscribers)
      this.unsubscribe(e);
  }
  /**
   *
   */
  socketDisconnect() {
    this.$__client.socketDisconnect(), this.$__subscribers = {};
  }
  /**
   * @param {Operation} request
   * @param {function} closure
   *
   * @return {string}
   */
  subscribe(e, t) {
    const n = Cb(e);
    return this.unsubscribe(n), this.$__subscribers[n] = this.$__client.subscribe(e).subscribe((a) => t(a)), n;
  }
  /**
   *
   * @param request
   * @returns {Promise<*>}
   */
  query(e) {
    return wt(this, null, function* () {
      return yield this.$__client.query(e);
    });
  }
  /**
   *
   * @param request
   * @returns {Promise<*>}
   */
  mutate(e) {
    return wt(this, null, function* () {
      return yield this.$__client.mutate(e);
    });
  }
  /**
   * Sets the authorization token for this session
   *
   * @param {string} token
   * @param {string} pubkey
   * @param {Wallet|null} wallet
   */
  setAuthData({
    token: e,
    pubkey: t,
    wallet: n
  }) {
    this.$__client.setAuthData({
      token: e,
      pubkey: t,
      wallet: n
    });
  }
  /**
   * Gets the current auth token
   *
   * @return {string|null}
   */
  getAuthToken() {
    const e = this.$__client.getAuthToken();
    return e ? e.getToken() : null;
  }
  /**
   * Gets the endpoint URI
   *
   * @return {string}
   */
  getUri() {
    return this.$__uri;
  }
  /**
   * Sets the endpoint URI
   *
   * @param {string} uri
   */
  setUri(e) {
    this.$__uri = e;
  }
  /**
   * @return {string|null}
   */
  getSocketUri() {
    return this.$__socket ? this.$__socket.socketUri : null;
  }
  /**
   *
   * @param {string} socketUri
   * @param {string} appKey
   */
  setSocketUri({
    socketUri: e,
    appKey: t
  }) {
    this.$__socket = arguments.length ? arguments[0] : this.$__socket;
  }
}
class $o {
  /**
   *
   * @param {ApolloClient} apolloClient
   */
  constructor(e) {
    this.client = e, this.$__variables = null, this.$__subscribe = null;
  }
  /**
   * Creates a new Request for the given parameters
   *
   * @param {{}} variables
   * @returns {{variables: (Object|null), fetchPolicy: string, query: null}}
   */
  createSubscribe({
    variables: e = null
  }) {
    if (this.$__variables = this.compiledVariables(e), !this.uri())
      throw new $r("Subscribe::createSubscribe() - Node URI was not initialized for this client instance!");
    if (this.$__subscribe === null)
      throw new $r("Subscribe::createSubscribe() - GraphQL subscription was not initialized!");
    return {
      query: this.$__subscribe,
      variables: this.variables(),
      fetchPolicy: "no-cache"
    };
  }
  /**
   * Sends the Query to a Knish.IO node and returns the Response
   *
   * @param {{}} variables
   * @param {function} closure
   * @return {string}
   */
  execute(n) {
    return wt(this, arguments, function* ({
      variables: e = null,
      closure: t
    }) {
      if (!t)
        throw new $r(`${this.constructor.name}::execute() - closure parameter is required!`);
      return this.$__request = this.createSubscribe({
        variables: e
      }), this.client.subscribe(this.$__request, t);
    });
  }
  /**
   * Returns a variables object for the Query
   *
   * @param variables
   * @return {object}
   */
  compiledVariables(e = null) {
    return e || {};
  }
  /**
   * Returns the Knish.IO endpoint URI
   *
   * @return {string}
   */
  uri() {
    return this.client.getUri();
  }
  /**
   * Returns the query variables object
   *
   * @return {object|null}
   */
  variables() {
    return this.$__variables;
  }
}
class O8 extends $o {
  constructor(e) {
    super(e), this.$__subscribe = fr`
      subscription onCreateMolecule ( $bundle: String! ) {
        CreateMolecule( bundle: $bundle ) {
          molecularHash,
          cellSlug,
          counterparty,
          bundleHash,
          status,
          local,
          height,
          depth,
          createdAt,
          receivedAt,
          processedAt,
          broadcastedAt,
          reason,
          reasonPayload,
          payload,
          status,
          atoms {
            molecularHash,
            position,
            isotope,
            walletAddress,
            tokenSlug,
            batchId,
            value,
            index,
            metaType,
            metaId,
            metasJson,
            otsFragment,
            createdAt,
            metas {
              molecularHash,
              position,
              metaType,
              metaId,
              key,
              value,
              createdAt,
            }
          }
        }
      }
    `;
  }
}
class B8 extends $o {
  constructor(e) {
    super(e), this.$__subscribe = fr`
      subscription onWalletStatus ( $bundle: String!, $token: String! ) {
        WalletStatus( bundle: $bundle, token: $token ) {
          bundle,
          token,
          admission,
          balance,
        }
      }
    `;
  }
}
class P8 extends $o {
  constructor(e) {
    super(e), this.$__subscribe = fr`
      subscription onActiveWallet ( $bundle: String! ) {
        ActiveWallet( bundle: $bundle ) {
          address,
          bundleHash,
          walletBundle {
            bundleHash,
            slug,
            createdAt,
          },
          tokenSlug,
          token {
            slug,
            name,
            fungibility,
            supply,
            decimals,
            amount,
            icon,
            createdAt
          },
          batchId,
          position,
          characters,
          pubkey,
          amount,
          createdAt,
          metas {
            molecularHash,
            position,
            metaType,
            metaId,
            key,
            value,
            createdAt,
          }
        }
      }
    `;
  }
}
class D8 extends $o {
  constructor(e) {
    super(e), this.$__subscribe = fr`
      subscription onActiveUser ( $metaType: String!, $metaId: String! ) {
        ActiveUser( metaType: $metaType, metaId: $metaId ) {
          bundleHash,
          metaType,
          metaId,
          jsonData,
          createdAt,
          updatedAt
        }
      }`;
  }
}
class N8 extends Cr {
  /**
   * Class constructor
   *
   * @param {Query} query
   * @param {object} json
   */
  constructor({
    query: e,
    json: t
  }) {
    super({
      query: e,
      json: t,
      dataKey: "data.ActiveSession"
    });
  }
}
class q8 extends Dh {
  /**
   * Class constructor
   *
   * @param apolloClient
   */
  constructor(e) {
    super(e), this.$__query = fr`mutation(
      $bundleHash: String!,
      $metaType: String!,
      $metaId: String!,
      $ipAddress: String,
      $browser: String,
      $osCpu: String,
      $resolution: String,
      $timeZone: String,
      $json: String ) {
      ActiveSession(
        bundleHash: $bundleHash,
        metaType: $metaType,
        metaId: $metaId,
        ipAddress: $ipAddress,
        browser: $browser,
        osCpu: $osCpu,
        resolution: $resolution,
        timeZone: $timeZone,
        json: $json
      ) {
        bundleHash,
        metaType,
        metaId,
        jsonData,
        createdAt,
        updatedAt
      }
    }`;
  }
  /**
   * Builds a Response object out of a JSON string
   *
   * @param {object} json
   * @return {ResponseActiveSession}
   */
  createResponse(e) {
    return new N8({
      query: this,
      json: e
    });
  }
}
class L8 extends Cr {
  /**
   * Class constructor
   *
   * @param {Query} query
   * @param {object} json
   */
  constructor({
    query: e,
    json: t
  }) {
    super({
      query: e,
      json: t,
      dataKey: "data.ActiveUser"
    });
  }
  payload() {
    const e = this.data();
    if (!e)
      return null;
    const t = [];
    for (const n of e) {
      const a = Wn({}, n);
      a.jsonData && (a.jsonData = JSON.parse(a.jsonData)), a.createdAt && (a.createdAt = new Date(a.createdAt)), a.updatedAt && (a.updatedAt = new Date(a.updatedAt)), t.push(a);
    }
    return t;
  }
}
class F8 extends Fr {
  /**
   * Class constructor
   *
   * @param httpClient
   */
  constructor(e) {
    super(e), this.$__query = fr`query ActiveUserQuery ($bundleHash:String, $metaType: String, $metaId: String) {
      ActiveUser (bundleHash: $bundleHash, metaType: $metaType, metaId: $metaId) {
        bundleHash,
        metaType,
        metaId,
        jsonData,
        createdAt,
        updatedAt
      }
    }`;
  }
  /**
   * @param {object} json
   * @return {ResponseQueryActiveSession}
   */
  createResponse(e) {
    return new L8({
      query: this,
      json: e
    });
  }
}
class U8 extends Cr {
  /**
   * Class constructor
   *
   * @param {Query} query
   * @param {object} json
   */
  constructor({
    query: e,
    json: t
  }) {
    super({
      query: e,
      json: t,
      dataKey: "data.UserActivity"
    });
  }
  payload() {
    const e = JSON.parse(JSON.stringify(this.data()));
    if (e.instances)
      for (const t of e.instances)
        t.jsonData = JSON.parse(t.jsonData);
    return e;
  }
}
class $8 extends Fr {
  /**
   * Class constructor
   *
   * @param httpClient
   */
  constructor(e) {
    super(e), this.$__query = fr`query UserActivity (
      $bundleHash:String,
      $metaType: String,
      $metaId: String,
      $ipAddress: String,
      $browser: String,
      $osCpu: String,
      $resolution: String,
      $timeZone: String,
      $countBy: [CountByUserActivity],
      $interval: span
    ) {
      UserActivity (
        bundleHash: $bundleHash,
        metaType: $metaType,
        metaId: $metaId,
        ipAddress: $ipAddress,
        browser: $browser,
        osCpu: $osCpu,
        resolution: $resolution,
        timeZone: $timeZone,
        countBy: $countBy,
        interval: $interval
      ) {
        createdAt,
        bundleHash,
        metaType,
        metaId,
        instances {
          bundleHash,
          metaType,
          metaId,
          jsonData,
          createdAt,
          updatedAt
        },
        instanceCount {
          ...SubFields,
          ...Recursive
        }
      }
    }

    fragment SubFields on InstanceCountType {
      id,
      count
    }

    fragment Recursive on InstanceCountType {
      instances {
        ...SubFields
        instances {
          ...SubFields,
          instances {
            ...SubFields
            instances {
              ...SubFields
              instances {
                ...SubFields
                instances {
                  ...SubFields
                  instances {
                    ...SubFields
                    instances {
                      ...SubFields
                    }
                  }
                }
              }
            }
          }
        }
      }
    }`;
  }
  /**
   * Returns a Response object
   *
   * @param {object} json
   * @return {ResponseQueryUserActivity}
   */
  createResponse(e) {
    return new U8({
      query: this,
      json: e
    });
  }
}
class j8 extends Fr {
  /**
   * Class constructor
   *
   * @param apolloClient
   */
  constructor(e) {
    super(e), this.$__query = fr`query( $slug: String, $slugs: [ String! ], $limit: Int, $order: String ) {
      Token( slug: $slug, slugs: $slugs, limit: $limit, order: $order ) {
        slug,
        name,
        fungibility,
        supply,
        decimals,
        amount,
        icon,
      }
    }`;
  }
  /**
   *
   * @param json
   * @returns {Response}
   */
  createResponse(e) {
    return new Cr({
      query: this,
      json: e,
      dataKey: "data.Token"
    });
  }
}
class qv extends sr {
  /**
   * Class constructor
   *
   * @param {string} message
   * @param {string|null} fileName
   * @param {number|null} lineNumber
   */
  constructor(e = "Authorization attempt rejected by ledger.", t = null, n = null) {
    super(e, t, n), this.name = "AuthorizationRejectedException";
  }
}
class H8 extends Cr {
  /**
   * Class constructor
   *
   * @param {Query} query
   * @param {object} json
   */
  constructor({
    query: e,
    json: t
  }) {
    super({
      query: e,
      json: t,
      dataKey: "data.Atom"
    });
  }
  /**
   * Returns meta type instance results
   *
   * @return {null|*}
   */
  payload() {
    const e = this.data();
    if (!e)
      return null;
    const t = {
      instances: [],
      instanceCount: {},
      paginatorInfo: {}
    };
    if (e.instances) {
      t.instances = e.instances;
      for (const n in t.instances) {
        const a = t.instances[n];
        a.metasJson && (t.instances[n].metas = JSON.parse(a.metasJson));
      }
    }
    return e.instanceCount && (t.instanceCount = e.instanceCount), e.paginatorInfo && (t.paginatorInfo = e.paginatorInfo), t;
  }
  metas() {
    const e = this.payload(), t = [];
    if (e && e.instances)
      for (const n of e.instances)
        n.metasJson && t.push(JSON.parse(n.metasJson));
    return t;
  }
}
class Lv extends Fr {
  /**
   * Class constructor
   *
   * @param apolloClient
   */
  constructor(e) {
    super(e), this.$__query = fr`query(
      $molecularHashes: [String!],
      $bundleHashes: [String!],
      $positions:[String!],
      $walletAddresses: [String!],
      $isotopes: [String!],
      $tokenSlugs: [String!],
      $cellSlugs: [String!],
      $batchIds: [String!],
      $values: [String!],
      $metaTypes: [String!],
      $metaIds: [String!],
      $indexes: [String!],
      $filter: [ MetaFilter! ],
      $latest: Boolean,
      $queryArgs: QueryArgs,
    ) {
      Atom(
        molecularHashes: $molecularHashes,
        bundleHashes: $bundleHashes,
        positions: $positions,
        walletAddresses: $walletAddresses,
        isotopes: $isotopes,
        tokenSlugs: $tokenSlugs,
        cellSlugs: $cellSlugs,
        batchIds: $batchIds,
        values: $values,
        metaTypes: $metaTypes,
        metaIds: $metaIds,
        indexes: $indexes,
        filter: $filter,
        latest: $latest,
        queryArgs: $queryArgs,
      ) {
        instances {
          position,
          walletAddress,
          tokenSlug,
          isotope,
          index,
          molecularHash,
          metaId,
          metaType,
          metasJson,
          batchId,
          value,
          bundleHashes,
          cellSlugs,
          createdAt,
          otsFragment
        },
        paginatorInfo {
          currentPage,
          total
        }
      }
    }`;
  }
  /**
   * Queries Knish.IO Atoms
   *
   * @param {string[]} molecularHashes
   * @param {string} molecularHash
   * @param {string[]} bundleHashes
   * @param {string} bundleHash
   * @param {string[]} positions
   * @param {string} position
   * @param {string[]} walletAddresses
   * @param {string} walletAddress
   * @param {string[]} isotopes
   * @param {string} isotope
   * @param {string[]} tokenSlugs
   * @param {string} tokenSlug
   * @param {string[]} cellSlugs
   * @param {string} cellSlug
   * @param {string[]} batchIds
   * @param {string} batchId
   * @param {string[]} values
   * @param {string|number} value
   * @param {string[]} metaTypes
   * @param {string} metaType
   * @param {string[]} metaIds
   * @param {string} metaId
   * @param {number[]} indexes
   * @param {number} index
   * @param {object[]} filter,
   * @param {boolean} latest
   * @param {object} queryArgs
   * @return {object}
   */
  static createVariables({
    molecularHashes: e,
    molecularHash: t,
    bundleHashes: n,
    bundleHash: a,
    positions: i,
    position: o,
    walletAddresses: u,
    walletAddress: c,
    isotopes: h,
    isotope: s,
    tokenSlugs: d,
    tokenSlug: l,
    cellSlugs: y,
    cellSlug: m,
    batchIds: w,
    batchId: E,
    values: S,
    value: P,
    metaTypes: L,
    metaType: U,
    metaIds: z,
    metaId: K,
    indexes: re,
    index: oe,
    filter: se,
    latest: ve,
    queryArgs: Q
  }) {
    return t && (e = e || [], e.push(t)), a && (n = n || [], n.push(a)), o && (i = i || [], i.push(o)), c && (u = u || [], u.push(c)), s && (h = h || [], h.push(s)), l && (d = d || [], d.push(l)), m && (y = y || [], y.push(m)), E && (w = w || [], w.push(E)), P && (S = S || [], S.push(P)), U && (L = L || [], L.push(U)), K && (z = z || [], z.push(K)), oe && (re = re || [], re.push(oe)), {
      molecularHashes: e,
      bundleHashes: n,
      positions: i,
      walletAddresses: u,
      isotopes: h,
      tokenSlugs: d,
      cellSlugs: y,
      batchIds: w,
      values: S,
      metaTypes: L,
      metaIds: z,
      indexes: re,
      filter: se,
      latest: ve,
      queryArgs: Q
    };
  }
  /**
   * Returns a Response object
   *
   * @param {object} json
   * @return {ResponseAtom}
   */
  createResponse(e) {
    return new H8({
      query: this,
      json: e
    });
  }
}
class z8 extends Cr {
  /**
   * Class constructor
   *
   * @param {Query} query
   * @param {object} json
   */
  constructor({
    query: e,
    json: t
  }) {
    super({
      query: e,
      json: t
    }), this.dataKey = "data.Policy", this.init();
  }
  /**
   *
   * @returns {null|object}
   */
  payload() {
    const e = this.data();
    return e && e.callback ? JSON.parse(e.callback) : null;
  }
}
class V8 extends Fr {
  /**
   * Class constructor
   *
   * @param apolloClient
   */
  constructor(e) {
    super(e), this.$__query = fr`query( $metaType: String, $metaId: String, ) {
      Policy( metaType: $metaType, metaId: $metaId ) {
        molecularHash,
        position,
        metaType,
        metaId,
        conditions,
        callback,
        rule,
        createdAt
      }
    }`;
  }
  /**
   * Returns a Response object
   *
   * @param {object} json
   * @return {ResponsePolicy}
   */
  createResponse(e) {
    return new z8({
      query: this,
      json: e
    });
  }
}
class W8 extends Cr {
  /**
   * Class constructor
   *
   * @param {Query} query
   * @param {object} json
   */
  constructor({
    query: e,
    json: t
  }) {
    super({
      query: e,
      json: t,
      dataKey: "data.MetaTypeViaAtom"
    });
  }
  payload() {
    const e = this.data();
    if (!e || e.length === 0)
      return null;
    const t = {
      instances: {},
      instanceCount: {},
      paginatorInfo: {}
    }, n = e.pop();
    return n.instances && (t.instances = n.instances), n.instanceCount && (t.instanceCount = n.instanceCount), n.paginatorInfo && (t.paginatorInfo = n.paginatorInfo), t;
  }
}
class Fv extends Fr {
  /**
   * Class constructor
   *
   * @param apolloClient
   */
  constructor(e) {
    super(e), this.$__query = fr`query ($metaTypes: [String!], $metaIds: [String!], $values: [String!], $keys: [String!], $latest: Boolean, $filter: [MetaFilter!], $queryArgs: QueryArgs, $countBy: String, $atomValues: [String!] ) {
      MetaTypeViaAtom(
        metaTypes: $metaTypes
        metaIds: $metaIds
        atomValues: $atomValues
        filter: $filter,
        latest: $latest,
        queryArgs: $queryArgs
        countBy: $countBy
      ) {
        metaType,
        instanceCount {
          key,
          value
        },
        instances {
          metaType,
          metaId,
          createdAt,
          metas( values: $values, keys: $keys ) {
            molecularHash,
            position,
            key,
            value,
            createdAt
          }
        },
        paginatorInfo {
          currentPage,
          total
        }
      }
    }`;
  }
  /**
   * Builds a GraphQL-friendly variables object based on input fields
   *
   * @param {string|array|null} metaType
   * @param {string|array|null} metaId
   * @param {string|null} key
   * @param {string|null} value
   * @param {array|null} values
   * @param {array|null} keys
   * @param {array|null} atomValues
   * @param {boolean|null} latest
   * @param {boolean|null} latestMetas
   * @param {array|null} filter
   * @param {object|null} queryArgs
   * @param {string|null} countBy
   * @return {{}}
   */
  static createVariables({
    metaType: e = null,
    metaId: t = null,
    key: n = null,
    value: a = null,
    keys: i = null,
    values: o = null,
    atomValues: u = null,
    latest: c = null,
    latestMetas: h = !0,
    filter: s = null,
    queryArgs: d = null,
    countBy: l = null
  }) {
    const y = {};
    return u && (y.atomValues = u), i && (y.keys = i), o && (y.values = o), e && (y.metaTypes = typeof e == "string" ? [e] : e), t && (y.metaIds = typeof t == "string" ? [t] : t), l && (y.countBy = l), s && (y.filter = s), n && a && (y.filter = y.filter || [], y.filter.push({
      key: n,
      value: a,
      comparison: "="
    })), c && (y.latest = !!c, y.latest = !!h), d && ((typeof d.limit == "undefined" || d.limit === 0) && (d.limit = "*"), y.queryArgs = d), y;
  }
  /**
   * Returns a Response object
   *
   * @param {object} json
   * @return {ResponseMetaTypeViaAtom}
   */
  createResponse(e) {
    return new W8({
      query: this,
      json: e
    });
  }
}
class K8 extends rn {
}
class Q8 extends kr {
  /**
   *
   * @param {string} metaType
   * @param {string} metaId
   * @param {object[]} rule
   * @param {object} policy
   */
  fillMolecule({
    metaType: e,
    metaId: t,
    rule: n,
    policy: a
  }) {
    this.$__molecule.createRule({
      metaType: e,
      metaId: t,
      rule: n,
      policy: a
    }), this.$__molecule.sign({}), this.$__molecule.check();
  }
  /**
   * Builds a new Response object from a JSON string
   *
   * @param {object} json
   * @return {ResponseCreateRule}
   */
  createResponse(e) {
    return new K8({
      query: this,
      json: e
    });
  }
}
class G8 extends kr {
  /**
   * Fills the Molecule with provided wallet and amount data
   *
   * @param amount
   * @param tradeRates
   */
  fillMolecule({
    amount: e,
    tradeRates: t
  }) {
    this.$__molecule.initDepositBuffer({
      amount: e,
      tradeRates: t
    }), this.$__molecule.sign({}), this.$__molecule.check(this.$__molecule.sourceWallet);
  }
}
class J8 extends kr {
  /**
   *
   * @param recipients
   * @param signingWallet
   */
  fillMolecule({
    recipients: e,
    signingWallet: t
  }) {
    this.$__molecule.initWithdrawBuffer({
      recipients: e,
      signingWallet: t
    }), this.$__molecule.sign({}), this.$__molecule.check(this.$__molecule.sourceWallet);
  }
}
function xn(r, e, t, n) {
  return new (t || (t = Promise))(function(a, i) {
    function o(h) {
      try {
        c(n.next(h));
      } catch (s) {
        i(s);
      }
    }
    function u(h) {
      try {
        c(n.throw(h));
      } catch (s) {
        i(s);
      }
    }
    function c(h) {
      var s;
      h.done ? a(h.value) : (s = h.value, s instanceof t ? s : new t(function(d) {
        d(s);
      })).then(o, u);
    }
    c((n = n.apply(r, e || [])).next());
  });
}
function Sn(r, e) {
  var t, n, a, i, o = { label: 0, sent: function() {
    if (1 & a[0])
      throw a[1];
    return a[1];
  }, trys: [], ops: [] };
  return i = { next: u(0), throw: u(1), return: u(2) }, typeof Symbol == "function" && (i[Symbol.iterator] = function() {
    return this;
  }), i;
  function u(c) {
    return function(h) {
      return function(s) {
        if (t)
          throw new TypeError("Generator is already executing.");
        for (; i && (i = 0, s[0] && (o = 0)), o; )
          try {
            if (t = 1, n && (a = 2 & s[0] ? n.return : s[0] ? n.throw || ((a = n.return) && a.call(n), 0) : n.next) && !(a = a.call(n, s[1])).done)
              return a;
            switch (n = 0, a && (s = [2 & s[0], a.value]), s[0]) {
              case 0:
              case 1:
                a = s;
                break;
              case 4:
                return o.label++, { value: s[1], done: !1 };
              case 5:
                o.label++, n = s[1], s = [0];
                continue;
              case 7:
                s = o.ops.pop(), o.trys.pop();
                continue;
              default:
                if (a = o.trys, !((a = a.length > 0 && a[a.length - 1]) || s[0] !== 6 && s[0] !== 2)) {
                  o = 0;
                  continue;
                }
                if (s[0] === 3 && (!a || s[1] > a[0] && s[1] < a[3])) {
                  o.label = s[1];
                  break;
                }
                if (s[0] === 6 && o.label < a[1]) {
                  o.label = a[1], a = s;
                  break;
                }
                if (a && o.label < a[2]) {
                  o.label = a[2], o.ops.push(s);
                  break;
                }
                a[2] && o.ops.pop(), o.trys.pop();
                continue;
            }
            s = e.call(r, o);
          } catch (d) {
            s = [6, d], n = 0;
          } finally {
            t = a = 0;
          }
        if (5 & s[0])
          throw s[1];
        return { value: s[0] ? s[1] : void 0, done: !0 };
      }([c, h]);
    };
  }
}
var Uc = { exclude: [] }, Lb = {}, Y8 = { timeout: "true" }, Zr = function(r, e) {
  typeof window != "undefined" && (Lb[r] = e);
}, X8 = function() {
  return Object.fromEntries(Object.entries(Lb).filter(function(r) {
    var e, t = r[0];
    return !(!((e = Uc == null ? void 0 : Uc.exclude) === null || e === void 0) && e.includes(t));
  }).map(function(r) {
    return [r[0], (0, r[1])()];
  }));
}, Uv = 3432918353, $v = 461845907, Z8 = 3864292196, ex = 2246822507, tx = 3266489909;
function ic(r, e) {
  return r << e | r >>> 32 - e;
}
function Lh(r, e) {
  e === void 0 && (e = 0);
  for (var t = e, n = 0, a = 3 & r.length, i = r.length - a, o = 0; o < i; )
    n = 255 & r.charCodeAt(o) | (255 & r.charCodeAt(++o)) << 8 | (255 & r.charCodeAt(++o)) << 16 | (255 & r.charCodeAt(++o)) << 24, ++o, n = ic(n = Math.imul(n, Uv), 15), t = ic(t ^= n = Math.imul(n, $v), 13), t = Math.imul(t, 5) + Z8;
  switch (n = 0, a) {
    case 3:
      n ^= (255 & r.charCodeAt(o + 2)) << 16;
    case 2:
      n ^= (255 & r.charCodeAt(o + 1)) << 8;
    case 1:
      n ^= 255 & r.charCodeAt(o), n = ic(n = Math.imul(n, Uv), 15), t ^= n = Math.imul(n, $v);
  }
  return ((t = function(u) {
    return u ^= u >>> 16, u = Math.imul(u, ex), u ^= u >>> 13, u = Math.imul(u, tx), u ^ u >>> 16;
  }(t ^= r.length)) >>> 0).toString(36);
}
function rx(r, e) {
  return new Promise(function(t) {
    setTimeout(function() {
      return t(e);
    }, r);
  });
}
function nx(r, e, t) {
  return Promise.all(r.map(function(n) {
    return Promise.race([n, rx(e, t)]);
  }));
}
var ix = 1e3;
function ax() {
  return xn(this, void 0, void 0, function() {
    var r, e, t, n, a;
    return Sn(this, function(i) {
      switch (i.label) {
        case 0:
          return i.trys.push([0, 3, , 4]), [4, X8()];
        case 1:
          return r = i.sent(), e = Object.keys(r), [4, nx(Object.values(r), ix, Y8)];
        case 2:
          return t = i.sent(), n = t.filter(function(o) {
            return o !== void 0;
          }), a = {}, n.forEach(function(o, u) {
            a[e[u]] = o;
          }), [2, Fb(a, Uc.exclude || [])];
        case 3:
          throw i.sent();
        case 4:
          return [2];
      }
    });
  });
}
function Fb(r, e) {
  var t = {}, n = function(i) {
    if (r.hasOwnProperty(i)) {
      var o = r[i];
      if (typeof o != "object" || Array.isArray(o))
        e.includes(i) || (t[i] = o);
      else {
        var u = Fb(o, e.map(function(c) {
          return c.startsWith(i + ".") ? c.slice(i.length + 1) : c;
        }));
        Object.keys(u).length > 0 && (t[i] = u);
      }
    }
  };
  for (var a in r)
    n(a);
  return t;
}
function ox() {
  return xn(this, void 0, void 0, function() {
    var r;
    return Sn(this, function(e) {
      switch (e.label) {
        case 0:
          return e.trys.push([0, 2, , 3]), [4, ax()];
        case 1:
          return r = e.sent(), [2, Lh(JSON.stringify(r)).toString()];
        case 2:
          throw e.sent();
        case 3:
          return [2];
      }
    });
  });
}
function sx(r) {
  for (var e = 0, t = 0; t < r.length; ++t)
    e += Math.abs(r[t]);
  return e;
}
function Ub(r, e, t) {
  for (var n = [], a = 0; a < r[0].data.length; a++) {
    for (var i = [], o = 0; o < r.length; o++)
      i.push(r[o].data[a]);
    n.push(fx(i));
  }
  var u = new Uint8ClampedArray(n);
  return new ImageData(u, e, t);
}
function fx(r) {
  if (r.length === 0)
    return 0;
  for (var e = {}, t = 0, n = r; t < n.length; t++)
    e[i = n[t]] = (e[i] || 0) + 1;
  var a = r[0];
  for (var i in e)
    e[i] > e[a] && (a = parseInt(i, 10));
  return a;
}
function Aa() {
  if (typeof navigator == "undefined")
    return { name: "unknown", version: "unknown" };
  for (var r = navigator.userAgent, e = { Edg: "Edge", OPR: "Opera" }, t = 0, n = [new RegExp("(?<name>Edge|Edg)\\/(?<version>\\d+(?:\\.\\d+)?)"), new RegExp("(?<name>(?:Chrome|Chromium|OPR|Opera|Vivaldi|Brave))\\/(?<version>\\d+(?:\\.\\d+)?)"), new RegExp("(?<name>(?:Firefox|Waterfox|Iceweasel|IceCat))\\/(?<version>\\d+(?:\\.\\d+)?)"), new RegExp("(?<name>Safari)\\/(?<version>\\d+(?:\\.\\d+)?)"), new RegExp("(?<name>MSIE|Trident|IEMobile).+?(?<version>\\d+(?:\\.\\d+)?)"), new RegExp("(?<name>[A-Za-z]+)\\/(?<version>\\d+(?:\\.\\d+)?)"), new RegExp("(?<name>SamsungBrowser)\\/(?<version>\\d+(?:\\.\\d+)?)")]; t < n.length; t++) {
    var a = n[t], i = r.match(a);
    if (i && i.groups)
      return { name: e[i.groups.name] || i.groups.name, version: i.groups.version };
  }
  return { name: "unknown", version: "unknown" };
}
Zr("audio", function() {
  return xn(this, void 0, void 0, function() {
    return Sn(this, function(r) {
      return [2, new Promise(function(e, t) {
        try {
          var n = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(1, 5e3, 44100), a = n.createBufferSource(), i = n.createOscillator();
          i.frequency.value = 1e3;
          var o, u = n.createDynamicsCompressor();
          u.threshold.value = -50, u.knee.value = 40, u.ratio.value = 12, u.attack.value = 0, u.release.value = 0.2, i.connect(u), u.connect(n.destination), i.start(), n.oncomplete = function(c) {
            o = c.renderedBuffer.getChannelData(0), e({ sampleHash: sx(o), oscillator: i.type, maxChannels: n.destination.maxChannelCount, channelCountMode: a.channelCountMode });
          }, n.startRendering();
        } catch (c) {
          console.error("Error creating audio fingerprint:", c), t(c);
        }
      })];
    });
  });
});
var ux = Aa().name !== "SamsungBrowser" ? 1 : 3, jv = 280, Hv = 20;
Aa().name != "Firefox" && Zr("canvas", function() {
  return document.createElement("canvas").getContext("2d"), new Promise(function(r) {
    var e = Array.from({ length: ux }, function() {
      return function() {
        var t = document.createElement("canvas"), n = t.getContext("2d");
        if (!n)
          return new ImageData(1, 1);
        t.width = jv, t.height = Hv;
        var a = n.createLinearGradient(0, 0, t.width, t.height);
        a.addColorStop(0, "red"), a.addColorStop(0.16666666666666666, "orange"), a.addColorStop(0.3333333333333333, "yellow"), a.addColorStop(0.5, "green"), a.addColorStop(0.6666666666666666, "blue"), a.addColorStop(0.8333333333333334, "indigo"), a.addColorStop(1, "violet"), n.fillStyle = a, n.fillRect(0, 0, t.width, t.height);
        var i = "Random Text WMwmil10Oo";
        n.font = "23.123px Arial", n.fillStyle = "black", n.fillText(i, -5, 15), n.fillStyle = "rgba(0, 0, 255, 0.5)", n.fillText(i, -3.3, 17.7), n.beginPath(), n.moveTo(0, 0), n.lineTo(2 * t.width / 7, t.height), n.strokeStyle = "white", n.lineWidth = 2, n.stroke();
        var o = n.getImageData(0, 0, t.width, t.height);
        return o;
      }();
    });
    r({ commonImageDataHash: Lh(Ub(e, jv, Hv).data.toString()).toString() });
  });
});
var cx = ["Arial", "Arial Black", "Arial Narrow", "Arial Rounded MT", "Arimo", "Archivo", "Barlow", "Bebas Neue", "Bitter", "Bookman", "Calibri", "Cabin", "Candara", "Century", "Century Gothic", "Comic Sans MS", "Constantia", "Courier", "Courier New", "Crimson Text", "DM Mono", "DM Sans", "DM Serif Display", "DM Serif Text", "Dosis", "Droid Sans", "Exo", "Fira Code", "Fira Sans", "Franklin Gothic Medium", "Garamond", "Geneva", "Georgia", "Gill Sans", "Helvetica", "Impact", "Inconsolata", "Indie Flower", "Inter", "Josefin Sans", "Karla", "Lato", "Lexend", "Lucida Bright", "Lucida Console", "Lucida Sans Unicode", "Manrope", "Merriweather", "Merriweather Sans", "Montserrat", "Myriad", "Noto Sans", "Nunito", "Nunito Sans", "Open Sans", "Optima", "Orbitron", "Oswald", "Pacifico", "Palatino", "Perpetua", "PT Sans", "PT Serif", "Poppins", "Prompt", "Public Sans", "Quicksand", "Rajdhani", "Recursive", "Roboto", "Roboto Condensed", "Rockwell", "Rubik", "Segoe Print", "Segoe Script", "Segoe UI", "Sora", "Source Sans Pro", "Space Mono", "Tahoma", "Taviraj", "Times", "Times New Roman", "Titillium Web", "Trebuchet MS", "Ubuntu", "Varela Round", "Verdana", "Work Sans"], hx = ["monospace", "sans-serif", "serif"];
function zv(r, e) {
  if (!r)
    throw new Error("Canvas context not supported");
  return r.font, r.font = "72px ".concat(e), r.measureText("WwMmLli0Oo").width;
}
function lx() {
  var r, e = document.createElement("canvas"), t = (r = e.getContext("webgl")) !== null && r !== void 0 ? r : e.getContext("experimental-webgl");
  return t && "getParameter" in t ? { vendor: (t.getParameter(t.VENDOR) || "").toString(), renderer: (t.getParameter(t.RENDERER) || "").toString(), version: (t.getParameter(t.VERSION) || "").toString(), shadingLanguageVersion: (t.getParameter(t.SHADING_LANGUAGE_VERSION) || "").toString() } : "undefined";
}
function dx() {
  var r = new Float32Array(1), e = new Uint8Array(r.buffer);
  return r[0] = 1 / 0, r[0] = r[0] - r[0], e[3];
}
function px(r, e) {
  var t = {};
  return e.forEach(function(n) {
    var a = function(i) {
      if (i.length === 0)
        return null;
      var o = {};
      i.forEach(function(h) {
        var s = String(h);
        o[s] = (o[s] || 0) + 1;
      });
      var u = i[0], c = 1;
      return Object.keys(o).forEach(function(h) {
        o[h] > c && (u = h, c = o[h]);
      }), u;
    }(r.map(function(i) {
      return n in i ? i[n] : void 0;
    }).filter(function(i) {
      return i !== void 0;
    }));
    a && (t[n] = a);
  }), t;
}
Aa().name != "Firefox" && Zr("fonts", function() {
  var r = this;
  return new Promise(function(e, t) {
    try {
      (function(n) {
        var a;
        xn(this, void 0, void 0, function() {
          var i, o, u;
          return Sn(this, function(c) {
            switch (c.label) {
              case 0:
                return document.body ? [3, 2] : [4, (h = 50, new Promise(function(d) {
                  return setTimeout(d, h, s);
                }))];
              case 1:
                return c.sent(), [3, 0];
              case 2:
                if (i = document.createElement("iframe"), (o = i.style).setProperty("display", "block", "important"), o.setProperty("visibility", "visible"), i.src = "about:blank", document.body.appendChild(i), !(u = i.contentDocument || ((a = i.contentWindow) === null || a === void 0 ? void 0 : a.document)))
                  throw new Error("Iframe document is not accessible");
                return n({ iframe: u }), setTimeout(function() {
                  document.body.removeChild(i);
                }, 0), [2];
            }
            var h, s;
          });
        });
      })(function(n) {
        var a = n.iframe;
        return xn(r, void 0, void 0, function() {
          var i, o, u, c;
          return Sn(this, function(h) {
            return i = a.createElement("canvas"), o = i.getContext("2d"), u = hx.map(function(s) {
              return zv(o, s);
            }), c = {}, cx.forEach(function(s) {
              var d = zv(o, s);
              u.includes(d) || (c[s] = d);
            }), e(c), [2];
          });
        });
      });
    } catch (n) {
      t({ error: "unsupported" });
    }
  });
}), Zr("hardware", function() {
  return new Promise(function(r, e) {
    var t = navigator.deviceMemory !== void 0 ? navigator.deviceMemory : 0, n = window.performance && window.performance.memory ? window.performance.memory : 0;
    r({ videocard: lx(), architecture: dx(), deviceMemory: t.toString() || "undefined", jsHeapSizeLimit: n.jsHeapSizeLimit || "undefined" });
  });
}), Zr("locales", function() {
  return new Promise(function(r) {
    r({ languages: navigator.language, timezone: Intl.DateTimeFormat().resolvedOptions().timeZone });
  });
});
var Vv = ["accelerometer", "accessibility", "accessibility-events", "ambient-light-sensor", "background-fetch", "background-sync", "bluetooth", "camera", "clipboard-read", "clipboard-write", "device-info", "display-capture", "gyroscope", "geolocation", "local-fonts", "magnetometer", "microphone", "midi", "nfc", "notifications", "payment-handler", "persistent-storage", "push", "speaker", "storage-access", "top-level-storage-access", "window-management", "query"];
function vx() {
  var r = [], e = { "prefers-contrast": ["high", "more", "low", "less", "forced", "no-preference"], "any-hover": ["hover", "none"], "any-pointer": ["none", "coarse", "fine"], pointer: ["none", "coarse", "fine"], hover: ["hover", "none"], update: ["fast", "slow"], color: ["8", "16", "256"], "inverted-colors": ["inverted", "none"], "prefers-reduced-motion": ["reduce", "no-preference"], "prefers-reduced-transparency": ["reduce", "no-preference"], scripting: ["none", "initial-only", "enabled"], "forced-colors": ["active", "none"], "prefers-color-scheme": ["dark", "light", "no-preference"] };
  return Object.keys(e).forEach(function(t) {
    e[t].forEach(function(n) {
      matchMedia("(".concat(t, ": ").concat(n, ")")).matches && r.push("".concat(t, ": ").concat(n));
    });
  }), r;
}
function yx() {
  if (window.location.protocol === "https:" && typeof window.ApplePaySession == "function")
    try {
      for (var r = window.ApplePaySession.supportsVersion, e = 15; e > 0; e--)
        if (r(e))
          return e;
    } catch (t) {
      return 0;
    }
  return 0;
}
Zr("permissions", function() {
  return xn(this, void 0, void 0, function() {
    var r;
    return Sn(this, function(e) {
      return r = Array.from({ length: 3 }, function() {
        return function() {
          return xn(this, void 0, void 0, function() {
            var t, n, a, i, o;
            return Sn(this, function(u) {
              switch (u.label) {
                case 0:
                  t = {}, n = 0, a = Vv, u.label = 1;
                case 1:
                  if (!(n < a.length))
                    return [3, 6];
                  i = a[n], u.label = 2;
                case 2:
                  return u.trys.push([2, 4, , 5]), [4, navigator.permissions.query({ name: i })];
                case 3:
                  return o = u.sent(), t[i] = o.state.toString(), [3, 5];
                case 4:
                  return u.sent(), [3, 5];
                case 5:
                  return n++, [3, 1];
                case 6:
                  return [2, t];
              }
            });
          });
        }();
      }), [2, Promise.all(r).then(function(t) {
        return px(t, Vv);
      })];
    });
  });
}), Zr("plugins", function() {
  var r = [];
  if (navigator.plugins)
    for (var e = 0; e < navigator.plugins.length; e++) {
      var t = navigator.plugins[e];
      r.push([t.name, t.filename, t.description].join("|"));
    }
  return new Promise(function(n) {
    n({ plugins: r });
  });
}), Zr("screen", function() {
  return new Promise(function(r) {
    r({ is_touchscreen: navigator.maxTouchPoints > 0, maxTouchPoints: navigator.maxTouchPoints, colorDepth: screen.colorDepth, mediaMatches: vx() });
  });
}), Zr("system", function() {
  return new Promise(function(r) {
    var e = Aa();
    r({ platform: window.navigator.platform, cookieEnabled: window.navigator.cookieEnabled, productSub: navigator.productSub, product: navigator.product, useragent: navigator.userAgent, browser: { name: e.name, version: e.version }, applePayVersion: yx() });
  });
});
var Dr, bx = Aa().name !== "SamsungBrowser" ? 1 : 3, Tt = null;
typeof document != "undefined" && ((Dr = document.createElement("canvas")).width = 200, Dr.height = 100, Tt = Dr.getContext("webgl")), Zr("webgl", function() {
  return xn(this, void 0, void 0, function() {
    var r;
    return Sn(this, function(e) {
      try {
        if (!Tt)
          throw new Error("WebGL not supported");
        return r = Array.from({ length: bx }, function() {
          return function() {
            try {
              if (!Tt)
                throw new Error("WebGL not supported");
              var t = `
          attribute vec2 position;
          void main() {
              gl_Position = vec4(position, 0.0, 1.0);
          }
      `, n = `
          precision mediump float;
          void main() {
              gl_FragColor = vec4(0.812, 0.195, 0.553, 0.921); // Set line color
          }
      `, a = Tt.createShader(Tt.VERTEX_SHADER), i = Tt.createShader(Tt.FRAGMENT_SHADER);
              if (!a || !i)
                throw new Error("Failed to create shaders");
              if (Tt.shaderSource(a, t), Tt.shaderSource(i, n), Tt.compileShader(a), !Tt.getShaderParameter(a, Tt.COMPILE_STATUS))
                throw new Error("Vertex shader compilation failed: " + Tt.getShaderInfoLog(a));
              if (Tt.compileShader(i), !Tt.getShaderParameter(i, Tt.COMPILE_STATUS))
                throw new Error("Fragment shader compilation failed: " + Tt.getShaderInfoLog(i));
              var o = Tt.createProgram();
              if (!o)
                throw new Error("Failed to create shader program");
              if (Tt.attachShader(o, a), Tt.attachShader(o, i), Tt.linkProgram(o), !Tt.getProgramParameter(o, Tt.LINK_STATUS))
                throw new Error("Shader program linking failed: " + Tt.getProgramInfoLog(o));
              Tt.useProgram(o);
              for (var u = 137, c = new Float32Array(4 * u), h = 2 * Math.PI / u, s = 0; s < u; s++) {
                var d = s * h;
                c[4 * s] = 0, c[4 * s + 1] = 0, c[4 * s + 2] = Math.cos(d) * (Dr.width / 2), c[4 * s + 3] = Math.sin(d) * (Dr.height / 2);
              }
              var l = Tt.createBuffer();
              Tt.bindBuffer(Tt.ARRAY_BUFFER, l), Tt.bufferData(Tt.ARRAY_BUFFER, c, Tt.STATIC_DRAW);
              var y = Tt.getAttribLocation(o, "position");
              Tt.enableVertexAttribArray(y), Tt.vertexAttribPointer(y, 2, Tt.FLOAT, !1, 0, 0), Tt.viewport(0, 0, Dr.width, Dr.height), Tt.clearColor(0, 0, 0, 1), Tt.clear(Tt.COLOR_BUFFER_BIT), Tt.drawArrays(Tt.LINES, 0, 2 * u);
              var m = new Uint8ClampedArray(Dr.width * Dr.height * 4);
              return Tt.readPixels(0, 0, Dr.width, Dr.height, Tt.RGBA, Tt.UNSIGNED_BYTE, m), new ImageData(m, Dr.width, Dr.height);
            } catch (w) {
              return new ImageData(1, 1);
            } finally {
              Tt && (Tt.bindBuffer(Tt.ARRAY_BUFFER, null), Tt.useProgram(null), Tt.viewport(0, 0, Tt.drawingBufferWidth, Tt.drawingBufferHeight), Tt.clearColor(0, 0, 0, 0));
            }
          }();
        }), [2, { commonImageHash: Lh(Ub(r, Dr.width, Dr.height).data.toString()).toString() }];
      } catch (t) {
        return [2, { webgl: "unsupported" }];
      }
      return [2];
    });
  });
});
var Jn = function(r, e, t, n) {
  for (var a = (t - e) / n, i = 0, o = 0; o < n; o++)
    i += r(e + (o + 0.5) * a);
  return i * a;
};
Zr("math", function() {
  return xn(void 0, void 0, void 0, function() {
    return Sn(this, function(r) {
      return [2, { acos: Math.acos(0.5), asin: Jn(Math.asin, -1, 1, 97), atan: Jn(Math.atan, -1, 1, 97), cos: Jn(Math.cos, 0, Math.PI, 97), cosh: Math.cosh(9 / 7), e: Math.E, largeCos: Math.cos(1e20), largeSin: Math.sin(1e20), largeTan: Math.tan(1e20), log: Math.log(1e3), pi: Math.PI, sin: Jn(Math.sin, -Math.PI, Math.PI, 97), sinh: Jn(Math.sinh, -9 / 7, 7 / 9, 97), sqrt: Math.sqrt(2), tan: Jn(Math.tan, 0, 2 * Math.PI, 97), tanh: Jn(Math.tanh, -9 / 7, 7 / 9, 97) }];
    });
  });
});
class mx {
  /**
   * Class constructor
   *
   * @param {string} uri
   * @param {string|null} cellSlug
   * @param {object|null} socket
   * @param {ApolloClient|null} client
   * @param {number} serverSdkVersion
   * @param {boolean} logging
   */
  constructor({
    uri: e,
    cellSlug: t = null,
    client: n = null,
    socket: a = null,
    serverSdkVersion: i = 3,
    logging: o = !1
  }) {
    this.initialize({
      uri: e,
      cellSlug: t,
      socket: a,
      client: n,
      serverSdkVersion: i,
      logging: o
    });
  }
  /**
   * Initializes a new Knish.IO client session
   *
   * @param {string|[]} uri
   * @param {string|null} cellSlug
   * @param {object|null} socket
   * @param {ApolloClient|null} client
   * @param {number} serverSdkVersion
   * @param {boolean} logging
   */
  initialize({
    uri: e,
    cellSlug: t = null,
    socket: n = null,
    client: a = null,
    serverSdkVersion: i = 3,
    logging: o = !1
  }) {
    this.$__logging = o, this.$__uris = typeof e == "object" ? e : [e], this.$__authTokenObjects = {}, this.$__authInProcess = !1, t && this.setCellSlug(t);
    for (const u in this.$__uris) {
      const c = this.$__uris[u];
      this.$__authTokenObjects[c] = null;
    }
    this.$__logging && console.info(`KnishIOClient::initialize() - Initializing new Knish.IO client session for SDK version ${i}...`), this.reset(), this.$__client = a || new C8({
      socket: Wn({
        socketUri: null,
        appKey: "knishio"
      }, n || {}),
      serverUri: this.getRandomUri()
    }), this.$__serverSdkVersion = i;
  }
  /**
   * Get random uri from specified this.$__uris
   *
   * @return {string}
   */
  getRandomUri() {
    const e = Math.floor(Math.random() * this.$__uris.length);
    return this.$__uris[e];
  }
  /**
   *
   * @param encrypt
   * @return {boolean}
   */
  switchEncryption(e) {
    return this.$__encrypt === e ? !1 : (this.$__logging && console.info(`KnishIOClient::switchEncryption() - Forcing encryption ${e ? "on" : "off"} to match node...`), this.$__encrypt = e, this.$__client.setEncryption(e), !0);
  }
  /**
   * De-initializes the Knish.IO client session so that a new session can replace it
   */
  deinitialize() {
    this.$__logging && console.info("KnishIOClient::deinitialize() - Clearing the Knish.IO client session..."), this.reset();
  }
  /**
   * Subscribes the client to the node's broadcast socket
   *
   * @return {ApolloClient}
   */
  subscribe() {
    if (!this.client().getSocketUri())
      throw new $r("KnishIOClient::subscribe() - Socket client not initialized!");
    return this.client();
  }
  /**
   * Gets the client's SDK version
   *
   * @return {number}
   */
  getServerSdkVersion() {
    return this.$__serverSdkVersion;
  }
  /**
   * Reset common properties
   */
  reset() {
    this.$__secret = "", this.$__bundle = "", this.remainderWallet = null;
  }
  /**
   * Returns the currently defined Cell identifier for this session
   *
   * @return {string|null}
   */
  cellSlug() {
    return this.$__cellSlug || null;
  }
  /**
   * Sets the Cell identifier for this session
   *
   * @param cellSlug
   */
  setCellSlug(e) {
    this.$__cellSlug = e;
  }
  /**
   * Retrieves the endpoint URI for this session
   *
   * @return {string}
   */
  uri() {
    return this.$__client.getUri();
  }
  /**
   * Returns the Apollo client class session
   *
   * @return {ApolloClient}
   */
  client() {
    if (!this.$__authInProcess) {
      const e = this.getRandomUri();
      this.$__client.setUri(e);
      const t = this.$__authTokenObjects[e];
      t ? this.$__client.setAuthData(t.getAuthData()) : this.requestAuthToken({
        secret: this.$__secret,
        cellSlug: this.$__cellSlug,
        encrypt: this.$__encrypt
      }).then(() => {
      });
    }
    return this.$__client;
  }
  /**
   * Returns whether a secret is being stored for this session
   *
   * @return {boolean}
   */
  hasSecret() {
    return !!this.$__secret;
  }
  /**
   * Set the client's secret
   *
   * @param secret
   */
  setSecret(e) {
    this.$__secret = e, this.$__bundle = Nn(e, "setSecret");
  }
  /**
   * Retrieves the stored secret for this session
   *
   * @return {string}
   */
  getSecret() {
    if (!this.hasSecret())
      throw new hc("KnishIOClient::getSecret() - Unable to find a stored secret! Have you set a secret?");
    return this.$__secret;
  }
  /**
   * Returns whether a bundle hash is being stored for this session
   *
   * @return {boolean}
   */
  hasBundle() {
    return !!this.$__bundle;
  }
  /**
   * Returns the bundle hash for this session
   *
   * @return {string}
   */
  getBundle() {
    if (!this.hasBundle())
      throw new hc("KnishIOClient::getBundle() - Unable to find a stored bundle! Have you set a secret?");
    return this.$__bundle;
  }
  /**
   * Retrieves the device fingerprint.
   *
   * @returns {Promise<string>} A promise that resolves to the device fingerprint as a string.
   */
  getFingerprint() {
    return ox();
  }
  /**
   * Retrieves this session's wallet used for signing the next Molecule
   *
   * @return {Promise<*|Wallet|null>}
   */
  getSourceWallet() {
    return wt(this, null, function* () {
      let e = (yield this.queryContinuId({
        bundle: this.getBundle()
      })).payload();
      return e ? e.key = tr.generateKey({
        secret: this.getSecret(),
        token: e.token,
        position: e.position
      }) : e = new tr({
        secret: this.getSecret()
      }), e;
    });
  }
  /**
   * Retrieves this session's remainder wallet
   *
   * @return {null}
   */
  getRemainderWallet() {
    return this.remainderWallet;
  }
  /**
   * Instantiates a new Molecule and prepares this client session to operate on it
   *
   * @param secret
   * @param bundle
   * @param sourceWallet
   * @param remainderWallet
   * @return {Promise<Molecule>}
   */
  createMolecule(i) {
    return wt(this, arguments, function* ({
      secret: e = null,
      bundle: t = null,
      sourceWallet: n = null,
      remainderWallet: a = null
    }) {
      return this.$__logging && console.info("KnishIOClient::createMolecule() - Creating a new molecule..."), e = e || this.getSecret(), t = t || this.getBundle(), !n && this.lastMoleculeQuery && this.getRemainderWallet().token === "USER" && this.lastMoleculeQuery.response() && this.lastMoleculeQuery.response().success() && (n = this.getRemainderWallet()), n === null && (n = yield this.getSourceWallet()), this.remainderWallet = a || tr.create({
        secret: e,
        bundle: t,
        token: "USER",
        batchId: n.batchId,
        characters: n.characters
      }), new mn({
        secret: e,
        sourceWallet: n,
        remainderWallet: this.getRemainderWallet(),
        cellSlug: this.cellSlug(),
        version: this.getServerSdkVersion()
      });
    });
  }
  /**
   * Builds a new instance of the provided Query class
   *
   * @param queryClass
   * @return {*}
   */
  createQuery(e) {
    return new e(this.client());
  }
  /**
   * Builds a new instance of the provided Subscription class
   *
   * @param subscribeClass
   * @return {*}
   */
  createSubscribe(e) {
    return new e(this.subscribe());
  }
  /**
   * Uses the supplied Mutation class to build a new tailored Molecule
   *
   * @param mutationClass
   * @param molecule
   */
  createMoleculeMutation(n) {
    return wt(this, arguments, function* ({
      mutationClass: e,
      molecule: t = null
    }) {
      this.$__logging && console.info(`KnishIOClient::createMoleculeQuery() - Creating a new ${e.name} query...`);
      const a = t || (yield this.createMolecule({})), i = new e(this.client(), a);
      if (!(i instanceof kr))
        throw new $r(`${this.constructor.name}::createMoleculeMutation() - This method only accepts MutationProposeMolecule!`);
      return this.lastMoleculeQuery = i, i;
    });
  }
  /**
   *
   * @param query
   * @param variables
   * @returns {Promise<*>}
   */
  executeQuery(e, t = null) {
    return wt(this, null, function* () {
      return this.$__authToken && this.$__authToken.isExpired() && (console.info("KnishIOClient::executeQuery() - Access token is expired. Getting new one..."), yield this.requestAuthToken({
        secret: this.$__secret,
        cellSlug: this.$__cellSlug,
        encrypt: this.$__encrypt
      })), e.execute({
        variables: t
      });
    });
  }
  /**
   * Retrieves the balance wallet for a specified Knish.IO identity and token slug
   *
   * @param {string} token
   * @param {string|null} bundle
   * @param {string} type
   * @returns {Promise<*>}
   */
  queryBalance(a) {
    return wt(this, arguments, function* ({
      token: e,
      bundle: t = null,
      type: n = "regular"
    }) {
      const i = this.createQuery(U5);
      return this.executeQuery(i, {
        bundleHash: t || this.getBundle(),
        token: e,
        type: n
      });
    });
  }
  /**
   *
   * @param {string} token
   * @param {number} amount
   * @param {string} type
   * @returns {Promise<{address}|{position}|*>}
   */
  querySourceWallet(a) {
    return wt(this, arguments, function* ({
      token: e,
      amount: t,
      type: n = "regular"
    }) {
      const i = (yield this.queryBalance({
        token: e,
        type: n
      })).payload();
      if (i === null || mi.cmp(i.balance, t) < 0)
        throw new bn();
      if (!i.position || !i.address)
        throw new bn("Source wallet can not be a shadow wallet.");
      return i;
    });
  }
  /**
   * @param {string|null} bundle
   * @param {function} closure
   * @return {Promise<string>}
   */
  subscribeCreateMolecule(n) {
    return wt(this, arguments, function* ({
      bundle: e,
      closure: t
    }) {
      return yield this.createSubscribe(O8).execute({
        variables: {
          bundle: e || this.getBundle()
        },
        closure: t
      });
    });
  }
  /**
   * Creates a subscription for updating Wallet status
   *
   * @param {string|null} bundle
   * @param {string} token
   * @param {function} closure
   * @return {string}
   */
  subscribeWalletStatus({
    bundle: e,
    token: t,
    closure: n
  }) {
    if (!t)
      throw new $r(`${this.constructor.name}::subscribeWalletStatus() - Token parameter is required!`);
    return this.createSubscribe(B8).execute({
      variables: {
        bundle: e || this.getBundle(),
        token: t
      },
      closure: n
    });
  }
  /**
   *  Creates a subscription for updating active Wallet
   *
   * @param {string|null} bundle
   * @param {function} closure
   * @return {string}
   */
  subscribeActiveWallet({
    bundle: e,
    closure: t
  }) {
    return this.createSubscribe(P8).execute({
      variables: {
        bundle: e || this.getBundle()
      },
      closure: t
    });
  }
  /**
   * Creates a subscription for updating list of active sessions for a given MetaType
   *
   * @param {string} metaType
   * @param {string} metaId
   * @param {function} closure
   * @return {*}
   */
  subscribeActiveSession({
    metaType: e,
    metaId: t,
    closure: n
  }) {
    return this.createSubscribe(D8).execute({
      variables: {
        metaType: e,
        metaId: t
      },
      closure: n
    });
  }
  /**
   * Unsubscribes from a given subscription name
   *
   * @param {string} operationName
   */
  unsubscribe(e) {
    this.subscribe().unsubscribe(e);
  }
  unsubscribeAll() {
    this.subscribe().unsubscribeAll();
  }
  /**
   * Retrieves metadata for the given metaType and provided parameters
   *
   * @param {string|array|null} metaType
   * @param {string|array|null} metaId
   * @param {string|array|null} key
   * @param {string|array|null} value
   * @param {boolean|null} latest
   * @param {boolean|null} latestMetas
   * @param {object|null} fields
   * @param {object|null} filter
   * @param {object|null} queryArgs
   * @param {string|null} count
   * @param {string|null} countBy
   * @param {boolean} throughAtom
   * @param {array|null} values
   * @param {array|null} keys
   * @param {array|null} atomValues
   * @return {Promise<ResponseMetaType>}
   */
  queryMeta({
    metaType: e,
    metaId: t = null,
    key: n = null,
    value: a = null,
    latest: i = !0,
    latestMetas: o = !0,
    fields: u = null,
    filter: c = null,
    queryArgs: h = null,
    count: s = null,
    countBy: d = null,
    throughAtom: l = !0,
    values: y = null,
    keys: m = null,
    atomValues: w = null
  }) {
    this.$__logging && console.info(`KnishIOClient::queryMeta() - Querying metaType: ${e}, metaId: ${t}...`);
    let E, S;
    return l ? (E = this.createQuery(Fv), S = Fv.createVariables({
      metaType: e,
      metaId: t,
      key: n,
      value: a,
      latest: i,
      latestMetas: o,
      filter: c,
      queryArgs: h,
      countBy: d,
      values: y,
      keys: m,
      atomValues: w
    })) : (E = this.createQuery(rc), S = rc.createVariables({
      metaType: e,
      metaId: t,
      key: n,
      value: a,
      latest: i,
      latestMetas: o,
      filter: c,
      queryArgs: h,
      count: s,
      countBy: d
    })), this.executeQuery(E, S).then((P) => P.payload());
  }
  /**
   * Retrieves metadata for the given metaType and provided parameters
   *
   * @param {string|array|null} metaType
   * @param {string|array|null} metaId
   * @param {string|array|null} key
   * @param {string|array|null} value
   * @param {boolean|null} latest
   * @param {object|null} fields
   * @param {object|null} filter
   * @return {Promise<ResponseMetaType>}
   */
  queryMetaInstance({
    metaType: e,
    metaId: t = null,
    key: n = null,
    value: a = null,
    latest: i = null,
    filter: o = null,
    fields: u = null
  }) {
    this.$__logging && console.info(`KnishIOClient::queryMetaInstance() - Querying metaType: ${e}, metaId: ${t}...`);
    const c = this.createQuery(rc), h = {
      metaType: e,
      metaIds: [t],
      keys: [n],
      values: [a],
      latest: i,
      filter: o
    };
    return this.executeQuery(c, h).then((s) => s.data());
  }
  /**
   * Query batch to get cascading meta instances by batchID
   *
   * @param batchId
   * @return {Promise<*>}
   */
  queryBatch(t) {
    return wt(this, arguments, function* ({
      batchId: e
    }) {
      this.$__logging && console.info(`KnishIOClient::queryBatch() - Querying cascading meta instances for batchId: ${e}...`);
      const n = this.createQuery(pa);
      return yield this.executeQuery(n, {
        batchId: e
      });
    });
  }
  /**
   * Query batch history to get cascading meta instances by batchID
   *
   * @param batchId
   * @return {Promise<*>}
   */
  queryBatchHistory(t) {
    return wt(this, arguments, function* ({
      batchId: e
    }) {
      this.$__logging && console.info(`KnishIOClient::queryBatchHistory() - Querying cascading meta instances for batchId: ${e}...`);
      const n = this.createQuery(j5);
      return yield this.executeQuery(n, {
        batchId: e
      });
    });
  }
  /**
   * Queries atom instances based on the provided parameters.
   *
   * @param {string[]} molecularHashes - Array of multiple molecular hashes.
   * @param {string} molecularHash - Single molecular hash.
   * @param {string[]} bundleHashes - Array of multiple bundle hashes.
   * @param {string} bundleHash - Single bundle hash.
   * @param {number[]} positions - Array of multiple positions.
   * @param {number} position - Single position.
   * @param {string[]} walletAddresses - Array of multiple wallet addresses.
   * @param {string} walletAddress - Single wallet address.
   * @param {string[]} isotopes - Array of multiple isotopes.
   * @param {string} isotope - Single isotope.
   * @param {string[]} tokenSlugs - Array of multiple token slugs.
   * @param {string} tokenSlug - Single token slug.
   * @param {string[]} cellSlugs - Array of multiple cell slugs.
   * @param {string} cellSlug - Single cell slug.
   * @param {string[]} batchIds - Array of multiple batch IDs.
   * @param {string} batchId - Single batch ID.
   * @param {any[]} values - Array of multiple values.
   * @param {any} value - Single value.
   * @param {string[]} metaTypes - Array of multiple meta types.
   * @param {string} metaType - Single meta type.
   * @param {string[]} metaIds - Array of multiple meta IDs.
   * @param {string} metaId - Single meta ID.
   * @param {string[]} indexes - Array of multiple atom indices.
   * @param {string} index - Single atom index.
   * @param {object} filter - The filter object.
   * @param {boolean} latest - The latest flag.
   * @param {object} [queryArgs] - The query arguments (limit, offset).
   * @param {number} [queryArgs.limit=15] - The limit.
   * @param {number} [queryArgs.offset=1] - The offset.
   *
   * @returns {Promise<ResponseAtom>} - A promise that resolves with the queried atom instances.
   */
  queryAtom(A) {
    return wt(this, arguments, function* ({
      molecularHashes: e,
      molecularHash: t,
      bundleHashes: n,
      bundleHash: a,
      positions: i,
      position: o,
      walletAddresses: u,
      walletAddress: c,
      isotopes: h,
      isotope: s,
      tokenSlugs: d,
      tokenSlug: l,
      cellSlugs: y,
      cellSlug: m,
      batchIds: w,
      batchId: E,
      values: S,
      value: P,
      metaTypes: L,
      metaType: U,
      metaIds: z,
      metaId: K,
      indexes: re,
      index: oe,
      filter: se,
      latest: ve,
      queryArgs: Q = {
        limit: 15,
        offset: 1
      }
    }) {
      this.$__logging && console.info("KnishIOClient::queryAtom() - Querying atom instances");
      const b = this.createQuery(Lv);
      return yield this.executeQuery(b, Lv.createVariables({
        molecularHashes: e,
        molecularHash: t,
        bundleHashes: n,
        bundleHash: a,
        positions: i,
        position: o,
        walletAddresses: u,
        walletAddress: c,
        isotopes: h,
        isotope: s,
        tokenSlugs: d,
        tokenSlug: l,
        cellSlugs: y,
        cellSlug: m,
        batchIds: w,
        batchId: E,
        values: S,
        value: P,
        metaTypes: L,
        metaType: U,
        metaIds: z,
        metaId: K,
        indexes: re,
        index: oe,
        filter: se,
        latest: ve,
        queryArgs: Q
      }));
    });
  }
  /**
   * Builds and executes a molecule to issue a new Wallet on the ledger
   *
   * @param {string} token - The token slug for the new wallet
   * @returns {Promise<ResponseCreateWallet>} - A Promise that resolves with the result of the execution.
   */
  createWallet(t) {
    return wt(this, arguments, function* ({
      token: e
    }) {
      const n = new tr({
        secret: this.getSecret(),
        token: e
      }), a = yield this.createMoleculeMutation({
        mutationClass: i8
      });
      return a.fillMolecule(n), yield this.executeQuery(a);
    });
  }
  /**
   * Queries the ledger to retrieve a list of active sessions for the given MetaType
   *
   * @param {string} bundleHash - The hash of the session bundle.
   * @param {string} metaType - The type of metadata associated with the session.
   * @param {string} metaId - The ID of the metadata associated with the session.
   * @returns {Promise<ResponseQueryActiveSession>} - Returns a promise containing the result of the query.
   */
  queryActiveSession(a) {
    return wt(this, arguments, function* ({
      bundleHash: e,
      metaType: t,
      metaId: n
    }) {
      const i = this.createQuery(F8);
      return yield this.executeQuery(i, {
        bundleHash: e,
        metaType: t,
        metaId: n
      });
    });
  }
  /**
   * Queries user activity based on the provided parameters.
   *
   * @param {string} bundleHash - The bundle hash.
   * @param {string} metaType - The meta type.
   * @param {string} metaId - The meta ID.
   * @param {string} ipAddress - The IP address.
   * @param {string} browser - The browser.
   * @param {string} osCpu - The operating system and CPU.
   * @param {string} resolution - The screen resolution.
   * @param {string} timeZone - The time zone.
   * @param {string} countBy - The count by parameter.
   * @param {string} interval - The interval parameter.
   *
   * @returns {Promise<ResponseQueryUserActivity>} The result of the query.
   */
  queryUserActivity(d) {
    return wt(this, arguments, function* ({
      bundleHash: e,
      metaType: t,
      metaId: n,
      ipAddress: a,
      browser: i,
      osCpu: o,
      resolution: u,
      timeZone: c,
      countBy: h,
      interval: s
    }) {
      const l = this.createQuery($8);
      return yield this.executeQuery(l, {
        bundleHash: e,
        metaType: t,
        metaId: n,
        ipAddress: a,
        browser: i,
        osCpu: o,
        resolution: u,
        timeZone: c,
        countBy: h,
        interval: s
      });
    });
  }
  /**
   * Builds and executes a molecule to declare an active session for the given MetaType
   *
   * @param {Object} options - The options for activating a session.
   * @param {string} options.bundle - The bundle hash.
   * @param {string} options.metaType - The meta type.
   * @param {string} options.metaId - The meta ID.
   * @param {string} options.ipAddress - The client's IP address.
   * @param {string} options.browser - The client's browser.
   * @param {string} options.osCpu - The client's operating system and CPU.
   * @param {string} options.resolution - The client's screen resolution.
   * @param {string} options.timeZone - The client's time zone.
   * @param {Object} [options.json={}] - Additional JSON data.
   * @returns {Promise<ResponseActiveSession>} A promise that resolves with the result of the activation.
   */
  activeSession(s) {
    return wt(this, arguments, function* ({
      bundle: e,
      metaType: t,
      metaId: n,
      ipAddress: a,
      browser: i,
      osCpu: o,
      resolution: u,
      timeZone: c,
      json: h = {}
    }) {
      const d = this.createQuery(q8);
      return yield this.executeQuery(d, {
        bundleHash: e,
        metaType: t,
        metaId: n,
        ipAddress: a,
        browser: i,
        osCpu: o,
        resolution: u,
        timeZone: c,
        json: JSON.stringify(h)
      });
    });
  }
  /**
   * Creates a new token with the given parameters.
   *
   * @param {object} options - The options for creating the token.
   * @param {string} options.token - The token identifier.
   * @param {number} [options.amount] - The amount of tokens to create.
   * @param {object} [options.meta] - Additional metadata for the token.
   * @param {string} [options.batchId] - The batch identifier for stackable tokens.
   * @param {array} [options.units] - The unit IDs for the token.
   *
   * @throws {StackableUnitDecimalsException} If a stackable token has decimals.
   * @throws {StackableUnitAmountException} If stackable units are provided with an amount.
   *
   * @returns {Promise<ResponseCreateToken>} A Promise that resolves to the result of creating the token.
   */
  createToken(o) {
    return wt(this, arguments, function* ({
      token: e,
      amount: t = null,
      meta: n = null,
      batchId: a = null,
      units: i = []
    }) {
      const u = dr.get(n || {}, "fungibility");
      if (u === "stackable" && (n.batchId = a || po({})), ["nonfungible", "stackable"].includes(u) && i.length > 0) {
        if (dr.get(n || {}, "decimals") > 0)
          throw new s8();
        if (t > 0)
          throw new Ga();
        t = i.length, n.splittable = 1, n.decimals = 0, n.tokenUnits = JSON.stringify(i);
      }
      const c = new tr({
        secret: this.getSecret(),
        bundle: this.getBundle(),
        token: e,
        batchId: a
      }), h = yield this.createMoleculeMutation({
        mutationClass: W5
      });
      return h.fillMolecule({
        recipientWallet: c,
        amount: t,
        meta: n || {}
      }), yield this.executeQuery(h);
    });
  }
  /**
   * Creates a new rule with the specified parameters.
   *
   * @param {string} metaType - The type of the metadata associated with the rule.
   * @param {string} metaId - The ID of the metadata associated with the rule.
   * @param {object} rule - The rule object.
   * @param {object} [policy={}] - The policy object. (optional)
   * @returns {Promise<ResponseCreateRule>} - A promise that resolves to the created rule.
   */
  createRule(i) {
    return wt(this, arguments, function* ({
      metaType: e,
      metaId: t,
      rule: n,
      policy: a = {}
    }) {
      const o = yield this.createMoleculeMutation(
        {
          mutationClass: Q8,
          molecule: yield this.createMolecule({
            secret: this.getSecret(),
            sourceWallet: yield this.getSourceWallet()
          })
        }
      );
      return o.fillMolecule({
        metaType: e,
        metaId: t,
        rule: n,
        policy: a
      }), yield this.executeQuery(o);
    });
  }
  /**
   * Builds and executes a molecule to convey new metadata to the ledger
   *
   * @param {string} metaType - The type of the metadata entry.
   * @param {string} metaId - The ID of the metadata entry.
   * @param {Object} [meta=null] - The metadata object.
   * @param {Object} [policy={}] - The policy object.
   * @returns {Promise<ResponseCreateMeta>} - A Promise that resolves with the created metadata entry.
   */
  createMeta(i) {
    return wt(this, arguments, function* ({
      metaType: e,
      metaId: t,
      meta: n = null,
      policy: a = {}
    }) {
      const o = yield this.createMoleculeMutation(
        {
          mutationClass: r8,
          molecule: yield this.createMolecule({
            secret: this.getSecret(),
            sourceWallet: yield this.getSourceWallet()
          })
        }
      ), u = n || {};
      return o.fillMolecule({
        metaType: e,
        metaId: t,
        meta: u,
        policy: a
      }), yield this.executeQuery(o);
    });
  }
  /**
   * Builds and executes a molecule to create a new identifier on the ledger
   *
   * @param {string} type - The type of the identifier.
   * @param {string} contact - The contact associated with the identifier.
   * @param {string} code - The code for the identifier.
   * @returns {Promise<ResponseCreateIdentifier>} - A promise that resolves to the created identifier.
   */
  createIdentifier(a) {
    return wt(this, arguments, function* ({
      type: e,
      contact: t,
      code: n
    }) {
      const i = yield this.createMoleculeMutation({
        mutationClass: X5
      });
      return i.fillMolecule({
        type: e,
        contact: t,
        code: n
      }), yield this.executeQuery(i);
    });
  }
  /**
   * Creates a policy for a given metaType and metaId.
   *
   * @param {Object} options - The options for creating the policy.
   * @param {string} options.metaType - The type of the meta.
   * @param {string} options.metaId - The ID of the meta.
   * @param {Object} [options.policy={}] - The policy object.
   * @returns {Promise<*>} - A promise that resolves with the result of the execution.
   */
  createPolicy(a) {
    return wt(this, arguments, function* ({
      metaType: e,
      metaId: t,
      policy: n = {}
    }) {
      const i = yield this.createMolecule({});
      i.addPolicyAtom({
        metaType: e,
        metaId: t,
        meta: {},
        policy: n
      }), i.addContinuIdAtom(), i.sign({
        bundle: this.getBundle()
      }), i.check();
      const o = yield this.createMoleculeMutation({
        mutationClass: kr,
        molecule: i
      });
      return yield this.executeQuery(o);
    });
  }
  /**
   * Queries the policy based on the provided metaType and metaId.
   *
   * @param {string} metaType - The type of the meta.
   * @param {string} metaId - The ID of the meta.
   * @returns {Promise<ResponsePolicy>} - A Promise that resolves to the query result.
   */
  queryPolicy(n) {
    return wt(this, arguments, function* ({
      metaType: e,
      metaId: t
    }) {
      const a = this.createQuery(V8);
      return yield this.executeQuery(a, {
        metaType: e,
        metaId: t
      });
    });
  }
  /**
   * Queries wallets based on the provided parameters.
   *
   * @param {object} options - The options for querying wallets.
   * @param {string|null} options.bundle - The bundle to query wallets for.
   * @param {string|null} options.token - The token to query wallets for.
   * @param {boolean} [options.unspent=true] - Whether to include unspent wallets or not.
   *
   * @returns {Promise<ResponseWalletList>} - A promise that resolves to the response payload of the query.
   */
  queryWallets({
    bundle: e = null,
    token: t = null,
    unspent: n = !0
  }) {
    this.$__logging && console.info(`KnishIOClient::queryWallets() - Querying wallets${e ? ` for ${e}` : ""}...`);
    const a = this.createQuery(L5);
    return this.executeQuery(a, {
      bundleHash: e || this.getBundle(),
      tokenSlug: t,
      unspent: n
    }).then((i) => i.payload());
  }
  /**
   * Queries wallet bundle metadata.
   *
   * @param {Object} options - The options for the query.
   * @param {string|null} options.bundle - The bundle to query. Default is null.
   * @param {string|null} options.fields - The fields to retrieve. Default is null.
   * @param {boolean} options.raw - Whether to return the raw response or the payload. Default is false.
   * @returns {Promise<ResponseWalletBundle|{}|null>} - A promise that resolves to the response or payload.
   */
  queryBundle({
    bundle: e = null,
    fields: t = null,
    raw: n = !1
  }) {
    this.$__logging && console.info(`KnishIOClient::queryBundle() - Querying wallet bundle metadata${e ? ` for ${e}` : ""}...`), e || (e = this.getBundle()), typeof e == "string" && (e = [e]);
    const a = this.createQuery(q5);
    return this.executeQuery(a, { bundleHashes: e }).then((i) => n ? i : i.payload());
  }
  /**
   * Queries the ledger for the next ContinuId wallet
   *
   * @param {String} bundle - The bundle hash used in the query.
   * @returns {Promise<ResponseContinuId>} - A promise that resolves to the result of the query.
   */
  queryContinuId(t) {
    return wt(this, arguments, function* ({
      bundle: e
    }) {
      const n = this.createQuery(D5);
      return this.executeQuery(n, {
        bundle: e
      });
    });
  }
  /**
   * Requests tokens for a specific recipient or for the current wallet bundle.
   *
   * @param {Object} options - The options for the token request.
   * @param {string} options.token - The token slug.
   * @param {string|Wallet} [options.to] - The recipient of the tokens. If not provided, tokens will be requested for the current wallet bundle.
   * @param {number|null} [options.amount=null] - The amount of tokens to request. If not provided and `options.units` are provided, the amount will be calculated based on the number of
   * units.
   * @param {Array} [options.units=[]] - The array of unit IDs. If provided, the amount will be calculated based on the length of `options.units`.
   * @param {Object|null} [options.meta=null] - Additional metadata for the token request.
   * @param {string|null} [options.batchId=null] - The batch ID for the token request. If not provided and the token is stackable, a new batch ID will be generated.
   *
   * @returns {Promise<ResponseRequestTokens>} - A promise that resolves with the response from the token request.
   *
   * @throws {BatchIdException} - When a non-stackable token is used and `options.batchId` is not null.
   * @throws {StackableUnitAmountException} - When both `options.units` and `options.amount` are provided for stackable tokens.
   */
  requestTokens(u) {
    return wt(this, arguments, function* ({
      token: e,
      to: t,
      amount: n = null,
      units: a = [],
      meta: i = null,
      batchId: o = null
    }) {
      let c, h;
      i = i || {};
      const s = this.createQuery(j8), d = yield this.executeQuery(s, {
        slug: e
      }), l = dr.get(d.data(), "0.fungibility") === "stackable";
      if (!l && o !== null)
        throw new ro("Expected Batch ID = null for non-stackable tokens.");
      if (l && o === null && (o = po({})), a.length > 0) {
        if (n > 0)
          throw new Ga();
        n = a.length, i.tokenUnits = JSON.stringify(a);
      }
      t ? (Object.prototype.toString.call(t) === "[object String]" && (tr.isBundleHash(t) ? (c = "walletBundle", h = t) : t = tr.create({
        secret: t,
        token: e
      })), t instanceof tr && (c = "wallet", i.position = t.position, i.bundle = t.bundle, h = t.address)) : (c = "walletBundle", h = this.getBundle());
      const y = yield this.createMoleculeMutation({
        mutationClass: Q5
      });
      return y.fillMolecule({
        token: e,
        amount: n,
        metaType: c,
        metaId: h,
        meta: i,
        batchId: o
      }), yield this.executeQuery(y);
    });
  }
  /**
   * Claims a shadow wallet for a given token.
   *
   * @param {string} token - The token for which to claim the shadow wallet.
   * @param {string|null} batchId - The batch ID of the shadow wallet (optional).
   * @param {string|null} molecule - The molecule associated with the shadow wallet (optional).
   *
   * @returns {Promise<ResponseClaimShadowWallet>} - A promise that resolves to the result of the claim operation.
   */
  claimShadowWallet(a) {
    return wt(this, arguments, function* ({
      token: e,
      batchId: t = null,
      molecule: n = null
    }) {
      const i = yield this.createMoleculeMutation({
        mutationClass: e8,
        molecule: n
      });
      return i.fillMolecule({
        token: e,
        batchId: t
      }), yield this.executeQuery(i);
    });
  }
  /**
   * Claims all shadow wallets for a given token.
   *
   * @param {Object} options - The options for claiming shadow wallets.
   * @param {string} options.token - The token to claim shadow wallets for.
   * @returns {Promise<*>} - A promise that resolves to an array of responses from claiming shadow wallets.
   * @throws {WalletShadowException} - If the shadow wallet list is invalid or if a non-shadow wallet is found.
   */
  claimShadowWallets(t) {
    return wt(this, arguments, function* ({
      token: e
    }) {
      const n = yield this.queryWallets({ token: e });
      if (!n || !Array.isArray(n))
        throw new Dv();
      n.forEach((i) => {
        if (!i.isShadow())
          throw new Dv();
      });
      const a = [];
      for (const i of n)
        a.push(yield this.claimShadowWallet({
          token: e,
          batchId: i.batchId
        }));
      return a;
    });
  }
  /**
   * Transfers tokens from one wallet to another.
   *
   * @param {Object} options - The transfer options.
   * @param {string} options.bundleHash - The bundle hash of the source wallet.
   * @param {string} options.token - The token to transfer.
   * @param {number} [options.amount=null] - The amount of tokens to transfer. Not required if units are provided.
   * @param {Array} [options.units=[]] - An array of units to transfer. Overrides the amount if provided.
   * @param {string} [options.batchId=null] - The batch ID for the recipient wallet.
   * @param {Object} [options.sourceWallet=null] - The source wallet object. If not provided, it will be queried.
   *
   * @returns {Promise} - A Promise that resolves to the transaction result.
   *
   * @throws {StackableUnitAmountException} - If both amount and units are provided.
   * @throws {TransferBalanceException} - If the source wallet does not have enough balance.
   */
  transferToken(u) {
    return wt(this, arguments, function* ({
      bundleHash: e,
      token: t,
      amount: n = null,
      units: a = [],
      batchId: i = null,
      sourceWallet: o = null
    }) {
      if (a.length > 0) {
        if (n > 0)
          throw new Ga();
        n = a.length;
      }
      if (o === null && (o = yield this.querySourceWallet({
        token: t,
        amount: n
      })), o === null || mi.cmp(o.balance, n) < 0)
        throw new bn();
      const c = tr.create({
        bundle: e,
        token: t
      });
      i !== null ? c.batchId = i : c.initBatchId({
        sourceWallet: o
      });
      const h = o.createRemainder(this.getSecret());
      o.splitUnits(
        a,
        h,
        c
      );
      const s = yield this.createMolecule({
        sourceWallet: o,
        remainderWallet: h
      }), d = yield this.createMoleculeMutation({
        mutationClass: J5,
        molecule: s
      });
      return d.fillMolecule({
        recipientWallet: c,
        amount: n
      }), yield this.executeQuery(d);
    });
  }
  /**
   * Deposits buffer token into the source wallet.
   *
   * @param {Object} options - The options for depositing buffer token.
   * @param {string} options.tokenSlug - The slug of the token to deposit.
   * @param {number} options.amount - The amount of token to deposit.
   * @param {Object} options.tradeRates - The trade rates for the deposit.
   * @param {Wallet|null} options.sourceWallet - The source wallet for the deposit. If not provided, a source wallet will be queried.
   *
   * @returns {Promise<*>} - A promise that resolves with the result of the deposit.
   */
  depositBufferToken(i) {
    return wt(this, arguments, function* ({
      tokenSlug: e,
      amount: t,
      tradeRates: n,
      sourceWallet: a = null
    }) {
      a === null && (a = yield this.querySourceWallet({
        token: e,
        amount: t
      }));
      const o = a.createRemainder(this.getSecret()), u = yield this.createMolecule({
        sourceWallet: a,
        remainderWallet: o
      }), c = yield this.createMoleculeMutation({
        mutationClass: G8,
        molecule: u
      });
      return c.fillMolecule({
        amount: t,
        tradeRates: n
      }), yield this.executeQuery(c);
    });
  }
  /**
   * Withdraws buffer tokens.
   *
   * @param {Object} options - The options for withdrawing buffer tokens.
   * @param {string} options.tokenSlug - The token slug.
   * @param {number} options.amount - The amount of tokens to withdraw.
   * @param {Object} [options.sourceWallet=null] - The source wallet to withdraw tokens from. If not provided, a source wallet will be queried.
   * @param {Object} [options.signingWallet=null] - The signing wallet to use for the transaction.
   * @returns {Promise<Object>} A promise that resolves to the result of the withdrawal transaction.
   */
  withdrawBufferToken(i) {
    return wt(this, arguments, function* ({
      tokenSlug: e,
      amount: t,
      sourceWallet: n = null,
      signingWallet: a = null
    }) {
      n === null && (n = yield this.querySourceWallet({
        token: e,
        amount: t,
        type: "buffer"
      }));
      const o = n, u = yield this.createMolecule({
        sourceWallet: n,
        remainderWallet: o
      }), c = yield this.createMoleculeMutation({
        mutationClass: J8,
        molecule: u
      }), h = {};
      return h[this.getBundle()] = t, c.fillMolecule({
        recipients: h,
        signingWallet: a
      }), yield this.executeQuery(c);
    });
  }
  /**
   * Builds and executes a molecule to destroy the specified Token units
   *
   * @param {string} token
   * @param {number|null} amount
   * @param {array|null} units
   * @param {Wallet|null} sourceWallet
   * @return {Promise<unknown>}
   */
  burnTokens(i) {
    return wt(this, arguments, function* ({
      token: e,
      amount: t = null,
      units: n = [],
      sourceWallet: a = null
    }) {
      a === null && (a = yield this.querySourceWallet({
        token: e,
        amount: t
      }));
      const o = a.createRemainder(this.getSecret());
      if (n.length > 0) {
        if (t > 0)
          throw new Ga();
        t = n.length, a.splitUnits(
          n,
          o
        );
      }
      const u = yield this.createMolecule({
        sourceWallet: a,
        remainderWallet: o
      });
      u.burnToken({ amount: t }), u.sign({
        bundle: this.getBundle()
      }), u.check();
      const c = yield this.createMoleculeMutation({
        mutationClass: kr,
        molecule: u
      });
      return this.executeQuery(c);
    });
  }
  /**
   * Builds and executes a molecule to destroy the specified Token units
   *
   * @param {string} token
   * @param {number|null} amount
   * @param {array|null} units
   * @param {Wallet|null} sourceWallet
   * @return {Promise<unknown>}
   */
  replenishToken(i) {
    return wt(this, arguments, function* ({
      token: e,
      amount: t = null,
      units: n = [],
      sourceWallet: a = null
    }) {
      if (a === null && (a = (yield this.queryBalance({ token: e })).payload()), !a)
        throw new bn("Source wallet is missing or invalid.");
      const o = a.createRemainder(this.getSecret()), u = yield this.createMolecule({
        sourceWallet: a,
        remainderWallet: o
      });
      u.replenishToken({
        amount: t,
        units: n
      }), u.sign({
        bundle: this.getBundle()
      }), u.check();
      const c = yield this.createMoleculeMutation({
        mutationClass: kr,
        molecule: u
      });
      return this.executeQuery(c);
    });
  }
  /**
   *
   * @param bundleHash
   * @param tokenSlug
   * @param newTokenUnit
   * @param fusedTokenUnitIds
   * @param sourceWallet
   * @returns {Promise<*>}
   */
  fuseToken(o) {
    return wt(this, arguments, function* ({
      bundleHash: e,
      tokenSlug: t,
      newTokenUnit: n,
      fusedTokenUnitIds: a,
      sourceWallet: i = null
    }) {
      if (i === null && (i = (yield this.queryBalance({ token: t })).payload()), i === null)
        throw new bn("Source wallet is missing or invalid.");
      if (!i.tokenUnits || !i.tokenUnits.length)
        throw new bn("Source wallet does not have token units.");
      if (!a.length)
        throw new bn("Fused token unit list is empty.");
      const u = [];
      i.tokenUnits.forEach((l) => {
        u.push(l.id);
      }), a.forEach((l) => {
        if (!u.includes(l))
          throw new bn(`Fused token unit ID = ${l} does not found in the source wallet.`);
      });
      const c = tr.create({
        bundle: e,
        token: t
      });
      c.initBatchId({ sourceWallet: i });
      const h = i.createRemainder(this.getSecret());
      i.splitUnits(a, h), n.metas.fusedTokenUnits = i.getTokenUnitsData(), c.tokenUnits = [n];
      const s = yield this.createMolecule({
        sourceWallet: i,
        remainderWallet: h
      });
      s.fuseToken(i.tokenUnits, c), s.sign({
        bundle: this.getBundle()
      }), s.check();
      const d = yield this.createMoleculeMutation({
        mutationClass: kr,
        molecule: s
      });
      return this.executeQuery(d);
    });
  }
  /**
   * Requests a guest authentication token using the fingerprint of the user.
   * @param {Object} options - The options for the guest authentication token request.
   * @param {string} options.cellSlug - The slug of the cell to request the token for.
   * @param {boolean} options.encrypt - Indicates whether the session should be encrypted.
   * @returns {Promise<ResponseRequestAuthorizationGuest>} - A promise that resolves to the response of the guest authentication token request.
   */
  requestGuestAuthToken(n) {
    return wt(this, arguments, function* ({
      cellSlug: e,
      encrypt: t
    }) {
      this.setCellSlug(e);
      const a = new tr({
        secret: Yi(this.getFingerprint()),
        token: "AUTH"
      }), i = yield this.createQuery(o8), o = {
        cellSlug: e,
        pubkey: a.pubkey,
        encrypt: t
      }, u = yield i.execute(o);
      if (u.success()) {
        const c = oa.create(u.payload(), a);
        this.setAuthToken(c);
      } else
        throw new qv(`KnishIOClient::requestGuestAuthToken() - Authorization attempt rejected by ledger. Reason: ${u.reason()}`);
      return u;
    });
  }
  /**
   * Request a profile auth token
   *
   * @param secret
   * @param encrypt
   * @returns {Promise<ResponseRequestAuthorization>}
   */
  requestProfileAuthToken(n) {
    return wt(this, arguments, function* ({
      secret: e,
      encrypt: t
    }) {
      this.setSecret(e);
      const a = new tr({
        secret: e,
        token: "AUTH"
      }), i = yield this.createMolecule({
        secret: e,
        sourceWallet: a
      }), o = yield this.createMoleculeMutation({
        mutationClass: z5,
        molecule: i
      });
      o.fillMolecule({ meta: { encrypt: t ? "true" : "false" } });
      const u = yield o.execute({});
      if (u.success()) {
        const c = oa.create(u.payload(), a);
        this.setAuthToken(c);
      } else
        throw new qv(`KnishIOClient::requestProfileAuthToken() - Authorization attempt rejected by ledger. Reason: ${u.reason()}`);
      return u;
    });
  }
  /**
   * Request an auth token (guest or profile)
   *
   * @param secret
   * @param seed
   * @param cellSlug
   * @param encrypt
   * @returns {Promise<ResponseRequestAuthorizationGuest|ResponseRequestAuthorization|null>}
   */
  requestAuthToken(i) {
    return wt(this, arguments, function* ({
      secret: e = null,
      seed: t = null,
      cellSlug: n = null,
      encrypt: a = !1
    }) {
      if (this.$__serverSdkVersion < 3)
        return this.$__logging && console.warn("KnishIOClient::authorize() - Server SDK version does not require an authorization..."), null;
      e === null && t && (e = Yi(t)), this.$__authInProcess = !0;
      let o;
      return e ? o = yield this.requestProfileAuthToken({
        secret: e,
        encrypt: a
      }) : o = yield this.requestGuestAuthToken({
        cellSlug: n,
        encrypt: a
      }), this.$__logging && console.info(`KnishIOClient::authorize() - Successfully retrieved auth token ${this.$__authToken.getToken()}...`), this.switchEncryption(a), this.$__authInProcess = !1, o;
    });
  }
  /**
   * Sets the auth token
   *
   * @param {AuthToken} authToken
   */
  setAuthToken(e) {
    if (!e) {
      this.$__logging && console.info("KnishIOClient::setAuthToken() - authToken object is empty.");
      return;
    }
    this.$__authTokenObjects[this.uri()] = e, this.client().setAuthData(e.getAuthData()), this.$__authToken = e;
  }
  /**
   * Returns the current authorization token
   *
   * @return {AuthToken}
   */
  getAuthToken() {
    return this.$__authToken;
  }
}
class $b {
  /**
   *
   * @param graphqlUrl
   * @param encrypt
   */
  constructor(e, t = !1) {
    this.encrypt = t, this.secrets = [Yi(), Yi()], this.tokenSlugs = ["TESTTOKEN", "UTENVSTACKABLE", "UTSTACKUNIT", "UTENVSTACKUNIT", "UTSTACKUNITZONES", "UTSLUG0", "UTSLUG1"], this.graphqlUrl = e, console.log(`---------- GraphQL URI: ${this.graphqlUrl}`), this.clients = {}, this.tokenUnits = [
      ["unit_id_1", "unit_name_1"],
      ["unit_id_2", "unit_name_2"],
      ["unit_id_3", "unit_name_3"],
      ["unit_id_4", "unit_name_4"],
      ["unit_id_5", "unit_name_5"],
      ["unit_id_6", "unit_name_6"],
      ["unit_id_7", "unit_name_7"],
      ["unit_id_8", "unit_name_8"],
      ["unit_id_9", "unit_name_9"],
      ["unit_id_10", "unit_name_10"],
      ["unit_id_11", "unit_name_11"]
    ], this.replenishTokenUnits = [
      ["unit_id_12", "unit_id_12"],
      ["unit_id_13", "unit_id_13"],
      ["unit_id_14", "unit_id_14"],
      ["unit_id_15", "unit_id_15"]
    ];
    const n = (a, i = 0) => {
      const o = [];
      return a.forEach((u, c) => {
        const h = Array.from(u);
        h.push({ fragmentZone: i + c }), o.push(h);
      }), o;
    };
    this.tokenUnitsFZ = n(this.tokenUnits), this.replenishTokenUnitsFZ = n(Array.from(this.replenishTokenUnits), this.tokenUnits.length), this.fragmentZones = this.tokenUnitsFZ.length + this.replenishTokenUnitsFZ.length, this.fusedTokenUnitIds = [], this.tokenUnitsFZ.slice(0, 5).forEach((a) => {
      this.fusedTokenUnitIds.push(a[0]);
    });
  }
  /**
   * Run all
   */
  static run(e) {
    return wt(this, null, function* () {
      for (const t in e)
        yield new $b(e[t]).testAll();
    });
  }
  /**
   * Test all KnishIOClient functions
   */
  testAll() {
    return wt(this, null, function* () {
      console.info(`Executing test for: ${this.graphqlUrl}...`), yield this.client(this.secrets[0]), yield this.client(this.secrets[1]), yield this.testCreateToken(), yield this.testFuseToken(), yield this.testCreateWallet(), yield this.testCreateMeta(), yield this.testCreateIdentifier(), yield this.testRequestTokens(), yield this.testTransferToken(), yield this.testBurnToken(), yield this.testReplenishToken(), yield this.testClaimShadowWallet(), yield this.testWalletBufferTransactions(), yield this.testQueryMeta(), yield this.testQueryWallets(), yield this.testQueryBundle(), yield this.testQueryBalance();
    });
  }
  /**
   *
   * @returns {Promise<void>}
   */
  testTokenExpiration() {
    return wt(this, null, function* () {
      const e = yield this.client(this.secrets[0]), t = (n) => {
        setTimeout((a) => {
          console.warn(`setTimeout ${n}`), a.queryMeta({
            metaType: "metaType",
            metaId: "metaId"
          });
        }, n, e, n);
      };
      t(3e3), t(3e4), t(61e3), t(64e3);
    });
  }
  /**
   * @throws Exception
   */
  testCreateToken() {
    return wt(this, null, function* () {
      const e = {};
      let t = yield this.client(this.secrets[0]);
      e[0] = yield t.createToken({
        token: this.tokenSlugs[0],
        amount: 1e3,
        meta: {
          name: this.tokenSlugs[0],
          fungibility: "stackable",
          supply: "replenishable",
          decimals: 0,
          icon: "icon"
        },
        batchId: "batch_0"
      }), this.checkResponse(e[0], "testCreateToken.0");
      const n = yield this.client(Bt.env.SECRET_TOKEN_KNISH);
      e[1] = yield n.createToken({
        token: this.tokenSlugs[1],
        amount: 1e3,
        meta: {
          name: this.tokenSlugs[1],
          fungibility: "stackable",
          supply: "limited",
          decimals: 0,
          icon: "icon"
        },
        batchId: "server_batch_0"
      }), this.checkResponse(e[1], "testCreateToken.1"), e[2] = yield t.createToken({
        token: this.tokenSlugs[2],
        units: this.tokenUnits,
        meta: {
          name: this.tokenSlugs[2],
          supply: "replenishable",
          fungibility: "stackable"
        },
        batchId: "unit_batch_0"
      }), this.checkResponse(e[2], "testCreateToken.2"), e[3] = yield n.createToken({
        token: this.tokenSlugs[3],
        units: this.tokenUnits,
        meta: {
          name: this.tokenSlugs[3],
          supply: "limited",
          fungibility: "stackable"
        },
        batchId: "server_unit_batch_0"
      }), this.checkResponse(e[3], "testCreateToken.3"), e[4] = yield t.createToken({
        token: this.tokenSlugs[4],
        units: this.tokenUnitsFZ,
        meta: {
          name: this.tokenSlugs[4],
          supply: "replenishable",
          fungibility: "stackable",
          fragmentZones: this.fragmentZones
        },
        batchId: "unit_fz_batch_0"
      }), this.checkResponse(e[4], "testCreateToken.4"), t = yield this.client(this.secrets[0]);
      for (const a of [this.tokenSlugs[5], this.tokenSlugs[6]])
        e[0] = yield t.createToken({
          token: a,
          amount: 1e3,
          meta: {
            name: a,
            fungibility: "fungible",
            supply: "limited",
            decimals: 0,
            icon: "icon"
          }
        }), this.checkResponse(e[0], `testCreateToken.${a}`);
    });
  }
  /**
   *
   */
  testCreateWallet() {
    return wt(this, null, function* () {
      const t = yield (yield this.client(this.secrets[0])).createWallet({
        token: this.tokenSlugs[1]
      });
      this.checkResponse(t, "testCreateWallet");
    });
  }
  /**
   *
   */
  testCreateMeta() {
    return wt(this, null, function* () {
      const t = yield (yield this.client(this.secrets[0])).createMeta({
        metaType: "metaType",
        metaId: "metaId",
        meta: {
          key1: "value1",
          key2: "value2"
        }
      });
      this.checkResponse(t, "testCreateMeta");
    });
  }
  /**
   *
   */
  testCreateIdentifier() {
    return wt(this, null, function* () {
      const t = yield (yield this.client(this.secrets[0])).createIdentifier({
        type: "email",
        contact: "test@test.com",
        code: "1234"
      });
      console.log(" ############### testCreateIdentifier ###############"), t.reason() !== "Outdated code" && console.error("Error with response."), this.debug(t);
    });
  }
  /**
   *
   */
  testRequestTokens() {
    return wt(this, null, function* () {
      const e = yield this.client(this.secrets[0]);
      let t = yield e.requestTokens({
        token: this.tokenSlugs[1],
        amount: 10,
        to: this.secrets[0],
        batchId: "batch_5"
      });
      this.checkResponse(t, "testRequestTokens.1"), t = yield e.requestTokens({
        token: this.tokenSlugs[3],
        units: ["unit_id_10", "unit_id_11"],
        to: this.secrets[0],
        batchId: "batch_6"
      }), this.checkResponse(t, "testRequestTokens.2");
    });
  }
  /**
   *
   * @return {Promise<void>}
   */
  testTransferToken() {
    return wt(this, null, function* () {
      const e = Nn(this.secrets[1]);
      let t;
      const n = yield this.client(this.secrets[0]);
      t = yield n.transferToken({
        bundleHash: e,
        token: this.tokenSlugs[0],
        amount: 10,
        batchId: "batch_1"
      }), this.checkResponse(t, "testTransferToken"), t = yield n.transferToken({
        bundleHash: e,
        token: this.tokenSlugs[2],
        units: ["unit_id_1", "unit_id_2"],
        batchId: "batch_2"
      }), this.checkResponse(t, "testTransferUnitToken");
    });
  }
  /**
   *
   */
  testBurnToken() {
    return wt(this, null, function* () {
      let e;
      const t = yield this.client(this.secrets[0]);
      e = yield t.burnTokens({
        token: this.tokenSlugs[0],
        amount: 10
      }), this.checkResponse(e, "testBurnToken"), e = yield t.burnTokens({
        token: this.tokenSlugs[2],
        units: ["unit_id_3", "unit_id_4"]
      }), this.checkResponse(e, "testBurnUnitToken");
    });
  }
  /**
   *
   */
  testReplenishToken() {
    return wt(this, null, function* () {
      let e;
      const t = yield this.client(this.secrets[0]);
      e = yield t.replenishToken({
        token: this.tokenSlugs[0],
        amount: 25
      }), this.checkResponse(e, "testReplenishToken"), e = yield t.replenishToken({
        token: this.tokenSlugs[2],
        amount: 0,
        units: this.replenishTokenUnits
      }), this.checkResponse(e, "testReplenishUnitToken");
    });
  }
  /**
   *
   * @returns {Promise<void>}
   */
  testFuseToken() {
    return wt(this, null, function* () {
      const e = this.tokenSlugs[4], t = Yi(), n = yield this.client(t), a = new xi("fusedTokenUnitId"), i = yield this.client(this.secrets[0]), o = yield i.fuseToken({
        bundleHash: n.getBundle(),
        tokenSlug: e,
        newTokenUnit: a,
        fusedTokenUnitIds: this.fusedTokenUnitIds
      });
      this.checkResponse(o, "testFuseToken");
      const u = (yield n.queryBalance({ token: e })).payload(), c = (yield i.queryBalance({ token: e })).payload();
      console.assert(u.tokenUnits.length, 1), console.assert(u.tokenUnits[0].id, "fusedTokenUnitId");
      const h = u.tokenUnits[0].getFusedTokenUnits();
      console.assert(h.length, this.fusedTokenUnitIds.length);
      const s = [];
      h.forEach((l) => {
        s.push(l[0]);
      }), console.assert(c.tokenUnits.length, 6);
      const d = [];
      c.tokenUnits.forEach((l) => {
        d.push(l.id);
      }), console.assert(
        d,
        ["unit_id_6", "unit_id_7", "unit_id_8", "unit_id_9", "unit_id_10", "unit_id_11"]
      );
    });
  }
  /**
   *
   */
  testClaimShadowWallet() {
    return wt(this, null, function* () {
      const e = yield this.client(this.secrets[1]), t = yield e.queryBalance({
        token: this.tokenSlugs[0]
      }), n = yield e.claimShadowWallet({
        token: this.tokenSlugs[0],
        batchId: t.payload().batchId
      });
      this.checkResponse(n, "testClaimShadowWallet");
    });
  }
  /**
   *
   * @returns {Promise<void>}
   */
  testWalletBufferTransactions() {
    return wt(this, null, function* () {
      const e = yield this.client(this.secrets[0]), t = {};
      t[this.tokenSlugs[1]] = 200 / 100, t[this.tokenSlugs[3]] = 200 / 200;
      const n = yield e.depositBufferToken({
        tokenSlug: this.tokenSlugs[5],
        amount: 200,
        tradeRates: t
      });
      this.checkResponse(n, "testWalletBufferTransactions: depositBufferToken"), yield e.withdrawBufferToken({
        tokenSlug: this.tokenSlugs[5],
        amount: 100
      }), this.checkResponse(n, "testWalletBufferTransactions: withdrawBufferToken");
    });
  }
  /**
   *
   */
  testQueryMeta() {
    return wt(this, null, function* () {
      const t = yield (yield this.client(this.secrets[0])).queryMeta({
        metaType: "metaType",
        metaId: "metaId"
      });
      this.checkResponse(t, "testQueryMeta");
    });
  }
  /**
   *
   */
  testQueryWallets() {
    return wt(this, null, function* () {
      const t = yield (yield this.client(this.secrets[0])).queryWallets({});
      this.checkResponse(t, "testQueryWallets");
    });
  }
  /**
   *
   */
  testQueryBundle() {
    return wt(this, null, function* () {
      const t = yield (yield this.client(this.secrets[0])).queryBundle({});
      this.checkResponse(t, "testQueryBundle");
    });
  }
  /**
   *
   */
  testQueryContinuId() {
    return wt(this, null, function* () {
      const e = Nn(this.secrets[0]), n = yield (yield this.client(this.secrets[0])).queryContinuId({
        bundle: e
      });
      this.checkResponse(n, "testQueryContinuId");
    });
  }
  /**
   * @throws Exception
   */
  testQueryBalance() {
    return wt(this, null, function* () {
      const t = yield (yield this.client(this.secrets[0])).queryBalance({
        token: this.tokenSlugs[0]
      });
      this.checkResponse(t, "testQueryBalance");
    });
  }
  /**
   * Get a client for each secret
   *
   * @param secret
   * @param cellSlug
   * @returns {Promise<*>}
   */
  client(e, t = "unit_test") {
    return wt(this, null, function* () {
      return this.clients[e] || (this.clients[e] = new mx({
        uri: this.graphqlUrl,
        logging: !0
      }), yield this.clients[e].requestAuthToken({
        secret: e,
        encrypt: this.encrypt,
        cellSlug: t
      }), this.clients[e].getAuthToken() || console.log("Error with authorize - get an empty response.")), this.clients[e];
    });
  }
  /**
   * Check a response
   * @param response
   * @param key
   */
  checkResponse(e, t) {
    console.log(` ############### ${t} ###############`), e instanceof rn ? (console.log(e), e.success() || this.debug(e), console.assert(e.success(), e)) : this.debug(e);
  }
  /**
   * Debug output
   * @param response
   */
  debug(e) {
    e.data && dr.get(e.data() || {}, "reason") ? console.log(e.data().reason) : console.log(e);
  }
}
export {
  Ut as Atom,
  mx as KnishIOClient,
  lo as Meta,
  mn as Molecule,
  $b as Test,
  tr as Wallet,
  b2 as base64ToHex,
  Ex as bufferToHexString,
  v2 as charsetBaseConvert,
  ho as chunkSubstr,
  Nn as generateBundleHash,
  Yi as generateSecret,
  Mx as hexStringToBuffer,
  y2 as hexToBase64,
  m2 as isHex,
  jc as randomString
};
//# sourceMappingURL=client.es.mjs.map
