"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("js-sha3"),t=require("big-integer"),s=require("@stablelib/base64"),n=require("get-random-values"),i=require("big-integer/BigInteger"),a=require("base-x"),r=require("buffer"),l=require("tweetnacl"),o=require("tweetnacl-sealedbox-js"),u=require("@stablelib/utf8"),c=require("apollo-link"),h=require("graphql-tag");require("apollo-client/util/Observable");var d=require("apollo-client"),p=require("isomorphic-fetch"),m=require("apollo-cache-inmemory"),y=require("apollo-link-http"),g=require("apollo-link-error"),b=require("laravel-echo"),k=require("socket.io-client"),_=require("graphql");function f(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var w=f(t),$=f(n),S=f(i),I=f(a),x=f(h),A=f(p),T=f(b),v=f(k);class q{static toHex(e,t){const s=(e,t)=>{const s=t?["0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F"]:["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"];return s[Math.floor(e/16)]+s[e%16]},n=Object.assign({grouping:0,rowlength:0,uppercase:!1},t||{});let i="",a=0,r=0;for(let t=0;t<e.length&&(i+=s(e[t],n.uppercase),t!==e.length-1);++t)n.grouping>0&&++a===n.grouping&&(a=0,n.rowlength>0&&++r===n.rowlength?(r=0,i+="\n"):i+=" ");return i}static toUint8Array(e){let t=e.toLowerCase().replace(/\s/g,"");t.length%2==1&&(t=`0${t}`);let s=new Uint8Array(Math.floor(t.length/2)),n=-1;for(let e=0;e<t.length;++e){let i=t[e],a=["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"].indexOf(i);if(-1===a)throw Error("unexpected character");-1===n?n=16*a:(s[Math.floor(e/2)]=n+a,n=-1)}return s}}function W(e,t){const s=Math.ceil(e.length/t),n=[];for(let i=0,a=0;i<s;++i,a+=t)n[i]=e.substr(a,t);return n}function M(e=256,t="abcdef0123456789"){let s=new Uint8Array(e);return s=$.default(s),s=s.map((e=>t.charCodeAt(e%t.length))),String.fromCharCode.apply(null,s)}function C(e,t,s,n,i){if(n=n||"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz~`!@#$%^&*()-_=+[{]}\\|;:'\",<.>/?¿¡",i=i||n,t>n.length||s>i.length)return console.warn("Strings::charsetBaseConvert() - Can't convert",e,"to base",s,"greater than symbol table length. src-table:",n.length,"dest-table:",i.length),!1;let a=w.default(0);for(let s=0;s<e.length;s++)a=a.multiply(t).add(n.indexOf(e.charAt(s)));if(a.lesser(0))return 0;let r=a.mod(s),l=i.charAt(r),o=a.divide(s);for(;!o.equals(0);)r=o.mod(s),o=o.divide(s),l=i.charAt(r)+l;return l}function U(e){return s.encode(q.toUint8Array(e))}function H(e){return q.toHex(s.decode(e),{})}function B(e){return/^[A-F0-9]+$/i.test(e)}String.prototype.trim||(String.prototype.trim=function(){return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,"")}),String.prototype.toCamelCase||(String.prototype.toCamelCase=function(){return this.toLowerCase().replace(/[^a-zA-Z0-9]+(.)/g,((e,t)=>t.toUpperCase()))}),String.prototype.toSnakeCase||(String.prototype.toSnakeCase=function(){return this.replace(/[A-Z]/g,(e=>`_${e.toLowerCase()}`))});class K{constructor({modelType:e,modelId:t,meta:s,snapshotMolecule:n=null}){this.modelType=e,this.modelId=t,this.meta=s,this.snapshotMolecule=n,this.createdAt=+new Date}static normalizeMeta(e){const t=[];for(const s in e)e.hasOwnProperty(s)&&null!==e[s]&&t.push({key:s,value:e[s].toString()});return t}static aggregateMeta(e){let t={};if(Array.isArray(e))for(let s of e)t[s.key]=s.value;else t=e;return t}}class O{constructor({position:e=null,walletAddress:t=null,isotope:s=null,token:n=null,value:i=null,batchId:a=null,metaType:r=null,metaId:l=null,meta:o=null,otsFragment:u=null,index:c=null}){this.position=e,this.walletAddress=t,this.isotope=s,this.token=n,this.value=null!==i?String(i):null,this.batchId=a,this.metaType=r,this.metaId=l,this.meta=o?K.normalizeMeta(o):[],this.index=c,this.otsFragment=u,this.createdAt=String(+new Date)}aggregatedMeta(){return K.aggregateMeta(this.meta)}static jsonToObject(e){const t=Object.assign(new O({}),JSON.parse(e)),s=Object.keys(new O({}));for(const e in t)t.hasOwnProperty(e)&&!s.includes(e)&&delete t[e];return t}static hashAtoms({atoms:t,output:s="base17"}){const n=e.shake256.create(256),i=t.length,a=O.sortAtoms(t);for(const e of a){n.update(String(i));for(const t in e)if(e.hasOwnProperty(t)){if(["batchId","pubkey","characters"].includes(t)&&null===e[t])continue;if(["otsFragment","index"].includes(t))continue;if("meta"===t){for(const s of e[t])void 0!==s.value&&null!==s.value&&(n.update(String(s.key)),n.update(String(s.value)));continue}if(["position","walletAddress","isotope"].includes(t)){n.update(null===e[t]?"":String(e[t]));continue}null!==e[t]&&n.update(null===e[t]?"":String(e[t]))}}switch(s){case"hex":return n.hex();case"array":return n.array();default:return C(n.hex(),16,17,"0123456789abcdef","0123456789abcdefg").padStart(64,"0")}}static sortAtoms(e){const t=[...e];return t.sort(((e,t)=>e.index===t.index?0:e.index<t.index?-1:1)),t}}class R{constructor(e={}){this.$options=Object.assign({characters:"GMP"},e),this.$encoder=I.default(this[this.$options.characters]||this.GMP)}encode(e){return this.$encoder.encode(r.Buffer.from(e))}decode(e){return this.$encoder.decode(e)}get GMP(){return"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuv"}get BITCOIN(){return"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}get FLICKR(){return"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}get RIPPLE(){return"rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz"}get IPFS(){return"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}}class j{constructor(e=null){this.base=new R(e)}encrypt(e,t){return this.encode(o.seal(u.encode(JSON.stringify(e)),this.decode(t)))}decrypt(e,t,s){try{return JSON.parse(u.decode(o.open(this.decode(e),this.decode(s),this.decode(t))))}catch(e){return null}}generatePrivateKey(t){const s=e.shake256.create(8*l.box.secretKeyLength);return s.update(t),this.base.encode(r.Buffer.from(s.digest()))}generatePublicKey(e){const t=l.box.keyPair.fromSecretKey(this.decode(e));return this.encode(t.publicKey)}shortHash(t){const s=e.shake256.create(64);return s.update(t),this.base.encode(r.Buffer.from(s.digest()))}decode(e){return this.base.decode(e)}encode(e){return this.base.encode(e)}}function E(t=null,s=2048){if(console.info(`Crypto::generateSecret() - Computing new secret${t?" from existing seed":""}...`),t){const n=e.shake256.create(2*s);return n.update(t),n.hex()}return M(s)}function P(t){console.info("Crypto::generateBundleHash() - Computing wallet bundle from secret...");const s=e.shake256.create(256);return s.update(t),s.hex()}function Q({molecularHash:e=null,index:t=null}){return null!==e&&null!==t?P(String(e)+String(t)):M(64)}function N(e=64){return M(e,"abcdef0123456789")}function F(e,t,s=null){return new j(s).encrypt(e,t)}function V(e,t,s,n=null){return new j(n).decrypt(e,t,s)}function L(e,t=null){return new j(t).generatePrivateKey(e)}function D(e,t=null){return new j(t).generatePublicKey(e)}function z(e,t=null){return new j(t).shortHash(e)}class J{constructor({secret:e=null,token:t="USER",position:s=null,batchId:n=null,characters:i=null}){this.token=t,this.balance=0,this.molecules={},this.key=null,this.address=null,this.privkey=null,this.pubkey=null,this.tokenUnits=[],this.bundle=e?P(e):null,this.batchId=n,this.position=s,this.characters="undefined"!==(new R)[i]?i:null,e&&(this.position=this.position||N(),this.prepareKeys(e))}static create({secretOrBundle:e,token:t,batchId:s=null,characters:n=null}){let i=J.isBundleHash(e)?null:e,a=i?P(i):e,r=i?N():null,l=new J({secret:i,token:t,position:r,batchId:s,characters:n});return l.bundle=a,l}static isBundleHash(e){return"string"==typeof e&&(64===e.length&&B(e))}static getTokenUnits(e){let t=[];return e.forEach((e=>{t.push({id:e.shift(),name:e.shift(),metas:e})})),t}hasTokenUnits(){return!!this.tokenUnits&&this.tokenUnits.length>0}tokenUnitsJson(){if(this.hasTokenUnits()){const e=[];return this.tokenUnits.forEach((t=>{e.push([t.id,t.name].concat(t.metas))})),JSON.stringify(e)}return null}splitUnits(e,t,s=null){if(0===e.length)return;let n=[],i=[];this.tokenUnits.forEach((t=>{e.includes(t.id)?n.push(t):i.push(t)})),this.tokenUnits=n,null!==s&&(s.tokenUnits=n),t.tokenUnits=i}isShadow(){return!(void 0!==this.position&&null!==this.position||void 0!==this.address&&null!==this.address)}initBatchId({sourceWallet:e,remainder:t=!1}){e.batchId&&(this.batchId=t?e.batchId:Q({}))}prepareKeys(e){null===this.key&&null===this.address&&(this.key=J.generatePrivateKey({secret:e,token:this.token,position:this.position}),this.address=J.generatePublicKey(this.key),this.getMyEncPrivateKey(),this.getMyEncPublicKey())}getMyEncPrivateKey(){return null===this.privkey&&null!==this.key&&(this.privkey=L(this.key,this.characters)),this.privkey}getMyEncPublicKey(){const e=this.getMyEncPrivateKey();return!this.pubkey&&e&&(this.pubkey=D(e,this.characters)),this.pubkey}encryptMyMessage(e){const t={};for(let s=1,n=arguments.length;s<n;s++)t[z(arguments[s],this.characters)]=F(e,arguments[s],this.characters);return t}decryptMyMessage(e){const t=this.getMyEncPublicKey();let s=e;return null!==e&&"object"==typeof e&&"[object Object]"===Object.prototype.toString.call(e)&&(s=e[z(t,this.characters)]||""),V(s,this.getMyEncPrivateKey(),t,this.characters)}encryptString({data:e,publicKeys:t}){if(e){const s=this.getMyEncPublicKey();"string"==typeof t&&(t=[t]);const n=this.encryptMyMessage(e,s,...t);return btoa(JSON.stringify(n))}}decryptString({data:e,fallbackValue:t=null}){if(e)try{const s=JSON.parse(atob(e));return this.decryptMyMessage(s)||t}catch(s){return console.error(s),t||e}}static generatePrivateKey({secret:t,token:s,position:n}){const i=S.default(t,16).add(S.default(n,16)),a=e.shake256.create(8192);return a.update(i.toString(16)),s&&a.update(s),e.shake256.create(8192).update(a.hex()).hex()}static generatePublicKey(t){const s=W(t,128),n=e.shake256.create(8192);for(const t in s){let i=s[t];for(let t=1;t<=16;t++)i=e.shake256.create(512).update(i).hex();n.update(i)}return e.shake256.create(256).update(n.hex()).hex()}}class Z extends TypeError{constructor(e=null,t=null,s=null){if(super(e,t,s),null===e)throw new this(`Unknown ${this.constructor.name}`);this.name="BaseException"}toString(){return`${this.name}: ${this.message}.\nStack:\n${this.stack}`}}class G extends Z{constructor(e="There is an atom without an index",t=null,s=null){super(e,t,s),this.name="AtomIndexException"}}class X extends Z{constructor(e="The molecule does not contain atoms",t=null,s=null){super(e,t,s),this.name="AtomsMissingException"}}class Y extends Z{constructor(e="The molecular hash does not match",t=null,s=null){super(e,t,s),this.name="MolecularHashMismatchException"}}class ee extends Z{constructor(e="The molecular hash is missing",t=null,s=null){super(e,t,s),this.name="MolecularHashMissingException"}}class te extends Z{constructor(e="OTS malformed",t=null,s=null){super(e,t,s),this.name="SignatureMalformedException"}}class se extends Z{constructor(e="One-time signature (OTS) does not match!",t=null,s=null){super(e,t,s),this.name="SignatureMismatchException"}}class ne extends Z{constructor(e="Insufficient balance to make transfer",t=null,s=null){super(e,t,s),this.name="TransferBalanceException"}}class ie extends Z{constructor(e="Token transfer atoms are malformed",t=null,s=null){super(e,t,s),this.name="TransferMalformedException"}}class ae extends Z{constructor(e="Token slugs for wallets in transfer do not match!",t=null,s=null){super(e,t,s),this.name="TransferMismatchedException"}}class re extends Z{constructor(e="Invalid remainder provided",t=null,s=null){super(e,t,s),this.name="TransferRemainderException"}}class le extends Z{constructor(e="Sender and recipient(s) cannot be the same",t=null,s=null){super(e,t,s),this.name="TransferToSelfException"}}class oe extends Z{constructor(e="Token transfer atoms are unbalanced",t=null,s=null){super(e,t,s),this.name="TransferUnbalancedException"}}class ue extends Z{constructor(e="Empty meta data.",t=null,s=null){super(e,t,s),this.name="MetaMissingException"}}class ce extends Z{constructor(e="Wrong type of token for this isotope",t=null,s=null){super(e,t,s),this.name="WrongTokenTypeException"}}class he extends Z{constructor(e="Incorrect BatchId",t=null,s=null){super(e,t,s),this.name="BatchIdException"}}class de{static continuId(e){de.missing(e);if("USER"===e.atoms[0].token&&de.isotopeFilter("I",e.atoms).length<1)throw new X("Check::continuId() - Molecule is missing required ContinuID Atom!");return!0}static batchId(e){if(e.atoms.length>0){const t=e.atoms[0];if("V"===t.isotope&&null!==t.batchId){const s=de.isotopeFilter("V",e.atoms),n=s[s.length-1];if(t.batchId!==n.batchId)throw new he;for(const e of s)if(null===e.batchId)throw new he}return!0}throw new he}static isotopeI(e){de.missing(e);for(let t of de.isotopeFilter("I",e.atoms)){if("USER"!==t.token)throw new ce(`Check::isotopeI() - "${t.token}" is not a valid Token slug for "${t.isotope}" isotope Atoms!`);if(0===t.index)throw new G(`Check::isotopeI() - Isotope "${t.isotope}" Atoms must have a non-zero index!`)}return!0}static isotopeU(e){de.missing(e);for(let t of de.isotopeFilter("U",e.atoms)){if("AUTH"!==t.token)throw new ce(`Check::isotopeU() - "${t.token}" is not a valid Token slug for "${t.isotope}" isotope Atoms!`);if(0!==t.index)throw new G(`Check::isotopeU() - Isotope "${t.isotope}" Atoms must have an index equal to 0!`)}return!0}static isotopeM(e){de.missing(e);for(let t of de.isotopeFilter("M",e.atoms)){if(t.meta.length<1)throw new ue;if("USER"!==t.token)throw new ce(`Check::isotopeM() - "${t.token}" is not a valid Token slug for "${t.isotope}" isotope Atoms!`)}return!0}static isotopeC(e){de.missing(e);for(let t of de.isotopeFilter("C",e.atoms)){if("USER"!==t.token)throw new ce(`Check::isotopeC() - "${t.token}" is not a valid Token slug for "${t.isotope}" isotope Atoms!`);if(0!==t.index)throw new G(`Check::isotopeC() - Isotope "${t.isotope}" Atoms must have an index equal to 0!`)}return!0}static isotopeT(e){de.missing(e);for(let t of de.isotopeFilter("T",e.atoms)){const e=t.aggregatedMeta();if("wallet"===String(t.metaType).toLowerCase())for(let t of["position","bundle"])if(!e.hasOwnProperty(t)||!Boolean(e[t]))throw new ue(`Check::isotopeT() - Required meta field "${t}" is missing!`);for(let t of["token"])if(!e.hasOwnProperty(t)||!Boolean(e[t]))throw new ue(`Check::isotopeT() - Required meta field "${t}" is missing!`);if("USER"!==t.token)throw new ce(`Check::isotopeT() - "${t.token}" is not a valid Token slug for "${t.isotope}" isotope Atoms!`);if(0!==t.index)throw new G(`Check::isotopeT() - Isotope "${t.isotope}" Atoms must have an index equal to 0!`)}return!0}static isotopeR(e){de.missing(e);for(let t of de.isotopeFilter("R",e.atoms)){const e=t.aggregatedMeta();for(let t of["callback","conditions","rule"])if(!e.hasOwnProperty(t))throw new ue(`Check::isotopeR() - Required meta field "${t}" is missing!`);try{const t=JSON.parse(e.conditions);for(let e of t){const t=Object.keys(e),s=t.filter((function(e){return-1!==["key","value","comparison"].indexOf(e)})),n=t.filter((function(e){return-1!==["managedBy"].indexOf(e)}));if(s.length<3&&n.length<1)throw new ue("Check::isotopeR() - Required condition field is missing!")}}catch(e){throw new ue("Check::isotopeR() - Condition is formatted incorrectly!")}}return!0}static isotopeV(e,t=null){de.missing(e);const s=de.isotopeFilter("V",e.atoms);if(0===s.length)return!0;const n=e.atoms[0];if("V"===n.isotope&&2===s.length){const e=s[s.length-1];if(n.token!==e.token)throw new ae;if(e.value<0)throw new ie;return!0}let i=0,a=0;for(let t in e.atoms)if(e.atoms.hasOwnProperty(t)){const s=e.atoms[t];if("V"!==s.isotope)continue;if(a=1*s.value,Number.isNaN(a))throw new TypeError('Invalid isotope "V" values');if(s.token!==n.token)throw new ae;if(t>0){if(a<0)throw new ie;if(s.walletAddress===n.walletAddress)throw new le}i+=a}if(i!==a)throw new oe;if(t){if(a=1*n.value,Number.isNaN(a))throw new TypeError('Invalid isotope "V" values');const e=1*t.balance+1*a;if(e<0)throw new ne;if(e!==i)throw new re}else if(0!==a)throw new re;return!0}static molecularHash(e){if(de.missing(e),e.molecularHash!==O.hashAtoms({atoms:e.atoms}))throw new Y;return!0}static ots(t){de.missing(t);const s=t.atoms[0].walletAddress,n=de.normalizedHash(t.molecularHash);let i=t.atoms.map((e=>e.otsFragment)).reduce(((e,t)=>e+t));if(2048!==i.length&&(i=H(i),2048!==i.length))throw new te;const a=W(i,128);let r="";for(const t in a){let s=a[t];for(let i=0,a=8+n[t];i<a;i++)s=e.shake256.create(512).update(s).hex();r+=s}const l=e.shake256.create(8192).update(r).hex();if(e.shake256.create(256).update(l).hex()!==s)throw new se;return!0}static index(e){de.missing(e);for(let t of e.atoms)if(null===t.index)throw new G;return!0}static isotopeFilter(e,t){return(t=t||[]).filter((t=>e===t.isotope))}static normalizedHash(e){return de.normalize(de.enumerate(e))}static enumerate(e){const t={0:-8,1:-7,2:-6,3:-5,4:-4,5:-3,6:-2,7:-1,8:0,9:1,a:2,b:3,c:4,d:5,e:6,f:7,g:8},s=[],n=e.toLowerCase().split("");for(let e=0,i=n.length;e<i;++e){const i=n[e];void 0!==t[i]&&(s[e]=t[i])}return s}static normalize(e){let t=e.reduce(((e,t)=>e+t));const s=t<0;for(;t<0||t>0;)for(const n of Object.keys(e)){if((s?e[n]<8:e[n]>-8)&&(s?(++e[n],++t):(--e[n],--t),0===t))break}return e}static missing(e){if(null===e.molecularHash)throw new ee;if(1>e.atoms.length)throw new X}}class pe extends Z{constructor(e="Insufficient balance for requested transfer",t=null,s=null){super(e,t,s),this.name="BalanceInsufficientException"}}class me extends Z{constructor(e="Amount cannot be negative!",t=null,s=null){super(e,t,s),this.name="NegativeAmountException"}}const ye=require("lodash.clonedeep");class ge{constructor(e=null){this.cellSlugOrigin=this.cellSlug=e}get cellSlugDelimiter(){return"."}cellSlugBase(){return(this.cellSlug||"").split(this.cellSlugDelimiter)[0]}toJSON(){let e=ye(this);for(let t of["remainderWallet","secret","sourceWallet","cellSlugOrigin"])e.hasOwnProperty(t)&&delete e[t];return e}check(e=null){return ge.verify({molecule:this,sourceWallet:e})}static verify({molecule:e,sourceWallet:t=null}){return de.molecularHash(e)&&de.ots(e)&&de.index(e)&&de.batchId(e)&&de.continuId(e)&&de.isotopeM(e)&&de.isotopeT(e)&&de.isotopeC(e)&&de.isotopeU(e)&&de.isotopeI(e)&&de.isotopeR(e)&&de.isotopeV(e,t)}static jsonToObject(e){const t={...new this,...JSON.parse(e)},s=Object.keys(new this);if(!Array.isArray(t.atoms))throw new X;for(const e in Object.keys(t.atoms)){t.atoms[e]=O.jsonToObject(JSON.stringify(t.atoms[e]));for(const s of["position","walletAddress","isotope"])if(void 0===t.atoms[e][s]||null===t.atoms[e][s])throw new X("MolecularStructure::jsonToObject() - Required Atom properties are missing!")}for(const e in t)t.hasOwnProperty(e)&&!s.includes(e)&&delete t[e];return t.atoms=O.sortAtoms(t.atoms),t}}class be extends ge{constructor({secret:e,sourceWallet:t=null,remainderWallet:s=null,cellSlug:n=null}){super(n),this.secret=e,this.sourceWallet=t,this.atoms=[],(s||t)&&(this.remainderWallet=s||J.create({secretOrBundle:e,token:t.token,batchId:t.batchId,characters:t.characters})),this.clear()}static generateNextAtomIndex(e){const t=e.length-1;return t>-1?e[t].index+1:0}continuIdMetaType(){return"walletBundle"}fill(e){for(let t in Object.keys(e))this[t]=e[t]}addAtom(e){return this.molecularHash=null,this.atoms.push(e),this.atoms=O.sortAtoms(this.atoms),this}finalMetas(e=null,t=null){return e=e||{},(t=t||this.sourceWallet).hasTokenUnits()&&(e.tokenUnits=t.tokenUnitsJson()),e.pubkey=t.pubkey,e.characters=t.characters,e}contextMetas(e=null,t=null){return e=e||{}}replenishTokens({amount:e,token:t,metas:s}){s.action="add";for(let e of["address","position","batchId"])if(void 0===s[e])throw new ue(`Molecule::replenishTokens() - Missing ${e} in meta!`);return this.molecularHash=null,this.atoms.push(new O({position:this.sourceWallet.position,walletAddress:this.sourceWallet.address,isotope:"C",token:this.sourceWallet.token,amount:e,batchId:this.sourceWallet.batchId,metaType:"token",metaId:t,meta:this.finalMetas(s),index:this.generateIndex()})),this.addUserRemainderAtom(this.remainderWallet),this.atoms=O.sortAtoms(this.atoms),this}addUserRemainderAtom(e){return this.molecularHash=null,this.atoms.push(new O({position:e.position,walletAddress:e.address,isotope:"I",token:e.token,metaType:"walletBundle",metaId:e.bundle,meta:this.finalMetas({},e),index:this.generateIndex()})),this.atoms=O.sortAtoms(this.atoms),this}burnToken({amount:e,walletBundle:t=null}){if(e<0)throw new me("Molecule::burnToken() - Amount to burn must be positive!");if(this.sourceWallet.balance-e<0)throw new pe;return this.molecularHash=null,this.atoms.push(new O({position:this.sourceWallet.position,walletAddress:this.sourceWallet.address,isotope:"V",token:this.sourceWallet.token,value:-e,batchId:this.sourceWallet.batchId,meta:this.finalMetas({}),index:this.generateIndex()})),this.atoms.push(new O({position:this.remainderWallet.position,walletAddress:this.remainderWallet.address,isotope:"V",token:this.sourceWallet.token,value:this.sourceWallet.balance-e,batchId:this.remainderWallet.batchId,metaType:t?"walletBundle":null,metaId:t,meta:this.finalMetas({},this.remainderWallet),index:this.generateIndex()})),this.atoms=O.sortAtoms(this.atoms),this}initValue({recipientWallet:e,amount:t}){if(this.sourceWallet.balance-t<0)throw new pe;return this.molecularHash=null,this.atoms.push(new O({position:this.sourceWallet.position,walletAddress:this.sourceWallet.address,isotope:"V",token:this.sourceWallet.token,value:-t,batchId:this.sourceWallet.batchId,meta:this.finalMetas({}),index:this.generateIndex()})),this.atoms.push(new O({position:e.position,walletAddress:e.address,isotope:"V",token:this.sourceWallet.token,value:t,batchId:e.batchId,metaType:"walletBundle",metaId:e.bundle,meta:this.finalMetas({},e),index:this.generateIndex()})),this.atoms.push(new O({position:this.remainderWallet.position,walletAddress:this.remainderWallet.address,isotope:"V",token:this.sourceWallet.token,value:this.sourceWallet.balance-t,batchId:this.remainderWallet.batchId,metaType:"walletBundle",metaId:this.sourceWallet.bundle,meta:this.finalMetas({},this.remainderWallet),index:this.generateIndex()})),this.atoms=O.sortAtoms(this.atoms),this}initWalletCreation(e){this.molecularHash=null;const t={address:e.address,token:e.token,bundle:e.bundle,position:e.position,amount:0,batchId:e.batchId,pubkey:e.pubkey,characters:e.characters};return this.atoms.push(new O({position:this.sourceWallet.position,walletAddress:this.sourceWallet.address,isotope:"C",token:this.sourceWallet.token,batchId:this.sourceWallet.batchId,metaType:"wallet",metaId:e.address,meta:this.finalMetas(this.contextMetas(t),e),index:this.generateIndex()})),this.addUserRemainderAtom(this.remainderWallet),this.atoms=O.sortAtoms(this.atoms),this}initTokenCreation({recipientWallet:e,amount:t,meta:s}){this.molecularHash=null;for(const t of["walletAddress","walletPosition","walletPubkey","walletCharacters"])s[t]||(s[t]=e[t.toLowerCase().substr(6)]);return this.atoms.push(new O({position:this.sourceWallet.position,walletAddress:this.sourceWallet.address,isotope:"C",token:this.sourceWallet.token,value:t,batchId:e.batchId,metaType:"token",metaId:e.token,meta:this.finalMetas(this.contextMetas(s),this.sourceWallet),index:this.generateIndex()})),this.addUserRemainderAtom(this.remainderWallet),this.atoms=O.sortAtoms(this.atoms),this}createRule({metaType:e,metaId:t,meta:s}){for(let e of["conditions","callback","rule"]){if(void 0===s[e])throw new ue(`Molecule::createRule() - Value for required meta key ${e} in missing!`);for(let t of["[object Object]","[object Array]"])Object.prototype.toString.call(s[e])===t&&(s[e]=JSON.stringify(s[e]))}return this.addAtom(new O({position:this.sourceWallet.position,walletAddress:this.sourceWallet.address,isotope:"R",token:this.sourceWallet.token,metaType:e,metaId:t,meta:this.finalMetas(s,this.sourceWallet),index:this.generateIndex()})),this.addUserRemainderAtom(this.remainderWallet),this.atoms=O.sortAtoms(this.atoms),this}initShadowWalletClaim({token:e,wallet:t}){this.molecularHash=null;let s={tokenSlug:e,walletAddress:t.address,walletPosition:t.position,batchId:t.batchId};return this.atoms.push(new O({position:this.sourceWallet.position,walletAddress:this.sourceWallet.address,isotope:"C",token:this.sourceWallet.token,metaType:"wallet",metaId:t.address,meta:this.finalMetas(this.contextMetas(s)),index:this.generateIndex()})),this.addUserRemainderAtom(this.remainderWallet),this.atoms=O.sortAtoms(this.atoms),this}initIdentifierCreation({type:e,contact:t,code:s}){this.molecularHash=null;const n={code:s,hash:P(t.trim())};return this.atoms.push(new O({position:this.sourceWallet.position,walletAddress:this.sourceWallet.address,isotope:"C",token:this.sourceWallet.token,metaType:"identifier",metaId:e,meta:this.finalMetas(n,this.sourceWallet),index:this.generateIndex()})),this.addUserRemainderAtom(this.remainderWallet),this.atoms=O.sortAtoms(this.atoms),this}initMeta({meta:e,metaType:t,metaId:s}){return this.molecularHash=null,this.atoms.push(new O({position:this.sourceWallet.position,walletAddress:this.sourceWallet.address,isotope:"M",token:this.sourceWallet.token,batchId:this.sourceWallet.batchId,metaType:t,metaId:s,meta:this.finalMetas(e,this.sourceWallet),index:this.generateIndex()})),this.addUserRemainderAtom(this.remainderWallet),this.atoms=O.sortAtoms(this.atoms),this}initTokenRequest({token:e,amount:t,metaType:s,metaId:n,meta:i={},batchId:a=null}){return this.molecularHash=null,i.token=e,this.atoms.push(new O({position:this.sourceWallet.position,walletAddress:this.sourceWallet.address,isotope:"T",token:this.sourceWallet.token,value:t,batchId:a,metaType:s,metaId:n,meta:this.finalMetas(i),index:this.generateIndex()})),this.addUserRemainderAtom(this.remainderWallet),this.atoms=O.sortAtoms(this.atoms),this}initAuthorization({meta:e}){return this.molecularHash=null,this.atoms.push(new O({position:this.sourceWallet.position,walletAddress:this.sourceWallet.address,isotope:"U",token:this.sourceWallet.token,batchId:this.sourceWallet.batchId,meta:this.finalMetas(e),index:this.generateIndex()})),this.atoms=O.sortAtoms(this.atoms),this}clear(){return this.molecularHash=null,this.bundle=null,this.status=null,this.createdAt=String(+new Date),this.atoms=[],this}sign({anonymous:t=!1,compressed:s=!0}){if(0===this.atoms.length||0!==this.atoms.filter((e=>!(e instanceof O))).length)throw new X;t||(this.bundle=P(this.secret)),this.molecularHash=O.hashAtoms({atoms:this.atoms});const n=this.atoms[0],i=W(J.generatePrivateKey({secret:this.secret,token:n.token,position:n.position}),128),a=de.normalizedHash(this.molecularHash);let r="";for(const t in i){let s=i[t];for(let n=0,i=8-a[t];n<i;n++)s=e.shake256.create(512).update(s).hex();r+=s}s&&(r=U(r));const l=W(r,Math.ceil(r.length/this.atoms.length));let o=null;for(let e=0,t=l.length;e<t;e++)this.atoms[e].otsFragment=l[e],o=this.atoms[e].position;return o}generateIndex(){return be.generateNextAtomIndex(this.atoms)}}class ke{static __init(e,t){this.arr=[],this.key=null,this.arr=String(t).split("."),this.key=this.arr.shift();const s=Number(this.key);Number.isInteger(s)&&(this.key=s),this.__nextKey=this.arr.length,this.__next=this.__tic(e)}static __tic(e){return!!(Array.isArray(e)||e instanceof Object)&&void 0!==e[this.key]}static has(e,t){return this.__init(e,t),!!this.__next&&(0===this.__nextKey||this.has(e[this.key],this.arr.join(".")))}static get(e,t,s=null){return this.__init(e,t),this.__next?0===this.__nextKey?e[this.key]:this.get(e[this.key],this.arr.join("."),s):s}}class _e{static val(e){return Math.abs(1e18*e)<1?0:e}static cmp(e,t,s=!1){const n=1e18*_e.val(e),i=1e18*_e.val(t);return Math.abs(n-i)<1?0:n>i?1:-1}static equal(e,t){return 0===_e.cmp(e,t)}}class fe{static create(e,t){let s=new fe(e);return s.setWallet(t),s}static restore(e){let t=new Wallet({secret:e.wallet.secret,token:"AUTH",position:e.wallet.position,characters:e.wallet.characters});return fe.create({token:e.token,expiresAt:e.expiresAt,time:e.time,pubkey:e.pubkey,encrypt:e.encrypt},t)}constructor({token:e,expiresAt:t,time:s,pubkey:n,encrypt:i}){this.$__token=e,this.$__expiresAt=t,this.$__time=s,this.$__pubkey=n,this.$__encrypt=i}setWallet(e){this.$__wallet=e}getAuthData(){return{token:this.$__token,pubkey:this.$__pubkey,wallet:this.$__wallet}}getSnapshot(){return{token:this.$__token,expiresAt:this.$__expiresAt,time:this.$__time,pubkey:this.$__pubkey,encrypt:this.$__encrypt,wallet:{secret:this.$__wallet.secret,position:this.$__wallet.position,characters:this.$__wallet.characters}}}isExpired(){return!this.$__expiresAt||1e3*this.$__expiresAt<=Date.now()}}class we extends Z{constructor(e="Code exception",t=null,s=null){super(e,t,s),this.name="CodeException"}}class $e extends Z{constructor(e="GraphQL did not provide a valid response.",t=null,s=null){super(e,t,s),this.name="InvalidResponseException"}}class Se extends Z{constructor(e="Authorization token missing or invalid.",t=null,s=null){super(e,t,s),this.name="UnauthenticatedException"}}class Ie{constructor({query:e,json:t,dataKey:s=null}){if(this.dataKey=s,this.errorKey="exception",this.$__payload=null,this.$__query=e,this.$__originResponse=t,this.$__response=t,void 0===this.$__response||null===this.$__response)throw new $e;if(ke.has(this.$__response,this.errorKey)){const e=ke.get(this.$__response,this.errorKey);if(String(e).includes("Unauthenticated"))throw new Se;throw new $e}this.init()}data(){if(!this.dataKey)return this.response();if(!ke.has(this.response(),this.dataKey))throw new $e;return ke.get(this.response(),this.dataKey)}response(){return this.$__response}payload(){return null}query(){return this.$__query}status(){return null}init(){return null}}class xe{constructor(e){this.client=e,this.$__variables=null,this.$__query=null}async createResponseRaw(e){return this.createResponse(e)}createResponse(e){return new Ie({query:this,json:e})}createQuery({variables:e=null}){if(this.$__variables=this.compiledVariables(e),!this.uri())throw new we("Query::createQuery() - Node URI was not initialized for this client instance!");if(null===this.$__query)throw new we("Query::createQuery() - GraphQL subscription was not initialized!");return{query:this.$__query,variables:this.variables()}}async execute({variables:e=null}){this.$__request=this.createQuery({variables:e});let t=await this.client.query(this.$__request);return this.$__response=await this.createResponseRaw(t),this.$__response}compiledVariables(e=null){return e||{}}uri(){return this.client.getUri()}variables(){return this.$__variables}}class Ae extends Ie{constructor({query:e,json:t}){super({query:e,json:t}),this.dataKey="data.ContinuId",this.init()}payload(){let e=null;const t=this.data();return t&&(e=new J({secret:null,token:t.tokenSlug}),e.address=t.address,e.position=t.position,e.bundle=t.bundleHash,e.batchId=t.batchId,e.characters=t.characters,e.pubkey=t.pubkey,e.balance=1*t.amount),e}}class Te extends xe{constructor(e){super(e),this.$__query=x.default`query ($bundle: String!) {
      ContinuId(bundle: $bundle) {
        address,
        bundleHash,
        tokenSlug,
        position,
        batchId,
        characters,
        pubkey,
        amount,
        createdAt
      }
    }`}createResponse(e){return new Ae({query:this,json:e})}}class ve extends Ie{constructor({query:e,json:t}){super({query:e,json:t}),this.dataKey="data.WalletBundle",this.init()}payload(){const e=this.data();if(!e||0===e.length)return null;const t={};return e.forEach((e=>{e.metas=K.aggregateMeta(e.metas),t[e.bundleHash]=e})),t}}class qe extends xe{constructor(e){super(e),this.$__query=x.default`query( $bundleHash: String, $bundleHashes: [ String! ], $key: String, $keys: [ String! ], $value: String, $values: [ String! ], $keys_values: [ MetaInput ], $latest: Boolean, $limit: Int, $order: String ) {
      WalletBundle( bundleHash: $bundleHash, bundleHashes: $bundleHashes, key: $key, keys: $keys, value: $value, values: $values, keys_values: $keys_values, latest: $latest, limit: $limit, order: $order ) {
        bundleHash,
        metas {
          molecularHash,
          position,
          key,
          value,
          createdAt
        },
        createdAt
      }
    }`}createResponse(e){return new ve({query:this,json:e})}static createVariables({bundleHash:e=null,key:t=null,value:s=null,latest:n=!0}){const i={latest:n};return e&&(i["string"==typeof e?"bundleHash":"bundleHashes"]=e),t&&(i["string"==typeof t?"key":"keys"]=t),s&&(i["string"==typeof s?"value":"values"]=s),i}}class We extends Ie{constructor({query:e,json:t}){super({query:e,json:t}),this.dataKey="data.Wallet",this.init()}static toClientWallet({data:e,secret:t=null}){let s;return null===e.position||void 0===e.position?s=J.create({secretOrBundle:e.bundleHash,token:e.tokenSlug,batchId:e.batchId,characters:e.characters}):(s=new J({secret:t,token:e.tokenSlug,position:e.position,batchId:e.batchId,characters:e.characters}),s.address=e.address,s.bundle=e.bundleHash),e.token&&(s.tokenName=e.token.name,s.tokenAmount=e.token.amount,s.tokenSupply=e.token.supply,s.tokenFungibility=e.token.fungibility),s.tokenUnits=e.tokenUnits,s.molecules=e.molecules,s.balance=Number(e.amount),s.pubkey=e.pubkey,s.createdAt=e.createdAt,s}getWallets(e=null){const t=this.data();if(!t)return null;const s=[];for(let n of t)s.push(We.toClientWallet({data:n,secret:e}));return s}payload(){const e=this.data();if(!e)return null;const t=[];for(let s of e)t.push(We.toClientWallet({data:s}));return t}}class Me extends xe{constructor(e){super(e),this.$__query=x.default`query( $address: String, $bundleHash: String, $token: String, $position: String, $unspent: Boolean ) {
      Wallet( address: $address, bundleHash: $bundleHash, token: $token, position: $position, unspent: $unspent ) {
        address,
        bundleHash,
        token {
          name,
          amount,
          fungibility,
          supply
        },
        molecules {
          molecularHash,
          createdAt
        }
        tokenSlug,
        batchId,
        position,
        amount,
        characters,
        pubkey,
        createdAt,
        tokenUnits {
          id,
          name,
          metas
        }
      }
    }`}createResponse(e){return new We({query:this,json:e})}}class Ce extends Ie{constructor({query:e,json:t}){super({query:e,json:t}),this.dataKey="data.Balance",this.init()}payload(){const e=this.data();return e&&e.bundleHash&&e.tokenSlug?We.toClientWallet({data:e}):null}}class Ue extends xe{constructor(e){super(e),this.$__query=x.default`query( $address: String, $bundleHash: String, $token: String, $position: String ) {
      Balance( address: $address, bundleHash: $bundleHash, token: $token, position: $position ) {
        address,
        bundleHash,
        tokenSlug,
        batchId,
        position,
        amount,
        characters,
        pubkey,
        createdAt,
        tokenUnits {
          id,
          name,
          metas
        }
      }
    }`}createResponse(e){return new Ce({query:this,json:e})}}class He extends Ie{constructor({query:e,json:t}){super({query:e,json:t}),this.dataKey="data.MetaType",this.init()}payload(){const e=this.data();if(!e||0===e.length)return null;let t={instances:{},instanceCount:{},paginatorInfo:{}},s=e.pop();return s.instances&&(t.instances=s.instances),s.instanceCount&&(t.instanceCount=s.instanceCount),s.paginatorInfo&&(t.paginatorInfo=s.paginatorInfo),t}}class Be extends xe{constructor(e){super(e),this.$__query=x.default`query( $metaType: String, $metaTypes: [ String! ], $metaId: String, $metaIds: [ String! ], $key: String, $keys: [ String! ], $value: String, $values: [ String! ], $count: String, $latest: Boolean, $filter: [ MetaFilter! ], $latestMetas: Boolean, $queryArgs: QueryArgs, $countBy: String ) {
      MetaType( metaType: $metaType, metaTypes: $metaTypes, metaId: $metaId, metaIds: $metaIds, key: $key, keys: $keys, value: $value, values: $values, count: $count, filter: $filter, latestMetas: $latestMetas, queryArgs: $queryArgs, countBy: $countBy ) {
        metaType,
        instanceCount {
          key,
          value
        },
        instances {
          metaType,
          metaId,
          createdAt,
          metas(latest:$latest) {
            molecularHash,
            position,
            key,
            value,
            createdAt
          }
        },
        paginatorInfo {
          currentPage,
          total
        }
      }
    }`}createResponse(e){return new He({query:this,json:e})}static createVariables({metaType:e=null,metaId:t=null,key:s=null,value:n=null,latest:i=null,latestMetas:a=!0,filter:r=null,queryArgs:l=null,count:o=null,countBy:u=null}){const c={};return e&&(c["string"==typeof e?"metaType":"metaTypes"]=e),t&&(c["string"==typeof t?"metaId":"metaIds"]=t),s&&(c["string"==typeof s?"key":"keys"]=s),n&&(c["string"==typeof n?"value":"values"]=n),i&&(c.latest=!!i),a&&(c.latestMetas=!!a),r&&(c.filter=r),l&&(void 0!==l.limit&&0!==l.limit||(l.limit="*"),c.queryArgs=l),o&&(c.count=o),u&&(c.countBy=u),c}}class Ke extends xe{constructor(e){super(e),this.$__query=x.default`query( $batchId: String ) {
      Batch( batchId: $batchId ) {
        ${Ke.getFields()},
        children {
          ${Ke.getFields()}
        }
      }
    }`}static getFields(){return"batchId,\n              molecularHash,\n              type,\n              status,\n              createdAt,\n              wallet {\n                  address,\n                  bundleHash,\n                  amount,\n                  tokenSlug,\n                  token {\n                      name,\n                      amount\n                  },\n                  tokenUnits {\n                      id,\n                      name,\n                      metas\n                  }\n              },\n              fromWallet {\n                  address,\n                  bundleHash,\n                  amount,\n                  batchId\n              },\n              toWallet {\n                  address,\n                  bundleHash,\n                  amount,\n                  batchId\n              },\n              sourceTokenUnits {\n                  id,\n                  name,\n                  metas\n              },\n              transferTokenUnits {\n                  id,\n                  name,\n                  metas\n              },\n              metas {\n                  key,\n                  value,\n              },\n              throughMetas {\n                  key,\n                  value\n              }"}createResponse(e){let t=new Ie({query:this,json:e});return t.dataKey="data.Batch",t}}class Oe extends xe{constructor(e){super(e),this.$__query=x.default`query( $batchId: String ) {
      BatchHistory( batchId: $batchId ) {
        ${Ke.getFields()}
      }
    }`}createResponse(e){let t=new Ie({query:this,json:e});return t.dataKey="data.BatchHistory",t}}class Re extends Ie{constructor({query:e,json:t}){super({query:e,json:t}),this.dataKey="data.ProposeMolecule",this.$__clientMolecule=e.molecule(),this.init()}init(){const e=ke.get(this.data(),"payload");try{this.$__payload="[object String]"===Object.prototype.toString.call(e)?JSON.parse(e):e}catch(e){this.$__payload=null}}clientMolecule(){return this.$__clientMolecule}molecule(){const e=this.data();if(!e)return null;const t=new ge;return t.molecularHash=ke.get(e,"molecularHash"),t.status=ke.get(e,"status"),t.createdAt=ke.get(e,"createdAt"),t}success(){return"accepted"===this.status()}status(){return ke.get(this.data(),"status","rejected")}reason(){return ke.get(this.data(),"reason","Invalid response from server")}payload(){return this.$__payload}}class je extends xe{constructor(e){super(e)}createQuery({variables:e=null}){const t=super.createQuery({variables:e});return t.mutation=t.query,delete t.query,t}async execute({variables:e=null}){this.$__request=this.createQuery({variables:e});let t=await this.client.mutate(this.$__request);return this.$__response=await this.createResponseRaw(t),this.$__response}}class Ee extends je{constructor(e,t=null){super(e),this.$__molecule=t,this.$__remainderWallet=null,this.$__query=x.default`mutation( $molecule: MoleculeInput! ) {
      ProposeMolecule( molecule: $molecule ) {
        molecularHash,
        height,
        depth,
        status,
        reason,
        payload,
        createdAt,
        receivedAt,
        processedAt,
        broadcastedAt,
      }
    }`}compiledVariables(e){return{...super.compiledVariables(e),molecule:this.molecule()}}createResponse(e){return new Re({query:this,json:e})}async execute({variables:e=null}){return(e=e||{}).molecule=this.molecule(),super.execute({variables:e})}remainderWallet(){return this.$__remainderWallet}molecule(){return this.$__molecule}}class Pe extends Re{payloadKey(e){if(!ke.has(this.payload(),e))throw new $e(`ResponseRequestAuthorization::payloadKey() - '${e}' key was not found in the payload!`);return ke.get(this.payload(),e)}token(){return this.payloadKey("token")}time(){return this.payloadKey("time")}encrypt(){return this.payloadKey("encrypt")}pubKey(){return this.payloadKey("key")}}class Qe extends Ee{fillMolecule({meta:e}){this.$__molecule.initAuthorization({meta:e}),this.$__molecule.sign({}),this.$__molecule.check()}createResponse(e){return new Pe({query:this,json:e})}}class Ne extends Re{}class Fe extends Ee{fillMolecule({recipientWallet:e,amount:t,meta:s=null}){this.$__molecule.initTokenCreation({recipientWallet:e,amount:t,meta:s||{}}),this.$__molecule.sign({}),this.$__molecule.check()}createResponse(e){return new Ne({query:this,json:e})}}class Ve extends Re{}class Le extends Ee{fillMolecule({token:e,amount:t,metaType:s,metaId:n,meta:i=null,batchId:a=null}){this.$__molecule.initTokenRequest({token:e,amount:t,metaType:s,metaId:n,meta:i||{},batchId:a}),this.$__molecule.sign({}),this.$__molecule.check()}createResponse(e){return new Ve({query:this,json:e})}}class De extends Re{payload(){const e={reason:null,status:null},t=this.data();return e.reason=void 0===t.reason?"Invalid response from server":t.reason,e.status=void 0===t.status?"rejected":t.status,e}}class ze extends Ee{fillMolecule({recipientWallet:e,amount:t}){this.$__molecule.initValue({recipientWallet:e,amount:t}),this.$__molecule.sign({}),this.$__molecule.check(this.$__molecule.sourceWallet)}createResponse(e){return new De({query:this,json:e})}}class Je extends Re{}class Ze extends Ee{fillMolecule({type:e,contact:t,code:s}){this.$__molecule.initIdentifierCreation({type:e,contact:t,code:s}),this.$__molecule.sign({}),this.$__molecule.check()}createResponse(e){return new Je({query:this,json:e})}}class Ge extends Re{}class Xe extends Ee{fillMolecule({token:e,batchId:t=null}){let s=J.create({secretOrBundle:this.$__molecule.secret,token:e,batchId:t});this.$__molecule.initShadowWalletClaim({token:e,wallet:s}),this.$__molecule.sign({}),this.$__molecule.check()}createResponse(e){return new Ge({query:this,json:e})}}class Ye extends Re{}class et extends Ee{fillMolecule({metaType:e,metaId:t,meta:s}){this.$__molecule.initMeta({meta:s,metaType:e,metaId:t}),this.$__molecule.sign({}),this.$__molecule.check()}createResponse(e){return new Ye({query:this,json:e})}}class tt extends Re{}class st extends Ee{fillMolecule(e){this.$__molecule.initWalletCreation(e),this.$__molecule.sign({}),this.$__molecule.check()}createResponse(e){return new tt({query:this,json:e})}}class nt extends Ie{constructor({query:e,json:t}){super({query:e,json:t}),this.dataKey="data.AccessToken",this.init()}reason(){return"Invalid response from server"}success(){return null!==this.payload()}payload(){return this.data()}payloadKey(e){if(!ke.has(this.payload(),e))throw new $e(`ResponseAuthorizationGuest::payloadKey() - '${e}' key is not found in the payload!`);return ke.get(this.payload(),e)}token(){return this.payloadKey("token")}time(){return this.payloadKey("time")}pubKey(){return this.payloadKey("key")}encrypt(){return this.payloadKey("encrypt")}}class it extends je{constructor(e){super(e),this.$__query=x.default`mutation( $cellSlug: String, $pubkey: String, $encrypt: Boolean ) {
      AccessToken( cellSlug: $cellSlug, pubkey: $pubkey, encrypt: $encrypt ) {
        token,
        time,
        key,
        expiresAt,
        encrypt
      }
    }`}createResponse(e){return new nt({query:this,json:e})}}class at extends Z{constructor(e="The shadow wallet does not exist",t=null,s=null){super(e,t,s),this.name="WalletShadowException"}}class rt extends Z{constructor(e="Stackable tokens with unit IDs cannot have decimal places!",t=null,s=null){super(e,t,s),this.name="StackableUnitDecimalsException"}}class lt extends Z{constructor(e="Stackable tokens with unit IDs cannot have decimal places!",t=null,s=null){super(e,t,s),this.name="StackableUnitAmountException"}}function ot(e){return e.query.definitions.find((e=>"OperationDefinition"===e.kind)).selectionSet.selections.find((e=>"Field"===e.kind)).name.value}function ut({graphQLErrors:e,networkError:t,operation:s,forward:n}){e&&e.map((({message:e,debugMessage:t,locations:s,path:n})=>console.error(`[GraphQL error]: ${e}\r\n`,`  Message : ${t}\r\n`,`  Path    : ${n}\r\n`,`  Location: ${s}\r\n`))),t&&console.error(`[Network error]: ${t}`)}function ct(e){return(t,s)=>{let n;return new c.Observable((i=>(s(t).subscribe(function(e,t,s,n){return i=>{const a=ot(t),r=function(e,t){if(e.extensions&&e.extensions.lighthouse_subscriptions&&e.extensions.lighthouse_subscriptions.version){const s=e.extensions.lighthouse_subscriptions.version;if(s<2&&e.extensions.lighthouse_subscriptions.channels)return e.extensions.lighthouse_subscriptions.channels[t];if(2===s)return e.extensions.lighthouse_subscriptions.channel}return null}(i,a);r?(n(r),function(e,t,s,n){e.private(t.replace(/^private-/,"")).listen(".lighthouse-subscription",(e=>{let t=e.data;t.data&&(t=t.data),t[n]&&(t=t[n]),s.next(t)}))}(e,r,s,a)):(s.next(i),s.complete())}}(e,t,i,(e=>n=e))),()=>function(e,t){const s=t();s&&e.leave(s)}(e,(()=>n)))))}}class ht extends y.HttpLink{constructor(e){super(e)}request(e,t){return t(e)}}class dt extends g.ErrorLink{constructor(e){super(e)}request(e,t){return t(e)}}class pt extends c.ApolloLink{constructor({socketUri:e}){super(),console.log("EchoLink::constructor()..."),this.echo=null,this.socketUri=null,this.auth="",this.setEcho(e)}getAuthToken(){return this.auth}setAuthToken(e){this.auth=e}getSocketUri(){return this.socketUri}setEcho(e){console.log(`Connecting to socket endpoint ${e}...`),this.socketUri=e,this.echo=new T.default({broadcaster:"socket.io",client:v.default,authEndpoint:"graphql/subscriptions/auth",host:this.getSocketUri(),transports:["websocket"],auth:{headers:{"X-Auth-Token":this.getAuthToken(),Accept:"application/json"}}})}request(e,t){return this.echo.options.auth.headers["X-Auth-Token"]=this.getAuthToken(),ct(this.echo)(e,t)}}class mt extends c.ApolloLink{constructor(){super(),this.auth=""}getAuthToken(){return this.auth}setAuthToken(e){this.auth=e}request(e,t){return e.setContext((({headers:e={}})=>({headers:{...e,"X-Auth-Token":this.getAuthToken()}}))),t(e)}}class yt extends c.ApolloLink{constructor(){super(),this.__wallet=null,this.__pubkey=null}setWallet(e){this.__wallet=e}getWallet(){return this.__wallet}setPubKey(e){this.__pubkey=e}getPubKey(){return this.__pubkey}request(e,t){const s=ot(e),n=function(e){return e.query.definitions.find((e=>"OperationDefinition"===e.kind)).operation}(e),i="mutation"===n&&"ProposeMolecule"===s,a=["query"===n&&["__schema","ContinuId"].includes(s),"mutation"===n&&"AccessToken"===s,i&&"U"===ke.get(e,"variables.molecule.atoms.0.isotope")],r=JSON.stringify({query:_.print(e.query),variables:JSON.stringify(e.variables)}),l=this.getWallet(),o=this.getPubKey();for(const s in a)if(a[s])return t(e);if(!o)throw new we("CipherLink::request() - Node public key missing!");if(!l)throw new we("CipherLink::request() - Authorized wallet missing!");return e.operationName=null,e.query=x.default`query ( $Hash: String! ) { CipherHash ( Hash: $Hash ) { hash } }`,e.variables={Hash:JSON.stringify(l.encryptMyMessage(r,o))},t(e).map((e=>{let t=e.data;if(t.data&&(t=t.data),t.CipherHash&&t.CipherHash.hash){const e=JSON.parse(t.CipherHash.hash),s=l.decryptMyMessage(e);if(null===s)throw new we("CipherLink::request() - Unable to decrypt response!");return s}return e}))}}class gt extends d.ApolloClient{constructor({serverUri:e,socketUri:t,encrypt:s=!1}){const n=[],i=new ht({uri:e,fetch:A.default,transportBatching:!0}),a=new dt(ut),r=new mt;let l=null,o=null;n.push(r),s&&(l=new yt,n.push(l)),t&&(o=new pt({socketUri:t}),n.push(o)),n.push(a.concat(i)),super({link:c.ApolloLink.from(n),cache:new m.InMemoryCache,connectToDevTools:!0,defaultOptions:{watchQuery:{fetchPolicy:"no-cache",errorPolicy:"ignore"},query:{fetchPolicy:"no-cache",errorPolicy:"all"},mutate:{fetchPolicy:"no-cache",errorPolicy:"all"},subscribe:{fetchPolicy:"no-cache",errorPolicy:"all"}}}),this.__serverUri=e,this.__socketUri=t,this.__authLink=r,this.__echoLink=o,this.__cipherLink=l,this.__pubkey=null,this.__wallet=null}getAuthToken(){return this.__authLink.getAuthToken()}getPubKey(){return this.__pubkey}getWallet(){return this.__wallet}setAuthData({token:e,pubkey:t=null,wallet:s=null}){this.__wallet=s,this.__pubkey=t,this.__authLink.setAuthToken(e),this.__echoLink&&this.__echoLink.setAuthToken(e),this.__cipherLink&&(this.__cipherLink.setWallet(this.__wallet),this.__cipherLink.setPubKey(this.__pubkey))}getServerUri(){return this.__serverUri}getSocketUri(){return this.__socketUri}}class bt{constructor({serverUri:e,socketUri:t=null,encrypt:s=!1}){this.$__subscribers={},this.$__uri=e,this.$__socketUri=t,this.$__client=null,this.restartTransport(s)}restartTransport(e=!1){const t=new gt({serverUri:this.$__uri,socketUri:this.$__socketUri,encrypt:e});this.$__client&&(this.unsubscribeAll(),t.setAuthData({token:this.$__client.getAuthToken(),pubkey:this.$__client.getPubKey(),wallet:this.$__client.getWallet()})),this.$__client=t}enableEncryption(){this.restartTransport(!0)}disableEncryption(){this.restartTransport()}unsubscribe(e){this.$__subscribers[e]&&(this.$__subscribers[e].unsubscribe(),delete this.$__subscribers[e])}unsubscribeAll(){for(let e in this.$__subscribers)this.$__subscribers.hasOwnProperty(e)&&this.unsubscribe(e)}subscribe(e,t){const s=ot(e);return this.unsubscribe(s),this.$__subscribers[s]=this.$__client.subscribe(e).subscribe((e=>t(e))),s}async query(e){return await this.$__client.query(e)}async mutate(e){return await this.$__client.mutate(e)}setAuthData({token:e,pubkey:t,wallet:s}){this.$__client.setAuthData({token:e,pubkey:t,wallet:s})}getAuthToken(){return this.$__client.getAuthToken()}getUri(){return this.$__uri}setUri(e){this.$__uri=e}getSocketUri(){return this.$__socketUri}setSocketUri(e){this.$__socketUri=e}}class kt{constructor(e){this.client=e,this.$__variables=null,this.$__subscribe=null}createSubscribe({variables:e=null}){if(this.$__variables=this.compiledVariables(e),!this.uri())throw new we("Subscribe::createSubscribe() - Node URI was not initialized for this client instance!");if(null===this.$__subscribe)throw new we("Subscribe::createSubscribe() - GraphQL subscription was not initialized!");return{query:this.$__subscribe,variables:this.variables(),fetchPolicy:"no-cache"}}async execute({variables:e=null,closure:t}){if(!t)throw new we(`${this.constructor.name}::execute() - closure parameter is required!`);return this.$__request=this.createSubscribe({variables:e}),this.client.subscribe(this.$__request,t)}compiledVariables(e=null){return e||{}}uri(){return this.client.getUri()}variables(){return this.$__variables}}class _t extends kt{constructor(e){super(e),this.$__subscribe=x.default`
      subscription onCreateMolecule ( $bundle: String! ) {
        CreateMolecule( bundle: $bundle ) {
          molecularHash,
          cellSlug,
          counterparty,
          bundleHash,
          status,
          local,
          height,
          depth,
          createdAt,
          receivedAt,
          processedAt,
          broadcastedAt,
          reason,
          reasonPayload,
          payload,
          status,
          atoms {
            molecularHash,
            position,
            isotope,
            walletAddress,
            tokenSlug,
            batchId,
            value,
            index,
            metaType,
            metaId,
            metasJson,
            otsFragment,
            createdAt,
            metas {
              molecularHash,
              position,
              metaType,
              metaId,
              key,
              value,
              createdAt,
            }
          }
        }
      }
    `}}class ft extends kt{constructor(e){super(e),this.$__subscribe=x.default`
      subscription onWalletStatus ( $bundle: String!, $token: String! ) {
        WalletStatus( bundle: $bundle, token: $token ) {
          bundle,
          token,
          admission,
          balance,
        }
      }
    `}}class wt extends kt{constructor(e){super(e),this.$__subscribe=x.default`
      subscription onActiveWallet ( $bundle: String! ) {
        ActiveWallet( bundle: $bundle ) {
          address,
          bundleHash,
          walletBundle {
            bundleHash,
            slug,
            createdAt,
          },
          tokenSlug,
          token {
            slug,
            name,
            fungibility,
            supply,
            decimals,
            amount,
            icon,
            createdAt
          },
          batchId,
          position,
          characters,
          pubkey,
          amount,
          createdAt,
          metas {
            molecularHash,
            position,
            metaType,
            metaId,
            key,
            value,
            createdAt,
          }
        }
      }
    `}}class $t extends kt{constructor(e){super(e),this.$__subscribe=x.default`
      subscription onActiveUser ( $metaType: String!, $metaId: String! ) {
        ActiveUser( metaType: $metaType, metaId: $metaId ) {
          bundleHash,
          metaType,
          metaId,
          jsonData,
          createdAt,
          updatedAt
        }
      }`}}class St extends Ie{constructor({query:e,json:t}){super({query:e,json:t}),this.dataKey="data.ActiveSession",this.init()}}class It extends je{constructor(e){super(e),this.$__query=x.default`mutation(
      $bundleHash: String!,
      $metaType: String!,
      $metaId: String!,
      $ipAddress: String,
      $browser: String,
      $osCpu: String,
      $resolution: String,
      $timeZone: String,
      $json: String ) {
      ActiveSession(
        bundleHash: $bundleHash,
        metaType: $metaType,
        metaId: $metaId,
        ipAddress: $ipAddress,
        browser: $browser,
        osCpu: $osCpu,
        resolution: $resolution,
        timeZone: $timeZone,
        json: $json
      ) {
        bundleHash,
        metaType,
        metaId,
        jsonData,
        createdAt,
        updatedAt
      }
    }`}createResponse(e){return new St({query:this,json:e})}}class xt extends Ie{constructor({query:e,json:t}){super({query:e,json:t}),this.dataKey="data.ActiveUser",this.init()}payload(){const e=this.data();if(!e)return null;const t=[];for(let s of e){const e={...s};e.jsonData&&(e.jsonData=JSON.parse(e.jsonData)),e.createdAt&&(e.createdAt=new Date(e.createdAt)),e.updatedAt&&(e.updatedAt=new Date(e.updatedAt)),t.push(e)}return t}}class At extends xe{constructor(e){super(e),this.$__query=x.default`query ActiveUserQuery ($bundleHash:String, $metaType: String, $metaId: String) {
      ActiveUser (bundleHash: $bundleHash, metaType: $metaType, metaId: $metaId) {
        bundleHash,
        metaType,
        metaId,
        jsonData,
        createdAt,
        updatedAt
      }
    }`}createResponse(e){return new xt({query:this,json:e})}}class Tt extends Ie{constructor({query:e,json:t}){super({query:e,json:t}),this.dataKey="data.UserActivity",this.init()}payload(){const e=JSON.parse(JSON.stringify(this.data()));if(e.instances)for(const t of e.instances)t.jsonData=JSON.parse(t.jsonData);return e}}class vt extends xe{constructor(e){super(e),this.$__query=x.default`query UserActivity (
      $bundleHash:String,
      $metaType: String,
      $metaId: String,
      $ipAddress: String,
      $browser: String,
      $osCpu: String,
      $resolution: String,
      $timeZone: String,
      $countBy: [CountByUserActivity],
      $interval: span
    ) {
      UserActivity (
        bundleHash: $bundleHash,
        metaType: $metaType,
        metaId: $metaId,
        ipAddress: $ipAddress,
        browser: $browser,
        osCpu: $osCpu,
        resolution: $resolution,
        timeZone: $timeZone,
        countBy: $countBy,
        interval: $interval
      ) {
        createdAt,
        bundleHash,
        metaType,
        metaId,
        instances {
          bundleHash,
          metaType,
          metaId,
          jsonData,
          createdAt,
          updatedAt
        },
        instanceCount {
          ...SubFields,
          ...Recursive
        }
      }
    }

    fragment SubFields on InstanceCountType {
      id,
      count
    }

    fragment Recursive on InstanceCountType {
      instances {
        ...SubFields
        instances {
          ...SubFields,
          instances {
            ...SubFields
            instances {
              ...SubFields
              instances {
                ...SubFields
                instances {
                  ...SubFields
                  instances {
                    ...SubFields
                    instances {
                      ...SubFields
                    }
                  }
                }
              }
            }
          }
        }
      }
    }`}createResponse(e){return new Tt({query:this,json:e})}}class qt{constructor({uri:e,client:t=null,socketUri:s=null,serverSdkVersion:n=3,logging:i=!1,encrypt:a=!1}){this.initialize({uri:e,socketUri:s,client:t,serverSdkVersion:n,logging:i,encrypt:a})}initialize({uri:e,socketUri:t=null,client:s=null,serverSdkVersion:n=3,logging:i=!1,encrypt:a=!1}){this.$__logging=i,this.$__encrypt=!1,this.$__logging&&console.info(`KnishIOClient::initialize() - Initializing new Knish.IO client session for SDK version ${n}...`),this.reset(),this.$__client=s||new bt({socketUri:t,serverUri:e}),a&&this.enableEncryption(),this.$__serverSdkVersion=n}enableEncryption(){this.$__logging&&console.info("KnishIOClient::enableEncryption() - Enabling end-to-end encryption mode..."),this.$__encrypt=!0,this.$__client.enableEncryption()}disableEncryption(){this.$__logging&&console.info("KnishIOClient::disableEncryption() - Disabling end-to-end encryption mode..."),this.$__encrypt=!1,this.$__client.disableEncryption()}hasEncryption(){return this.$__encrypt}deinitialize(){this.$__logging&&console.info("KnishIOClient::deinitialize() - Clearing the Knish.IO client session..."),this.reset()}subscribe(){if(!this.client().getSocketUri())throw new we("KnishIOClient::subscribe() - Socket client not initialized!");return this.client()}getServerSdkVersion(){return this.$__serverSdkVersion}reset(){this.$__secret="",this.$__bundle="",this.remainderWallet=null}cellSlug(){return this.$__cellSlug||null}setCellSlug(e){this.$__cellSlug=e}uri(){return this.client().getUri()}client(){return this.$__client}hasSecret(){return!!this.$__secret}setSecret(e){this.$__secret=e,this.$__bundle=P(e)}getSecret(){if(!this.$__secret)throw new Se("KnishIOClient::getSecret() - Unable to find a stored getSecret!");return this.$__secret}getBundle(){if(!this.$__bundle)throw new Se("KnishIOClient::getBundle() - Unable to find a stored getBundle!");return this.$__bundle}async getSourceWallet(){let e=(await this.queryContinuId({bundle:this.getBundle()})).payload();return e||(e=new J({secret:this.getSecret()})),e}getRemainderWallet(){return this.remainderWallet}async createMolecule({secret:e=null,sourceWallet:t=null,remainderWallet:s=null}){this.$__logging&&console.info("KnishIOClient::createMolecule() - Creating a new molecule...");const n=e||this.getSecret();let i=t;return!t&&this.lastMoleculeQuery&&"AUTH"!==this.getRemainderWallet().token&&this.lastMoleculeQuery&&this.lastMoleculeQuery.response()&&this.lastMoleculeQuery.response().success()&&(i=this.getRemainderWallet()),null===i&&(i=await this.getSourceWallet()),this.remainderWallet=s||J.create({secretOrBundle:n,token:i.token,batchId:i.batchId,characters:i.characters}),new be({secret:n,sourceWallet:i,remainderWallet:this.getRemainderWallet(),cellSlug:this.cellSlug()})}createQuery(e){return new e(this.client())}createSubscribe(e){return new e(this.subscribe())}async createMoleculeMutation({mutationClass:e,molecule:t=null}){this.$__logging&&console.info(`KnishIOClient::createMoleculeQuery() - Creating a new ${e.name} query...`);let s=t||await this.createMolecule({});const n=new e(this.client(),s);if(!(n instanceof Ee))throw new we(`${this.constructor.name}::createMoleculeMutation() - This method only accepts MutationProposeMolecule!`);return this.lastMoleculeQuery=n,n}async requestAuthToken({secret:e=null,seed:t=null,cellSlug:s=null,encrypt:n=null}){this.$__logging&&console.info("KnishIOClient::requestAuthToken() - Requesting authorization token...");let i,a,r,l=!1;if(t?this.setSecret(E(t)):e?this.setSecret(e):(this.$__logging&&console.info("KnishIOClient::requestAuthToken() - Guest mode enabled..."),l=!0),this.$__cellSlug=s||this.cellSlug(),null===n&&(n=this.hasEncryption()),!(this.$__serverSdkVersion<3)){if(l)r=new J({secret:E(),token:"AUTH"}),i=await this.createQuery(it),a=await i.execute({variables:{cellSlug:this.$__cellSlug,pubkey:r.pubkey,encrypt:n}});else{const e=await this.createMolecule({secret:this.getSecret(),sourceWallet:new J({secret:this.getSecret(),token:"AUTH"})});i=await this.createMoleculeMutation({mutationClass:Qe,molecule:e}),i.fillMolecule({meta:{encrypt:String(n)}}),r=i.molecule.sourceWallet,a=await i.execute({})}if(a.success()){let e=fe.create(a.data(),r);return this.setAuthToken(e),this.$__logging&&console.info(`KnishIOClient::requestAuthToken() - Successfully retrieved auth token ${a.token()}...`),this.hasEncryption()!==a.encrypt()&&(this.$__logging&&console.warn("KnishIOClient::requestAuthToken() - Node not respecting requested encryption policy!"),a.encrypt()?(this.$__logging&&console.info("KnishIOClient::requestAuthToken() - Forcing encryption on to match node..."),this.enableEncryption()):(this.$__logging&&console.info("KnishIOClient::requestAuthToken() - Forcing encryption off to match node..."),this.disableEncryption())),e}throw this.$__logging&&console.warn("KnishIOClient::requestAuthToken() - Unable to retrieve auth token..."),new Se(a.reason())}this.$__logging&&console.warn("KnishIOClient::requestAuthToken() - Node SDK version does not require an auth token!")}async queryBalance({token:e,bundle:t=null}){return this.createQuery(Ue).execute({variables:{bundleHash:t||this.getBundle(),token:e}})}subscribeCreateMolecule({bundle:e,closure:t}){return this.createSubscribe(_t).execute({variables:{bundle:e||this.getBundle()},closure:t})}subscribeWalletStatus({bundle:e,token:t,closure:s}){if(!t)throw new we(`${this.constructor.name}::subscribeWalletStatus() - Token parameter is required!`);return this.createSubscribe(ft).execute({variables:{bundle:e||this.getBundle(),token:t},closure:s})}subscribeActiveWallet({bundle:e,closure:t}){return this.createSubscribe(wt).execute({variables:{bundle:e||this.getBundle()},closure:t})}subscribeActiveSession({metaType:e,metaId:t,closure:s}){return this.createSubscribe($t).execute({variables:{metaType:e,metaId:t},closure:s})}unsubscribe(e){this.subscribe().unsubscribe(e)}unsubscribeAll(){this.subscribe().unsubscribeAll()}queryMeta({metaType:e,metaId:t=null,key:s=null,value:n=null,latest:i=null,latestMetas:a=null,fields:r=null,filter:l=null,queryArgs:o=null,count:u=null,countBy:c=null}){this.$__logging&&console.info(`KnishIOClient::queryMeta() - Querying metaType: ${e}, metaId: ${t}...`);const h=this.createQuery(Be),d=Be.createVariables({metaType:e,metaId:t,key:s,value:n,latest:i,latestMetas:a,filter:l,queryArgs:o,count:u,countBy:c});return h.execute({variables:d,fields:r}).then((e=>e.payload()))}queryMetaInstance({metaType:e,metaId:t=null,key:s=null,value:n=null,latest:i=null,filter:a=null,fields:r=null}){this.$__logging&&console.info(`KnishIOClient::queryMetaInstance() - Querying metaType: ${e}, metaId: ${t}...`);const l={metaType:e,metaIds:[t],keys:[s],values:[n],latest:i,filter:a};return this.createQuery(Be).execute({variables:l,fields:r}).then((e=>e.data()))}async queryBatch({batchId:e}){this.$__logging&&console.info(`KnishIOClient::queryBatch() - Querying cascading meta instances for batchId: ${e}...`);const t=this.createQuery(Ke);return await t.execute({variables:{batchId:e}})}async queryBatchHistory({batchId:e}){this.$__logging&&console.info(`KnishIOClient::queryBatchHistory() - Querying cascading meta instances for batchId: ${e}...`);const t=this.createQuery(Oe);return await t.execute({variables:{batchId:e}})}async createWallet({token:e}){const t=new J({secret:this.getSecret(),token:e}),s=await this.createMoleculeMutation({mutationClass:st});return s.fillMolecule(t),await s.execute({})}async queryActiveSession({bundleHash:e,metaType:t,metaId:s}){const n=this.createQuery(At);return await n.execute({variables:{bundleHash:e,metaType:t,metaId:s}})}async queryUserActivity({bundleHash:e,metaType:t,metaId:s,ipAddress:n,browser:i,osCpu:a,resolution:r,timeZone:l,countBy:o,interval:u}){const c=this.createQuery(vt);return await c.execute({variables:{bundleHash:e,metaType:t,metaId:s,ipAddress:n,browser:i,osCpu:a,resolution:r,timeZone:l,countBy:o,interval:u}})}async activeSession({bundle:e,metaType:t,metaId:s,ipAddress:n,browser:i,osCpu:a,resolution:r,timeZone:l,json:o={}}){const u=this.createQuery(It);return await u.execute({variables:{bundleHash:e,metaType:t,metaId:s,ipAddress:n,browser:i,osCpu:a,resolution:r,timeZone:l,json:JSON.stringify(o)}})}async createToken({token:e,amount:t=null,meta:s=null,batchId:n=null,units:i=[]}){if("stackable"===ke.get(s||{},"fungibility")&&(n||(n=Q({})),s.batchId=n,i.length>0)){if(ke.get(s||{},"decimals")>0)throw new rt;if(t>0)throw new lt;t=i.length,s.splittable=1,s.tokenUnits=JSON.stringify(i)}const a=new J({secret:this.getSecret(),token:e,batchId:n}),r=await this.createMoleculeMutation({mutationClass:Fe});return r.fillMolecule({recipientWallet:a,amount:t,meta:s||{}}),await r.execute({})}async createMeta({metaType:e,metaId:t,meta:s=null}){const n=await this.createMoleculeMutation({mutationClass:et,molecule:await this.createMolecule({secret:this.getSecret(),sourceWallet:await this.getSourceWallet()})});return n.fillMolecule({metaType:e,metaId:t,meta:s}),await n.execute({})}async createIdentifier({type:e,contact:t,code:s}){const n=await this.createMoleculeMutation({mutationClass:Ze});return n.fillMolecule({type:e,contact:t,code:s}),await n.execute({})}queryWallets({bundle:e=null,token:t=null,unspent:s=!0}){this.$__logging&&console.info(`KnishIOClient::queryWallets() - Querying wallets${e?` for ${e}`:""}...`);return this.createQuery(Me).execute({variables:{bundleHash:e||this.getBundle(),token:t,unspent:s}}).then((e=>e.getWallets()))}queryShadowWallets({token:e="KNISH",bundle:t=null}){t=t||this.getBundle(),this.$__logging&&console.info(`KnishIOClient::queryShadowWallets() - Querying ${e} shadow wallets for ${t}...`);return this.createQuery(Me).execute({variables:{bundleHash:t,token:e}}).then((e=>e.payload()))}queryBundle({bundle:e=null,key:t=null,value:s=null,latest:n=!0,fields:i=null,raw:a=!1}){this.$__logging&&console.info(`KnishIOClient::queryBundle() - Querying wallet bundle metadata${e?` for ${e}`:""}...`);const r=this.createQuery(qe),l=qe.createVariables({bundleHash:e||this.getBundle(),key:t,value:s,latest:n});return r.execute({variables:l,fields:i}).then((e=>a?e:e.payload()))}async queryContinuId({bundle:e}){return this.createQuery(Te).execute({variables:{bundle:e}})}async requestTokens({token:e,to:t,amount:s=null,units:n=[],meta:i=null,batchId:a=null}){let r,l;if(i=i||{},n.length>0){if(s>0)throw new lt;s=n.length,i.tokenUnits=JSON.stringify(n)}t?("[object String]"===Object.prototype.toString.call(t)&&(J.isBundleHash(t)?(r="walletBundle",l=t):t=J.create({secretOrBundle:t,token:e})),t instanceof J&&(r="wallet",i.position=t.position,i.bundle=t.bundle,l=t.address)):(r="walletBundle",l=this.getBundle());const o=await this.createMoleculeMutation({mutationClass:Le});return o.fillMolecule({token:e,amount:s,metaType:r,metaId:l,meta:i,batchId:a}),await o.execute({})}async claimShadowWallet({token:e,batchId:t=null,molecule:s=null}){const n=await this.createMoleculeMutation({mutationClass:Xe,molecule:s});return n.fillMolecule({token:e,batchId:t}),await n.execute({})}async claimShadowWallets({token:e}){const t=await this.queryShadowWallets({token:e});if(!t||!Array.isArray(t))throw new at;t.forEach((e=>{if(!e.isShadow())throw new at}));let s=[];for(const n of t)s.push(await this.claimShadowWallet({token:e,batchId:n.batchId}));return s}async transferToken({recipient:e,token:t,amount:s=null,units:n=[],batchId:i=null,sourceWallet:a=null}){if(null===a&&(a=(await this.queryBalance({token:t})).payload()),n.length>0){if(s>0)throw new lt;s=n.length}if(null===a||_e.cmp(a.balance,s)<0)throw new ne;let r=e instanceof J?e:(await this.queryBalance({token:t,bundle:e})).payload();null===r&&(r=J.create({secretOrBundle:e,token:t})),null!==i?r.batchId=i:r.initBatchId({sourceWallet:a}),this.remainderWallet=J.create({secretOrBundle:this.getSecret(),token:t,characters:a.characters}),this.remainderWallet.initBatchId({sourceWallet:a,remainder:!0}),a.splitUnits(n,this.remainderWallet,r);const l=await this.createMolecule({sourceWallet:a,remainderWallet:this.remainderWallet}),o=await this.createMoleculeMutation({mutationClass:ze,molecule:l});return o.fillMolecule({recipientWallet:r,amount:s}),await o.execute({})}async burnTokens({token:e,amount:t=null,units:s=[],sourceWallet:n=null}){null===n&&(n=(await this.queryBalance({token:e})).payload());let i=J.create({secretOrBundle:this.getSecret(),token:e,characters:n.characters});if(i.initBatchId({sourceWallet:n,remainder:!0}),s.length>0){if(t>0)throw new lt;t=s.length,n.splitUnits(s,i)}let a=await this.createMolecule({secret:null,sourceWallet:n,remainderWallet:i});return a.burnToken({amount:t}),a.sign({}),a.check(),new Ee(this.client(),a).execute({})}async authorize({secret:e,cellSlug:t,encrypt:s=null}){if(this.$__serverSdkVersion<3)return void(this.$__logging&&console.warn("KnishIOClient::authorize() - Server SDK version does not require an authorization..."));let n;return e&&this.setSecret(e),t&&this.setCellSlug(t),n=e?await this.requestAuthToken({secret:e,encrypt:s}):await this.requestAuthToken({cellSlug:this.$__cellSlug,encrypt:s}),this.$__logging&&console.info(`KnishIOClient::authorize() - Successfully retrieved auth token ${n.token}...`),this.setAuthToken(n),n}setAuthToken(e){this.client().setAuthData(e.getAuthData()),this.$__authToken=e}getAuthToken(){return this.$__authToken}}exports.Atom=O,exports.KnishIOClient=qt,exports.Meta=K,exports.Molecule=be,exports.Test=class{constructor(e){this.secrets=[E(),E()],this.tokenSlugs=["TESTTOKEN","UTENVSTACKABLE","UTSTACKUNIT","UTENVSTACKUNIT"],this.graphqlUrl=e,console.log(`---------- GraphQL URI: ${this.graphqlUrl}`),this.clients={},this.tokenUnits=[["unit_id_1","unit_name_1","unit_meta_1"],["unit_id_2","unit_name_2","unit_meta_2"],["unit_id_3","unit_name_3","unit_meta_3"],["unit_id_4","unit_name_4","unit_meta_4"],["unit_id_5","unit_name_5","unit_meta_5"],["unit_id_6","unit_name_6","unit_meta_6"],["unit_id_7","unit_name_7","unit_meta_7"],["unit_id_8","unit_name_8","unit_meta_8"],["unit_id_9","unit_name_9","unit_meta_9"],["unit_id_10","unit_name_10","unit_meta_10"],["unit_id_11","unit_name_11","unit_meta_11"]],this.tokenUnits=[["unit_id_1"],["unit_id_2"],["unit_id_3"],["unit_id_4"],["unit_id_5"],["unit_id_6"],["unit_id_7"],["unit_id_8"],["unit_id_9"],["unit_id_10"],["unit_id_11"]]}async testAll(){await this.client(this.secrets[0]),await this.client(this.secrets[1]),await this.testCreateToken(),await this.testCreateWallet(),await this.testCreateMeta(),await this.testCreateIdentifier(),await this.testRequestTokens(),await this.testTransferToken(),await this.testBurnToken(),await this.testClaimShadowWallet(),await this.testQueryMeta(),await this.testQueryWallets(),await this.testQueryShadowWallets(),await this.testQueryBundle(),await this.testQueryBalance()}async testCreateToken(){let e=await this.client(this.secrets[0]),t=await this.client(process.env.SECRET_TOKEN_KNISH),s={};s[0]=await e.createToken({token:this.tokenSlugs[0],amount:1e3,meta:{name:this.tokenSlugs[0],fungibility:"stackable",supply:"limited",decimals:0,icon:"icon"},batchId:"batch_0"}),this.checkResponse(s[0],"testCreateToken.0"),s[1]=await t.createToken({token:this.tokenSlugs[1],amount:1e3,meta:{name:this.tokenSlugs[1],fungibility:"stackable",supply:"limited",decimals:0,icon:"icon"},batchId:"server_batch_0"}),this.checkResponse(s[1],"testCreateToken.1"),s[2]=await e.createToken({token:this.tokenSlugs[2],units:this.tokenUnits,meta:{name:this.tokenSlugs[2],supply:"limited",fungibility:"stackable"},batchId:"unit_batch_0"}),this.checkResponse(s[2],"testCreateToken.2"),s[3]=await t.createToken({token:this.tokenSlugs[3],units:this.tokenUnits,meta:{name:this.tokenSlugs[3],supply:"limited",fungibility:"stackable"},batchId:"server_unit_batch_0"}),this.checkResponse(s[3],"testCreateToken.3")}async testCreateWallet(){let e=await this.client(this.secrets[0]),t=await e.createWallet({token:this.tokenSlugs[1]});this.checkResponse(t,"testCreateWallet")}async testCreateMeta(){let e=await this.client(this.secrets[0]),t=await e.createMeta({metaType:"metaType",metaId:"metaId",meta:{key1:"value1",key2:"value2"}});this.checkResponse(t,"testCreateMeta")}async testCreateIdentifier(){let e=await this.client(this.secrets[0]),t=await e.createIdentifier({type:"email",contact:"test@test.com",code:"1234"});this.checkResponse(t,"testCreateIdentifier")}async testRequestTokens(){let e=await this.client(this.secrets[0]),t=await e.requestTokens({token:this.tokenSlugs[1],amount:10,to:this.secrets[0],batchId:"batch_5"});this.checkResponse(t,"testRequestTokens.1"),t=await e.requestTokens({token:this.tokenSlugs[3],units:["unit_id_10","unit_id_11"],to:this.secrets[0],batchId:"batch_6"}),this.checkResponse(t,"testRequestTokens.2")}async testTransferToken(){let e,t=P(this.secrets[1]),s=await this.client(this.secrets[0]);e=await s.transferToken({recipient:t,token:this.tokenSlugs[0],amount:10,batchId:"batch_1"}),this.checkResponse(e,"testTransferToken"),e=await s.transferToken({recipient:t,token:this.tokenSlugs[2],units:["unit_id_1","unit_id_2"],batchId:"batch_2"}),this.checkResponse(e,"testTransferUnitToken")}async testBurnToken(){let e;P(this.secrets[1]);let t=await this.client(this.secrets[0]);e=await t.burnTokens({token:this.tokenSlugs[0],amount:10,batchId:"batch_3"}),this.checkResponse(e,"testBurnToken"),e=await t.burnTokens({token:this.tokenSlugs[2],units:["unit_id_3","unit_id_4"],batchId:"batch_4"}),this.checkResponse(e,"testBurnUnitToken")}async testClaimShadowWallet(){let e=await this.client(this.secrets[1]),t=await e.queryBalance({token:this.tokenSlugs[0]}),s=await e.claimShadowWallet({token:this.tokenSlugs[0],batchId:t.payload().batchId});this.checkResponse(s,"testClaimShadowWallet")}async testQueryMeta(){let e=await this.client(this.secrets[0]),t=await e.queryMeta({metaType:"metaType",metaId:"metaId"});this.checkResponse(t,"testQueryMeta")}async testQueryWallets(){let e=await this.client(this.secrets[0]),t=await e.queryWallets({});this.checkResponse(t,"testQueryWallets")}async testQueryShadowWallets(){let e=await this.client(this.secrets[1]),t=await e.queryShadowWallets({token:this.tokenSlugs[0]});this.checkResponse(t,"testQueryShadowWallets")}async testQueryBundle(){let e=await this.client(this.secrets[0]),t=await e.queryBundle({});this.checkResponse(t,"testQueryBundle")}async testQueryContinuId(){let e=P(this.secrets[0]),t=await this.client(this.secrets[0]),s=await t.queryContinuId({bundle:e});this.checkResponse(s,"testQueryContinuId")}async testQueryBalance(){let e=await this.client(this.secrets[0]),t=await e.queryBalance({token:this.tokenSlugs[0]});this.checkResponse(t,"testQueryBalance")}async client(e,t="unit_test"){if(!this.clients[e]){this.clients[e]=new qt({uri:this.graphqlUrl,logging:!0}),await this.clients[e].requestAuthToken({secret:e,cellSlug:t})||console.log("Error with requestAuthToken - get an empty response.")}return this.clients[e]}checkResponse(e,t){console.log(` ############### ${t} ###############`),console.log(e),e instanceof Re?(e.success()||this.debug(e),console.assert("accepted"===e.status(),e)):this.debug(e)}debug(e){e.data&&ke.get(e.data()||{},"reason")?console.log(e.data().reason):console.log(e)}},exports.Wallet=J,exports.base64ToHex=H,exports.bufferToHexString=function(e){return q.toHex(e,{})},exports.charsetBaseConvert=C,exports.chunkSubstr=W,exports.decryptMessage=V,exports.encryptMessage=F,exports.generateBundleHash=P,exports.generateEncPrivateKey=L,exports.generateEncPublicKey=D,exports.generateSecret=E,exports.hashShare=z,exports.hexStringToBuffer=function(e){return q.toUint8Array(e)},exports.hexToBase64=U,exports.isHex=B,exports.randomString=M;
